//
#include "itemprocess.h"
#include "qautomation.h"
#include <QProcess>
#include "GC5005_OTP_DD.h"
#include "cvImageTool.h"
#include "jsl_controlpanel.h"


// #include "inc/HisCCMOTP.h"
// #pragma comment(lib, "./lib/x86/Release/HisCCMOTP32.lib")

typedef enum
{
	PD_ERR_OK = 0,
	PD_ERR_FILE_NOT_FOUND,
	PD_ERR_INIT_FAIL,
	PD_ERR_INVALID_PARAM,
	PD_ERR_OUTPUT_MEM_NOT_SUFFICIENT,
	PD_ERR_NOT_INITIALIZED,
	PD_ERR_INPUT_DATA_VERIFIED_FAIL,
	PD_ERR_OUTPUT_DATA_VERIFIED_FAIL,
	PD_ERR_QUALITY_VERIFIED_FAIL,
	PD_ERR_GENERAL_ERROR
} PD_ERR_CODE;

typedef PD_ERR_CODE (*mtk_pd_cali_init)(char *filename);
typedef PD_ERR_CODE (*mtk_pd_cali_get_max_output_size)(int& max_size);
typedef PD_ERR_CODE (*mtk_pd_cali_get_capture_num)(int& num);
typedef PD_ERR_CODE (*mtk_pd_cali_get_raw_width_height)(int& width, int& height);
typedef PD_ERR_CODE (*mtk_pd_cali_proc1)(unsigned short*raw, char *output, int max_output_size, int& output_size);
typedef PD_ERR_CODE (*mtk_pd_cali_proc2)(char **raw_seq, int *lens_pos, int num, char* output, int max_output_size, int& output_size);
typedef PD_ERR_CODE (*mtk_pd_cali_verify)(unsigned char *eeprom_buf);
typedef PD_ERR_CODE (*mtk_pd_cali_verify_proc1)(unsigned char *eeprom_buf_proc1);
typedef PD_ERR_CODE (*mtk_pd_cali_verify_proc2)(unsigned char *eeprom_buf_proc2);
typedef PD_ERR_CODE (*mtk_pd_cali_get_DAC_proc2)(unsigned char *eeprom_buf_proc2, int& DAC);

typedef PD_ERR_CODE (*mtkv1_pd_cali_proc3)(char **raw_seq, int *lens_pos, int num, char* output, int max_output_size, int& output_size);
typedef PD_ERR_CODE (*mtkv1_pd_cali_verify_proc3)(unsigned char *eeprom_buf_proc3, int* lensPos, int lensPosNum);
typedef PD_ERR_CODE (*mtkv1_pd_cali_get_DAC_proc3)(unsigned char *eeprom_buf_proc3, int& DAC);

typedef PD_ERR_CODE (*mtkv2_pd_cali_get_data_format_version)(unsigned char *eeprom_buf, int& version);
typedef PD_ERR_CODE (*mtkv2_pd_cali_get_linearity)(unsigned char *eeprom_buf_proc2, double* out_linearity);
typedef PD_ERR_CODE (*mtkv2_pd_cali_get_linearity_size)(unsigned char *eeprom_buf_proc2, int& sizeX, int& sizeY);

#include "inc/PDAFCalibrationTools_Rev.h"
//#include "inc/PDAFCalibrationTools_Dll.h"
typedef int (*qualcomm_PDAF_Cal_GainMap)(short *RAWDATA,int nWidth, int nHeight, PDAFPattern PDAFPatternValue, GainMap2DDataStruct *GainMapData2D, GainMap1DDataStruct *GainMapData1D, GainMapVerifyStruct &gmvs);
typedef int (*qualcomm_PDAF_Cal_PDConversionCoef)(short *FirstImg,short *SecondImg,int nWidth, int nHeight,float FirstImg_LensPos, float SecondImg_LensPos, GainMapStruct GainMap,PDAFPattern PDAFPatternValue, bool MultipleRegions,CalibrationKOutputParams &CalibrationKOutput);
typedef bool (*qualcomm_PDAF_Cal_Verification)(short *Distance50cmLensPosition9_Img,int nWidth, int nHeight,GainMapStruct GainMapData, PDAFPattern PDAFPatternValue,VerificationInputParams *VerificationValue,VerificationOutputParams &VerificationOutput);
typedef unsigned short (*qualcomm_GM_Constraint)(GainMapVerifyStruct &gmvs, GainMap2DDataStruct *gm2d, GainMap1DDataStruct *gm1d);
typedef int (*qualcomm_OTP_single_defect_1DGainmap)(GainMap1DDataStruct &gm1d, int GainDiff);
typedef int (*qualcomm_OTP_single_defect_2DGainmap)(GainMap2DDataStruct &gm2d, int GainDiff);
typedef void (*qualcomm_PDAF_Cal_get_lib_version)(char *s);
typedef void (*qualcomm_PDAF_Cal_get_lib_features)(char *s);

typedef int (*IMX258_PDAF_SPC_INI)( char* ini_file_path, short *pRaw10, short *pSPC);
typedef int (*IMX258_PDAF_SPC_Judge_INI)( char* ini_file_path, 	short *pRaw10,int *pSPC);

typedef int (*IMX230_PDAF_SPC_INI)( char* ini_file_path, short *pRaw10, short *pSPC);
typedef int (*IMX230_PDAF_SPC_Judge_INI)( char* ini_file_path, 	short *pRaw10,int *pSPC);
typedef int (*IMX230_PDAF_Window_DCC) (int lenspos1 ,int lenspos2 , int * Phase_diff1 ,int * Phase_diff2 ,int h_num ,int v_num , unsigned short *dcc_out);
typedef int (*IMX230_PDAF_Window_DCC_verify) (unsigned short  *dcc,int *pd,int h_num ,  int v_num , int *dac_out,  int *dac_center_out);

typedef int (*IMX298_PDAF_SPC_INI)( char* ini_file_path, short *pRaw10, short *pSPC);
typedef int (*IMX298_PDAF_SPC_Judge_INI)( char* ini_file_path, 	short *pRaw10,int *pSPC);
typedef int (*IMX298_PDAF_Window_DCC) (int lenspos1 ,int lenspos2 , int * Phase_diff1 ,int * Phase_diff2 ,int h_num ,int v_num , unsigned short *dcc_out);
typedef int (*IMX298_PDAF_Window_DCC_verify) (unsigned short  *dcc,int *pd,int h_num ,  int v_num , int *dac_out,  int *dac_center_out);

typedef int (*IMX230_PDAF_Window_DCC) (int lenspos1 , int lenspos2 ,  int * Phase_diff1 , int * Phase_diff2 , int h_num , int v_num ,unsigned short *dcc_out);
typedef int (*MX230_PDAF_Window_DCC_verify)( unsigned short  *dcc,int *pd, int h_num ,  int v_num , int *dac_out,  int *dac_center_out);
typedef int (*IMX298_PDAF_Window_DCC) (int lenspos1 , int lenspos2 ,  int * Phase_diff1 , int * Phase_diff2 , int h_num , int v_num ,unsigned short *dcc_out);
typedef int (*MX298_PDAF_Window_DCC_verify)( unsigned short  *dcc,int *pd, int h_num ,  int v_num , int *dac_out,  int *dac_center_out);


typedef int (*IMX386_PDAF_SPC_INI)( char* ini_file_path, short *pRaw10, short *pSPC);
typedef int (*IMX386_PDAF_SPC_Judge_INI)( char* ini_file_path, 	short *pRaw10,int *pSPC);
typedef int (*IMX386_PDAF_Window_DCC) (int lenspos1 ,int lenspos2 , int * Phase_diff1 ,int * Phase_diff2 ,int h_num ,int v_num , unsigned short *dcc_out);
typedef int (*IMX386_PDAF_Window_DCC_verify) (unsigned short  *dcc,int *pd,int h_num ,  int v_num , int *dac_out,  int *dac_center_out);

typedef int (*polyfit)(const double* BufferX, const double* BufferY, int Amount, int SizeSrc, double* ParaResK);
typedef int (*polyval)(const double* BufferX, double* BufferY, int Amount, double* ParaResK,int SizeSrc);
typedef int (*getMarkDistance_RGB24)(uchar* pRGB24,uchar *pDstBuffer,double *pflDist,INT ImgWidth,INT ImgHeight,INT morphSize, INT markMinArea, INT markMaxArea,INT markMinLength, INT markMaxLength,BOOL bDebug);
typedef INT (*opticalCenter)(unsigned char* pChannel8Bit, int width, int height, int &ocX, int &ocY,bool bDebugMode);	
	
typedef int (__cdecl *RolongowriteQualcommPDAF)(std::vector<std::wstring>& vectorHisCCMOTPInfoW, _HisQualcommPDAFBurn_Config* pstconfig , hardwarereadiic funreadiic , hardwarewriteiic funwriteiic , hardwaresetiicspeed funiicspeed , \
	hardwaresetvolt funsetvolt , hardwaregetvolt fungetvolt , hardwaresetvfuse funsetvfuse , hardwaregetvfuse fungetvfuse , hardwaregetframe fungetframe , \
	hardwarebatchwriteiic funbatchwriteiic , hardwarebatchreadiic funbatchreadiic , hardwaresetgpio funsetgpio , hardwaregetgpio fungetgpio , \
	hardwarepullreset funreset , hardwarepullpwnd funpwnd , hardwarebatchreadiicnolimit funbatchreadiicnolimit , hardwarebatchwriteiicnolimit funbatchwriteiicnolimit , \
	hisfx3logpush_back fuclogpushback , hardwarepagewriteiic fucpagewriteiic , hardwarepagereadiic fucpagereadiic, \
	hardwarepagewritespi funpagewritespi, hardwarepagereadspi funpagereadspi);
typedef int (__cdecl *RolongocheckQualcommPDAF)(std::vector<std::wstring>& vectorHisCCMOTPInfoW, _HisQualcommPDAFBurn_Config* pstconfig , hardwarereadiic funreadiic , hardwarewriteiic funwriteiic , hardwaresetiicspeed funiicspeed , \
	hardwaresetvolt funsetvolt , hardwaregetvolt fungetvolt , hardwaresetvfuse funsetvfuse , hardwaregetvfuse fungetvfuse , hardwaregetframe fungetframe , \
	hardwarebatchwriteiic funbatchwriteiic , hardwarebatchreadiic funbatchreadiic , hardwaresetgpio funsetgpio , hardwaregetgpio fungetgpio , \
	hardwarepullreset funreset , hardwarepullpwnd funpwnd , hardwarebatchreadiicnolimit funbatchreadiicnolimit , hardwarebatchwriteiicnolimit funbatchwriteiicnolimit , \
	hisfx3logpush_back fuclogpushback , hardwarepagewriteiic fucpagewriteiic , hardwarepagereadiic fucpagereadiic, \
	hardwarepagewritespi funpagewritespi, hardwarepagereadspi funpagereadspi);

typedef int (__cdecl *RolongowriteSONYPDAF)(std::vector<std::wstring>& vectorHisCCMOTPInfoW, _HisCCMSONYPDAFBurn_Config* pstconfig , hardwarereadiic funreadiic , hardwarewriteiic funwriteiic , hardwaresetiicspeed funiicspeed , \
	hardwaresetvolt funsetvolt , hardwaregetvolt fungetvolt , hardwaresetvfuse funsetvfuse , hardwaregetvfuse fungetvfuse , hardwaregetframe fungetframe , \
	hardwarebatchwriteiic funbatchwriteiic , hardwarebatchreadiic funbatchreadiic , hardwaresetgpio funsetgpio , hardwaregetgpio fungetgpio , \
	hardwarepullreset funreset , hardwarepullpwnd funpwnd , hardwarebatchreadiicnolimit funbatchreadiicnolimit , hardwarebatchwriteiicnolimit funbatchwriteiicnolimit , \
	hisfx3logpush_back funlogpushback  , hardwarepagewriteiic fucpagewriteiic  , hardwarepagereadiic fucpagereadiic, \
	hardwarepagewritespi funpagewritespi, hardwarepagereadspi funpagereadspi);
typedef int (__cdecl *RolongocheckSONYPDAF)(std::vector<std::wstring>& vectorHisCCMOTPInfoW, _HisCCMSONYPDAFBurn_Config* pstconfig , hardwarereadiic funreadiic , hardwarewriteiic funwriteiic , hardwaresetiicspeed funiicspeed , \
	hardwaresetvolt funsetvolt , hardwaregetvolt fungetvolt , hardwaresetvfuse funsetvfuse , hardwaregetvfuse fungetvfuse , hardwaregetframe fungetframe , \
	hardwarebatchwriteiic funbatchwriteiic , hardwarebatchreadiic funbatchreadiic , hardwaresetgpio funsetgpio , hardwaregetgpio fungetgpio , \
	hardwarepullreset funreset , hardwarepullpwnd funpwnd , hardwarebatchreadiicnolimit funbatchreadiicnolimit , hardwarebatchwriteiicnolimit funbatchwriteiicnolimit , \
	hisfx3logpush_back funlogpushback  , hardwarepagewriteiic fucpagewriteiic  , hardwarepagereadiic fucpagereadiic, \
	hardwarepagewritespi funpagewritespi, hardwarepagereadspi funpagereadspi);

typedef int (__cdecl *RolongowriteMTKPDAF)(std::vector<std::wstring>& vectorHisCCMOTPInfoW, _HisCCMMTKPDAFBurn_Config* pstconfig , hardwarereadiic funreadiic , hardwarewriteiic funwriteiic , hardwaresetiicspeed funiicspeed , \
	hardwaresetvolt funsetvolt , hardwaregetvolt fungetvolt , hardwaresetvfuse funsetvfuse , hardwaregetvfuse fungetvfuse , hardwaregetframe fungetframe , \
	hardwarebatchwriteiic funbatchwriteiic , hardwarebatchreadiic funbatchreadiic , hardwaresetgpio funsetgpio , hardwaregetgpio fungetgpio , \
	hardwarepullreset funreset , hardwarepullpwnd funpwnd , hardwarebatchreadiicnolimit funbatchreadiicnolimit , hardwarebatchwriteiicnolimit funbatchwriteiicnolimit , \
	hisfx3logpush_back funlogpushback  , hardwarepagewriteiic fucpagewriteiic  , hardwarepagereadiic fucpagereadiic, \
	hardwarepagewritespi funpagewritespi, hardwarepagereadspi funpagereadspi);
typedef int (__cdecl *RolongocheckMTKPDAF)(std::vector<std::wstring>& vectorHisCCMOTPInfoW, _HisCCMMTKPDAFBurn_Config* pstconfig , hardwarereadiic funreadiic , hardwarewriteiic funwriteiic , hardwaresetiicspeed funiicspeed , \
	hardwaresetvolt funsetvolt, hardwaregetvolt fungetvolt , hardwaresetvfuse funsetvfuse , hardwaregetvfuse fungetvfuse , hardwaregetframe fungetframe , \
	hardwarebatchwriteiic funbatchwriteiic , hardwarebatchreadiic funbatchreadiic , hardwaresetgpio funsetgpio , hardwaregetgpio fungetgpio , \
	hardwarepullreset funreset , hardwarepullpwnd funpwnd , hardwarebatchreadiicnolimit funbatchreadiicnolimit , hardwarebatchwriteiicnolimit funbatchwriteiicnolimit , \
	hisfx3logpush_back funlogpushback  , hardwarepagewriteiic fucpagewriteiic, hardwarepagereadiic fucpagereadiic, \
	hardwarepagewritespi funpagewritespi, hardwarepagereadspi funpagereadspi);

typedef int (__cdecl *RolongowriteHISIPDAF)(std::vector<std::wstring>& vectorHisCCMOTPInfoW, _HisCCMMTKPDAFBurn_Config* pstconfig , hardwarereadiic funreadiic , hardwarewriteiic funwriteiic , hardwaresetiicspeed funiicspeed , \
	hardwaresetvolt funsetvolt , hardwaregetvolt fungetvolt , hardwaresetvfuse funsetvfuse , hardwaregetvfuse fungetvfuse , hardwaregetframe fungetframe , \
	hardwarebatchwriteiic funbatchwriteiic , hardwarebatchreadiic funbatchreadiic , hardwaresetgpio funsetgpio , hardwaregetgpio fungetgpio , \
	hardwarepullreset funreset , hardwarepullpwnd funpwnd , hardwarebatchreadiicnolimit funbatchreadiicnolimit , hardwarebatchwriteiicnolimit funbatchwriteiicnolimit , \
	hisfx3logpush_back funlogpushback  , hardwarepagewriteiic fucpagewriteiic  , hardwarepagereadiic fucpagereadiic, \
	hardwarepagewritespi funpagewritespi, hardwarepagereadspi funpagereadspi);
typedef int (__cdecl *RolongocheckHISIPDAF)(std::vector<std::wstring>& vectorHisCCMOTPInfoW, _HisCCMMTKPDAFBurn_Config* pstconfig , hardwarereadiic funreadiic , hardwarewriteiic funwriteiic , hardwaresetiicspeed funiicspeed , \
	hardwaresetvolt funsetvolt, hardwaregetvolt fungetvolt , hardwaresetvfuse funsetvfuse , hardwaregetvfuse fungetvfuse , hardwaregetframe fungetframe , \
	hardwarebatchwriteiic funbatchwriteiic , hardwarebatchreadiic funbatchreadiic , hardwaresetgpio funsetgpio , hardwaregetgpio fungetgpio , \
	hardwarepullreset funreset , hardwarepullpwnd funpwnd , hardwarebatchreadiicnolimit funbatchreadiicnolimit , hardwarebatchwriteiicnolimit funbatchwriteiicnolimit , \
	hisfx3logpush_back funlogpushback  , hardwarepagewriteiic fucpagewriteiic, hardwarepagereadiic fucpagereadiic, \
	hardwarepagewritespi funpagewritespi, hardwarepagereadspi funpagereadspi);

typedef int (__cdecl *RolongoapplyOTPforPDAF)(std::vector<std::wstring>& vectorHisCCMOTPInfoW, _HisCCMOTP_Config* pstconfig , hardwarereadiic funreadiic , hardwarewriteiic funwriteiic , hardwaresetiicspeed funiicspeed , \
	hardwaresetvolt funsetvolt , hardwaregetvolt fungetvolt , hardwaresetvfuse funsetvfuse , hardwaregetvfuse fungetvfuse , hardwaregetframe fungetframe , \
	hardwarebatchwriteiic funbatchwriteiic , hardwarebatchreadiic funbatchreadiic , hardwaresetgpio funsetgpio , hardwaregetgpio fungetgpio , \
	hardwarepullreset funreset , hardwarepullpwnd funpwnd , hardwarebatchreadiicnolimit funbatchreadiicnolimit , hardwarebatchwriteiicnolimit funbatchwriteiicnolimit , \
	hisfx3logpush_back funlogpushback  , hardwarepagewriteiic fucpagewriteiic  , hardwarepagereadiic fucpagereadiic, \
	hardwarepagewritespi funpagewritespi, hardwarepagereadspi funpagereadspi);

typedef int (__cdecl *Rolongowriteotp)(std::vector<std::wstring>& vectorHisCCMOTPInfoW, _HisCCMOTP_Config* pstconfig , hardwarereadiic funreadiic , hardwarewriteiic funwriteiic , hardwaresetiicspeed funiicspeed , \
	hardwaresetvolt funsetvolt , hardwaregetvolt fungetvolt , hardwaresetvfuse funsetvfuse , hardwaregetvfuse fungetvfuse , hardwaregetframe fungetframe , \
	hardwarebatchwriteiic funbatchwriteiic , hardwarebatchreadiic funbatchreadiic , hardwaresetgpio funsetgpio , hardwaregetgpio fungetgpio , \
	hardwarepullreset funreset , hardwarepullpwnd funpwnd , hardwarebatchreadiicnolimit funbatchreadiicnolimit , hardwarebatchwriteiicnolimit funbatchwriteiicnolimit , \
	hisfx3logpush_back funlogpushback , hardwarepagewriteiic fucpagewriteiic , hardwarepagereadiic fucpagereadiic, \
	hardwarepagewritespi funpagewritespi, hardwarepagereadspi funpagereadspi);
typedef int (__cdecl *Rolongocheckotp)(std::vector<std::wstring>& vectorHisCCMOTPInfoW, _HisCCMOTP_Config* pstconfig, hardwarereadiic funreadiic , hardwarewriteiic funwriteiic , hardwaresetiicspeed funiicspeed , \
	hardwaresetvolt funsetvolt , hardwaregetvolt fungetvolt , hardwaresetvfuse funsetvfuse , hardwaregetvfuse fungetvfuse , hardwaregetframe fungetframe , \
	hardwarebatchwriteiic funbatchwriteiic , hardwarebatchreadiic funbatchreadiic , hardwaresetgpio funsetgpio , hardwaregetgpio fungetgpio , \
	hardwarepullreset funreset , hardwarepullpwnd funpwnd , hardwarebatchreadiicnolimit funbatchreadiicnolimit , hardwarebatchwriteiicnolimit funbatchwriteiicnolimit , \
	hisfx3logpush_back funlogpushback , hardwarepagewriteiic fucpagewriteiic , hardwarepagereadiic fucpagereadiic, \
	hardwarepagewritespi funpagewritespi, hardwarepagereadspi funpagereadspi);

typedef int (__cdecl *Rolongowritedualcameratestdata)(std::vector<std::wstring>& vectorHisCCMOTPInfoW, _HisCCMDualCameraBurn_Config* pstconfig , hardwarereadiic funreadiic , hardwarewriteiic funwriteiic , hardwaresetiicspeed funiicspeed , \
	hardwaresetvolt funsetvolt , hardwaregetvolt fungetvolt , hardwaresetvfuse funsetvfuse , hardwaregetvfuse fungetvfuse , hardwaregetframe fungetframe , \
	hardwarebatchwriteiic funbatchwriteiic , hardwarebatchreadiic funbatchreadiic , hardwaresetgpio funsetgpio , hardwaregetgpio fungetgpio , \
	hardwarepullreset funreset , hardwarepullpwnd funpwnd , hardwarebatchreadiicnolimit funbatchreadiicnolimit , hardwarebatchwriteiicnolimit funbatchwriteiicnolimit , \
	hisfx3logpush_back funlogpushback , hardwarepagewriteiic fucpagewriteiic , hardwarepagereadiic fucpagereadiic, \
	hardwarepagewritespi funpagewritespi, hardwarepagereadspi funpagereadspi);
typedef int (__cdecl *Rolongocheckdualcameratestdata)(std::vector<std::wstring>& vectorHisCCMOTPInfoW, _HisCCMDualCameraBurn_Config* pstconfig, hardwarereadiic funreadiic , hardwarewriteiic funwriteiic , hardwaresetiicspeed funiicspeed , \
	hardwaresetvolt funsetvolt , hardwaregetvolt fungetvolt , hardwaresetvfuse funsetvfuse , hardwaregetvfuse fungetvfuse , hardwaregetframe fungetframe , \
	hardwarebatchwriteiic funbatchwriteiic , hardwarebatchreadiic funbatchreadiic , hardwaresetgpio funsetgpio , hardwaregetgpio fungetgpio , \
	hardwarepullreset funreset , hardwarepullpwnd funpwnd , hardwarebatchreadiicnolimit funbatchreadiicnolimit , hardwarebatchwriteiicnolimit funbatchwriteiicnolimit , \
	hisfx3logpush_back funlogpushback , hardwarepagewriteiic fucpagewriteiic , hardwarepagereadiic fucpagereadiic, \
	hardwarepagewritespi funpagewritespi, hardwarepagereadspi funpagereadspi);


typedef int (*CoaxialityCailibrationbySquare)(unsigned char* pucrgbmainbuff,bool bIsrgbmain, int iWidthmain, int iHeightmain,unsigned char* pucrgbassistantbuff,bool bIsrgnassis,int iWidthassistance,int iHeightassistance,\
	double dChartsquaredistancex,double dChartsquaredistancey,double dCamdistance,double dDcam2chart,double&dAnglex,double& dAngley,int&iPixeldiffx,int& iPixeldiffy);

bool sort_fcplotitem(_focuscheckCurvePlotItem item1, _focuscheckCurvePlotItem item2)
{
	return item1.istep < item2.istep;
}

bool sort_lpitem_fov(_HisCCMAlg_LPItem_Info& item1, _HisCCMAlg_LPItem_Info& item2)
{
	return item1.flFOV < item2.flFOV;
}

bool sort_sfraitem_fov(_HisCCMAlg_SFRPlusHAItem_Info& item1, _HisCCMAlg_SFRPlusHAItem_Info& item2)
{
	return item1.flFOV < item2.flFOV;
}

bool sort_mtfitem_fov(_HisCCMAlg_MTFItem_Info& item1, _HisCCMAlg_MTFItem_Info& item2)
{
	return item1.flFOV < item2.flFOV;
}

itemprocess::itemprocess(bool bChannel1, _threadshareData& threadshareDataC, _global_itemexec& itemshareDataC, _globalFunctionPointer& globalFunPointerC, \
	QHImageFrame& imageframeC, QScrollBar& horizontalScrollBarC, QScrollBar& verticalScrollBarC, QLineEdit& serialNumberLineEditC,HisFX3CCMTest *parent)
	:bBoxChannel1(bChannel1), threadshareData(threadshareDataC), itemshareData(itemshareDataC), globalFunPointer(globalFunPointerC), \
	imageframe(imageframeC), horizontalScrollBar(horizontalScrollBarC), verticalScrollBar(verticalScrollBarC), serialNumberLineEdit(serialNumberLineEditC),bAutoFocus(false),widCCMTest(parent)
{
	licenseCount = 0;
	iMotorStartDec = iNearPeakMotorDec = iMiddlePeakMotorDec = iFarPeakMotorDec = 0x00FFFFFF;
	memset(pstAeData,	0,	45 *sizeof(_autoExposreData*));

	GetFreshframe = (bChannel1)?(GetFreshframeC1):(GetFreshframeC2);

	classLog	=	(bChannel1)?(&classGlobalLogC1):(&classGlobalLogC2);

#if (defined _WIN64) && (defined _DEBUG)
	QString strLibPath	=	QDir::currentPath() % "/HisCCMSensor64D";
#elif (defined _WIN64) && !(defined _DEBUG)
	QString strLibPath	=	QDir::currentPath() % "/HisCCMSensor64";
#elif (defined _WIN32) && (defined _DEBUG)
	QString strLibPath	=	QDir::currentPath() % "/HisCCMSensor32D";
#else
	QString strLibPath	=	QDir::currentPath() % "/HisCCMSensor32";
#endif

	getSensorAPIVersion = (RolongogetSensorAPIVersion)(strLibPath, "getSensorAPIVersion");
	getExposureTime = (RolongogetExposureTime)(QLibrary::resolve(strLibPath, "getExposureTime"));
	setExposureTime = (RolongosetExposureTime)(QLibrary::resolve(strLibPath, "setExposureTime"));
	setGlobalGain = (RolongosetGlobalGain)(QLibrary::resolve(strLibPath, "setGlobalGain"));
	setMotor = (RolongosetMotor)(QLibrary::resolve(strLibPath, "setMotor"));
	motorScaleto1023 = (RolongomotorScaleto1023)(QLibrary::resolve(strLibPath, "motorScaleto1023"));
	motorScalefrom1023 = (RolongomotorScalefrom1023)(QLibrary::resolve(strLibPath, "motorScalefrom1023"));
}

itemprocess::~itemprocess()
{
	for(int x=0;	x<45;	++x){
		HisReleaseNewO(pstAeData[x]);
	}
}

void itemprocess::finish()
{
	emit finished();
}

int itemprocess::GetTotalResult()
{
	itemshareData.itemstatusLock.lockForRead();
	int iResult	=	0, iErrorCode = 0;
	unsigned short usitem;
	for(QList<_itemStatus>::iterator theiterator = itemshareData.itemstatusList.begin(); theiterator != itemshareData.itemstatusList.end(); theiterator++){
		if(theiterator->ucstatus != _His_ItemStatus_PASS) {
			iResult			= HisCCMError_Result;
			iErrorCode	=	theiterator->iErrorCode;
			usitem			=	theiterator->usitem;
			break;
		}	
	}
	itemshareData.itemstatusLock.unlock();

	if(!iResult){
		//良品统计
		if(threadshareData.stStatisticsHistory.bEnable){
			++threadshareData.stStatisticsHistory.uiALL;
			++threadshareData.stStatisticsNow.uiALL;
			++threadshareData.stStatisticsHistory.uiPASS;
			++threadshareData.stStatisticsNow.uiPASS;

			unsigned int uiUPHIndex	=	(threadshareData.timerUPH.elapsed() % 3600000) /600000;
			if(uiUPHIndex != threadshareData.ucUPH10mIndex){
				threadshareData.ucUPH10mIndex	=	uiUPHIndex;
				threadshareData.ucUPH10m[uiUPHIndex]	=	1;
			}
			else{
				++(threadshareData.ucUPH10m[uiUPHIndex]);
			}
		}
	}
	else if(iErrorCode != HisFX3Error_Parameter && iErrorCode != HisFX3Error_USBDataOut && iErrorCode != HisFX3Error_CreateThread && \
		iErrorCode != HisFX3Error_License && iErrorCode != HisFX3Error_MemNotEnough && iErrorCode != HisFX3Error_CreateEvent && \
		iErrorCode != HisFX3Error_MallocBuffer && iErrorCode != HisFX3Error_IsNotOpen && iErrorCode != HisFX3Error_Construct && \
		iErrorCode != HisFX3Error_CloseUSB3){
			unsigned int uiUPHIndex	=	(threadshareData.timerUPH.elapsed() % 3600000) /600000;
			if(uiUPHIndex != threadshareData.ucUPH10mIndex){
				threadshareData.ucUPH10mIndex	=	uiUPHIndex;
				threadshareData.ucUPH10m[uiUPHIndex]	=	1;
			}
			else{
				++(threadshareData.ucUPH10m[uiUPHIndex]);
			}

			//不良品统计
			QString strErrorText;
			if(threadshareData.stStatisticsHistory.bEnable) { ++threadshareData.stStatisticsHistory.uiALL; ++threadshareData.stStatisticsNow.uiALL; }	
			switch (usitem){
			case mtffaitem:
				if(threadshareData.stStatisticsHistory.bEnable) {++threadshareData.stStatisticsHistory.uiFA; ++threadshareData.stStatisticsNow.uiFA;iResult=NG_FA;} 
				strErrorText = QTextCodec::codecForName( "GBK")->toUnicode("FA"); break;
			case sfrfacaitem:
				if(threadshareData.stStatisticsHistory.bEnable) {++threadshareData.stStatisticsHistory.uiFA; ++threadshareData.stStatisticsNow.uiFA;iResult=NG_FA;} 
				strErrorText = QTextCodec::codecForName( "GBK")->toUnicode("FA"); break;
			case autofageneralitem:
				if(threadshareData.stStatisticsHistory.bEnable) {++threadshareData.stStatisticsHistory.uiFA; ++threadshareData.stStatisticsNow.uiFA;iResult=NG_FA;} 
				strErrorText = QTextCodec::codecForName( "GBK")->toUnicode("FA"); break;
			case lpmfaitem: 
				if(threadshareData.stStatisticsHistory.bEnable) {++threadshareData.stStatisticsHistory.uiFA; ++threadshareData.stStatisticsNow.uiFA;iResult=NG_FA;} 
				strErrorText = QTextCodec::codecForName( "GBK")->toUnicode("FA"); break;
			case whitepanelitem_blemish :
			case whitepanelitem_blemishb: 
				if(threadshareData.stStatisticsHistory.bEnable) {++threadshareData.stStatisticsHistory.uiBlemish; ++threadshareData.stStatisticsNow.uiBlemish;iResult=NG_Blemish;}
				strErrorText = QTextCodec::codecForName( "GBK")->toUnicode("POG"); break;
			case whitepanelitem_color: 
				if(threadshareData.stStatisticsHistory.bEnable) {++threadshareData.stStatisticsHistory.uiColor; ++threadshareData.stStatisticsNow.uiColor;iResult=NG_Color;}
				strErrorText = QTextCodec::codecForName( "GBK")->toUnicode("Color"); break;
			case whitepanelitem_oc: 
				if(threadshareData.stStatisticsHistory.bEnable) {++threadshareData.stStatisticsHistory.uiOC; ++threadshareData.stStatisticsNow.uiOC;iResult=NG_OC; }
				strErrorText = QTextCodec::codecForName( "GBK")->toUnicode("OC"); break;
			case whitepanelitem_line: 
				if(threadshareData.stStatisticsHistory.bEnable) {++threadshareData.stStatisticsHistory.uiLine; ++threadshareData.stStatisticsNow.uiLine;iResult=NG_Line;} 
				strErrorText = QTextCodec::codecForName( "GBK")->toUnicode("Line"); break;
			case whitepanelitem_pixel: 
				if(threadshareData.stStatisticsHistory.bEnable) {++threadshareData.stStatisticsHistory.uiDefectPixel; ++threadshareData.stStatisticsNow.uiDefectPixel;iResult=NG_DefectPixel;} 
				strErrorText = QTextCodec::codecForName( "GBK")->toUnicode("POD"); break;
			case whitepanelitem_shading: 
				if(threadshareData.stStatisticsHistory.bEnable) {++threadshareData.stStatisticsHistory.uiShading; ++threadshareData.stStatisticsNow.uiShading;iResult=NG_Shading;} 
				strErrorText = QTextCodec::codecForName( "GBK")->toUnicode("Shading"); break;
			case whitepanelitem_vignetting: 
				if(threadshareData.stStatisticsHistory.bEnable) {++threadshareData.stStatisticsHistory.uiVignetting; ++threadshareData.stStatisticsNow.uiVignetting;iResult=NG_Vignetting;} 
				strErrorText = QTextCodec::codecForName( "GBK")->toUnicode("Veginetting"); break;
			case sfrnearafcitem: 
				if(threadshareData.stStatisticsHistory.bEnable) {++threadshareData.stStatisticsHistory.uiAFCNear; ++threadshareData.stStatisticsNow.uiAFCNear;iResult=NG_AFBurnCheck;}
				strErrorText = QTextCodec::codecForName( "GBK")->toUnicode("Near"); break;
			case sfrmiddleafcitem: 
				if(threadshareData.stStatisticsHistory.bEnable) {++threadshareData.stStatisticsHistory.uiAFCMiddle; ++threadshareData.stStatisticsNow.uiAFCMiddle; iResult=NG_AFCMiddle;}
				strErrorText = QTextCodec::codecForName( "GBK")->toUnicode("Middle"); break;
			case sfrfarafcitem: 
				if(threadshareData.stStatisticsHistory.bEnable) {++threadshareData.stStatisticsHistory.uiAFCFar; ++threadshareData.stStatisticsNow.uiAFCFar;iResult=NG_AFCFar;}
				strErrorText = QTextCodec::codecForName( "GBK")->toUnicode("Far"); break;
			case workcurrentitem:  
				if(threadshareData.stStatisticsHistory.bEnable) {++threadshareData.stStatisticsHistory.uiWorkCurrent; ++threadshareData.stStatisticsNow.uiWorkCurrent;iResult=NG_WorkCurrent; }
				strErrorText = QTextCodec::codecForName( "GBK")->toUnicode("Standby Current"); break;
			case standbycurrentitem:  
				if(threadshareData.stStatisticsHistory.bEnable) {++threadshareData.stStatisticsHistory.uiStandbyCurrent; ++threadshareData.stStatisticsNow.uiStandbyCurrent;iResult=NG_StandbyCurrent; }
				strErrorText = QTextCodec::codecForName( "GBK")->toUnicode("Work Current"); break;
			case otpburnitem:  
				if(threadshareData.stStatisticsHistory.bEnable) {++threadshareData.stStatisticsHistory.uiOTPBurn; ++threadshareData.stStatisticsNow.uiOTPBurn;iResult=NG_OTPBurn; }
				strErrorText = QTextCodec::codecForName( "GBK")->toUnicode("OTP Burn"); break;
			case otpcheckitem:  
				if(threadshareData.stStatisticsHistory.bEnable) {++threadshareData.stStatisticsHistory.uiOTPBurnCheck; ++threadshareData.stStatisticsNow.uiOTPBurnCheck;iResult=NG_OTPBurnCheck; }
				strErrorText = QTextCodec::codecForName( "GBK")->toUnicode("OTP Check"); break;
			case afburnitem:  
				if(threadshareData.stStatisticsHistory.bEnable) {++threadshareData.stStatisticsHistory.uiAFBurn; ++threadshareData.stStatisticsNow.uiAFBurn;iResult=NG_AFBurn; }
				strErrorText = QTextCodec::codecForName( "GBK")->toUnicode("AF Burn"); break;
			case afburncheckitem: 
				if(threadshareData.stStatisticsHistory.bEnable) {++threadshareData.stStatisticsHistory.uiAFBurnCheck; ++threadshareData.stStatisticsNow.uiAFBurnCheck;iResult=NG_AFBurnCheck; }
				strErrorText = QTextCodec::codecForName( "GBK")->toUnicode("AF Check"); break;
			case blackfielditem:  
				if(threadshareData.stStatisticsHistory.bEnable) {++threadshareData.stStatisticsHistory.uiLightPixel; ++threadshareData.stStatisticsNow.uiLightPixel;iResult=NG_LightPixel; }
				strErrorText = QTextCodec::codecForName( "GBK")->toUnicode("POD"); break;
			case sonypdafSPCitem:
				if(threadshareData.stStatisticsHistory.bEnable) {++threadshareData.stStatisticsHistory.uiPDAFBurn; ++threadshareData.stStatisticsNow.uiPDAFBurn; iResult=NG_PDAFBurn;}
				strErrorText = QTextCodec::codecForName( "GBK")->toUnicode("PDAF"); break;
			case pdafgbmtkcheckitem: 
				if(threadshareData.stStatisticsHistory.bEnable) {++threadshareData.stStatisticsHistory.uiPDAFBurnCheck; ++threadshareData.stStatisticsNow.uiPDAFBurnCheck; iResult=NG_PDAFBurnCheck;}
				strErrorText = QTextCodec::codecForName( "GBK")->toUnicode("PDAF Check"); break;
			case startpreviewitem:  
				if(threadshareData.stStatisticsHistory.bEnable) {++threadshareData.stStatisticsHistory.uiPreview; ++threadshareData.stStatisticsNow.uiPreview;iResult=NG_Preview; }
				strErrorText = QTextCodec::codecForName( "GBK")->toUnicode("Preview"); break;
			default: 
				if(threadshareData.stStatisticsHistory.bEnable) {++threadshareData.stStatisticsHistory.uiOther; ++threadshareData.stStatisticsNow.uiOther;iResult=NG_Other;}
				strErrorText = "Other"; break;
			}

	}
	else{

	}

	ROPLOW::SetStatisticsToDB(threadshareData.stStatisticsHistory, bBoxChannel1);
	emit drawTactistics();
	return iResult;
}

void itemprocess::updateItemstatus(_itemStatus& itemstatus)
{
	itemshareData.itemstatusLock.lockForWrite();
	itemstatus.shortcutKey		=	itemshareData.shortcutKey;
	itemstatus.ucClickTime		=	itemshareData.ucClickTime;;
	itemstatus.ucItemIndex		=	itemshareData.ucItemIndex;
	bool bExist				=	false;
	for(QList<_itemStatus>::iterator theiterator = itemshareData.itemstatusList.begin(); theiterator != itemshareData.itemstatusList.end(); theiterator++){
		if(theiterator->usitem == itemstatus.usitem && theiterator->ucItemIndex == itemstatus.ucItemIndex && \
			theiterator->ucClickTime == itemstatus.ucClickTime && theiterator->shortcutKey == itemstatus.shortcutKey){
				theiterator->ucstatus	=	itemstatus.ucstatus;
				theiterator->ustime		=	itemstatus.ustime;
				theiterator->iErrorCode		=	itemstatus.iErrorCode;
				bExist							=	true;
				break;
		}
	}
	if(!bExist) itemshareData.itemstatusList.push_back(itemstatus);
	itemshareData.itemstatusLock.unlock();
	emit updateresult();
	if(hisglobalparameter.bShowItem2EndResult || hisglobalparameter.getfaflag()){
		emit signalshowitem2endresult(itemstatus.usitem, itemstatus.ucstatus, itemstatus.ustime);
	}
}

int itemprocess::getccmhardwareParameter(bool bupdate, bool bcheck)
{
	itemshareData.itemparameterLock.lockForRead();
	if(!bupdate && itemshareData.ccmhardwareParameter){
		itemshareData.itemparameterLock.unlock();
		return 0;
	}

	QMutexLocker locker(&hisglobalparameter.mutexDatabase);

	itemshareData.itemparameterLock.unlock();
	itemshareData.itemparameterLock.lockForWrite();
	if(!itemshareData.ccmhardwareParameter)
		itemshareData.ccmhardwareParameter	=	new _ccmHardware;
	if(!itemshareData.ccmhardwareParameter){
		itemshareData.itemparameterLock.unlock();
		return HisFX3Error_MallocBuffer;
	}

	bool bparsesuccess	=	true, bItemExist = false;

	for(int w=0;	w<1;	++w)
	{
		QSqlDatabase customdb = QSqlDatabase::addDatabase("QSQLITE", "querycustom");
		customdb.setDatabaseName(QDir::currentPath() % "/HisFX3Custom");
		if (!customdb.open()){
			bparsesuccess	=	false;
			break;
		}

		QSqlQuery query(customdb);
		query.prepare("SELECT key,value,reserve FROM " % itemshareData.currentTableName % " WHERE classfy='platform' AND item='ccm' AND itemsuffix1='element' ORDER BY id ASC" );
		query.exec();
		QString strData;

		while (query.next()){
			bItemExist = true;
			strData	=	query.value(0).toString().trimmed().toLower();
			if(strData == "sensor_type"){
				itemshareData.ccmhardwareParameter->sensortype		=	query.value(1).toString();
				itemshareData.ccmhardwareParameter->b4Cell				=	!!query.value(2).toUInt();
			}
			else if(strData == "lens_type")
				itemshareData.ccmhardwareParameter->lenstype			=	query.value(1).toString();
			else if(strData == "motor_type")
				itemshareData.ccmhardwareParameter->motortype		=	query.value(1).toString();
			else if(strData == "project_name")
				itemshareData.ccmhardwareParameter->projectname	=	query.value(1).toString();
			else if(strData == "machinetype")
				itemshareData.ccmhardwareParameter->machinetype	=	query.value(1).toString();
			else if(strData == "ee_slave")
				itemshareData.ccmhardwareParameter->ucEESlave		=	(query.value(1).toString()).toUInt(0, 16);
			else if(strData == "sensorfactory"){
				itemshareData.ccmhardwareParameter->uiSensorFactory				=	(query.value(1).toString()).toUInt();
				itemshareData.ccmhardwareParameter->bCheckFrameRight		=	!!query.value(2).toUInt();
			}
			else if(strData == "opd")
				itemshareData.ccmhardwareParameter->dopd		=	(query.value(1).toString()).toDouble();
			else if(strData == "wdr")
				itemshareData.ccmhardwareParameter->dwdr		=	(query.value(1).toString()).toDouble();
			else if(strData == "actual")
				itemshareData.ccmhardwareParameter->dactual		=	(query.value(1).toString()).toDouble();
		}

		customdb.close();
	}

	QSqlDatabase::removeDatabase("querycustom");
	if(!bparsesuccess || !bItemExist){
		HisReleaseNewO(itemshareData.ccmhardwareParameter);
		itemshareData.itemparameterLock.unlock();
		return HisFX3Error_Parameter;
	}

	if(!bcheck) {itemshareData.itemparameterLock.unlock(); return 0; }

	if(itemshareData.ccmhardwareParameter->projectname.isEmpty()){
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("项目名称不能为空"));
		HisReleaseNewO(itemshareData.ccmhardwareParameter);
		itemshareData.itemparameterLock.unlock();
		return HisFX3Error_Parameter;
	}
	if(itemshareData.ccmhardwareParameter->sensortype.isEmpty()){
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("sensor型号不能为空"));
		HisReleaseNewO(itemshareData.ccmhardwareParameter);
		itemshareData.itemparameterLock.unlock();
		return HisFX3Error_Parameter;
	}

	itemshareData.itemparameterLock.unlock();
	return 0;
}

int itemprocess::getpreviewParameter(bool bupdate, bool bcheck)
{
	if(bBoxChannel1 && classPlatform.HisFX3GetOfflineModeInfo(NULL, NULL, NULL, NULL))
	{
		itemshareData.itemparameterLock.lockForWrite();
		if(!itemshareData.previewParameter)	itemshareData.previewParameter	=	new _HisFX3_PreviewStruct;
		classPlatform.HisFX3GetOfflineModeInfo(&(itemshareData.previewParameter->iWidth), &(itemshareData.previewParameter->iHeight), \
			&(itemshareData.previewParameter->ucDataFormat), &(itemshareData.previewParameter->uiFrameByteCount));
		itemshareData.itemparameterLock.unlock();
		threadshareData.ucInterpolation	=	1;
		return 0;
	}
	else if(!bBoxChannel1 && classPlatform.HisFX3GetOfflineModeInfo_S2(NULL, NULL, NULL, NULL))
	{
		itemshareData.itemparameterLock.lockForWrite();
		if(!itemshareData.previewParameter)	itemshareData.previewParameter	=	new _HisFX3_PreviewStruct;
		classPlatform.HisFX3GetOfflineModeInfo_S2(&(itemshareData.previewParameter->iWidth), &(itemshareData.previewParameter->iHeight), \
			&(itemshareData.previewParameter->ucDataFormat), &(itemshareData.previewParameter->uiFrameByteCount));
		itemshareData.itemparameterLock.unlock();
		return 0;
	}

	itemshareData.itemparameterLock.lockForRead();
	if(!bupdate && itemshareData.previewParameter){
		itemshareData.itemparameterLock.unlock();
		return 0;
	}

	QMutexLocker locker(&hisglobalparameter.mutexDatabase);

	itemshareData.itemparameterLock.unlock();
	itemshareData.itemparameterLock.lockForWrite();
	if (itemshareData.previewParameter){
		HisReleaseNewB(itemshareData.previewParameter->pusType);
		HisReleaseNewB(itemshareData.previewParameter->pui64Data);
		HisReleaseNewB(itemshareData.previewParameter->puiReg);
		HisReleaseNewB(itemshareData.previewParameter->pucSlave);
		HisReleaseNewO(itemshareData.previewParameter);
	}

	if(!itemshareData.previewParameter)
		itemshareData.previewParameter	=	new _HisFX3_PreviewStruct;
	if(!itemshareData.previewParameter){
		itemshareData.itemparameterLock.unlock();
		return HisFX3Error_MallocBuffer;
	}

	bool bparsesuccess	=	true, bItemExist = false;
	for(int w=0;	w<1;	++w){
		QSqlDatabase customdb = QSqlDatabase::addDatabase("QSQLITE", "querycustom");
		customdb.setDatabaseName(QDir::currentPath() % "/HisFX3Custom");
		if (!customdb.open()){
			bparsesuccess	=	false;
			break;
		}

		QString strData, strData2, strData3, strData4;
		QStringList stringlist, strname, strvalue;
		bool bok;
		QSqlQuery query(customdb);
		query.prepare("SELECT value FROM " % itemshareData.currentTableName % " WHERE classfy='platform' AND item='sensor' "
			"AND itemsuffix1='preview_i2c' ORDER BY id ASC");
		query.exec();

		while (query.next()){
			++(itemshareData.previewParameter->usI2CCount);
		}

		itemshareData.previewParameter->pusType		=	new unsigned short[itemshareData.previewParameter->usI2CCount];
		itemshareData.previewParameter->pui64Data		=	new unsigned __int64[itemshareData.previewParameter->usI2CCount];
		itemshareData.previewParameter->puiReg			=	new unsigned int[itemshareData.previewParameter->usI2CCount];
		itemshareData.previewParameter->pucSlave		=	new unsigned char[itemshareData.previewParameter->usI2CCount];
		if(!itemshareData.previewParameter->pusType || !itemshareData.previewParameter->pui64Data || \
			!itemshareData.previewParameter->puiReg || !itemshareData.previewParameter->pucSlave){
				bparsesuccess	=	false;
				break;
		}

		query.prepare("SELECT value FROM " % itemshareData.currentTableName % " WHERE classfy='platform' AND item='sensor' "
			"AND itemsuffix1='preview_i2c' ORDER BY id ASC");
		query.exec();
		unsigned short usIndex	=	0;
		while (query.next()){
			bItemExist	=	true;
			strData		=	query.value(0).toString();
			strData		=	strData.toLower();
			strData		=	strData.remove("0x");
			strData		=	strData.remove(" ");
			stringlist		=	strData.split(",", QString::SkipEmptyParts);
			if (stringlist.size() == 4){
				itemshareData.previewParameter->pucSlave[usIndex]		=	static_cast<unsigned char>(stringlist.at(0).toUShort(&bok, 16));
				itemshareData.previewParameter->puiReg[usIndex]		=	stringlist.at(1).toUInt(&bok, 16);
				itemshareData.previewParameter->pui64Data[usIndex]	=	stringlist.at(2).toULongLong(&bok, 16);
				itemshareData.previewParameter->pusType[usIndex]		=	stringlist.at(3).toUShort(&bok, 16);
				++usIndex;
			}
		}

		itemshareData.previewParameter->usI2CCount	=	usIndex;

		query.prepare("SELECT itemsuffix1,key,value,reserve,itemsuffix2 FROM " % itemshareData.currentTableName % " WHERE classfy='platform' AND item='sensor' "
			"AND itemsuffix1!='preview_i2c' ORDER BY id ASC" );
		query.exec();
		while (query.next()){
			bItemExist	=	true;
			strData	=	query.value(0).toString();	strData	=	strData.trimmed();		strData	=	strData.toLower();
			strData2	=	query.value(1).toString();	strData2	=	strData2.trimmed();	strData2	=	strData2.toLower();
			strData3	=	query.value(2).toString();	strData3	=	strData3.trimmed();	strData3	=	strData3.toLower();
			strData4	=	query.value(3).toString();	strData4	=	strData4.trimmed();	strData4	=	strData4.toLower();

			if (strData == "voltage"){
				if (strData2	==	"dovdd")			itemshareData.previewParameter->ucVolt_DOVDD	=	strData3.toFloat();
				else if (strData2	==	"dvdd")	itemshareData.previewParameter->ucVolt_DVDD		=	strData3.toFloat();
				else if (strData2	==	"avdd")	itemshareData.previewParameter->ucVolt_AVDD			=	strData3.toFloat();
				else if (strData2	==	"af")			itemshareData.previewParameter->ucVolt_AF			=	strData3.toFloat();
				else if (strData2	==	"vfuse")	itemshareData.previewParameter->ucVolt_VFuse	=	strData3.toFloat();
				else if (strData2	==	"iodd")	itemshareData.previewParameter->ucVolt_IODD			=	strData3.toFloat();
				else if (strData2	==	"pow")	itemshareData.previewParameter->ucVolt_POW			=	strData3.toFloat();
				else if (strData2	==	"v5")	itemshareData.previewParameter->ucVolt_5V					=	strData3.toUInt() & 0xFF;
				else if (strData2	==	"v12")	itemshareData.previewParameter->ucVolt_12V			=	strData3.toUInt() & 0xFF;
				else if (strData2	==	"voltflag")	itemshareData.previewParameter->uiVoltSetFlag		=	strData3.toUInt();
			}
			else if (strData == "signal"){ 
				if (strData2 == "mclk")							itemshareData.previewParameter->flMCLK						=	strData3.toFloat();
				else if(strData2 == "reset_activedlow")	itemshareData.previewParameter->bReset_ActiveLow	=	(strData3.toUInt())?(true):(false);
				else if(strData2 == "pwnd_activedlow")	itemshareData.previewParameter->bPWND_ActiveLow	=	(strData3.toUInt())?(true):(false);
				else if(strData2 == "signalflag")
				{
					itemshareData.previewParameter->bIsSetRST		=	query.value(4).toUInt();
					itemshareData.previewParameter->bIsSetPWDN	=	strData3.toUInt();
					itemshareData.previewParameter->bIsSetMCLK		=	strData4.toUInt();
				}
			}
			else if (strData == "i2c"){
				if (strData2 == "speed")	{
					itemshareData.previewParameter->usI2CSpeed	=	strData3.toUShort(&bok, 10);
					itemshareData.previewParameter->ucCommProtocal	=	strData4.toUInt();
					itemshareData.previewParameter->usI2CIntervalTime	=	query.value(4).toUInt();
				}
			}
			else if (strData == "mipi")
			{
				if (strData2 == "lane"){
					itemshareData.previewParameter->ucMIPILane					=	strData3.toUShort(&bok, 10);
					itemshareData.previewParameter->bDVP_VS_ActiveHigh	=	(strData4 == "high");
					itemshareData.previewParameter->ucDVP_LineFormat		=	query.value(4).toUInt() & 0xFF;
					ROPLOW::patchconfigstring(query.value(4).toString(), strname, strvalue);
					for(unsigned int x=0;	x<strname.size(); ++x)
					{
						if(strname.at(x) == "dvpdataline")			itemshareData.previewParameter->ucDVP_LineFormat  = strvalue.at(x).toUInt() & 0xFF;
						else if(strname.at(x) == "dvpps")	itemshareData.previewParameter->ucDVP_PhaseShift	= strvalue.at(x).toUInt() & 0xFF;
					}
				}
				else if (strData2 == "lvds_outputxhsvhs"){
					itemshareData.previewParameter->bOutputXSVS	=	(strData3 == "true");
				}
				else if (strData2 == "xhsvhs_value"){
					itemshareData.previewParameter->uiLVDS_XHS					=	strData3.toUInt();
					itemshareData.previewParameter->uiLVDS_XVS					=	strData4.toUInt();
				}
				else if (strData2 == "lvds_align_set") itemshareData.previewParameter->usLVDSAlign = strData3.toUShort();
				else if(strData2 == "signal mode") itemshareData.previewParameter->ucSignalMode = strData3.toUInt() & 0xFF;
			}
			else if (strData == "image"){
				if (strData2 == "width")			itemshareData.previewParameter->iWidth	=	strData3.toUInt();
				else if(strData2 == "height")	itemshareData.previewParameter->iHeight	=	strData3.toUInt();
				else if(strData2 == "data_format")	itemshareData.previewParameter->ucDataFormat = HISGLOBALUI::dataformat2UInt(strData3);
				else if(strData2 == "dummy_left")	itemshareData.previewParameter->uiDummyLeft	=	strData3.toUInt();
				else if(strData2 == "dummy_right")	itemshareData.previewParameter->uiDummyRight	=	strData3.toUInt();
				else if(strData2 == "dummy_top")	itemshareData.previewParameter->uiDummyTop	=	strData3.toUInt();
				else if(strData2 == "dummy_bottom")	itemshareData.previewParameter->uiDummyBottom	=	strData3.toUInt();
			}
		}

		switch (itemshareData.previewParameter->ucDataFormat){
		case HisBaylor8_BGGR:
		case HisBaylor8_RGGB:
		case HisBaylor8_GRBG:
		case HisBaylor8_GBRG:
		case HisBaylor8_MONO:
			itemshareData.previewParameter->uiFrameByteCount	=	itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight;
			break;
		case HisBaylor10_BGGR:
		case HisBaylor10_RGGB:
		case HisBaylor10_GRBG:
		case HisBaylor10_GBRG:
		case HisBaylor10_MONO:
			itemshareData.previewParameter->uiFrameByteCount	=	itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight *2;
			break;
		case HisBaylor12_BGGR:
		case HisBaylor12_RGGB:
		case HisBaylor12_GRBG:
		case HisBaylor12_GBRG:
		case HisBaylor12_MONO:
			itemshareData.previewParameter->uiFrameByteCount	=	itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight *2;
			break;
		case HisYUV8_422_YUYV:
		case HisYUV8_422_UYVY:
		case HisYUV8_422_YVYU:
		case HisYUV8_422_VYUY:
			itemshareData.previewParameter->uiFrameByteCount	=	itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight *2;
			break;
		case HisRGB_RGB24:
			itemshareData.previewParameter->uiFrameByteCount	=	itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight *3;
			break;
		default:
			itemshareData.previewParameter->uiFrameByteCount	=	0;
			break;
		}

		query.prepare("SELECT itemsuffix2 FROM " % itemshareData.currentTableName % " WHERE classfy='platform' AND item='sensor' AND itemsuffix1='otheradd'" );
		query.exec();
		while (query.next())
		{
			strData	=	query.value(0).toString();
			ROPLOW::patchconfigstring(strData, strname, strvalue);
			for(unsigned int x=0;	x<strname.size();	++x){
				if(strname.at(x) == "spicslow")	itemshareData.previewParameter->bSPICSLow	=	strvalue.at(x).toUInt();
				else if(strname.at(x) == "spilittileendian")	itemshareData.previewParameter->bSPILittleEndian	=	strvalue.at(x).toUInt();
				else if(strname.at(x) == "checkdeviceack")	itemshareData.previewParameter->bCheckDeviceAck	=	strvalue.at(x).toUInt();
				else if(strname.at(x) == "ddr3")	itemshareData.previewParameter->bUseDDR	=	strvalue.at(x).toUInt();
				else if(strname.at(x) == "virtualchannel")	itemshareData.previewParameter->bVirtualChannel	=	strvalue.at(x).toUInt();
				else if(strname.at(x) == "lanenumber")	itemshareData.previewParameter->ucLaneNum	=	strvalue.at(x).toUInt() & 0xFF;
			}
		}


		//--------------------------------------------------------//
		query.prepare("SELECT itemsuffix1,itemsuffix2,key,value FROM " % itemshareData.currentTableName % " WHERE classfy='platform' AND item='light' "
			"ORDER BY id ASC" );
		query.exec();
		//threadshareData.stawbpra.ucawb	=	His_AWB_NO;

		while (query.next())
		{
			bItemExist = true;
			strData	=	query.value(0).toString().trimmed();
			ROPLOW::patchconfigstring(strData, strname, strvalue);
			//(switch:manual)(r:1.0)(b:1.0)(frame:5)
			for(unsigned int i=0;	i<strname.size(); ++i){
				if(strname.at(i) == "exposureswitch"){
					if(strvalue.at(i) == "open") threadshareData.bIsexposure = true;
					else if(strvalue.at(i) == "close") threadshareData.bIsexposure = false;
				}
				else if(strname.at(i) == "analoggainswitch") threadshareData.bSetGlobalGain = (strvalue.at(i) == "open");			
				else if(strname.at(i) == "exposurevalue") threadshareData.flExposure = strvalue.at(i).toFloat();
				else if(strname.at(i) == "analoggainvalue") threadshareData.flGlobalGainValue = strvalue.at(i).toFloat();
				else if(strname.at(i) == "waitdata") threadshareData.usWaitPreviewDataTime = strvalue.at(i).toUShort();
				else if(strname.at(i) == "outputerrorframe") threadshareData.bOutputErrorFrame = (strvalue.at(i) == "true");
				else if(strname.at(i) == "interpolation") threadshareData.ucInterpolation	=	strvalue.at(i).toUInt() & 0xFF;
				else if(strname.at(i) == "tograyimage") threadshareData.bGrayImage	=	strvalue.at(i).toUInt();
			}
		}

		customdb.close();
	}



	QSqlDatabase::removeDatabase("querycustom");
	if(!bparsesuccess){
		if (itemshareData.previewParameter){
			HisReleaseNewB(itemshareData.previewParameter->pusType);
			HisReleaseNewB(itemshareData.previewParameter->pui64Data);
			HisReleaseNewB(itemshareData.previewParameter->puiReg);
			HisReleaseNewB(itemshareData.previewParameter->pucSlave);
			HisReleaseNewO(itemshareData.previewParameter);
		}
		itemshareData.itemparameterLock.unlock();
		return HisFX3Error_Parameter;
	}

	if(!bItemExist)
	{
		if (itemshareData.previewParameter){
			HisReleaseNewB(itemshareData.previewParameter->pusType);
			HisReleaseNewB(itemshareData.previewParameter->pui64Data);
			HisReleaseNewB(itemshareData.previewParameter->puiReg);
			HisReleaseNewB(itemshareData.previewParameter->pucSlave);
			HisReleaseNewO(itemshareData.previewParameter);
		}
		itemshareData.itemparameterLock.unlock();
		return HisFX3Error_Parameter;
	}

	if(!bcheck) {itemshareData.itemparameterLock.unlock(); return 0; }

	if(itemshareData.previewParameter->usI2CCount){
		unsigned char ucslave[20];
		unsigned short ustype[20];
		unsigned char ucslavecount	=	0;
		unsigned char uctypecount		=	0;
		unsigned int uislavehis[20];
		SecureZeroMemory(uislavehis, 20 *sizeof(unsigned int));
		unsigned int uitypehis[20];
		SecureZeroMemory(uitypehis, 20 *sizeof(unsigned int));
		unsigned char *pucslave	=	itemshareData.previewParameter->pucSlave;
		unsigned short *pustype		=	itemshareData.previewParameter->pusType;
		int iindex;
		unsigned char uctemp;
		for(unsigned short x=0;	x<itemshareData.previewParameter->usI2CCount;	++x){
			iindex	=	-1;
			for(uctemp=0;	uctemp<ucslavecount;	++uctemp){
				if(*pucslave == ucslave[uctemp]){
					iindex	=	uctemp;
					break;
				}
			}
			if(iindex < 0){
				if(ucslavecount < 20){
					ucslave[ucslavecount]	=	*pucslave;
					++(uislavehis[ucslavecount]);
					++ucslavecount;
				}
			}
			else{
				++(uislavehis[iindex]);
			}
			++pucslave;

			iindex	=	-1;
			for(uctemp=0;	uctemp<uctypecount;	++uctemp){
				if(*pustype == ustype[uctemp]){
					iindex	=	uctemp;
					break;
				}
			}
			if(iindex < 0){
				if(uctypecount < 20){
					ustype[uctypecount]	=	*pustype;
					++(uitypehis[uctypecount]);
					++uctypecount;
				}
			}
			else{
				++(uitypehis[iindex]);
			}
			++pustype;
		}

		iindex	=	0;
		for(uctemp=0;	uctemp<ucslavecount;	++uctemp){
			if(uislavehis[uctemp] > iindex){
				iindex	=	uislavehis[uctemp];
				itemshareData.previewParameter->ucSlave	=	ucslave[uctemp];
			}
		}

		iindex	=	0;
		for(uctemp=0;	uctemp<uctypecount;	++uctemp){
			if(uitypehis[uctemp] > iindex){
				iindex	=	uitypehis[uctemp];
				itemshareData.previewParameter->usI2CMode	=	ustype[uctemp];
			}
		}
	}

	if(itemshareData.previewParameter->ucMIPILane == _HisFX3_MIPILane_Stream_Lane1_ST || \
		itemshareData.previewParameter->ucMIPILane == _HisFX3_MIPILane_Stream_Lane2_ST){
			itemshareData.previewParameter->bDVP_HS_ActiveHigh	=	true;
			itemshareData.previewParameter->bDVP_VS_ActiveHigh	=	true;
	}

	if(!itemshareData.previewParameter->ucVolt_IODD) itemshareData.previewParameter->ucVolt_IODD	=	itemshareData.previewParameter->ucVolt_DOVDD;

	itemshareData.itemparameterLock.unlock();
	return 0;
}

#if (defined USE_EQUIPMENT_AFM_JSL_V2) 
int itemprocess::mtfFocus()
{

//***************** 2018.04.28 feng Add ************* 
#ifdef _DEBUG
		fnMTF_Q fnMTF=(fnMTF_Q)QLibrary::resolve("cvImageToold.dll","fnMTF");
#else
		fnMTF_Q fnMTF=(fnMTF_Q)QLibrary::resolve("cvImageTool.dll","fnMTF");
#endif
	if(!fnMTF){
		emit information(QString::fromLocal8Bit("!载入cvImageTool.dll失败，请检查是否存在"));
		return -1;
	}
//***************************************************

	if(!threadshareData.GetHisPreviewflag()) return HisFX3Error_IsNotPreview;
	int iresult	=	getmtffaParameter(false);
	if(iresult)	return iresult;
	if(iresult = getccmhardwareParameter(false))	return iresult;

	unsigned char* pucBufRaw10 = NULL;
	unsigned char* pucBufRaw = NULL;
	RECT* pstBlock	=	NULL, *pstTemp = NULL;
	_mtffaParameter* pstParameter	=	itemshareData.mtffaParameter;

	itemshareData.itemparameterLock.lockForRead();

	if(iresult = ROPLOW::GetMTFCABlock(itemshareData.previewParameter->iWidth, itemshareData.previewParameter->iHeight, \
		pstParameter->stMTFBasic, pstParameter->vectorMTFItem, &pstBlock)){
			if(iresult == HisFX3Error_Parameter)
				emit information(QTextCodec::codecForName( "GBK")->toUnicode("选取的MTF ROI超出了图像区域"));
			_CODE_AFC_MTF_EXIT1
	}

	_HisFX3_BaylorMode emDataFormat =	itemshareData.previewParameter->ucDataFormat;
	int iImgWidth =	itemshareData.previewParameter->iWidth, iImgHeight =	itemshareData.previewParameter->iHeight;
	unsigned int uiRawImgSize		=	itemshareData.previewParameter->iWidth * itemshareData.previewParameter->iHeight *3;
	unsigned char ucFrameType		=	_FrameType_RGB24;
	unsigned int uiPixelSize	=	iImgWidth *iImgHeight;
	pucBufRaw		=	(unsigned char*)_aligned_malloc(uiRawImgSize, _HisCacheLine_Aligned);
	if(!pucBufRaw){
		HisReleaseMalloc(pucBufRaw);
		HisReleaseMalloc(pucBufRaw10);
		itemshareData.itemparameterLock.unlock();
		return HisFX3Error_MallocBuffer;
	}

	std::vector<_itemDraw> vectorDraw;
	vectorDraw.reserve(50);
	std::vector<_itemDraw>::iterator iteratorDraw;
	_HisCCMAlg_AFC_MTF_DataItem stItemData, stMaxItem;

	ROPLOW::MFAMTFItemDataInitial(stItemData, pstParameter);
	stMaxItem	=	stItemData;

	_ShadingImageInfo ImgInfo;
	float flvalue, flmax, flmin,flHvalue,flVvalue;
	bool bInitFrame	=	true;

	RECT stMTFAutoROI;
	QElapsedTimer classFATime,classTotalTime;
	std::vector<double> vecMtfValue, vecPos;
	double dPosition=0x00;

	classTotalTime.restart();
	while(threadshareData.GetHisPreviewflag())
	{
		classFATime.restart();

		globalLeisaiMotion.axis_Move(0,2,dPosition,0,50000,true);// 移动Z轴 

		if(pstParameter->stMTFBasic.algswitch != 7){
			if(iresult	=	GetFreshframe(pucBufRaw, uiRawImgSize, ucFrameType, bInitFrame)) break;
			
		}else{
			unsigned int uiRawImgSize_raw10		=	iImgWidth *iImgHeight*2;
			unsigned char ucFrameType_raw10		=	_FrameType_Raw10;
			pucBufRaw10		=	(unsigned char*)_aligned_malloc(uiRawImgSize_raw10, _HisCacheLine_Aligned);
			if(!pucBufRaw10){
				HisReleaseMalloc(pucBufRaw);
				HisReleaseMalloc(pucBufRaw10);
				itemshareData.itemparameterLock.unlock();
				return HisFX3Error_MallocBuffer;
			}

			if(iresult	=	GetFreshframe(pucBufRaw10, uiRawImgSize_raw10, ucFrameType_raw10, bInitFrame)) break;
		}
		

		bInitFrame	=	false;
		vectorDraw.clear();

		pstTemp	=	pstBlock;
		stMTFAutoROI	=	*pstTemp;
		if(pstParameter->stMTFBasic.bAutoSeartchROI)
			classRolongoTest.CRolongoBlockAutomaticSearching(stMTFAutoROI, pucBufRaw, iImgWidth, iImgHeight, pstParameter->stMTFBasic.iblockwith *4, stMTFAutoROI);

		if(pstParameter->stMTFBasic.algswitch <= 4)
		{
			if(iresult	=	classAlgorithm.HisCCMMTF(pucBufRaw, iImgWidth, iImgHeight, stMTFAutoROI, pstParameter->stMTFBasic.algswitch, flvalue)) break;
		}else if(pstParameter->stMTFBasic.algswitch == 7){
			uchar ucFormat=(uchar)itemshareData.previewParameter->ucDataFormat;
			if(ucFormat==0x02||ucFormat==0x12){
				ImgInfo.uiFirstPixel = 0;
			}else if(ucFormat==0x03||ucFormat==0x13){
				ImgInfo.uiFirstPixel = 1;
			}else if(ucFormat==0x04||ucFormat==0x14){
				ImgInfo.uiFirstPixel = 2;
			}else if(ucFormat==0x01||ucFormat==0x11){
				ImgInfo.uiFirstPixel = 3;
			}

			ImgInfo.pImage = pucBufRaw10;
			ImgInfo.uiWidth = iImgWidth;
			ImgInfo.uiHeight = iImgHeight;
			ImgInfo.uiBlackLeve = 16*4;

			if(fnMTF(ImgInfo,stMTFAutoROI,flHvalue,flVvalue,FALSE));//if(iresult	=	classRolongoTest.HisCCMMTF(pucBufRaw, iImgWidth, iImgHeight, stMTFAutoROI, pstParameter->stMTFBasic.algswitch,flHvalue,flVvalue)) break;

		}
		else
		{
			if(iresult	=	classRolongoTest.HisCCMMTF(pucBufRaw, iImgWidth, iImgHeight, stMTFAutoROI, pstParameter->stMTFBasic.algswitch, flvalue)) break;
		}

		_HisCCMAlg_AFC_MTF_DataItem_EX stItemData_EX;//**** 2018/04/11 
		stItemData_EX.vectorFOV.resize(pstParameter->vectorMTFItem.size());

		if(pstParameter->stMTFBasic.algswitch != 7){
			stItemData.flCenterValue		=	flvalue;
		}else{
			stItemData.flCenterValue		=	(flHvalue+flVvalue)/2;
			stItemData_EX.flHCenterValue=flHvalue;
			stItemData_EX.flVCenterValue=flVvalue;
			stItemData_EX.flCenterValue=(flHvalue+flVvalue)/2;
		}
		stItemData.stCenterBlock		=	stMTFAutoROI;
		stItemData_EX.stCenterBlock=stMTFAutoROI;

		pstTemp++;

		for(unsigned int y=0;	y<pstParameter->vectorMTFItem.size(); ++y){
			flmax	=	-99999.0f; flmin	=	99999.0f;
			for(unsigned int x=0;	x<pstParameter->vectorMTFItem.at(y).ucBlockCount; ++x){
				stMTFAutoROI	=	*pstTemp;
				if(pstParameter->stMTFBasic.bAutoSeartchROI)
					classRolongoTest.CRolongoBlockAutomaticSearching(stMTFAutoROI, pucBufRaw, iImgWidth, iImgHeight, pstParameter->stMTFBasic.iblockwith *4, stMTFAutoROI);

				if(pstParameter->stMTFBasic.algswitch <= 4)
				{
					if(iresult	=	classAlgorithm.HisCCMMTF(pucBufRaw, iImgWidth, iImgHeight, stMTFAutoROI, pstParameter->stMTFBasic.algswitch, flvalue)) break;
				}else if(pstParameter->stMTFBasic.algswitch == 7){
					if(stItemData.vectorFOV.at(y).flFOV==0.7f){
						if(fnMTF(ImgInfo,stMTFAutoROI,flHvalue,flVvalue,TRUE));
					}else{
						if(fnMTF(ImgInfo,stMTFAutoROI,flHvalue,flVvalue,false));
					}
					
					//if(iresult	=	classRolongoTest.HisCCMMTF(pucBufRaw, iImgWidth, iImgHeight, stMTFAutoROI, pstParameter->stMTFBasic.algswitch,flHvalue,flVvalue)) break;
				}
				else
				{
					if(iresult	=	classRolongoTest.HisCCMMTF(pucBufRaw, iImgWidth, iImgHeight, stMTFAutoROI, pstParameter->stMTFBasic.algswitch, flvalue)) break;
				}

				if(pstParameter->stMTFBasic.algswitch != 7){
					stItemData.vectorFOV.at(y).flValue[x]		=	flvalue;
				}else{
					stItemData.vectorFOV.at(y).flValue[x]		=	(flHvalue+flVvalue)/2;
					stItemData_EX.vectorFOV.at(y).flHValue[x]=flHvalue;
					stItemData_EX.vectorFOV.at(y).flVValue[x]=flVvalue;
					stItemData_EX.vectorFOV.at(y).flValue[x]= (flHvalue+flVvalue)/2;
				}

				stItemData.vectorFOV.at(y).stBlock[x]	=	stMTFAutoROI;
				stItemData_EX.vectorFOV.at(y).stBlock[x]=stMTFAutoROI;

				pstTemp++;
				flmax	=	max(flmax, flvalue);
				flmin		=	min(flmin, flvalue);
			}
			if(iresult) break;
			stItemData.vectorFOV.at(y).flUniformValue	=	flmax - flmin;
		}

		HisReleaseMalloc(pucBufRaw10);
		if(iresult) break;

		if(pstParameter->stMTFBasic.algswitch != 7){
			ROPLOW::AddDrawMTFHA(stItemData, iImgWidth, iImgHeight, vectorDraw, pstParameter->stMTFBasic.flGradeMultiple);
		}else{
			ROPLOW::AddDrawMTFHE(stItemData_EX, iImgWidth, iImgHeight, vectorDraw,*pstParameter, pstParameter->stMTFBasic.flGradeMultiple);

			//************ 2018.04.11 判断 ************** 
			if(stItemData_EX.flHCenterValue<pstParameter->stMTFBasic.flHcenterspec||stItemData_EX.flHCenterValue<pstParameter->stMTFBasic.flHcenterspec\
				||stItemData_EX.flCenterValue<pstParameter->stMTFBasic.flcenterspec){
				iresult=-1;
			}

			for (int i=0;i<pstParameter->vectorMTFItem.size();i++)
			{
				for (int y=0;y<pstParameter->vectorMTFItem.at(i).ucBlockCount;y++)
				{
					if(stItemData_EX.vectorFOV.at(i).flHValue[y] < pstParameter->vectorMTFItem.at(i).flHSpec||stItemData_EX.vectorFOV.at(i).flVValue[y] < pstParameter->vectorMTFItem.at(i).flVSpec\
						||stItemData_EX.vectorFOV.at(i).flValue[y] < pstParameter->vectorMTFItem.at(i).flSpec){
						iresult=-1;
					}
				}
			}
		}

		_CODE_RJAFA_LP_ASIGNDRAW



			ROPLOW::MTFMFACaculateResult(stItemData, pstParameter->stMTFBasic.flGradeMultiple);
		if(stItemData.flWeightValue > stMaxItem.flWeightValue) stMaxItem = stItemData;	

		itemshareData.plotLock.lockForWrite();
#if (defined USE_MANUAL_LENS_BIN)	
		ROPLOW::fillMTFFALensBarChartDrawInfo(itemshareData.vecBarChartItem, stItemData, pstParameter, iImgWidth, iImgHeight);	
#else
		ROPLOW::fillMTFFABarChartDrawInfo(itemshareData.vecBarChartItem, stItemData, iImgWidth, iImgHeight, pstParameter->stMTFBasic.flGradeMultiple);
#endif
		itemshareData.dflBarChartYMin		=	0.0;
		itemshareData.dflBarChartYMax	=	1.0;
		itemshareData.plotLock.unlock();
		emit plotpainter(1);

		while(classFATime.elapsed() < 195) Sleep(10);
		Sleep(5);

		vecMtfValue.push_back(stItemData.flCenterValue);
		vecPos.push_back(dPosition);
		

		//*****************   Peak 条件  ******************
		int endPos=vecMtfValue.size()-1;
		if(vecMtfValue.at(endPos)<vecMtfValue.at(endPos-1)&&vecMtfValue.at(endPos-1)>vecMtfValue.at(endPos-2)){
			break;
		}

		//*************************************************

		if(classTotalTime.elapsed()>10000){//超时时间为 10s
			iresult= -1;
			break;
		}

		dPosition-=20;
	}

	//******** 跳回Peak点位置  ***************
	int maxPos=0;
	double dMaxValue=0.0f;
	for (int i=0;i<vecMtfValue.size();i++)
	{
		if(vecMtfValue.at(i)>dMaxValue){
			dMaxValue=vecMtfValue.at(i);
			maxPos=i;
		}
	}

	globalLeisaiMotion.axis_Move(0,2,(int)vecPos.at(maxPos)-dPosition,0,50000,true);

	//****************************************

	if(iresult){
		HisReleaseMalloc(pucBufRaw10);
		_CODE_AFC_MTF_EXIT1
	}
		if(!threadshareData.GetHisPreviewflag()){
			iresult	=	HisCCMError_NotPreivew;
			HisReleaseMalloc(pucBufRaw10);
			_CODE_AFC_MTF_EXIT1
		}

		iresult	=	(stItemData.ucStatus != 0)?(0):(HisCCMError_Result);

		HisReleaseMalloc(pucBufRaw10);
		_CODE_AFC_MTF_EXIT1
}
#endif

int itemprocess::startPreview()
{
#ifdef _HisFX3_Platform_Jigboard
	return Jig_StartPreview();
#endif


	if(bBoxChannel1) OutputDebugStringA("1- step 1");
	else OutputDebugStringA("2- step 1");
	threadshareData.SetHisPreviewflag(false);

	bool bIs	=	true;
	DWORD uistart	=	GetTickCount();
	while(GetTickCount() < uistart + _ThreadExit_TimeOut){
		threadshareData.flaglock.lockForRead();
		if(!(threadshareData.brawrun || threadshareData.brenderrun || threadshareData.brgbrun)){
			threadshareData.flaglock.unlock();
			bIs	=	false;
			break;
		}
		threadshareData.flaglock.unlock();
		::Sleep(10);
	}

	if(bIs)	return HisFX3Error_Timeout;

	if (threadshareData.bOfflineMode)
	{
		if (!itemshareData.breadsamepicture)//2018.05.07 change  (|1)
		{
			unsigned char ucloadflag	=	0;
			emit signalopenoffline(true);

			while (1)
			{
				Sleep(50);
				itemshareData.flagLock.lockForRead();
				ucloadflag	=itemshareData.ucOfflineloadimage;	
				itemshareData.flagLock.unlock();
				if(ucloadflag	==1)
				{
					itemshareData.flagLock.lockForWrite();
					itemshareData.ucOfflineloadimage	=0;	
					itemshareData.flagLock.unlock();
					break;
				}
				else if (ucloadflag	==2)
				{
					itemshareData.flagLock.lockForWrite();
					itemshareData.ucOfflineloadimage	=0;	
					itemshareData.flagLock.unlock();				
					break;
				}
			}
			if (ucloadflag	==2){
				return HisFX3Error_GrabFrame;
			}
		}
		else
		{
			unsigned char ucloadflag	=	0;
			emit signalopenofflineb(true);
			while (1)
			{
				Sleep(50);
				itemshareData.flagLock.lockForRead();
				ucloadflag	=itemshareData.ucOfflineloadimage;	
				itemshareData.flagLock.unlock();
				if(ucloadflag	==1)
				{
					itemshareData.flagLock.lockForWrite();
					itemshareData.ucOfflineloadimage	=0;	
					itemshareData.flagLock.unlock();
					break;
				}
				else if (ucloadflag	==2)
				{
					itemshareData.flagLock.lockForWrite();
					itemshareData.ucOfflineloadimage	=0;	
					itemshareData.flagLock.unlock();				
					break;
				}
			}
			if (ucloadflag	==2){
				return HisFX3Error_GrabFrame;
			}
		}

	} 

	// 	Sleep(100);
	int iresult	=	getpreviewParameter(false);
	if(iresult)	return iresult;
	if(iresult	=	getccmhardwareParameter(false))	return iresult;

	sprintf_s(itemshareData.previewParameter->strSensorName, 31, "%s", itemshareData.ccmhardwareParameter->sensortype.toAscii().data());
	itemshareData.previewParameter->sensorFactory		=	(_HisFX3_ImageSenor_Factory)(itemshareData.ccmhardwareParameter->uiSensorFactory);

	itemshareData.itemparameterLock.lockForRead();

	QString strFilePath	=	QDir::currentPath() % "/rolongotemplate/" % itemshareData.ccmhardwareParameter->projectname % \
		"[" % QString::number(itemshareData.previewParameter->iWidth) % "x" % \
		QString::number(itemshareData.previewParameter->iHeight) % "]";
	QDir classDir;
	classDir.mkpath(strFilePath);
	strFilePath.toWCharArray(threadshareData.wstrLSCTemplatePath);
	threadshareData.wstrLSCTemplatePath[strFilePath.size()]	=	L'\0';

	itemshareData.previewParameter->bDebug	=	threadshareData.bOutputErrorFrame;
	// 	itemshareData.previewParameter->timeTestMode = 1;

	if(bBoxChannel1) OutputDebugStringA("1- step 2");
	else OutputDebugStringA("2- step 2");

	if(bBoxChannel1)
		iresult	=	classPlatform.HisFX3StartPreview(itemshareData.previewParameter);
	else
		iresult	=	classPlatform.HisFX3StartPreview_S2(itemshareData.previewParameter);
	if(iresult){
		emit information(QString::fromWCharArray(classPlatform.GetLastError()));
		itemshareData.itemparameterLock.unlock();
		return iresult;
	}


	if(bBoxChannel1) OutputDebugStringA("1- step 3");
	else OutputDebugStringA("2- step 3");

	// 	emit information("Start Time: " % QString::number(itemshareData.previewParameter->testedTime));
	// 	if(bBoxChannel1) {
	// 		threadshareData.flaglock.unlock();
	// 		itemshareData.itemparameterLock.unlock();
	// 		return 0;
	// 	}
	threadshareData.flaglock.lockForWrite();
	if(itemshareData.previewParameter->ucDataFormat != threadshareData.ucFormat || itemshareData.previewParameter->iWidth != threadshareData.uiWidth || \
		itemshareData.previewParameter->iHeight != threadshareData.uiHeight || itemshareData.previewParameter->uiFrameByteCount != threadshareData.uiRawBufByte || \
		!threadshareData.pucRaw1 || !threadshareData.pucRaw2 || !threadshareData.pucRGB1 || !threadshareData.pucRGB2){
			threadshareData.ucFormat		=	itemshareData.previewParameter->ucDataFormat;
			threadshareData.uiWidth			=	itemshareData.previewParameter->iWidth;
			threadshareData.uiHeight			=	itemshareData.previewParameter->iHeight;
			threadshareData.uiRawBufByte	=	itemshareData.previewParameter->uiFrameByteCount;
			threadshareData.ucSlave			=	itemshareData.previewParameter->ucSlave;
			HisReleaseMalloc(threadshareData.pucRaw1);
			HisReleaseMalloc(threadshareData.pucRaw2);
			HisReleaseMalloc(threadshareData.pucRGB1);
			HisReleaseMalloc(threadshareData.pucRGB2);
			// 			if(bBoxChannel1) {
			// 				threadshareData.flaglock.unlock();
			// 				itemshareData.itemparameterLock.unlock();
			// 				return 0;
			// 			}
			threadshareData.pucRaw1	=	(unsigned char*)_aligned_malloc(threadshareData.uiRawBufByte, _HisCacheLine_Aligned);
			if(!threadshareData.pucRaw1){
				threadshareData.flaglock.unlock();
				itemshareData.itemparameterLock.unlock();
				stopPreview();
				return HisFX3Error_MallocBuffer;
			}
			// 			if(bBoxChannel1) {
			// 				threadshareData.flaglock.unlock();
			// 				itemshareData.itemparameterLock.unlock();
			// 				return 0;
			// 			}
			threadshareData.pucRaw2	=	(unsigned char*)_aligned_malloc(threadshareData.uiRawBufByte, _HisCacheLine_Aligned);
			if(!threadshareData.pucRaw2){
				HisReleaseMalloc(threadshareData.pucRaw1);
				threadshareData.flaglock.unlock();
				itemshareData.itemparameterLock.unlock();
				stopPreview();
				return HisFX3Error_MallocBuffer;
			}
			threadshareData.pucRGB1	=	(unsigned char*)_aligned_malloc(threadshareData.uiWidth*threadshareData.uiHeight*3, _HisCacheLine_Aligned);
			if(!threadshareData.pucRGB1){
				HisReleaseMalloc(threadshareData.pucRaw1);
				HisReleaseMalloc(threadshareData.pucRaw2);
				threadshareData.flaglock.unlock();
				itemshareData.itemparameterLock.unlock();
				stopPreview();
				return HisFX3Error_MallocBuffer;
			}
			threadshareData.pucRGB2	=	(unsigned char*)_aligned_malloc(threadshareData.uiWidth*threadshareData.uiHeight*3, _HisCacheLine_Aligned);
			if(!threadshareData.pucRGB2){
				HisReleaseMalloc(threadshareData.pucRaw1);
				HisReleaseMalloc(threadshareData.pucRaw2);
				HisReleaseMalloc(threadshareData.pucRGB1);
				threadshareData.flaglock.unlock();
				itemshareData.itemparameterLock.unlock();
				stopPreview();
				return HisFX3Error_MallocBuffer;
			}
	}

	// 	threadshareData.ui64Raw1Index = 0;
	// 	if(bBoxChannel1) {
	// 		threadshareData.flaglock.unlock();
	// 		itemshareData.itemparameterLock.unlock();
	// 		return 0;
	// 	}


	threadshareData.ui64Raw2Index=threadshareData.ui64Raw1Index = threadshareData.ui64RGB2Index = 0;
	threadshareData.flaglock.unlock();
	// 	if(bBoxChannel1) {
	// 		threadshareData.flaglock.unlock();
	// 		itemshareData.itemparameterLock.unlock();
	// 		return 0;
	// 	}
	threadshareData.SetHisPreviewflag(true);
	itemshareData.itemparameterLock.unlock();

	switch (threadshareData.stImageShowPolicy.ucMode)
	{
	case 2:
		horizontalScrollBar.setMaximum(max((int)itemshareData.previewParameter->iWidth - imageframe.width(), 0));
		verticalScrollBar.setMaximum(max((int)itemshareData.previewParameter->iHeight - imageframe.height(), 0));
		horizontalScrollBar.setValue((horizontalScrollBar.maximum() >>1));
		verticalScrollBar.setValue((verticalScrollBar.maximum() >>1));
		break;
	case 3:
		horizontalScrollBar.setMaximum(max((int)(itemshareData.previewParameter->iWidth <<1) - imageframe.width(), 0));
		verticalScrollBar.setMaximum(max((int)(itemshareData.previewParameter->iHeight <<1) - imageframe.height(), 0));
		horizontalScrollBar.setValue((horizontalScrollBar.maximum() >>1));
		verticalScrollBar.setValue((verticalScrollBar.maximum() >>1));
		break;
	case 4:
		horizontalScrollBar.setMaximum(max((int)(itemshareData.previewParameter->iWidth <<2) - imageframe.width(), 0));
		verticalScrollBar.setMaximum(max((int)(itemshareData.previewParameter->iHeight <<2) - imageframe.height(), 0));
		horizontalScrollBar.setValue((horizontalScrollBar.maximum() >>1));
		verticalScrollBar.setValue((verticalScrollBar.maximum() >>1));
		break;
	default:
		break;
	}

	threadshareData.ClearDSPFlag();
	emit startpreview();

	itemshareData.drawLock.lockForWrite();
	itemshareData.itemdrawList.clear();
	itemshareData.drawLock.unlock();

#ifdef _HisFX3_Platform_Jigboard
	return 0;
#endif

	if (threadshareData.bIsexposure)
	{
		if(classPlatform.getCurrentPlatformType() == _HisFX3_Platform_Type_UVC)
		{
			Sleep(150);
			if(iresult = classPlatform.UVCSetProperty(CAPTURE_EXPOSURE, threadshareData.flExposure, 0)){
				stopPreview();
				return iresult;
			}
		}
		else
		{
			if (iresult	=	setExposureTime((itemshareData.ccmhardwareParameter->sensortype.toAscii()).data(), itemshareData.previewParameter->ucSlave, \
				threadshareData.flExposure, globalFunPointer.ReadHisFX3IIC, globalFunPointer.WriteHisFX3IIC, globalFunPointer.SetHisFX3IICSpeed, globalFunPointer.PullHisFX3RESET, globalFunPointer.PullHisFX3PWND, \
				globalFunPointer.PageWriteHisFX3IIC, globalFunPointer.PageReadHisFX3IIC, globalFunPointer.HisFX3PageWriteSPI, globalFunPointer.HisFX3PageReadSPI))
			{
#if  !(defined _DEBUG) && !(defined _HisFX3_Platform_ANALOG)
				stopPreview();
#endif
				emit information("Set " % itemshareData.ccmhardwareParameter->sensortype % " Exposure Time Failed");
				return iresult;
			}
		}
	}

	if (threadshareData.bSetGlobalGain)
	{
		if(classPlatform.getCurrentPlatformType() == _HisFX3_Platform_Type_UVC)
		{
			if (!threadshareData.bIsexposure) Sleep(150);
			if(iresult = classPlatform.UVCSetProperty(CAPTURE_GAIN, threadshareData.flGlobalGainValue, 0)){
				stopPreview();
				return iresult;
			}
		}
		else
		{
#if (defined _WIN64) && (defined _DEBUG)
			QString strLibPath	=	QDir::currentPath() % "/HisCCMSensor64D";
#elif (defined _WIN64) && !(defined _DEBUG)
			QString strLibPath	=	QDir::currentPath() % "/HisCCMSensor64";
#elif (defined _WIN32) && (defined _DEBUG)
			QString strLibPath	=	QDir::currentPath() % "/HisCCMSensor32D";
#else
			QString strLibPath	=	QDir::currentPath() % "/HisCCMSensor32";
#endif

			RolongosetGlobalGain setGlobalGain = (RolongosetGlobalGain)(QLibrary::resolve(strLibPath, "setGlobalGain"));
			if(!setGlobalGain)
			{
				emit information(strLibPath % " Load Failed");
				return HisCCMError_LoadDLL;
			}

			if (iresult	=	setGlobalGain((itemshareData.ccmhardwareParameter->sensortype.toAscii()).data(), itemshareData.previewParameter->ucSlave, \
				threadshareData.flGlobalGainValue, globalFunPointer.ReadHisFX3IIC, globalFunPointer.WriteHisFX3IIC, globalFunPointer.SetHisFX3IICSpeed, globalFunPointer.PullHisFX3RESET, globalFunPointer.PullHisFX3PWND, \
				globalFunPointer.PageWriteHisFX3IIC, globalFunPointer.PageReadHisFX3IIC, globalFunPointer.HisFX3PageWriteSPI, globalFunPointer.HisFX3PageReadSPI)){
#if  !(defined _DEBUG) && !(defined _HisFX3_Platform_ANALOG)
					stopPreview();
#endif
					emit information("Set " % itemshareData.ccmhardwareParameter->sensortype % " Global Gain Fail");
					return iresult;
			}
		}
	}

	if(bBoxChannel1) OutputDebugStringA("1- step 4");
	else OutputDebugStringA("2- step 4");

	if(threadshareData.usWaitPreviewDataTime < 30000 && !threadshareData.bOfflineMode)
	{
		bool bCheckRightFrame	=	itemshareData.ccmhardwareParameter->bCheckFrameRight;

		if(classPlatform.getCurrentPlatformType() == _HisFX3_Platform_Type_UVC || \
			classPlatform.getCurrentPlatformType() == _HisFX3_Platform_Type_RTSPM || \
			classPlatform.getCurrentPlatformType() == _HisFX3_Platform_Type_HDMI)
			bCheckRightFrame = true;

		if(bCheckRightFrame)
		{			
			unsigned __int64 ui64Index	=	0;
			uistart	=	::GetTickCount();
			while(!ui64Index && ::GetTickCount() < uistart + threadshareData.usWaitPreviewDataTime){
				Sleep(10);
				if(bBoxChannel1)
					ui64Index	=	classPlatform.getUploadFrameIndex();
				else
					ui64Index	=	classPlatform.getUploadFrameIndex_S2();
			}

			if(!ui64Index)
			{
				stopPreview();
				return HisCCMError_NoFrame;
			}
		}
		else
		{
			Sleep(30);
			if(!globalFunPointer.IsHisFX3DataStreaming(threadshareData.usWaitPreviewDataTime))
			{
				stopPreview();
				return HisCCMError_NoFrame;
			}
		}
	}

	if(bBoxChannel1) OutputDebugStringA("1- step 5");
	else OutputDebugStringA("2- step 5");

	return 0;
}

int itemprocess::stopPreview()
{
	itemshareData.drawLock.lockForWrite();
	itemshareData.itemdrawList.clear();
	itemshareData.drawLock.unlock();
	threadshareData.SetHisPreviewflag(false);

	Sleep(20);

	DWORD dwT1= GetTickCount();
	int iresult;
	if(bBoxChannel1)
		iresult =	classPlatform.HisFX3StopPreview();
	else
		iresult =	classPlatform.HisFX3StopPreview_S2();
	emit information("stop: " % QString::number(GetTickCount() - dwT1));

	Sleep(20);

	bool bIs	=	true;
	DWORD uistart	=	GetTickCount();
	while(GetTickCount() < uistart + _ThreadExit_TimeOut)
	{
		threadshareData.flaglock.lockForRead();
		if(!(threadshareData.brawrun || threadshareData.brenderrun || threadshareData.brgbrun)){
			threadshareData.flaglock.unlock();
			bIs	=	false;
			break;
		}
		threadshareData.flaglock.unlock();
		Sleep(10);
	}

	if(bIs)
		return HisFX3Error_Timeout;
	return iresult;
}

int itemprocess::getBrightness(RECT stRange, int iMin, int iMax)
{
	if(!threadshareData.GetHisPreviewflag())	return HisCCMError_NotPreivew;

	itemshareData.itemparameterLock.lockForRead();
	int iwidth		=	itemshareData.previewParameter->iWidth;
	int iheight	=	itemshareData.previewParameter->iHeight;
	itemshareData.itemparameterLock.unlock();

	if((stRange.left >= stRange.right) || (stRange.top >= stRange.bottom) || \
		(stRange.left < 0) || (stRange.top < 0) || (stRange.right > iwidth) || \
		(stRange.bottom > iheight) || (iMin > iMax) || (iMax > 255) || (iMin < 0))
		return HisFX3Error_Parameter;

	unsigned char* pucrgb	=	(unsigned char*)_aligned_malloc(iwidth *iheight *3, _HisCacheLine_Aligned);
	if(!pucrgb)	return HisFX3Error_MallocBuffer;

	int iresult	=	GetFreshframe(pucrgb, iwidth *iheight *3, _FrameType_RGB24, true);
	if(iresult){
		HisReleaseMalloc(pucrgb);
		return iresult;
	}

	float flgrayValue;
	iresult	=	classAlgorithm.HisCCMBrightness(pucrgb, iwidth, iheight, stRange, flgrayValue);

	unsigned int uiSumG = 0, uiSumR = 0, uiSumB = 0;
	unsigned int uiWidthByte	=	itemshareData.previewParameter->iWidth *3;
	unsigned char* pucLine	=	pucrgb + (stRange.top *uiWidthByte + stRange.left *3);
	unsigned char* pucData;
	for(LONG y=stRange.top;	y<stRange.bottom;	++y){
		pucData	=	pucLine;
		pucLine	+=	uiWidthByte;
		for(LONG x=stRange.left;	x<stRange.right;	++x){
			uiSumR	+=	(unsigned int)(*pucData);
			++pucData;
			uiSumG	+=	(unsigned int)(*pucData);
			++pucData;
			uiSumB	+=	(unsigned int)(*pucData);
			++pucData;
		}
	}

	HisReleaseMalloc(pucrgb);
	if(iresult)	return iresult;

	float flAverR	=	(double)(uiSumR) / (double)((stRange.right-stRange.left) *(stRange.bottom - stRange.top));
	float flAverG	=	(double)(uiSumG) / (double)((stRange.right-stRange.left) *(stRange.bottom - stRange.top));
	float flAverB	=	(double)(uiSumB) / (double)((stRange.right-stRange.left) *(stRange.bottom - stRange.top));

	emit information(QTextCodec::codecForName( "GBK")->toUnicode("亮度(Y): ") % QString::number(flgrayValue, 'f', 3));
	emit information(QTextCodec::codecForName( "GBK")->toUnicode("亮度(R): ") % QString::number(flAverR, 'f', 3));
	emit information(QTextCodec::codecForName( "GBK")->toUnicode("亮度(G): ") % QString::number(flAverG, 'f', 3));
	emit information(QTextCodec::codecForName( "GBK")->toUnicode("亮度(B): ") % QString::number(flAverB, 'f', 3));

	std::vector<_itemDraw>::iterator theIterator;
	itemshareData.drawLock.lockForWrite();
	itemshareData.itemdrawList.resize(3);
	theIterator=itemshareData.itemdrawList.begin();

	if((flgrayValue < static_cast<float>(iMin)) || (flgrayValue > static_cast<float>(iMax))){
		theIterator->stcolor	=	QColor::fromRgb(255, 0, 0);
		theIterator->uctype	=	HisDrawType_Block;
		theIterator->strinfo.stblock	=	stRange;
		theIterator++;
		theIterator->stcolor	=	QColor::fromRgb(255, 0, 0);
		theIterator->uctype	=	HisDrawType_Text;
		theIterator->idata[0]	=	stRange.left;
		theIterator->idata[1]	=	stRange.top;
		sprintf_s(theIterator->strinfo.strtext,	15, "Lux:%.1f", flgrayValue);
		theIterator++;
		theIterator->stcolor	=	QColor::fromRgb(255, 255, 0);
		theIterator->uctype	=	HisDrawType_Text;
		theIterator->idata[0]	=	stRange.left;
		theIterator->idata[1]	=	stRange.bottom;
		sprintf_s(theIterator->strinfo.strtext,	15, "spec(%d,%d)", iMin, iMax);
		theIterator++;
		itemshareData.drawLock.unlock();
		return HisCCMError_Result;
	}
	theIterator->stcolor	=	QColor::fromRgb(0, 255, 0);
	theIterator->uctype	=	HisDrawType_Block;
	theIterator->strinfo.stblock	=	stRange;
	theIterator++;
	theIterator->stcolor	=	QColor::fromRgb(0, 255, 0);
	theIterator->uctype	=	HisDrawType_Text;
	theIterator->idata[0]	=	stRange.left;
	theIterator->idata[1]	=	stRange.top;
	sprintf_s(theIterator->strinfo.strtext,	15, "Lux:%.1f", flgrayValue);
	theIterator++;
	theIterator->stcolor	=	QColor::fromRgb(255, 255, 0);
	theIterator->uctype	=	HisDrawType_Text;
	theIterator->idata[0]	=	stRange.left;
	theIterator->idata[1]	=	stRange.bottom;
	sprintf_s(theIterator->strinfo.strtext,	15, "spec(%d,%d)", iMin, iMax);
	theIterator++;

	itemshareData.drawLock.unlock();
	return 0;
}

int itemprocess::getColorRatio(RECT stRange, double dflR2GrMin, double dflR2GrMax, double dflB2GrMin, double dflB2GrMax)
{
	if(!threadshareData.GetHisPreviewflag())
		return HisCCMError_NotPreivew;

	itemshareData.itemparameterLock.lockForRead();
	int iwidth		=	itemshareData.previewParameter->iWidth;
	int iheight		=	itemshareData.previewParameter->iHeight;
	_HisFX3_BaylorMode ucDataFormat	=	itemshareData.previewParameter->ucDataFormat;
	itemshareData.itemparameterLock.unlock();

	if((stRange.left >= stRange.right) || (stRange.top >= stRange.bottom) || \
		(stRange.left < 0) || (stRange.top < 0) || (stRange.right > iwidth) || \
		(stRange.bottom > iheight) || (dflR2GrMin > dflR2GrMax) || (dflB2GrMin > dflB2GrMax))
		return HisFX3Error_Parameter;

	unsigned char* pucraw8	=	(unsigned char*)_aligned_malloc(iwidth *iheight, _HisCacheLine_Aligned);
	if(!pucraw8)
		return HisFX3Error_MallocBuffer;

	int iresult	=	GetFreshframe(pucraw8, iwidth *iheight, _FrameType_Raw, true);
	if(iresult){
		HisReleaseMalloc(pucraw8);
		return iresult;
	}

	stRange.left			=	((stRange.left >>1) <<1);
	stRange.right		=	((stRange.right >>1) <<1);
	stRange.top			=	((stRange.top >>1) <<1);
	stRange.bottom	=	((stRange.bottom >>1) <<1);

	unsigned int x, uiB = 0, uiR = 0, uiGr = 0;
	unsigned char* pucData, *pucLine = pucraw8 + (stRange.top *iwidth + stRange.left);

	switch (ucDataFormat){
	case HisBaylor8_BGGR:
	case HisBaylor10_BGGR:
	case HisBaylor12_BGGR:
		for(unsigned int y=stRange.top;	y<stRange.bottom;	y+=2){
			pucData	=	pucLine;
			for(x=stRange.left;	x<stRange.right;	x+=2){
				uiB			=	uiB + static_cast<unsigned int>(*pucData);
				pucData	+=	2;
			}
			pucLine	+=	iwidth;
			pucData	=	pucLine;
			for(x=stRange.left;	x<stRange.right;	x+=2){
				uiGr			=	uiGr + static_cast<unsigned int>(*pucData);
				++pucData;
				uiR			=	uiR + static_cast<unsigned int>(*pucData);
				++pucData;
			}
			pucLine	+=	iwidth;
		}
		break;
	case HisBaylor8_RGGB:
	case HisBaylor10_RGGB:
	case HisBaylor12_RGGB:
		for(unsigned int y=stRange.top;	y<stRange.bottom;	y+=2){
			pucData	=	pucLine;
			for(x=stRange.left;	x<stRange.right;	x+=2){
				uiR			=	uiR + static_cast<unsigned int>(*pucData);
				++pucData;
				uiGr			=	uiGr + static_cast<unsigned int>(*pucData);
				++pucData;
			}
			pucLine	+=	iwidth;
			pucData	=	pucLine+1;
			for(x=stRange.left;	x<stRange.right;	x+=2){
				uiB			=	uiB + static_cast<unsigned int>(*pucData);
				pucData	+=	2;
			}
			pucLine	+=	iwidth;
		}
		break;
	case HisBaylor8_GRBG:
	case HisBaylor10_GRBG:
	case HisBaylor12_GRBG:
		for(unsigned int y=stRange.top;	y<stRange.bottom;	y+=2){
			pucData	=	pucLine;
			for(x=stRange.left;	x<stRange.right;	x+=2){
				uiGr			=	uiGr + static_cast<unsigned int>(*pucData);
				++pucData;
				uiR			=	uiR + static_cast<unsigned int>(*pucData);
				++pucData;
			}
			pucLine	+=	iwidth;
			pucData	=	pucLine;
			for(x=stRange.left;	x<stRange.right;	x+=2){
				uiB			=	uiB + static_cast<unsigned int>(*pucData);
				pucData	+=	2;
			}
			pucLine	+=	iwidth;
		}
		break;
	case HisBaylor8_GBRG:
	case HisBaylor10_GBRG:
	case HisBaylor12_GBRG:
		for(unsigned int y=stRange.top;	y<stRange.bottom;	y+=2){
			pucData	=	pucLine+1;
			for(x=stRange.left;	x<stRange.right;	x+=2){
				uiB			=	uiB + static_cast<unsigned int>(*pucData);
				pucData	+=	2;
			}
			pucLine	+=	iwidth;
			pucData	=	pucLine;
			for(x=stRange.left;	x<stRange.right;	x+=2){
				uiR			=	uiR + static_cast<unsigned int>(*pucData);
				++pucData;
				uiGr			=	uiGr + static_cast<unsigned int>(*pucData);
				++pucData;
			}
			pucLine	+=	iwidth;
		}
		break;
	default:
		HisReleaseMalloc(pucraw8);
		return HisFX3Error_Parameter;
		break;
	}

	HisReleaseMalloc(pucraw8);

	x	=	(stRange.right-stRange.left)*(stRange.bottom-stRange.top) /4;
	double dflAverageR		=	static_cast<double>(uiR) / static_cast<double>(x);
	double dflAverageB		=	static_cast<double>(uiB) / static_cast<double>(x);
	double dflAverageGr	=	static_cast<double>(uiGr) / static_cast<double>(x);
	emit information(QTextCodec::codecForName( "GBK")->toUnicode("R通道均值：") % QString::number(dflAverageR));
	emit information(QTextCodec::codecForName( "GBK")->toUnicode("B通道均值：") % QString::number(dflAverageB));
	emit information(QTextCodec::codecForName( "GBK")->toUnicode("Gr通道均值：") % QString::number(dflAverageGr));

	dflAverageGr				=	max(dflAverageGr, 0.1);
	double dflR2Gr			=	dflAverageR /dflAverageGr;
	double dflB2Gr			=	dflAverageB /dflAverageGr;
	emit information(QTextCodec::codecForName( "GBK")->toUnicode("R /Gr：") % QString::number(dflR2Gr));
	emit information(QTextCodec::codecForName( "GBK")->toUnicode("B /Gr：") % QString::number(dflB2Gr));

	const int ciDrawOffset	=	80;
	std::vector<_itemDraw>::iterator theIterator;
	itemshareData.drawLock.lockForWrite();
	itemshareData.itemdrawList.resize(5);
	theIterator=itemshareData.itemdrawList.begin();

	if(dflR2Gr > dflR2GrMax || dflR2Gr < dflR2GrMin || dflB2Gr > dflB2GrMax || dflB2Gr < dflB2GrMin){
		theIterator->stcolor	=	QColor::fromRgb(255, 0, 0);
		theIterator->uctype	=	HisDrawType_Block;
		theIterator->strinfo.stblock	=	stRange;
		theIterator++;
		theIterator->stcolor	=	QColor::fromRgb(255, 0, 0);
		theIterator->uctype	=	HisDrawType_Text;
		theIterator->idata[0]	=	stRange.left;
		theIterator->idata[1]	=	stRange.top;
		sprintf_s(theIterator->strinfo.strtext,	15, "R/Gr:%.3f", dflR2Gr);
		theIterator++;
		theIterator->stcolor	=	QColor::fromRgb(255, 255, 0);
		theIterator->uctype	=	HisDrawType_Text;
		theIterator->idata[0]	=	stRange.left;
		theIterator->idata[1]	=	stRange.top - ciDrawOffset;
		sprintf_s(theIterator->strinfo.strtext,	16, "spec:%.2f-%.2f", dflR2GrMin, dflR2GrMax);
		theIterator++;
		theIterator->stcolor	=	QColor::fromRgb(255, 0, 0);
		theIterator->uctype	=	HisDrawType_Text;
		theIterator->idata[0]	=	stRange.left;
		theIterator->idata[1]	=	stRange.bottom;
		sprintf_s(theIterator->strinfo.strtext,	15, "B/Gr:%.3f", dflB2Gr);
		theIterator++;
		theIterator->stcolor	=	QColor::fromRgb(255, 255, 0);
		theIterator->uctype	=	HisDrawType_Text;
		theIterator->idata[0]	=	stRange.left;
		theIterator->idata[1]	=	stRange.bottom + ciDrawOffset;
		sprintf_s(theIterator->strinfo.strtext,	16, "spec:%.2f-%.2f", dflB2GrMin, dflB2GrMax);
		theIterator++;
		itemshareData.drawLock.unlock();
		return HisCCMError_Result;
	}
	theIterator->stcolor	=	QColor::fromRgb(0, 255, 0);
	theIterator->uctype	=	HisDrawType_Block;
	theIterator->strinfo.stblock	=	stRange;
	theIterator++;
	theIterator->stcolor	=	QColor::fromRgb(0, 255, 0);
	theIterator->uctype	=	HisDrawType_Text;
	theIterator->idata[0]	=	stRange.left;
	theIterator->idata[1]	=	stRange.top;
	sprintf_s(theIterator->strinfo.strtext,	15, "R/Gr:%.3f", dflR2Gr);
	theIterator++;
	theIterator->stcolor	=	QColor::fromRgb(255, 255, 0);
	theIterator->uctype	=	HisDrawType_Text;
	theIterator->idata[0]	=	stRange.left;
	theIterator->idata[1]	=	stRange.top - ciDrawOffset;
	sprintf_s(theIterator->strinfo.strtext,	16, "spec:%.2f-%.2f", dflR2GrMin, dflR2GrMax);
	theIterator++;
	theIterator->stcolor	=	QColor::fromRgb(0, 255, 0);
	theIterator->uctype	=	HisDrawType_Text;
	theIterator->idata[0]	=	stRange.left;
	theIterator->idata[1]	=	stRange.bottom;
	sprintf_s(theIterator->strinfo.strtext,	15, "B/Gr:%.3f", dflB2Gr);
	theIterator++;
	theIterator->stcolor	=	QColor::fromRgb(255, 255, 0);
	theIterator->uctype	=	HisDrawType_Text;
	theIterator->idata[0]	=	stRange.left;
	theIterator->idata[1]	=	stRange.bottom + ciDrawOffset;
	sprintf_s(theIterator->strinfo.strtext,	16, "spec:%.2f-%.2f", dflB2GrMin, dflB2GrMax);
	theIterator++;

	itemshareData.drawLock.unlock();
	return 0;
}

int itemprocess::getlpFAParameter(bool bupdate, bool bcheck)
{
	QString strItemName;
	_lpMFAParameter* pstTheParamter;
	strItemName	=	"lpmfa";
	itemshareData.itemparameterLock.lockForRead();
	if(!bupdate && itemshareData.lpmfaParameter) { itemshareData.itemparameterLock.unlock(); return 0; }

	itemshareData.itemparameterLock.unlock();
	itemshareData.itemparameterLock.lockForWrite();
	if(!itemshareData.lpmfaParameter)		itemshareData.lpmfaParameter		=	new _lpMFAParameter;
	if(!itemshareData.lpmfaParameter) {	itemshareData.itemparameterLock.unlock(); return HisFX3Error_MallocBuffer; }
	pstTheParamter	=	itemshareData.lpmfaParameter;

	pstTheParamter->vectorLpItem.clear();
	QMutexLocker locker(&hisglobalparameter.mutexDatabase);

	bool bparsesuccess	=	true, bItemExist = false;

	//读取，解析config
	for(int  w=0;	w<1;	++w){ //此处是有意义的,不要删除
		QSqlDatabase customdb = QSqlDatabase::addDatabase("QSQLITE", "querycustom");
		customdb.setDatabaseName(QDir::currentPath() % "/HisFX3Custom");
		if (!customdb.open()){
			bparsesuccess	=	false;
			break;
		}

		QString strData, strdata2;
		QStringList strname, strvalue;
		QSqlQuery query(customdb);
		query.prepare("SELECT itemsuffix2,key,value,reserve FROM " % itemshareData.currentTableName % \
			" WHERE classfy='algorithm' AND item='" % strItemName % "' AND itemsuffix1='basic' ORDER BY id ASC" );
		query.exec();

		/************basic**************/
		//(markfmin:0.3)(markfmax:0.7)(markplmin:50)(markplmax:100)(grademultiple:1.2)
		//(lpwmin:100)(lpwmax:300)(lphmin:12)(lphmax:50)
		//(markangle:45)(lpdisdev:50)(lphexpand:5)
		while (query.next()){
			bItemExist = true;
			for(int y=0;	y<4;	++y){
				strData	=	query.value(y).toString();
				ROPLOW::patchconfigstring(strData, strname, strvalue);
				for(int x=0;	x<strname.size();	++x){
					if(strname.at(x) == "markfmin")	pstTheParamter->stLpBasic.dflConstMarkFMin	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "markfmax")	pstTheParamter->stLpBasic.dflConstMarkFMax	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "markplmin")	pstTheParamter->stLpBasic.usConstMarkPMin	=	strvalue.at(x).toInt();
					else if(strname.at(x) == "markplmax")	pstTheParamter->stLpBasic.usConstMarkPMax	=	strvalue.at(x).toInt();
					else if(strname.at(x) == "lpwmin")	pstTheParamter->stLpBasic.usConstLPWMin	=	strvalue.at(x).toInt();
					else if(strname.at(x) == "lpwmax")	pstTheParamter->stLpBasic.usConstLPWMax	=	strvalue.at(x).toInt();
					else if(strname.at(x) == "lphmin")	pstTheParamter->stLpBasic.usConstLPHMin	=	strvalue.at(x).toInt();
					else if(strname.at(x) == "lphmax")	pstTheParamter->stLpBasic.usConstLPHMax	=	strvalue.at(x).toInt();
					else if(strname.at(x) == "markangle")	pstTheParamter->stLpBasic.dflConstMarkAngle	=	strvalue.at(x).toInt();
					else if(strname.at(x) == "lpdisdev")	pstTheParamter->stLpBasic.usFOVDisDev	=	strvalue.at(x).toInt();
					else if(strname.at(x) == "lphexpand")	pstTheParamter->stLpBasic.usConstExpandH	=	strvalue.at(x).toInt();
					else if(strname.at(x) == "grademultiple")	pstTheParamter->stLpBasic.flGradeMultiple	=	strvalue.at(x).toFloat();
				}
			}
		}

		_HisCCMAlg_LPItem_Info stcircleitem;
		query.prepare("SELECT itemsuffix2,key,value,reserve FROM " % itemshareData.currentTableName % \
			" WHERE classfy='algorithm' AND item='" % strItemName % "' AND itemsuffix1='fovitem' ORDER BY id ASC" );
		query.exec();
		/************fovitem**************/
		//(fov:0.3)(angle:0)(weight:1.0)
		//(spech:900)(specv:900)(specu:200)
		//(lpmin:400)(lpmax:1100)
		//(lpnum:6)(threshold:20)(offset:0)
		while (query.next()){
			bItemExist = true;
			for(int y=0;	y<4;	++y){
				strData	=	query.value(y).toString();
				ROPLOW::patchconfigstring(strData, strname, strvalue);
				for(int x=0;	x<strname.size();	++x){
					if(strname.at(x) == "fov")	 stcircleitem.flFOV	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "weight")	 stcircleitem.flWeight	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "angle")	 stcircleitem.flAngle		=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "spech")	 stcircleitem.flSpecHor		=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "specv")	 stcircleitem.flSpecVec		=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "specu")	 stcircleitem.flSpecUniform		=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "lpmin")	 stcircleitem.usLPMin		=	strvalue.at(x).toInt();
					else if(strname.at(x) == "lpmax")	 stcircleitem.usLPMax		=	strvalue.at(x).toInt();
					else if(strname.at(x) == "lpnum")	 stcircleitem.ucConstLPNum		=	strvalue.at(x).toInt();
					else if(strname.at(x) == "threshold")	 stcircleitem.ucConstThresholdB8		=	strvalue.at(x).toInt();
					else if(strname.at(x) == "offset")	 stcircleitem.flValueOffset		=	strvalue.at(x).toFloat();
				}
			}

			pstTheParamter->vectorLpItem.push_back(stcircleitem);	
		}

		customdb.close();
	}

	QSqlDatabase::removeDatabase("querycustom");
	if(!bparsesuccess || !bItemExist){
		HisReleaseNewO(itemshareData.lpmfaParameter);
		itemshareData.itemparameterLock.unlock();
		return HisFX3Error_Parameter;
	}

	if(!bcheck) {itemshareData.itemparameterLock.unlock(); return 0; }

	std::sort(pstTheParamter->vectorLpItem.begin(), pstTheParamter->vectorLpItem.end(), sort_lpitem_fov);
	itemshareData.itemparameterLock.unlock();
	return 0;
}

int itemprocess::lpFA()
{
	_CODE_CLEAR_IMAGEDRAW

		//判断图像是否点亮
		if(!threadshareData.GetHisPreviewflag())	return HisCCMError_NotPreivew;

	//取得配置参数
	int iresult	=	getlpFAParameter(false);
	if(iresult)	return iresult;

	unsigned char* pucBufRaw = NULL, *pucBufY = NULL;
	itemshareData.itemparameterLock.lockForRead();
	_lpMFAParameter* pstParameter	=	itemshareData.lpmfaParameter;

	_HisFX3_BaylorMode emDataFormat =	itemshareData.previewParameter->ucDataFormat;
	int iImgWidth =	itemshareData.previewParameter->iWidth, iImgHeight =	itemshareData.previewParameter->iHeight;
	unsigned int uiRawImgSize	=	itemshareData.previewParameter->iWidth * itemshareData.previewParameter->iHeight *3;
	unsigned char ucFrameType	=	_FrameType_RGB24;
	switch (itemshareData.previewParameter->ucDataFormat){
	case HisBaylor10_BGGR:
	case HisBaylor12_BGGR:
	case HisBaylor8_BGGR:	emDataFormat	=	HisBaylor8_BGGR;	break;
	case HisBaylor10_RGGB:
	case HisBaylor12_RGGB:
	case HisBaylor8_RGGB:	emDataFormat	=	HisBaylor8_RGGB;	break;
	case HisBaylor10_GRBG:
	case HisBaylor12_GRBG:
	case HisBaylor8_GRBG:	emDataFormat	=	HisBaylor8_GRBG;	break;
	case HisBaylor10_GBRG:
	case HisBaylor12_GBRG:
	case HisBaylor8_GBRG:	emDataFormat	=	HisBaylor8_GBRG;	break;
	case HisBaylor10_MONO:
	case HisBaylor12_MONO:
	case HisBaylor8_MONO:	emDataFormat	=	HisBaylor8_MONO;	break;
	case HisRGB_RGB24:		break;
	default:
		uiRawImgSize		=	itemshareData.previewParameter->iWidth * itemshareData.previewParameter->iHeight *2;
		ucFrameType		=	_FrameType_Raw;
		break;
	}

	unsigned int uiPixelSize	=	iImgWidth *iImgHeight;
	pucBufRaw		=	(unsigned char*)_aligned_malloc(uiRawImgSize, _HisCacheLine_Aligned);
	pucBufY			=	(unsigned char*)_aligned_malloc(iImgWidth *iImgHeight, _HisCacheLine_Aligned);
	if(!(pucBufRaw && pucBufY)){
		HisReleaseMalloc(pucBufY);
		HisReleaseMalloc(pucBufRaw);
		return HisFX3Error_MallocBuffer;
	}

	std::vector<_itemDraw> vectorDraw;
	vectorDraw.reserve(56);
	_HisCCMAlg_RECT_FOV4 stRectFOV4;
	std::vector<_HisCCMAlg_RECT_FOV4> vectorRectFov4;
	vectorRectFov4.resize(pstParameter->vectorLpItem.size());

	RECT stValueLine, stMinLine, stMaxLine;
	int iCenterX, iCenterY;
	double dflAngle, dflDistance, dflValue;
	std::vector<RECT> vectorBlock;
	std::vector<RECT> vectorMark;
	vectorBlock.reserve(32);
	vectorMark.reserve(4);

	_HisCCMAlg_ImageBuffer stImgBuffer;
	stImgBuffer.pvImgBuf			=	(void*)(pucBufY);
	stImgBuffer.iImgWidth		=	iImgWidth;
	stImgBuffer.iImgHeight		=	iImgHeight;
	stImgBuffer.enumFormat	=	_HisCCMAlg_ImageBuffer_Type_Y_U8;
	stImgBuffer.enumChannel	=	_HisCCMAlg_ImageBuffer_Channel_Y; 
	bool bNext;

	_HisCCMAlg_AFC_LP_DataItem stDataItemMax, stDataItem;
	stDataItemMax.flWeightValue		=	stDataItem.flWeightValue		=	0.0f;
	stDataItemMax.ucStatus				=	stDataItem.ucStatus				=	0x0;
	stDataItemMax.dflMarkDistance	=	stDataItem.dflMarkDistance	=	0.0;
	stDataItemMax.ucFlag				=	stDataItem.ucFlag					=	0x0;

	float flChartLpValueMax	=	1.0;
	unsigned int uiFOVSize	=	pstParameter->vectorLpItem.size();
	stDataItem.vectorFOV.resize(uiFOVSize);
	stDataItemMax.vectorFOV.resize(uiFOVSize);
	for(unsigned int x=0;	x<uiFOVSize;	++x){
		stDataItemMax.vectorFOV.at(x).flFOV	=	stDataItem.vectorFOV.at(x).flFOV					=	pstParameter->vectorLpItem.at(x).flFOV;
		stDataItemMax.vectorFOV.at(x).flAngle	=	stDataItem.vectorFOV.at(x).flAngle				=	pstParameter->vectorLpItem.at(x).flAngle;
		stDataItemMax.vectorFOV.at(x).flSpecHor	=	stDataItem.vectorFOV.at(x).flSpecHor			=	pstParameter->vectorLpItem.at(x).flSpecHor;
		stDataItemMax.vectorFOV.at(x).flSpecVec	=	stDataItem.vectorFOV.at(x).flSpecVec			=	pstParameter->vectorLpItem.at(x).flSpecVec;
		stDataItemMax.vectorFOV.at(x).flSpecUniform	=	stDataItem.vectorFOV.at(x).flSpecUniform	=	pstParameter->vectorLpItem.at(x).flSpecUniform;
		stDataItemMax.vectorFOV.at(x).flWeight	=	stDataItem.vectorFOV.at(x).flWeight				=	pstParameter->vectorLpItem.at(x).flWeight;
		stDataItemMax.vectorFOV.at(x).ucStatus	=	stDataItem.vectorFOV.at(x).ucStatus			=	0x0;
		memset(stDataItem.vectorFOV.at(x).stLpValue, 0, sizeof(_HisCCMAlg_Resolution) *4);
		memset(stDataItemMax.vectorFOV.at(x).stLpValue, 0, sizeof(_HisCCMAlg_Resolution) *4);
		flChartLpValueMax	=	max(flChartLpValueMax, pstParameter->vectorLpItem.at(x).usLPMax);
	}

	float cflMaxValue	=	0.0f;
	for(unsigned int x=0;	x<pstParameter->vectorLpItem.size();	++x)
		cflMaxValue	=	max(cflMaxValue, pstParameter->vectorLpItem.at(x).usLPMax);

	bool bDrawMax	=	false;

	_itemStatus itemstatus;
	itemstatus.ucstatus	=	_His_ItemStatus_NG;
	itemstatus.usitem		=	lpmfaitem;
	bool binitframe				=	true;
	QElapsedTimer classFATime;

	while(threadshareData.GetHisPreviewflag() && hisglobalparameter.getfaflag())
	{
		classFATime.restart();
		stDataItem.ucStatus	=	0x0;
		stDataItem.flWeightValue		=	0.0f;
		stDataItem.dflMarkDistance	=	0.0;
		stDataItem.ucFlag					=	0x0;
		for(unsigned int x=0;	x<stDataItem.vectorFOV.size();	++x)
			memset(stDataItem.vectorFOV.at(x).stLpValue, 0, sizeof(_HisCCMAlg_Resolution) *4);
		if(iresult		=	GetFreshframe(pucBufRaw, uiRawImgSize, ucFrameType, binitframe)) break;
		binitframe	=	false;

		if(emDataFormat >= HisYUV8_422_YUYV && emDataFormat <= HisYUV8_422_VYUY)
			classAlgorithm.extactYfromYUV422U8(pucBufRaw, pucBufY, iImgWidth*iImgHeight, emDataFormat); //抽取Y通道
		else{ //抽取G通道作为Y通道
			unsigned char* pucSrc = pucBufRaw + 1, *pucDes = pucBufY;
			for(unsigned int x=0;	x<uiPixelSize;	++x){
				*pucDes	=	*pucSrc;
				++pucDes;
				pucSrc	+=	3;
			}
		}

		vectorDraw.clear();
		ROPLOW::AddDrawEllipse((iImgWidth>>1), (iImgHeight >>1), iImgWidth, iImgHeight, pstParameter->stLpBasic.dflConstMarkFMin, 1, vectorDraw);
		ROPLOW::AddDrawEllipse((iImgWidth>>1), (iImgHeight >>1), iImgWidth, iImgHeight, pstParameter->stLpBasic.dflConstMarkFMax, 1, vectorDraw);

		bNext	=	true;
		if(iresult = classAlgorithm.HisCCMlinePairDetectHA((char*)(pucBufY), iImgWidth, iImgHeight, pstParameter->stLpBasic.usConstLPWMin, \
			pstParameter->stLpBasic.usConstLPWMax,pstParameter->stLpBasic.usConstLPHMin, pstParameter->stLpBasic.usConstLPHMax,\
			pstParameter->stLpBasic.usConstMarkPMin, pstParameter->stLpBasic.usConstMarkPMax, pstParameter->stLpBasic.dflConstMarkFMin, \
			pstParameter->stLpBasic.dflConstMarkFMax,pstParameter->stLpBasic.dflConstMarkAngle,  \
			pstParameter->stLpBasic.usConstExpandW, pstParameter->stLpBasic.usConstExpandH, \
			iCenterX, iCenterY, dflAngle, dflDistance, vectorBlock, vectorMark)){
				emit information(QTextCodec::codecForName( "GBK")->toUnicode("无法提取出MARK点的位置信息"));
				bNext	=	false;
		}

		if(bNext){
			stDataItem.dflMarkDistance	=	dflDistance;
			for(unsigned int x=0;	x<pstParameter->vectorLpItem.size(); ++x)
				ROPLOW::AddDesiredFOV4Cross(dflDistance*pstParameter->vectorLpItem.at(x).flFOV, pstParameter->vectorLpItem.at(x).flAngle, iCenterX, iCenterY, vectorDraw);
			ROPLOW::AddDrawMark(vectorMark, 1, vectorDraw);

			for(unsigned int x=0;	x<pstParameter->vectorLpItem.size(); ++x){
				iresult	=	classAlgorithm.HisCCMExtractLPDetectHBFOV4(vectorBlock, iImgWidth, iImgHeight, iCenterX, iCenterY, \
					pstParameter->vectorLpItem.at(x).flFOV*dflDistance, pstParameter->vectorLpItem.at(x).flAngle, \
					pstParameter->stLpBasic.usFOVDisDev, stRectFOV4);
				if(iresult)	{
					emit information(QTextCodec::codecForName( "GBK")->toUnicode("无法提取线对位置信息 FOV: ") % QString::number(pstParameter->vectorLpItem.at(x).flFOV));
					bNext	=	false;
					continue;
				}

				ROPLOW::AddDrawFOV4(stRectFOV4, 1, vectorDraw);
				vectorRectFov4.at(x)	=	stRectFOV4;

				for(unsigned int i=0;	i<4; ++i){
					iresult	=	classAlgorithm.HisCCMLinePairValueHA(stImgBuffer,  vectorRectFov4.at(x).stBlocks[i], pstParameter->vectorLpItem.at(x).ucConstLPNum, \
						pstParameter->vectorLpItem.at(x).ucConstThresholdB8, pstParameter->vectorLpItem.at(x).usLPMin, \
						pstParameter->vectorLpItem.at(x).usLPMax, dflAngle, pstParameter->vectorLpItem.at(x).flValueOffset, dflValue, stValueLine, stMinLine, stMaxLine);
					if(vectorRectFov4.at(x).stBlocks[i].right-vectorRectFov4.at(x).stBlocks[i].left > vectorRectFov4.at(x).stBlocks[i].bottom - vectorRectFov4.at(x).stBlocks[i].top)
						ROPLOW::AddDrawLP(vectorRectFov4.at(x).stBlocks[i], stValueLine, stMaxLine, stMinLine, iImgWidth, iImgHeight,pstParameter->vectorLpItem.at(x).flSpecVec, dflValue, 1, vectorDraw, pstParameter->stLpBasic.flGradeMultiple);
					else
						ROPLOW::AddDrawLP(vectorRectFov4.at(x).stBlocks[i], stValueLine, stMaxLine, stMinLine, iImgWidth, iImgHeight, pstParameter->vectorLpItem.at(x).flSpecHor, dflValue, 1, vectorDraw, pstParameter->stLpBasic.flGradeMultiple);
					ROPLOW::LpMFAItemDataAdd(stDataItem, vectorRectFov4.at(x).stBlocks[i], dflValue, x, i);
				}			
			}
		}

		ROPLOW::LpMFACaculateResult(stDataItem, pstParameter->stLpBasic.flGradeMultiple);

		_CODE_RJAFA_LP_ASIGNDRAW

			itemshareData.plotLock.lockForWrite();
#if (defined USE_MANUAL_LENS_BIN)	
#else
		ROPLOW::fillLpFABarChartDrawInfo(itemshareData.vecBarChartItem, stDataItem, iImgWidth, iImgHeight, pstParameter->stLpBasic.flGradeMultiple);
#endif
		itemshareData.dflBarChartYMin		=	0.0;
		itemshareData.dflBarChartYMax	=	flChartLpValueMax;
		itemshareData.plotLock.unlock();
		emit plotpainter(1);

		itemstatus.ucstatus	=	stDataItem.ucStatus | 0x80;
		// 		itemstatus.ucstatus	=	(stDataItem.ucStatus >= 0x1)?(_His_ItemStatus_PASS):(_His_ItemStatus_NG);
		updateItemstatus(itemstatus);
		// 		emit showresult((stDataItem.ucStatus == 0x1)?(0):(1));

		while(classFATime.elapsed() < 195) Sleep(10);
		Sleep(5);
	}

	itemshareData.itemparameterLock.unlock();
	HisReleaseMalloc(pucBufRaw);
	HisReleaseMalloc(pucBufY);
	if(!threadshareData.GetHisPreviewflag())	return HisCCMError_NotPreivew;

	ROPLOW::LpMFASaveLog(stDataItem, *classLog, iImgWidth, iImgHeight);

	return (stDataItem.ucStatus  != 0)?(0):(HisCCMError_Result);
}

int itemprocess::getLpAFCParameter(unsigned char uctype, bool bupdate, bool bcheck)
{
	QString strItemName;
	_lpAFCParameter* pstTheParamter;
	if(uctype == 1){
		strItemName	=	"afclpmiddle";
		itemshareData.itemparameterLock.lockForRead();
		if(!bupdate && itemshareData.lpmiddleafcParameter) { itemshareData.itemparameterLock.unlock(); return 0; }

		itemshareData.itemparameterLock.unlock();
		itemshareData.itemparameterLock.lockForWrite();
		if(!itemshareData.lpmiddleafcParameter)	itemshareData.lpmiddleafcParameter		=	new _lpAFCParameter;
		if(!itemshareData.lpmiddleafcParameter) {	itemshareData.itemparameterLock.unlock(); return HisFX3Error_MallocBuffer; }
		pstTheParamter	=	itemshareData.lpmiddleafcParameter;
	}
	else if(uctype == 2){
		strItemName	=	"afclpfar";
		itemshareData.itemparameterLock.lockForRead();
		if(!bupdate && itemshareData.lpfarafcParameter) { itemshareData.itemparameterLock.unlock(); return 0; }

		itemshareData.itemparameterLock.unlock();
		itemshareData.itemparameterLock.lockForWrite();
		if(!itemshareData.lpfarafcParameter)	itemshareData.lpfarafcParameter		=	new _lpAFCParameter;
		if(!itemshareData.lpfarafcParameter) {	itemshareData.itemparameterLock.unlock(); return HisFX3Error_MallocBuffer; }
		pstTheParamter	=	itemshareData.lpfarafcParameter;
	}
	else{
		strItemName	=	"afclpnear";
		itemshareData.itemparameterLock.lockForRead();
		if(!bupdate && itemshareData.lpnearafcParameter) { itemshareData.itemparameterLock.unlock(); return 0; }

		itemshareData.itemparameterLock.unlock();
		itemshareData.itemparameterLock.lockForWrite();
		if(!itemshareData.lpnearafcParameter)		itemshareData.lpnearafcParameter		=	new _lpAFCParameter;
		if(!itemshareData.lpnearafcParameter) {	itemshareData.itemparameterLock.unlock(); return HisFX3Error_MallocBuffer; }
		pstTheParamter	=	itemshareData.lpnearafcParameter;
	}

	pstTheParamter->vectorLpItem.clear();
	QMutexLocker locker(&hisglobalparameter.mutexDatabase);

	bool bparsesuccess	=	true, bItemExist = false;

	//读取，解析config
	for(int  w=0;	w<1;	++w){ //此处是有意义的,不要删除
		QSqlDatabase customdb = QSqlDatabase::addDatabase("QSQLITE", "querycustom");
		customdb.setDatabaseName(QDir::currentPath() % "/HisFX3Custom");
		if (!customdb.open()){
			bparsesuccess	=	false;
			break;
		}

		QString strData, strdata2;
		QStringList strname, strvalue;
		QSqlQuery query(customdb);
		query.prepare("SELECT itemsuffix2,key,value,reserve FROM " % itemshareData.currentTableName % \
			" WHERE classfy='algorithm' AND item='" % strItemName % "' AND itemsuffix1='basic' ORDER BY id ASC" );
		query.exec();

		/************basic**************/
		//(markfmin:0.3)(markfmax:0.7)(markplmin:50)(markplmax:100)
		//(lpwmin:100)(lpwmax:300)(lphmin:12)(lphmax:50)
		//(markangle:45)(lpdisdev:50)(lphexpand:5)(frameaverage:1)
		while (query.next()){
			bItemExist = true;
			for(int y=0;	y<4;	++y){
				strData	=	query.value(y).toString();
				ROPLOW::patchconfigstring(strData, strname, strvalue);
				for(int x=0;	x<strname.size();	++x){
					if(strname.at(x) == "markfmin")	pstTheParamter->stLpBasic.dflConstMarkFMin	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "markfmax")	pstTheParamter->stLpBasic.dflConstMarkFMax	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "markplmin")	pstTheParamter->stLpBasic.usConstMarkPMin	=	strvalue.at(x).toInt();
					else if(strname.at(x) == "markplmax")	pstTheParamter->stLpBasic.usConstMarkPMax	=	strvalue.at(x).toInt();
					else if(strname.at(x) == "lpwmin")	pstTheParamter->stLpBasic.usConstLPWMin	=	strvalue.at(x).toInt();
					else if(strname.at(x) == "lpwmax")	pstTheParamter->stLpBasic.usConstLPWMax	=	strvalue.at(x).toInt();
					else if(strname.at(x) == "lphmin")	pstTheParamter->stLpBasic.usConstLPHMin	=	strvalue.at(x).toInt();
					else if(strname.at(x) == "lphmax")	pstTheParamter->stLpBasic.usConstLPHMax	=	strvalue.at(x).toInt();
					else if(strname.at(x) == "markangle")	pstTheParamter->stLpBasic.dflConstMarkAngle	=	strvalue.at(x).toInt();
					else if(strname.at(x) == "lpdisdev")	pstTheParamter->stLpBasic.usFOVDisDev	=	strvalue.at(x).toInt();
					else if(strname.at(x) == "lphexpand")	pstTheParamter->stLpBasic.usConstExpandH	=	strvalue.at(x).toInt();
					else if(strname.at(x) == "frameaverage")	pstTheParamter->stLpBasic.ucFrames	=	strvalue.at(x).toUInt() & 0xFF;
				}
			}
		}

		_HisCCMAlg_LPItem_Info stcircleitem;
		query.prepare("SELECT itemsuffix2,key,value,reserve FROM " % itemshareData.currentTableName % \
			" WHERE classfy='algorithm' AND item='" % strItemName % "' AND itemsuffix1='fovitem' ORDER BY id ASC" );
		query.exec();
		/************fovitem**************/
		//(fov:0.3)(angle:0)(weight:1.0)
		//(spech:900)(specv:900)(specu:200)
		//(lpmin:400)(lpmax:1100)
		//(lpnum:6)(threshold:20)(offset:0)
		while (query.next()){
			bItemExist = true;
			for(int y=0;	y<4;	++y){
				strData	=	query.value(y).toString();
				ROPLOW::patchconfigstring(strData, strname, strvalue);
				for(int x=0;	x<strname.size();	++x){
					if(strname.at(x) == "fov")	 stcircleitem.flFOV	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "weight")	 stcircleitem.flWeight	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "angle")	 stcircleitem.flAngle		=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "spech")	 stcircleitem.flSpecHor		=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "specv")	 stcircleitem.flSpecVec		=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "specu")	 stcircleitem.flSpecUniform		=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "lpmin")	 stcircleitem.usLPMin		=	strvalue.at(x).toInt();
					else if(strname.at(x) == "lpmax")	 stcircleitem.usLPMax		=	strvalue.at(x).toInt();
					else if(strname.at(x) == "lpnum")	 stcircleitem.ucConstLPNum		=	strvalue.at(x).toInt();
					else if(strname.at(x) == "threshold")	 stcircleitem.ucConstThresholdB8		=	strvalue.at(x).toInt();
					else if(strname.at(x) == "offset")	 stcircleitem.flValueOffset		=	strvalue.at(x).toFloat();
				}
			}

			pstTheParamter->vectorLpItem.push_back(stcircleitem);	
		}

		query.prepare("SELECT itemsuffix2,key,value,reserve FROM " % itemshareData.currentTableName % \
			" WHERE classfy='algorithm' AND item='" % strItemName % "' AND itemsuffix1='statics' ORDER BY id ASC" );
		query.exec();
		/************statics**************/
		//(tactics:0)(usedb:true)(maxstep:10)(stepdelay:500)(valuechoose:0)(valuetype:0)
		//(motorstart:0)(motorend:1023)(motormin:0)(motormax:1023)(bigstep:20)(middlestep:10)(smallstep:5)
		//(curvedef:0.2)(falloffdef:0.1)(linearback:true)
		while (query.next()){
			bItemExist = true;
			for(int y=0;	y<4;	++y){
				strData	=	query.value(y).toString();
				ROPLOW::patchconfigstring(strData, strname, strvalue);
				for(int x=0;	x<strname.size();	++x){
					if(strname.at(x) == "tactics")	 pstTheParamter->stTacticsBasic.ucTactics	=	strvalue.at(x).toInt();
					else if(strname.at(x) == "maxstep")	 pstTheParamter->stTacticsBasic.usMaxSteps	=	strvalue.at(x).toInt();
					else if(strname.at(x) == "stepdelay")	 pstTheParamter->stTacticsBasic.usStepDelay	=	strvalue.at(x).toInt();
					else if(strname.at(x) == "valuechoose")	 pstTheParamter->stTacticsBasic.ucValueChoose	=	strvalue.at(x).toInt();
					else if(strname.at(x) == "valuetype")	 pstTheParamter->stTacticsBasic.ucValueTypeChoose	=	strvalue.at(x).toInt();
					else if(strname.at(x) == "motorstart")	 pstTheParamter->stTacticsBasic.sMotorStart	=	strvalue.at(x).toInt();
					else if(strname.at(x) == "motorend")	 pstTheParamter->stTacticsBasic.sMotorEnd	=	strvalue.at(x).toInt();
					else if(strname.at(x) == "motormin")	 pstTheParamter->stTacticsBasic.sMotorSpecMin	=	strvalue.at(x).toInt();
					else if(strname.at(x) == "motormax")	 pstTheParamter->stTacticsBasic.sMotorSpecMax	=	strvalue.at(x).toInt();
					else if(strname.at(x) == "bigstep")	 pstTheParamter->stTacticsBasic.ucBigStep	=	strvalue.at(x).toInt();
					else if(strname.at(x) == "middlestep")	 pstTheParamter->stTacticsBasic.ucMiddleStep	=	strvalue.at(x).toInt();
					else if(strname.at(x) == "smallstep")	 pstTheParamter->stTacticsBasic.ucSmallStep	=	strvalue.at(x).toInt();
					else if(strname.at(x) == "curvedef")	 pstTheParamter->stTacticsBasic.flCurveValidDef	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "falloffdef")	 pstTheParamter->stTacticsBasic.flCurveFalloffDef	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "usedb") pstTheParamter->stTacticsBasic.bDataBase = (strvalue.at(x) == "true");
					else if(strname.at(x) == "fitting") pstTheParamter->stTacticsBasic.bCurveFitting = (strvalue.at(x) == "true");
					else if(strname.at(x) == "linearback") pstTheParamter->stTacticsBasic.bLinearBack = (strvalue.at(x) == "true");
				}
			}
		}

		customdb.close();
	}

	QSqlDatabase::removeDatabase("querycustom");
	if(!bparsesuccess || !bItemExist){
		if(uctype == 0) {HisReleaseNewO(itemshareData.lpnearafcParameter);}
		else if(uctype == 1) {HisReleaseNewO(itemshareData.lpmiddleafcParameter);}
		else {HisReleaseNewO(itemshareData.lpfarafcParameter);}
		itemshareData.itemparameterLock.unlock();
		return HisFX3Error_Parameter;
	}

	if(!bcheck) {itemshareData.itemparameterLock.unlock(); return 0; }

	if(pstTheParamter->stTacticsBasic.ucTactics == _HisCCMAlg_Rolongo_AFC_Tactics_Linear || \
		pstTheParamter->stTacticsBasic.ucTactics == _HisCCMAlg_Rolongo_AFC_Tactics_Single)
		pstTheParamter->stTacticsBasic.bDataBase=	false;

	std::sort(pstTheParamter->vectorLpItem.begin(), pstTheParamter->vectorLpItem.end(), sort_lpitem_fov);

	pstTheParamter->stLpBasic.flGradeMultiple	=	1.0f;
	itemshareData.itemparameterLock.unlock();
	return 0;
}

int itemprocess::lpAFC(unsigned char uctype, int iNewStactics, int& iOldStatics) //0-近焦 1-中焦 2-远焦
{
	_CODE_CLEAR_IMAGEDRAW

		bool bGetDB	=	false;
	if((uctype == 0 && itemshareData.lpnearafcParameter == NULL) || \
		(uctype == 1 && itemshareData.lpmiddleafcParameter == NULL) || \
		(uctype == 2 && itemshareData.lpfarafcParameter == NULL)) bGetDB = true;

	int iresult	=	getLpAFCParameter(uctype, false);
	if(iresult)	return iresult;
	if(iresult = getccmhardwareParameter(false))	return iresult;

	unsigned char* pucBufRaw = NULL, *pucBufY = NULL;
	_HisCCMAlg_AFC_LP_DB* pstAFCLpDB;
	_lpAFCParameter* pstParameter;
	if(uctype == 1)	{
		pstParameter	=	itemshareData.lpmiddleafcParameter;
		pstAFCLpDB	=	&stAFCLpMiddleDB;
	}
	else if(uctype == 2) {
		pstParameter = itemshareData.lpfarafcParameter;
		pstAFCLpDB	=	&stAFCLpFarDB;
	}
	else {
		pstParameter	=	itemshareData.lpnearafcParameter;
		pstAFCLpDB	=	&stAFCLpNearDB;
	}

	if(iNewStactics >= _HisCCMAlg_Rolongo_AFC_Tactics_PASS && iNewStactics <= _HisCCMAlg_Rolongo_AFC_Tactics_Inflexion){
		iOldStatics	=	pstParameter->stTacticsBasic.ucTactics;
		pstParameter->stTacticsBasic.ucTactics	=	iNewStactics;
	}

	if(bGetDB && pstParameter->stTacticsBasic.bDataBase){
		if(iresult = ROPLOW::AFCLpHAFromDB(uctype, pstParameter, pstAFCLpDB, bBoxChannel1)) return iresult;
	}

	itemshareData.itemparameterLock.lockForRead();

	emit information("db item: " % QString::number(pstAFCLpDB->vectorItem.size()));
	std::vector<_HisCCMAlg_AFC_LP_DB_Item>::iterator iteratordb;

	int iMotorPosNow	=	pstParameter->stTacticsBasic.sMotorStart;
	if(pstParameter->stTacticsBasic.bDataBase && pstAFCLpDB->vectorItem.size() > 0){
		iMotorPosNow	=	0;
		for(iteratordb = pstAFCLpDB->vectorItem.begin(); iteratordb != pstAFCLpDB->vectorItem.end(); iteratordb++){
			iMotorPosNow	+=	iteratordb->sMotorEnd;
		}
		iMotorPosNow	/=	pstAFCLpDB->vectorItem.size();

		emit information("db motor: " % QString::number(iMotorPosNow));

		if(iresult = setMotor(itemshareData.ccmhardwareParameter->motortype.toAscii().data(), itemshareData.previewParameter->ucSlave, \
			itemshareData.ccmhardwareParameter->projectname.toAscii().data(), iMotorPosNow, globalFunPointer.ReadHisFX3IIC, globalFunPointer.WriteHisFX3IIC, globalFunPointer.SetHisFX3IICSpeed, globalFunPointer.PullHisFX3RESET, globalFunPointer.PullHisFX3PWND, \
			globalFunPointer.PageWriteHisFX3IIC, globalFunPointer.PageReadHisFX3IIC, globalFunPointer.HisFX3PageWriteSPI, globalFunPointer.HisFX3PageReadSPI)) _CODE_AFC_LP_EXIT1
			::Sleep(pstParameter->stTacticsBasic.usStepDelay);
	}
	else if(pstParameter->stTacticsBasic.ucTactics != _HisCCMAlg_Rolongo_AFC_Tactics_Single){
		if(iresult = setMotor(itemshareData.ccmhardwareParameter->motortype.toAscii().data(), itemshareData.previewParameter->ucSlave, \
			itemshareData.ccmhardwareParameter->projectname.toAscii().data(), iMotorPosNow, globalFunPointer.ReadHisFX3IIC, globalFunPointer.WriteHisFX3IIC, globalFunPointer.SetHisFX3IICSpeed, globalFunPointer.PullHisFX3RESET, globalFunPointer.PullHisFX3PWND, \
			globalFunPointer.PageWriteHisFX3IIC, globalFunPointer.PageReadHisFX3IIC, globalFunPointer.HisFX3PageWriteSPI, globalFunPointer.HisFX3PageReadSPI)) _CODE_AFC_LP_EXIT1
			::Sleep(pstParameter->stTacticsBasic.usStepDelay);
	}


	_HisFX3_BaylorMode emDataFormat =	itemshareData.previewParameter->ucDataFormat;
	int iImgWidth =	itemshareData.previewParameter->iWidth, iImgHeight =	itemshareData.previewParameter->iHeight;
	unsigned int uiRawImgSize		=	itemshareData.previewParameter->iWidth * itemshareData.previewParameter->iHeight *3;
	unsigned char ucFrameType	=	_FrameType_RGB24;
	switch (itemshareData.previewParameter->ucDataFormat){
	case HisBaylor10_BGGR:
	case HisBaylor12_BGGR:
	case HisBaylor8_BGGR:	emDataFormat	=	HisBaylor8_BGGR;	break;
	case HisBaylor10_RGGB:
	case HisBaylor12_RGGB:
	case HisBaylor8_RGGB:	emDataFormat	=	HisBaylor8_RGGB;	break;
	case HisBaylor10_GRBG:
	case HisBaylor12_GRBG:
	case HisBaylor8_GRBG:	emDataFormat	=	HisBaylor8_GRBG;	break;
	case HisBaylor10_GBRG:
	case HisBaylor12_GBRG:
	case HisBaylor8_GBRG:	emDataFormat	=	HisBaylor8_GBRG;	break;
	case HisBaylor10_MONO:
	case HisBaylor12_MONO:
	case HisBaylor8_MONO:	emDataFormat	=	HisBaylor8_MONO;	break;
	case HisRGB_RGB24: break;
	default:
		uiRawImgSize		=	itemshareData.previewParameter->iWidth * itemshareData.previewParameter->iHeight *2;
		ucFrameType		=	_FrameType_Raw;
		break;
	}

	unsigned int uiPixelSize	=	iImgWidth *iImgHeight;
	pucBufRaw		=	(unsigned char*)_aligned_malloc(uiRawImgSize, _HisCacheLine_Aligned);
	pucBufY			=	(unsigned char*)_aligned_malloc(iImgWidth *iImgHeight, _HisCacheLine_Aligned);
	if(!(pucBufRaw && pucBufY)){
		HisReleaseMalloc(pucBufY);
		HisReleaseMalloc(pucBufRaw);
		itemshareData.itemparameterLock.unlock();
		return HisFX3Error_MallocBuffer;
	}

	std::vector<_itemDraw> vectorDraw;
	vectorDraw.reserve(56);
	std::vector<_HisCCMAlg_AFC_LP_DataItem> vectorItemData;
	_HisCCMAlg_RECT_FOV4 stRectFOV4;
	std::vector<_HisCCMAlg_RECT_FOV4> vectorRectFov4;
	vectorRectFov4.resize(pstParameter->vectorLpItem.size());
	_HisCCMAlg_AFC_Linear_Result stLinearResult;

	RECT stValueLine, stMinLine, stMaxLine;
	int iCenterX, iCenterY;
	double dflAngle, dflDistance, dflValue;
	std::vector<RECT> vectorBlock;
	std::vector<RECT> vectorMark;
	vectorBlock.reserve(32);
	vectorMark.reserve(4);

	float flChartLpValueMax	=	1.0;
	for(unsigned int x=0;	x<pstParameter->vectorLpItem.size(); ++x){
		flChartLpValueMax	=	max(flChartLpValueMax, pstParameter->vectorLpItem.at(x).usLPMax);
	}

	_HisCCMAlg_ImageBuffer stImgBuffer;
	stImgBuffer.pvImgBuf			=	(void*)(pucBufY);
	stImgBuffer.iImgWidth		=	iImgWidth;
	stImgBuffer.iImgHeight		=	iImgHeight;
	stImgBuffer.enumFormat		=	_HisCCMAlg_ImageBuffer_Type_Y_U8;
	stImgBuffer.enumChannel	=	_HisCCMAlg_ImageBuffer_Channel_Y; 
	bool bNext;

	for(unsigned int uistepcount=0; uistepcount < pstParameter->stTacticsBasic.usMaxSteps && hisglobalparameter.getrunflag() && threadshareData.GetHisPreviewflag(); ++uistepcount){

		ROPLOW::AFCLpItemDataInitial(vectorItemData, pstParameter->vectorLpItem, iMotorPosNow);

		for(unsigned char frame = 0; frame < pstParameter->stLpBasic.ucFrames; ++frame){
#ifdef _HisFX3_Platform_Jigboard
			if(iresult = Jig_Change2Capture()){
				emit information(QTextCodec::codecForName( "GBK")->toUnicode("切换到JIG全像素失败：0x") % QString::number(iresult, 16));
				break;
			}
			Sleep(4000);
#endif
			if(iresult	=	GetFreshframe(pucBufRaw, uiRawImgSize, ucFrameType, !uistepcount)) {
				emit information(QTextCodec::codecForName( "GBK")->toUnicode("抓图失败：0x") % QString::number(iresult, 16));
				break;
			}
			if(emDataFormat >= HisYUV8_422_YUYV && emDataFormat <= HisYUV8_422_VYUY)
				classAlgorithm.extactYfromYUV422U8(pucBufRaw, pucBufY, iImgWidth*iImgHeight, emDataFormat); //抽取Y通道
			else{ //抽取G通道作为Y通道
				unsigned char* pucSrc = pucBufRaw + 1, *pucDes = pucBufY;
				for(unsigned int x=0;	x<uiPixelSize;	++x){
					*pucDes	=	*pucSrc;
					++pucDes;
					pucSrc	+=	3;
				}
			}

			vectorDraw.clear();
			ROPLOW::AddDrawEllipse((iImgWidth>>1), (iImgHeight >>1), iImgWidth, iImgHeight, pstParameter->stLpBasic.dflConstMarkFMin, 1, vectorDraw);
			ROPLOW::AddDrawEllipse((iImgWidth>>1), (iImgHeight >>1), iImgWidth, iImgHeight, pstParameter->stLpBasic.dflConstMarkFMax, 1, vectorDraw);

			bNext	=	true;
			if(iresult = classAlgorithm.HisCCMlinePairDetectHA((char*)(pucBufY), iImgWidth, iImgHeight, pstParameter->stLpBasic.usConstLPWMin, \
				pstParameter->stLpBasic.usConstLPWMax,pstParameter->stLpBasic.usConstLPHMin, pstParameter->stLpBasic.usConstLPHMax,\
				pstParameter->stLpBasic.usConstMarkPMin, pstParameter->stLpBasic.usConstMarkPMax, pstParameter->stLpBasic.dflConstMarkFMin, \
				pstParameter->stLpBasic.dflConstMarkFMax,pstParameter->stLpBasic.dflConstMarkAngle,  \
				pstParameter->stLpBasic.usConstExpandW, pstParameter->stLpBasic.usConstExpandH, \
				iCenterX, iCenterY, dflAngle, dflDistance, vectorBlock, vectorMark)){
					emit information(QTextCodec::codecForName( "GBK")->toUnicode("无法提取出MARK点的位置信息"));
					bNext	=	false;
			}

			if(bNext){
				(vectorItemData.end() - 1)->dflMarkDistance		=	dflDistance;
				for(unsigned int x=0;	x<pstParameter->vectorLpItem.size(); ++x)
					ROPLOW::AddDesiredFOV4Cross(dflDistance*pstParameter->vectorLpItem.at(x).flFOV, pstParameter->vectorLpItem.at(x).flAngle, iCenterX, iCenterY, vectorDraw);
				ROPLOW::AddDrawMark(vectorMark, 1, vectorDraw);

				for(unsigned int x=0;	x<pstParameter->vectorLpItem.size(); ++x){
					iresult	=	classAlgorithm.HisCCMExtractLPDetectHBFOV4(vectorBlock, iImgWidth, iImgHeight, iCenterX, iCenterY, \
						pstParameter->vectorLpItem.at(x).flFOV*dflDistance, pstParameter->vectorLpItem.at(x).flAngle, \
						pstParameter->stLpBasic.usFOVDisDev, stRectFOV4);
					if(iresult)	{
						emit information(QTextCodec::codecForName( "GBK")->toUnicode("无法提取线对位置信息 FOV: ") % QString::number(pstParameter->vectorLpItem.at(x).flFOV));
						bNext	=	false;
						continue;
					}

					ROPLOW::AddDrawFOV4(stRectFOV4, 1, vectorDraw);
					vectorRectFov4[x]	=	stRectFOV4;

					for(unsigned int i=0;	i<4; ++i){
						iresult	=	classAlgorithm.HisCCMLinePairValueHA(stImgBuffer,  vectorRectFov4.at(x).stBlocks[i], pstParameter->vectorLpItem.at(x).ucConstLPNum, \
							pstParameter->vectorLpItem.at(x).ucConstThresholdB8, pstParameter->vectorLpItem.at(x).usLPMin, \
							pstParameter->vectorLpItem.at(x).usLPMax, dflAngle, pstParameter->vectorLpItem.at(x).flValueOffset, dflValue, stValueLine, stMinLine, stMaxLine);
						if(vectorRectFov4.at(x).stBlocks[i].right-vectorRectFov4.at(x).stBlocks[i].left > vectorRectFov4.at(x).stBlocks[i].bottom - vectorRectFov4.at(x).stBlocks[i].top)
							ROPLOW::AddDrawLP(vectorRectFov4.at(x).stBlocks[i], stValueLine, stMaxLine, stMinLine, iImgWidth, iImgHeight,pstParameter->vectorLpItem.at(x).flSpecVec, dflValue, 1, vectorDraw, pstParameter->stLpBasic.flGradeMultiple);
						else
							ROPLOW::AddDrawLP(vectorRectFov4.at(x).stBlocks[i], stValueLine, stMaxLine, stMinLine, iImgWidth, iImgHeight, pstParameter->vectorLpItem.at(x).flSpecHor, dflValue, 1, vectorDraw, pstParameter->stLpBasic.flGradeMultiple);
						ROPLOW::AFCItemDataAdd(vectorItemData, vectorRectFov4.at(x).stBlocks[i],  stValueLine, stMaxLine, stMinLine, dflValue, x, i);
					}
				}
			}

			_CODE_RJAFA_LP_ASIGNDRAW

#ifdef _HisFX3_Platform_Jigboard
				hisglobalparameter.Jig_bRefreshImage	=	true;
#endif
		}

		for(unsigned int x=0;	x<pstParameter->vectorLpItem.size(); ++x)
		{
			float flmax = 0.0f, flmin = 99999.0f;
			for(unsigned int i=0;	i<4;	++i){
				(vectorItemData.end()-1)->vectorFOV[x].stLpValue[i].flValue		/=	pstParameter->stLpBasic.ucFrames;
				flmax	=	max(flmax, (vectorItemData.end()-1)->vectorFOV[x].stLpValue[i].flValue);
				flmin		=	min(flmin, (vectorItemData.end()-1)->vectorFOV[x].stLpValue[i].flValue);

				(vectorItemData.end()-1)->vectorFOV[x].stBlock[i].left	/=	pstParameter->stLpBasic.ucFrames;
				(vectorItemData.end()-1)->vectorFOV[x].stBlock[i].right	/=	pstParameter->stLpBasic.ucFrames;
				(vectorItemData.end()-1)->vectorFOV[x].stBlock[i].top	/=	pstParameter->stLpBasic.ucFrames;
				(vectorItemData.end()-1)->vectorFOV[x].stBlock[i].bottom	/=	pstParameter->stLpBasic.ucFrames;
				(vectorItemData.end()-1)->vectorFOV[x].stValueLine[i].left	/=	pstParameter->stLpBasic.ucFrames;
				(vectorItemData.end()-1)->vectorFOV[x].stValueLine[i].right	/=	pstParameter->stLpBasic.ucFrames;
				(vectorItemData.end()-1)->vectorFOV[x].stValueLine[i].top	/=	pstParameter->stLpBasic.ucFrames;
				(vectorItemData.end()-1)->vectorFOV[x].stValueLine[i].bottom	/=	pstParameter->stLpBasic.ucFrames;
				(vectorItemData.end()-1)->vectorFOV[x].stMinLine[i].left	/=	pstParameter->stLpBasic.ucFrames;
				(vectorItemData.end()-1)->vectorFOV[x].stMinLine[i].right	/=	pstParameter->stLpBasic.ucFrames;
				(vectorItemData.end()-1)->vectorFOV[x].stMinLine[i].top	/=	pstParameter->stLpBasic.ucFrames;
				(vectorItemData.end()-1)->vectorFOV[x].stMinLine[i].bottom	/=	pstParameter->stLpBasic.ucFrames;
				(vectorItemData.end()-1)->vectorFOV[x].stMaxLine[i].left	/=	pstParameter->stLpBasic.ucFrames;
				(vectorItemData.end()-1)->vectorFOV[x].stMaxLine[i].right	/=	pstParameter->stLpBasic.ucFrames;
				(vectorItemData.end()-1)->vectorFOV[x].stMaxLine[i].top	/=	pstParameter->stLpBasic.ucFrames;
				(vectorItemData.end()-1)->vectorFOV[x].stMaxLine[i].bottom	/=	pstParameter->stLpBasic.ucFrames;
			}
			(vectorItemData.end()-1)->vectorFOV[x].flUniformValue	=	flmax - flmin;
		}

		iresult	=	classAlgorithm.HisAFCTactics_LP_DB_HA(pstParameter->stTacticsBasic, vectorItemData, *pstAFCLpDB, iMotorPosNow);
		if(iresult)	break;
		if(iMotorPosNow != 0xFFFFFF)
			emit information("next motor: " % QString::number(iMotorPosNow));

		if(iMotorPosNow == 0x00FFFFFF){
			iresult	=	0;
			break;
		}

		if(iresult = setMotor(itemshareData.ccmhardwareParameter->motortype.toAscii().data(), itemshareData.previewParameter->ucSlave, \
			itemshareData.ccmhardwareParameter->projectname.toAscii().data(), iMotorPosNow, globalFunPointer.ReadHisFX3IIC, globalFunPointer.WriteHisFX3IIC, globalFunPointer.SetHisFX3IICSpeed, globalFunPointer.PullHisFX3RESET, globalFunPointer.PullHisFX3PWND, \
			globalFunPointer.PageWriteHisFX3IIC, globalFunPointer.PageReadHisFX3IIC, globalFunPointer.HisFX3PageWriteSPI, globalFunPointer.HisFX3PageReadSPI)) break;
		::Sleep(pstParameter->stTacticsBasic.usStepDelay);

		if(pstParameter->stTacticsBasic.ucTactics == _HisCCMAlg_Rolongo_AFC_Tactics_Single || \
			pstParameter->stTacticsBasic.ucTactics == _HisCCMAlg_Rolongo_AFC_Tactics_PASS){
				itemshareData.plotLock.lockForWrite();
				ROPLOW::fillLpFABarChartDrawInfo(itemshareData.vecBarChartItem, *(vectorItemData.end()-1), iImgWidth, iImgHeight, pstParameter->stLpBasic.flGradeMultiple);
				itemshareData.dflBarChartYMin		=	0.0;
				itemshareData.dflBarChartYMax	=	flChartLpValueMax;
				itemshareData.plotLock.unlock();
				emit plotpainter(1);
		}
		else if(pstParameter->stTacticsBasic.ucTactics == _HisCCMAlg_Rolongo_AFC_Tactics_Linear){
			itemshareData.plotLock.lockForWrite();
			ROPLOW::curveLpAFCCurveDraw(itemshareData.vecCurvePoint, itemshareData.vecCurveLineColor, itemshareData.vecCurveLegend, \
				vectorItemData, iImgWidth, iImgHeight);
			itemshareData.dflCurveYMin		=	0.0;
			itemshareData.dflCurveYMax	=	1.0;
			itemshareData.dflCurveXMin		=	pstParameter->stTacticsBasic.sMotorStart;
			itemshareData.dflCurveXMax		=	pstParameter->stTacticsBasic.sMotorEnd;
			itemshareData.bCurveXScaleAuto	=	false;
			itemshareData.ucCurveType		=	2;
			itemshareData.plotLock.unlock();
			emit plotpainter(2);
		}
		else{
			itemshareData.plotLock.lockForWrite();
			ROPLOW::curveLpAFCCurveDraw(itemshareData.vecCurvePoint, itemshareData.vecCurveLineColor, itemshareData.vecCurveLegend, \
				vectorItemData, iImgWidth, iImgHeight);
			itemshareData.dflCurveYMin		=	0.0;
			itemshareData.dflCurveYMax	=	1.0;
			itemshareData.dflCurveXMin		=	pstParameter->stTacticsBasic.sMotorStart;
			itemshareData.dflCurveXMax		=	pstParameter->stTacticsBasic.sMotorEnd;
			itemshareData.bCurveXScaleAuto	=	false;
			itemshareData.ucCurveType		=	1;
			itemshareData.plotLock.unlock();
			emit plotpainter(2);
		}
	}

	if(pstParameter->stTacticsBasic.ucTactics == _HisCCMAlg_Rolongo_AFC_Tactics_Single || \
		pstParameter->stTacticsBasic.ucTactics == _HisCCMAlg_Rolongo_AFC_Tactics_PASS){

	}
	else if(pstParameter->stTacticsBasic.ucTactics == _HisCCMAlg_Rolongo_AFC_Tactics_Linear){
		itemshareData.plotLock.lockForWrite();
		ROPLOW::curveLpAFCCurveDraw(itemshareData.vecCurvePoint, itemshareData.vecCurveLineColor, itemshareData.vecCurveLegend, \
			vectorItemData, iImgWidth, iImgHeight);
		itemshareData.dflCurveYMin		=	0.0;
		itemshareData.dflCurveYMax	=	1.0;
		itemshareData.dflCurveXMin		=	pstParameter->stTacticsBasic.sMotorStart;
		itemshareData.dflCurveXMax		=	pstParameter->stTacticsBasic.sMotorEnd;
		itemshareData.bCurveXScaleAuto	=	false;
		itemshareData.ucCurveType		=	2;
		itemshareData.plotLock.unlock();
		emit plotpainter(2);
	}
	else{
		itemshareData.plotLock.lockForWrite();
		ROPLOW::curveLpAFCCurveDraw(itemshareData.vecCurvePoint, itemshareData.vecCurveLineColor, itemshareData.vecCurveLegend, \
			vectorItemData, iImgWidth, iImgHeight);
		itemshareData.dflCurveYMin		=	0.0;
		itemshareData.dflCurveYMax	=	1.0;
		itemshareData.dflCurveXMin		=	pstParameter->stTacticsBasic.sMotorStart;
		itemshareData.dflCurveXMax		=	pstParameter->stTacticsBasic.sMotorEnd;
		itemshareData.bCurveXScaleAuto	=	false;
		itemshareData.ucCurveType		=	1;
		itemshareData.plotLock.unlock();
		emit plotpainter(2);
	}


	unsigned int uiSaveIndex	=	0xFFFFFFFF;
	float flMaxWeightValue	=	-10.0f;
	bool bTempResult	=	false;
	for(unsigned int x=0;	x<vectorItemData.size(); ++x){
		if(vectorItemData.at(x).ucFlag == 0x1){
			uiSaveIndex	=	x;
			break;
		}
		else if(bTempResult){
			if(vectorItemData.at(x).ucStatus >= 0x1 && vectorItemData.at(x).flWeightValue > flMaxWeightValue){
				flMaxWeightValue	=	vectorItemData.at(x).flWeightValue;
				uiSaveIndex				=	x;
			}
		}
		else{
			if(vectorItemData.at(x).ucStatus >= 0x1 || vectorItemData.at(x).flWeightValue > flMaxWeightValue){
				flMaxWeightValue	=	vectorItemData.at(x).flWeightValue;
				uiSaveIndex				=	x;
				bTempResult			=	(vectorItemData.at(x).ucStatus >= 0x1);
			}
		}
	}

	if(vectorItemData.at(uiSaveIndex).ucStatus == 0x0)	iresult	=	HisCCMError_NoFocusStep;

	if(uiSaveIndex != 0xFFFFFFFF && uiSaveIndex != vectorItemData.size() - 1){
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("马达运动到最优点:") % QString::number(vectorItemData.at(uiSaveIndex).sMotorStep));
		int iresult2 = iresult;
		if(iresult = setMotor(itemshareData.ccmhardwareParameter->motortype.toAscii().data(), itemshareData.previewParameter->ucSlave, \
			itemshareData.ccmhardwareParameter->projectname.toAscii().data(), vectorItemData.at(uiSaveIndex).sMotorStep, globalFunPointer.ReadHisFX3IIC, globalFunPointer.WriteHisFX3IIC, globalFunPointer.SetHisFX3IICSpeed, globalFunPointer.PullHisFX3RESET, globalFunPointer.PullHisFX3PWND, \
			globalFunPointer.PageWriteHisFX3IIC, globalFunPointer.PageReadHisFX3IIC, globalFunPointer.HisFX3PageWriteSPI, globalFunPointer.HisFX3PageReadSPI)) 
			_CODE_AFC_LP_EXIT1
			iresult = iresult2;

		vectorDraw.clear();
		for(unsigned int x=0;	x<pstParameter->vectorLpItem.size(); ++x){
			for(unsigned int i=0;	i<4; ++i){
				if(vectorItemData.at(uiSaveIndex).vectorFOV.at(x).stLpValue[i].ucOrientation == 0x1)
					ROPLOW::AddDrawLP(vectorItemData.at(uiSaveIndex).vectorFOV.at(x).stBlock[i], vectorItemData.at(uiSaveIndex).vectorFOV.at(x).stValueLine[i], \
					vectorItemData.at(uiSaveIndex).vectorFOV.at(x).stMaxLine[i], vectorItemData.at(uiSaveIndex).vectorFOV.at(x).stMinLine[i], \
					iImgWidth, iImgHeight,pstParameter->vectorLpItem.at(x).flSpecVec, vectorItemData.at(uiSaveIndex).vectorFOV.at(x).stLpValue[i].flValue, 1, vectorDraw, pstParameter->stLpBasic.flGradeMultiple);
				else
					ROPLOW::AddDrawLP(vectorItemData.at(uiSaveIndex).vectorFOV.at(x).stBlock[i], vectorItemData.at(uiSaveIndex).vectorFOV.at(x).stValueLine[i], \
					vectorItemData.at(uiSaveIndex).vectorFOV.at(x).stMaxLine[i], vectorItemData.at(uiSaveIndex).vectorFOV.at(x).stMinLine[i], \
					iImgWidth, iImgHeight, pstParameter->vectorLpItem.at(x).flSpecHor, vectorItemData.at(uiSaveIndex).vectorFOV.at(x).stLpValue[i].flValue, 1, vectorDraw, pstParameter->stLpBasic.flGradeMultiple);
			}
		}

		_CODE_RJAFA_LP_ASIGNDRAW
	}

	if(hisglobalparameter.bDebugMode && vectorItemData.size() > 1){
		QString strSerialNumber;
		classLog->getserialnumber(strSerialNumber);
		if(strSerialNumber.isEmpty()) strSerialNumber = "1";
		strSerialNumber	=	QDir::currentPath() % "/" % strSerialNumber;
		if(uctype == 0) strSerialNumber = strSerialNumber % " Lp AFC Near Curve.csv";
		else if(uctype == 1) strSerialNumber = strSerialNumber % " Lp AFC Middle Curve.csv";
		else strSerialNumber = strSerialNumber % " Lp AFC Far Curve.csv";
		ROPLOW::saveLpHAAFCCurve2File(vectorItemData, pstParameter, strSerialNumber);
	}

	if(iresult){
		ROPLOW::saveLpAFCResult(uctype, false, uiSaveIndex, vectorItemData, pstParameter, *classLog, iImgWidth, iImgHeight);
		_CODE_AFC_LP_EXIT1
	}

	if(pstParameter->stTacticsBasic.ucTactics == _HisCCMAlg_Rolongo_AFC_Tactics_PEAK || \
		pstParameter->stTacticsBasic.ucTactics == _HisCCMAlg_Rolongo_AFC_Tactics_Inflexion){
			if(uctype == 0)	emit information(QTextCodec::codecForName( "GBK")->toUnicode("近焦最优点马达坐标：") % QString::number(vectorItemData.at(uiSaveIndex).sMotorStep));
			else if(uctype == 1)	emit information(QTextCodec::codecForName( "GBK")->toUnicode("中焦最优点马达坐标：") % QString::number(vectorItemData.at(uiSaveIndex).sMotorStep));
			else emit information(QTextCodec::codecForName( "GBK")->toUnicode("远焦最优点马达坐标：") % QString::number(vectorItemData.at(uiSaveIndex).sMotorStep));

			if(vectorItemData.at(uiSaveIndex).sMotorStep < pstParameter->stTacticsBasic.sMotorSpecMin && \
				vectorItemData.at(uiSaveIndex).sMotorStep > pstParameter->stTacticsBasic.sMotorSpecMax){
					iresult	=	HisCCMError_Result;
					emit information(QTextCodec::codecForName( "GBK")->toUnicode("最优点点马达位置超出规格"));
					_CODE_AFC_LP_EXIT1
			}

			if(uctype == 0)	iNearPeakMotorDec	=	vectorItemData.at(uiSaveIndex).sMotorStep;
			else if(uctype == 1)	iMiddlePeakMotorDec	=	vectorItemData.at(uiSaveIndex).sMotorStep;
			else iFarPeakMotorDec	=	vectorItemData.at(uiSaveIndex).sMotorStep;
	}
	else if(pstParameter->stTacticsBasic.ucTactics == _HisCCMAlg_Rolongo_AFC_Tactics_Linear){

	}

	ROPLOW::saveLpAFCResult(uctype, true, uiSaveIndex, vectorItemData, pstParameter, *classLog, iImgWidth, iImgHeight);

	if(pstParameter->stTacticsBasic.bDataBase && !iresult){
		ROPLOW::AFCLpHAToDB(uctype, pstParameter, pstAFCLpDB, vectorItemData, uiSaveIndex, bBoxChannel1);
	}
	_CODE_AFC_LP_EXIT1
}

int itemprocess::getmtffaParameter(bool bupdate, bool bcheck )
{
	QString strItemName;
	_mtffaParameter* pstTheParamter;
	strItemName	=	"mtfmfa";
	itemshareData.itemparameterLock.lockForRead();
	if(!bupdate && itemshareData.mtffaParameter) { itemshareData.itemparameterLock.unlock(); return 0; }

	itemshareData.itemparameterLock.unlock();
	itemshareData.itemparameterLock.lockForWrite();
	if(!itemshareData.mtffaParameter)		itemshareData.mtffaParameter		=	new _mtffaParameter;
	if(!itemshareData.mtffaParameter) {	itemshareData.itemparameterLock.unlock(); return HisFX3Error_MallocBuffer; }
	pstTheParamter	=	itemshareData.mtffaParameter;
	pstTheParamter->vectorMTFItem.clear();

	QMutexLocker locker(&hisglobalparameter.mutexDatabase);

	bool bparsesuccess	=	true, bItemExist = false;

	//读取，解析config
	for(int  w=0;	w<1;	++w){ //此处是有意义的,不要删除
		QSqlDatabase customdb = QSqlDatabase::addDatabase("QSQLITE", "querycustom");
		customdb.setDatabaseName(QDir::currentPath() % "/HisFX3Custom");
		if (!customdb.open()){
			bparsesuccess	=	false;
			break;
		}

		QString strData, strdata2;
		QStringList strname, strvalue;
		QSqlQuery query(customdb);
		query.prepare("SELECT itemsuffix2,key,value,reserve FROM " % itemshareData.currentTableName % \
			" WHERE classfy='algorithm' AND item='" % strItemName % "' AND itemsuffix1='basic' ORDER BY id ASC" );
		query.exec();

		/************basic**************/
		//(algswitch:0)(roiw:y)(roih:100)(centerspec:0.5)(centerweight:1.0)(autoseartch:true)(grademultiple:1.2)
		//(gradecount:4)(grade_d:0.1)(grade_c:0.1)(grade_b:0.1)(grade_a:0.1)
		while (query.next()){
			bItemExist = true;
			for(int y=0;	y<4;	++y){
				strData	=	query.value(y).toString();
				ROPLOW::patchconfigstring(strData, strname, strvalue);
				for(int x=0;	x<strname.size();	++x){
					if(strname.at(x) == "algswitch")	pstTheParamter->stMTFBasic.algswitch	=	strvalue.at(x).toInt();
					else if(strname.at(x) == "roiw")	pstTheParamter->stMTFBasic.iblockwith	=	strvalue.at(x).toInt();
					else if(strname.at(x) == "roih")	pstTheParamter->stMTFBasic.iblockheight	=	strvalue.at(x).toInt();
					else if(strname.at(x) == "centerspec")	pstTheParamter->stMTFBasic.flcenterspec	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "centerspec_h")	pstTheParamter->stMTFBasic.flHcenterspec	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "centerspec_v")	pstTheParamter->stMTFBasic.flVcenterspec	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "centerweight")	pstTheParamter->stMTFBasic.flcenterweight	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "autoseartch")	pstTheParamter->stMTFBasic.bAutoSeartchROI	=	(strvalue.at(x) == "true");
					else if(strname.at(x) == "gradecount")	pstTheParamter->stMTFBasic.ucGrade	=	strvalue.at(x).toUInt();
					else if(strname.at(x) == "grade_d")	pstTheParamter->stMTFBasic.flCenterGradeD	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "grade_c")	pstTheParamter->stMTFBasic.flCenterGradeC	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "grade_b")	pstTheParamter->stMTFBasic.flCenterGradeB		=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "grade_e")	pstTheParamter->stMTFBasic.flCenterGradeE		=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "grademultiple")	pstTheParamter->stMTFBasic.flGradeMultiple		=	strvalue.at(x).toFloat();
				}
			}
		}

		_HisCCMAlg_MTFItem_Info stcircleitem;
		query.prepare("SELECT itemsuffix2,key,value,reserve FROM " % itemshareData.currentTableName % \
			" WHERE classfy='algorithm' AND item='" % strItemName % "' AND itemsuffix1='fovitem' ORDER BY id ASC" );
		query.exec();
		/************fovitem**************/
		//(blockcount:4)(fov:0.5)(angle:0)(weight:1.0)
		//(spec:0.5)(specuniform:0.5)
		//(grade_d:0.1)(grade_c:0.1)(grade_b:0.1)(grade_e:0.1)
		while (query.next()){
			bItemExist = true;
			for(int y=0;	y<4;	++y){
				strData	=	query.value(y).toString();
				ROPLOW::patchconfigstring(strData, strname, strvalue);
				for(int x=0;	x<strname.size();	++x){
					if(strname.at(x) == "blockcount")	 stcircleitem.ucBlockCount	=	strvalue.at(x).toInt();
					else if(strname.at(x) == "fov")	 stcircleitem.flFOV	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "weight")	 stcircleitem.flWeight	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "angle")	 stcircleitem.flAngle		=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "spec")	 stcircleitem.flSpec		=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "specuniform")	 stcircleitem.flSpecUniform		=	0.5f;//strvalue.at(x).toFloat();
					else if(strname.at(x) == "grade_d")	 stcircleitem.flGradeD			=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "grade_c")	 stcircleitem.flGradeC			=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "grade_b")	 stcircleitem.flGradeB			=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "grade_e")	 stcircleitem.flGradeE			=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "spec_h")	 stcircleitem.flHSpec			=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "spec_v")	 stcircleitem.flVSpec			=	strvalue.at(x).toFloat();
				}
			}

			pstTheParamter->vectorMTFItem.push_back(stcircleitem);	
		}

		customdb.close();
	}

	QSqlDatabase::removeDatabase("querycustom");
	if(!bparsesuccess || !bItemExist){
		HisReleaseNewO(itemshareData.mtffaParameter);
		itemshareData.itemparameterLock.unlock();
		return HisFX3Error_Parameter;
	}

	if(!bcheck) {itemshareData.itemparameterLock.unlock(); return 0; }

	int iLeftLimit			= itemshareData.mtffaParameter->stMTFBasic.iblockwith /2;
	int iRightLimit		=	itemshareData.previewParameter->iWidth - itemshareData.mtffaParameter->stMTFBasic.iblockwith /2;
	int iTopLimit			=	itemshareData.mtffaParameter->stMTFBasic.iblockheight /2;
	int iBottomLimit	=	itemshareData.previewParameter->iHeight - itemshareData.mtffaParameter->stMTFBasic.iblockheight /2;

	pstTheParamter->stMTFBasic.iblockwith		=	((pstTheParamter->stMTFBasic.iblockwith >> 2) <<2);
	pstTheParamter->stMTFBasic.iblockheight	=	((pstTheParamter->stMTFBasic.iblockheight >> 2) <<2);

	std::sort(pstTheParamter->vectorMTFItem.begin(), pstTheParamter->vectorMTFItem.end(), sort_mtfitem_fov); 

	RECT* pstBlock = NULL;
	if(ROPLOW::GetMTFCABlock(itemshareData.previewParameter->iWidth, itemshareData.previewParameter->iHeight, \
		itemshareData.mtffaParameter->stMTFBasic, itemshareData.mtffaParameter->vectorMTFItem, &pstBlock)){
			HisReleaseNewO(itemshareData.mtffaParameter);
			HisReleaseNewB(pstBlock);
			itemshareData.itemparameterLock.unlock();
			emit information(tr("Error: The MTF position exceed image zone."));
			return HisFX3Error_Parameter;
	}
	HisReleaseNewB(pstBlock);

	itemshareData.itemparameterLock.unlock();
	return 0;
}



int itemprocess::mtfFA(unsigned int uiOpMode)
{
	if(uiOpMode != 1)
		_CODE_CLEAR_IMAGEDRAW

//***************** 2018.04.28 feng Add ************* 
#ifdef _DEBUG
		fnMTF_Q fnMTF=(fnMTF_Q)QLibrary::resolve("cvImageToold.dll","fnMTF");
#else
		fnMTF_Q fnMTF=(fnMTF_Q)QLibrary::resolve("cvImageTool.dll","fnMTF");
#endif
	if(!fnMTF){
		emit information(QString::fromLocal8Bit("!载入cvImageTool.dll失败，请检查是否存在"));
		return -1;
	}
//***************************************************

	if(!threadshareData.GetHisPreviewflag()) return HisFX3Error_IsNotPreview;
	int iresult	=	getmtffaParameter(false);
	if(iresult)	return iresult;
	if(iresult = getccmhardwareParameter(false))	return iresult;

	unsigned char* pucBufRaw10 = NULL;
	unsigned char* pucBufRaw = NULL;
	RECT* pstBlock	=	NULL, *pstTemp = NULL;
	_mtffaParameter* pstParameter	=	itemshareData.mtffaParameter;

	itemshareData.itemparameterLock.lockForRead();

	if(iresult = ROPLOW::GetMTFCABlock(itemshareData.previewParameter->iWidth, itemshareData.previewParameter->iHeight, \
		pstParameter->stMTFBasic, pstParameter->vectorMTFItem, &pstBlock)){
			if(iresult == HisFX3Error_Parameter)
				emit information(QTextCodec::codecForName( "GBK")->toUnicode("选取的MTF ROI超出了图像区域"));
			_CODE_AFC_MTF_EXIT1
	}

	_HisFX3_BaylorMode emDataFormat =	itemshareData.previewParameter->ucDataFormat;
	int iImgWidth =	itemshareData.previewParameter->iWidth, iImgHeight =	itemshareData.previewParameter->iHeight;
	unsigned int uiRawImgSize		=	itemshareData.previewParameter->iWidth * itemshareData.previewParameter->iHeight *3;
	unsigned char ucFrameType		=	_FrameType_RGB24;
	unsigned int uiPixelSize	=	iImgWidth *iImgHeight;
	pucBufRaw		=	(unsigned char*)_aligned_malloc(uiRawImgSize, _HisCacheLine_Aligned);
	if(!pucBufRaw){
		HisReleaseMalloc(pucBufRaw);
		HisReleaseMalloc(pucBufRaw10);
		itemshareData.itemparameterLock.unlock();
		return HisFX3Error_MallocBuffer;
	}

	std::vector<_itemDraw> vectorDraw;
	vectorDraw.reserve(50);
	std::vector<_itemDraw>::iterator iteratorDraw;
	_HisCCMAlg_AFC_MTF_DataItem stItemData, stMaxItem;

	ROPLOW::MFAMTFItemDataInitial(stItemData, pstParameter);
	stMaxItem	=	stItemData;

	_ShadingImageInfo ImgInfo;
	float flvalue, flmax, flmin,flHvalue,flVvalue;
	bool bInitFrame	=	true;
	_itemStatus itemstatus;
	itemstatus.ucstatus	=	_His_ItemStatus_NG;
	itemstatus.usitem		=	mtffaitem;
	RECT stMTFAutoROI;
	QElapsedTimer classFATime;

	while(threadshareData.GetHisPreviewflag() && hisglobalparameter.getfaflag())
	{
		classFATime.restart();
		if(iresult	=	GetFreshframe(pucBufRaw, uiRawImgSize, ucFrameType, bInitFrame)) break;

		/*
		if(pstParameter->stMTFBasic.algswitch != 7){
			if(iresult	=	GetFreshframe(pucBufRaw, uiRawImgSize, ucFrameType, bInitFrame)) break;
			
		}else{
			unsigned int uiRawImgSize_raw10		=	iImgWidth *iImgHeight*2;
			unsigned char ucFrameType_raw10		=	_FrameType_Raw10;
			pucBufRaw10		=	(unsigned char*)_aligned_malloc(uiRawImgSize_raw10, _HisCacheLine_Aligned);
			if(!pucBufRaw10){
				HisReleaseMalloc(pucBufRaw);
				HisReleaseMalloc(pucBufRaw10);
				itemshareData.itemparameterLock.unlock();
				return HisFX3Error_MallocBuffer;
			}

			if(iresult	=	GetFreshframe(pucBufRaw10, uiRawImgSize_raw10, ucFrameType_raw10, bInitFrame)) break;
		}
		*/

		bInitFrame	=	false;
		vectorDraw.clear();

		pstTemp	=	pstBlock;
		stMTFAutoROI	=	*pstTemp;
		if(pstParameter->stMTFBasic.bAutoSeartchROI)
			classRolongoTest.CRolongoBlockAutomaticSearching(stMTFAutoROI, pucBufRaw, iImgWidth, iImgHeight, pstParameter->stMTFBasic.iblockwith *4, stMTFAutoROI);

		if(pstParameter->stMTFBasic.algswitch <= 4)
		{
			if(iresult	=	classAlgorithm.HisCCMMTF(pucBufRaw, iImgWidth, iImgHeight, stMTFAutoROI, pstParameter->stMTFBasic.algswitch, flvalue)) break;
		}else if(pstParameter->stMTFBasic.algswitch == 7){
			uchar ucFormat=(uchar)itemshareData.previewParameter->ucDataFormat;
			if(ucFormat==0x02||ucFormat==0x12){
				ImgInfo.uiFirstPixel = 0;
			}else if(ucFormat==0x03||ucFormat==0x13){
				ImgInfo.uiFirstPixel = 1;
			}else if(ucFormat==0x04||ucFormat==0x14){
				ImgInfo.uiFirstPixel = 2;
			}else if(ucFormat==0x01||ucFormat==0x11){
				ImgInfo.uiFirstPixel = 3;
			}

			ImgInfo.pImage = pucBufRaw10;
			ImgInfo.uiWidth = iImgWidth;
			ImgInfo.uiHeight = iImgHeight;
			ImgInfo.uiBlackLeve = 16*4;

			if(iresult	=	classRolongoTest.HisCCMMTF(pucBufRaw, iImgWidth, iImgHeight, stMTFAutoROI, pstParameter->stMTFBasic.algswitch, flHvalue,flVvalue)) break;
			//if(fnMTF(ImgInfo,stMTFAutoROI,flHvalue,flVvalue,FALSE));//if(iresult	=	classRolongoTest.HisCCMMTF(pucBufRaw, iImgWidth, iImgHeight, stMTFAutoROI, pstParameter->stMTFBasic.algswitch,flHvalue,flVvalue)) break;

		}
		else
		{
			if(iresult	=	classRolongoTest.HisCCMMTF(pucBufRaw, iImgWidth, iImgHeight, stMTFAutoROI, pstParameter->stMTFBasic.algswitch, flvalue)) break;
		}

		//_HisCCMAlg_AFC_MTF_DataItem_EX stItemData_EX;//**** 2018/04/11 
		stItemData_EX.vectorFOV.resize(pstParameter->vectorMTFItem.size());

		if(pstParameter->stMTFBasic.algswitch != 7){
			stItemData.flCenterValue		=	flvalue;
			stItemData_EX.flCenterValue = flvalue;
		}else{
			stItemData.flCenterValue		=	(flHvalue+flVvalue)/2;
			stItemData_EX.flHCenterValue=flHvalue;
			stItemData_EX.flVCenterValue=flVvalue;
			stItemData_EX.flCenterValue=(flHvalue+flVvalue)/2;
		}
		stItemData.stCenterBlock		=	stMTFAutoROI;
		stItemData_EX.stCenterBlock=stMTFAutoROI;

		pstTemp++;

		for(unsigned int y=0;	y<pstParameter->vectorMTFItem.size(); ++y){
			flmax	=	-99999.0f; flmin	=	99999.0f;
			for(unsigned int x=0;	x<pstParameter->vectorMTFItem.at(y).ucBlockCount; ++x){
				stMTFAutoROI	=	*pstTemp;
				if(pstParameter->stMTFBasic.bAutoSeartchROI)
					classRolongoTest.CRolongoBlockAutomaticSearching(stMTFAutoROI, pucBufRaw, iImgWidth, iImgHeight, pstParameter->stMTFBasic.iblockwith *4, stMTFAutoROI);

				if(pstParameter->stMTFBasic.algswitch <= 4)
				{
					if(iresult	=	classAlgorithm.HisCCMMTF(pucBufRaw, iImgWidth, iImgHeight, stMTFAutoROI, pstParameter->stMTFBasic.algswitch, flvalue)) break;
				}else if(pstParameter->stMTFBasic.algswitch == 7){

					if(iresult	=	classRolongoTest.HisCCMMTF(pucBufRaw, iImgWidth, iImgHeight, stMTFAutoROI, pstParameter->stMTFBasic.algswitch,flHvalue,flVvalue)) break;
				}
				else
				{
					if(iresult	=	classRolongoTest.HisCCMMTF(pucBufRaw, iImgWidth, iImgHeight, stMTFAutoROI, pstParameter->stMTFBasic.algswitch, flvalue)) break;
				}

				if(pstParameter->stMTFBasic.algswitch != 7){
					stItemData.vectorFOV.at(y).flValue[x]		=	flvalue;
					stItemData_EX.vectorFOV.at(y).flValue[x] =	flvalue;
				}else{
					stItemData.vectorFOV.at(y).flValue[x]		=	(flHvalue+flVvalue)/2;
					stItemData_EX.vectorFOV.at(y).flHValue[x]=flHvalue;
					stItemData_EX.vectorFOV.at(y).flVValue[x]=flVvalue;
					stItemData_EX.vectorFOV.at(y).flValue[x]= (flHvalue+flVvalue)/2;
				}

				stItemData.vectorFOV.at(y).stBlock[x]	=	stMTFAutoROI;
				stItemData_EX.vectorFOV.at(y).stBlock[x]=stMTFAutoROI;

				pstTemp++;
				flmax	=	max(flmax, flvalue);
				flmin		=	min(flmin, flvalue);
			}
			if(iresult) break;
			stItemData.vectorFOV.at(y).flUniformValue	=	flmax - flmin;
		}

		HisReleaseMalloc(pucBufRaw10);
		if(iresult) break;

		if(pstParameter->stMTFBasic.algswitch != 7){
			ROPLOW::AddDrawMTFHA(stItemData, iImgWidth, iImgHeight, vectorDraw, pstParameter->stMTFBasic.flGradeMultiple);
		}else{
			ROPLOW::AddDrawMTFHE(stItemData_EX, iImgWidth, iImgHeight, vectorDraw,*pstParameter, pstParameter->stMTFBasic.flGradeMultiple);

			//************ 2018.04.11 判断 ************** 
			if(stItemData_EX.flHCenterValue<pstParameter->stMTFBasic.flHcenterspec||stItemData_EX.flVCenterValue<pstParameter->stMTFBasic.flVcenterspec\
				||stItemData_EX.flCenterValue<pstParameter->stMTFBasic.flcenterspec){
				iresult=-1;
			}

			for (int i=0;i<pstParameter->vectorMTFItem.size();i++)
			{
				for (int y=0;y<pstParameter->vectorMTFItem.at(i).ucBlockCount;y++)
				{
					if(stItemData_EX.vectorFOV.at(i).flHValue[y] < pstParameter->vectorMTFItem.at(i).flHSpec||stItemData_EX.vectorFOV.at(i).flVValue[y] < pstParameter->vectorMTFItem.at(i).flVSpec\
						||stItemData_EX.vectorFOV.at(i).flValue[y] < pstParameter->vectorMTFItem.at(i).flSpec){
						iresult=-1;
					}
				}
			}

			if(iresult==0) itemstatus.ucstatus	=0;
			else itemstatus.ucstatus	=1;
		}

		_CODE_RJAFA_LP_ASIGNDRAW



		ROPLOW::MTFMFACaculateResult(stItemData, pstParameter->stMTFBasic.flGradeMultiple);
		if(stItemData.flWeightValue > stMaxItem.flWeightValue) stMaxItem = stItemData;	

		itemshareData.plotLock.lockForWrite();
#if (defined USE_MANUAL_LENS_BIN)	
		ROPLOW::fillMTFFALensBarChartDrawInfo(itemshareData.vecBarChartItem, stItemData, pstParameter, iImgWidth, iImgHeight);	
#else
		ROPLOW::fillMTFFABarChartDrawInfo(itemshareData.vecBarChartItem, stItemData, iImgWidth, iImgHeight, pstParameter->stMTFBasic.flGradeMultiple);
#endif
		itemshareData.dflBarChartYMin		=	0.0;
		itemshareData.dflBarChartYMax	=	1.0;
		itemshareData.plotLock.unlock();
		emit plotpainter(1);

		if(pstParameter->stMTFBasic.algswitch != 7)
			itemstatus.ucstatus	=	(stItemData.ucStatus | 0x80);
		updateItemstatus(itemstatus);

		if(uiOpMode == 1) break;

		while(classFATime.elapsed() < 195) Sleep(10);
		Sleep(5);
	}

	if(iresult){
		HisReleaseMalloc(pucBufRaw10);
		_CODE_AFC_MTF_EXIT1
	}
		if(!threadshareData.GetHisPreviewflag()){
			iresult	=	HisCCMError_NotPreivew;
			HisReleaseMalloc(pucBufRaw10);
			_CODE_AFC_MTF_EXIT1
		}

		iresult	=	(stItemData.ucStatus != 0)?(0):(HisCCMError_Result);

		if(uiOpMode != 1)
		{
			ROPLOW::saveMTFHAMFAResult(!iresult, stItemData, pstParameter, *classLog, iImgWidth, iImgHeight);
		}

		HisReleaseMalloc(pucBufRaw10);
		_CODE_AFC_MTF_EXIT1
}


int itemprocess::getmtfAFCCAParameter(unsigned char uctype, bool bupdate, bool bcheck)
{
	QString strItemName;
	_mtfAFCParameter* pstTheParamter;
	if(uctype == 1){
		strItemName	=	"afcmtfmiddle";
		itemshareData.itemparameterLock.lockForRead();
		if(!bupdate && itemshareData.mtfmiddleafcParameter) { itemshareData.itemparameterLock.unlock(); return 0; }

		itemshareData.itemparameterLock.unlock();
		itemshareData.itemparameterLock.lockForWrite();
		if(!itemshareData.mtfmiddleafcParameter)	itemshareData.mtfmiddleafcParameter		=	new _mtfAFCParameter;
		if(!itemshareData.mtfmiddleafcParameter) {	itemshareData.itemparameterLock.unlock(); return HisFX3Error_MallocBuffer; }
		pstTheParamter	=	itemshareData.mtfmiddleafcParameter;
	}
	else if(uctype == 2){
		strItemName	=	"afcmtffar";
		itemshareData.itemparameterLock.lockForRead();
		if(!bupdate && itemshareData.mtffarafcParameter) { itemshareData.itemparameterLock.unlock(); return 0; }

		itemshareData.itemparameterLock.unlock();
		itemshareData.itemparameterLock.lockForWrite();
		if(!itemshareData.mtffarafcParameter)	itemshareData.mtffarafcParameter		=	new _mtfAFCParameter;
		if(!itemshareData.mtffarafcParameter) {	itemshareData.itemparameterLock.unlock(); return HisFX3Error_MallocBuffer; }
		pstTheParamter	=	itemshareData.mtffarafcParameter;
	}
	else{
		strItemName	=	"afcmtfnear";
		itemshareData.itemparameterLock.lockForRead();
		if(!bupdate && itemshareData.mtfnearafcParameter) { itemshareData.itemparameterLock.unlock(); return 0; }

		itemshareData.itemparameterLock.unlock();
		itemshareData.itemparameterLock.lockForWrite();
		if(!itemshareData.mtfnearafcParameter)		itemshareData.mtfnearafcParameter		=	new _mtfAFCParameter;
		if(!itemshareData.mtfnearafcParameter) {	itemshareData.itemparameterLock.unlock(); return HisFX3Error_MallocBuffer; }
		pstTheParamter	=	itemshareData.mtfnearafcParameter;
	}

	pstTheParamter->vectorMTFItem.clear();
	QMutexLocker locker(&hisglobalparameter.mutexDatabase);

	bool bparsesuccess	=	true, bItemExist = false;

	//读取，解析config
	for(int  w=0;	w<1;	++w){ //此处是有意义的,不要删除
		QSqlDatabase customdb = QSqlDatabase::addDatabase("QSQLITE", "querycustom");
		customdb.setDatabaseName(QDir::currentPath() % "/HisFX3Custom");
		if (!customdb.open()){
			bparsesuccess	=	false;
			break;
		}

		QString strData, strdata2;
		QStringList strname, strvalue;
		QSqlQuery query(customdb);
		query.prepare("SELECT itemsuffix2,key,value,reserve FROM " % itemshareData.currentTableName % \
			" WHERE classfy='algorithm' AND item='" % strItemName % "' AND itemsuffix1='basic' ORDER BY id ASC" );
		query.exec();

		/************basic**************/
		//(algswitch:0)(roiw:y)(roih:100)(centerspec:0.5)(centerweight:1.0)(autoseartch:true)
		while (query.next()){
			bItemExist = true;
			for(int y=0;	y<4;	++y){
				strData	=	query.value(y).toString();
				ROPLOW::patchconfigstring(strData, strname, strvalue);
				for(int x=0;	x<strname.size();	++x){
					if(strname.at(x) == "algswitch")	pstTheParamter->stMTFBasic.algswitch	=	strvalue.at(x).toInt();
					else if(strname.at(x) == "roiw")	pstTheParamter->stMTFBasic.iblockwith	=	strvalue.at(x).toInt();
					else if(strname.at(x) == "roih")	pstTheParamter->stMTFBasic.iblockheight	=	strvalue.at(x).toInt();
					else if(strname.at(x) == "centerspec")	pstTheParamter->stMTFBasic.flcenterspec	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "centerspec_h")	pstTheParamter->stMTFBasic.flHcenterspec	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "centerspec_v")	pstTheParamter->stMTFBasic.flVcenterspec	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "grade_b")	pstTheParamter->stMTFBasic.flCenterGradeB	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "centerweight")	pstTheParamter->stMTFBasic.flcenterweight	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "autoseartch") pstTheParamter->stMTFBasic.bAutoSeartchROI = (strvalue.at(x) == "true");
				}
			}
		}

		_HisCCMAlg_MTFItem_Info stcircleitem;
		query.prepare("SELECT itemsuffix2,key,value,reserve FROM " % itemshareData.currentTableName % \
			" WHERE classfy='algorithm' AND item='" % strItemName % "' AND itemsuffix1='fovitem' ORDER BY id ASC" );
		query.exec();
		/************fovitem**************/
		//(blockcount:4)(fov:0.5)(angle:0)(weight:1.0)
		//(spec:0.5)(specuniform:0.5)
		while (query.next()){
			bItemExist = true;
			for(int y=0;	y<4;	++y){
				strData	=	query.value(y).toString();
				ROPLOW::patchconfigstring(strData, strname, strvalue);
				for(int x=0;	x<strname.size();	++x){
					if(strname.at(x) == "blockcount")	 stcircleitem.ucBlockCount	=	strvalue.at(x).toInt();
					else if(strname.at(x) == "fov")	 stcircleitem.flFOV	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "weight")	 stcircleitem.flWeight	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "angle")	 stcircleitem.flAngle		=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "spec")	 stcircleitem.flSpec		=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "spec_h")	 stcircleitem.flHSpec		=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "spec_v")	 stcircleitem.flVSpec		=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "grade_b")	 stcircleitem.flGradeB			=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "specuniform")	 stcircleitem.flSpecUniform		=	strvalue.at(x).toFloat();
				}
			}

			pstTheParamter->vectorMTFItem.push_back(stcircleitem);	
		}

		query.prepare("SELECT itemsuffix2,key,value,reserve FROM " % itemshareData.currentTableName % \
			" WHERE classfy='algorithm' AND item='" % strItemName % "' AND itemsuffix1='statics' ORDER BY id ASC" );
		query.exec();
		/************statics**************/
		//(tactics:0)(usedb:true)(maxstep:10)(stepdelay:500)(valuechoose:0)(valuetype:0)
		//(motorstart:0)(motorend:1023)(motormin:0)(motormax:1023)(bigstep:20)(middlestep:10)(smallstep:5)
		//(curvedef:0.2)(falloffdef:0.1)(linearback:true)(teststartmotor:true)(startmotordef:0.05)(startmotormin:0)(startmotormax:1023)
		while (query.next()){
			bItemExist = true;
			for(int y=0;	y<4;	++y){
				strData	=	query.value(y).toString();
				ROPLOW::patchconfigstring(strData, strname, strvalue);
				for(int x=0;	x<strname.size();	++x){
					if(strname.at(x) == "tactics")	 pstTheParamter->stTacticsBasic.ucTactics	=	strvalue.at(x).toInt();
					else if(strname.at(x) == "maxstep")	 pstTheParamter->stTacticsBasic.usMaxSteps	=	strvalue.at(x).toInt();
					else if(strname.at(x) == "stepdelay")	 pstTheParamter->stTacticsBasic.usStepDelay	=	strvalue.at(x).toInt();
					else if(strname.at(x) == "valuechoose")	 pstTheParamter->stTacticsBasic.ucValueChoose	=	strvalue.at(x).toInt();
					else if(strname.at(x) == "valuetype")	 pstTheParamter->stTacticsBasic.ucValueTypeChoose	=	strvalue.at(x).toInt();
					else if(strname.at(x) == "motorstart")	 pstTheParamter->stTacticsBasic.sMotorStart	=	strvalue.at(x).toInt();
					else if(strname.at(x) == "motorend")	 pstTheParamter->stTacticsBasic.sMotorEnd	=	strvalue.at(x).toInt();
					else if(strname.at(x) == "motormin")	 pstTheParamter->stTacticsBasic.sMotorSpecMin	=	strvalue.at(x).toInt();
					else if(strname.at(x) == "motormax")	 pstTheParamter->stTacticsBasic.sMotorSpecMax	=	strvalue.at(x).toInt();
					else if(strname.at(x) == "bigstep")	 pstTheParamter->stTacticsBasic.ucBigStep	=	strvalue.at(x).toInt();
					else if(strname.at(x) == "middlestep")	 pstTheParamter->stTacticsBasic.ucMiddleStep	=	strvalue.at(x).toInt();
					else if(strname.at(x) == "smallstep")	 pstTheParamter->stTacticsBasic.ucSmallStep	=	strvalue.at(x).toInt();
					else if(strname.at(x) == "curvedef")	 pstTheParamter->stTacticsBasic.flCurveValidDef	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "falloffdef")	 pstTheParamter->stTacticsBasic.flCurveFalloffDef	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "usedb") pstTheParamter->stTacticsBasic.bDataBase = (strvalue.at(x) == "true");
					else if(strname.at(x) == "fitting") pstTheParamter->stTacticsBasic.bCurveFitting = (strvalue.at(x) == "true");
					else if(strname.at(x) == "linearback") pstTheParamter->stTacticsBasic.bLinearBack = (strvalue.at(x) == "true");
					else if(strname.at(x) == "teststartmotor") pstTheParamter->stTacticsBasic.bTestStartMotor = (strvalue.at(x) == "true");
					else if(strname.at(x) == "startmotordef")	 pstTheParamter->stTacticsBasic.flStartMotorDevDef	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "startmotormin")	 pstTheParamter->stTacticsBasic.sStartMotorMin	=	strvalue.at(x).toInt();
					else if(strname.at(x) == "startmotormax")	 pstTheParamter->stTacticsBasic.sStartMotorMax	=	strvalue.at(x).toInt();
				}
			}
		}

		customdb.close();
	}

	QSqlDatabase::removeDatabase("querycustom");
	if(!bparsesuccess || !bItemExist){
		if(uctype == 0) {HisReleaseNewO(itemshareData.mtfnearafcParameter);}
		else if(uctype == 1) {HisReleaseNewO(itemshareData.mtfmiddleafcParameter);}
		else {HisReleaseNewO(itemshareData.mtffarafcParameter);}
		itemshareData.itemparameterLock.unlock();
		return HisFX3Error_Parameter;
	}

	if(!bcheck) {itemshareData.itemparameterLock.unlock(); return 0; }

	if(pstTheParamter->stTacticsBasic.ucTactics == _HisCCMAlg_Rolongo_AFC_Tactics_Linear || \
		pstTheParamter->stTacticsBasic.ucTactics == _HisCCMAlg_Rolongo_AFC_Tactics_Single)
		pstTheParamter->stTacticsBasic.bDataBase=	false;

	pstTheParamter->stMTFBasic.iblockwith		=	((pstTheParamter->stMTFBasic.iblockwith >> 2) <<2);
	pstTheParamter->stMTFBasic.iblockheight	=	((pstTheParamter->stMTFBasic.iblockheight >> 2) <<2);

	std::sort(pstTheParamter->vectorMTFItem.begin(), pstTheParamter->vectorMTFItem.end(), sort_mtfitem_fov);

	RECT* pstBlock = NULL;
	if(ROPLOW::GetMTFCABlock(itemshareData.previewParameter->iWidth, itemshareData.previewParameter->iHeight, \
		pstTheParamter->stMTFBasic, pstTheParamter->vectorMTFItem, &pstBlock)){
			if(uctype == 0) {HisReleaseNewO(itemshareData.mtfnearafcParameter);}
			else if(uctype == 1) {HisReleaseNewO(itemshareData.mtfmiddleafcParameter);}
			else {HisReleaseNewO(itemshareData.mtffarafcParameter);}
			HisReleaseNewB(pstBlock);
			itemshareData.itemparameterLock.unlock();
			emit information(tr("Error: The MTF position exceed image zone."));
			return HisFX3Error_Parameter;
	}
	HisReleaseNewB(pstBlock);

	pstTheParamter->stMTFBasic.flGradeMultiple	=	1.0f;
	itemshareData.itemparameterLock.unlock();
	return 0;
}

int itemprocess::mtfAFCCA(unsigned char uctype, int iNewStactics, int& iOldStatics)
{
	_CODE_CLEAR_IMAGEDRAW
		QqrealList list=QqrealList()<<1<<2<<3;
		emit sig_test(list);
		if(!threadshareData.GetHisPreviewflag())	return HisCCMError_NotPreivew;

//***************** 2018.04.28 feng Add ************* 
#ifdef _DEBUG
		fnMTF_Q fnMTF=(fnMTF_Q)QLibrary::resolve("cvImageToold.dll","fnMTF");
		getMarkDistance_RGB24 funCalMarkDist=(getMarkDistance_RGB24)QLibrary::resolve("fqqImageToolD.dll","getMarkDistance_RGB24");
		polyfit funPolyfit=(polyfit)QLibrary::resolve("fqqImageToolD.dll","polyfit");
#else
		fnMTF_Q fnMTF=(fnMTF_Q)QLibrary::resolve("cvImageTool.dll","fnMTF");
		getMarkDistance_RGB24 funCalMarkDist=(getMarkDistance_RGB24)QLibrary::resolve("fqqImageTool.dll","getMarkDistance_RGB24");
		polyfit funPolyfit=(polyfit)QLibrary::resolve("fqqImageTool.dll","polyfit");
#endif

	/*if(!fnMTF){
		emit information(QString::fromLocal8Bit("!载入cvImageTool.dll失败，请检查是否存在"));
		return -1;
	}*/
	/*if(!funCalMarkDist){
		emit information(QString::fromLocal8Bit("!载入fqqImageTool.dll失败，请检查是否存在"));
		return -1;
	}*/

	//***************************************************** 


	bool bGetDB	=	false;
	if((uctype == 0 && itemshareData.mtfnearafcParameter == NULL) || \
		(uctype == 1 && itemshareData.mtfmiddleafcParameter == NULL) || \
		(uctype == 2 && itemshareData.mtffarafcParameter == NULL)) bGetDB = true;

	int iresult	=	getmtfAFCCAParameter(uctype, false);
	if(iresult)	return iresult;
	if(iresult = getccmhardwareParameter(false))	return iresult;

	unsigned char* pucBufRaw = NULL;
	_ShadingImageInfo ImgInfo;
	unsigned char* pucBufRaw10=NULL;
	RECT* pstBlock	=	NULL, *pstTemp = NULL;
	_HisCCMAlg_AFC_MTF_DB* pstAFCMTFDB;
	_mtfAFCParameter* pstParameter;
	if(uctype == 1)	{
		pstParameter	=	itemshareData.mtfmiddleafcParameter;
		pstAFCMTFDB	=	&stAFCMTFMiddleDB;
	}
	else if(uctype == 2) {
		pstParameter = itemshareData.mtffarafcParameter;
		pstAFCMTFDB	=	&stAFCMTFFarDB;
	}
	else {
		pstParameter	=	itemshareData.mtfnearafcParameter;
		pstAFCMTFDB	=	&stAFCMTFNearDB;
	}

	if(iNewStactics >= _HisCCMAlg_Rolongo_AFC_Tactics_PASS && iNewStactics <= _HisCCMAlg_Rolongo_AFC_Tactics_Inflexion){
		iOldStatics	=	pstParameter->stTacticsBasic.ucTactics;
		pstParameter->stTacticsBasic.ucTactics	=	iNewStactics;
	}

	if(bGetDB && pstParameter->stTacticsBasic.bDataBase){
		if(iresult = ROPLOW::AFCMTFHAFromDB(uctype, pstParameter, pstAFCMTFDB, bBoxChannel1)) return iresult;
	}

	itemshareData.itemparameterLock.lockForRead();

	if(iresult = ROPLOW::GetMTFCABlock(itemshareData.previewParameter->iWidth, itemshareData.previewParameter->iHeight, \
		pstParameter->stMTFBasic, pstParameter->vectorMTFItem, &pstBlock)){
			if(iresult == HisFX3Error_Parameter)
				emit information(QTextCodec::codecForName( "GBK")->toUnicode("选取的MTF ROI超出了图像区域"));
			_CODE_AFC_MTF_EXIT1
	}

	emit information("db item: " % QString::number(pstAFCMTFDB->vectorItem.size()));
	std::vector<_HisCCMAlg_AFC_MTF_DB_Item>::iterator iteratordb;
	int iMotorPosNow	=	pstParameter->stTacticsBasic.sMotorStart;
	if(pstParameter->stTacticsBasic.bDataBase && pstAFCMTFDB->vectorItem.size() > 0){
		iMotorPosNow	=	0;
		for(iteratordb = pstAFCMTFDB->vectorItem.begin(); iteratordb != pstAFCMTFDB->vectorItem.end(); iteratordb++){
			iMotorPosNow	+=	iteratordb->sMotorEnd;
		}
		iMotorPosNow	/=	pstAFCMTFDB->vectorItem.size();

		emit information("db motor: " % QString::number(iMotorPosNow));

		if(iresult = setMotor(itemshareData.ccmhardwareParameter->motortype.toAscii().data(), itemshareData.previewParameter->ucSlave, \
			itemshareData.ccmhardwareParameter->projectname.toAscii().data(), iMotorPosNow, globalFunPointer.ReadHisFX3IIC, globalFunPointer.WriteHisFX3IIC, globalFunPointer.SetHisFX3IICSpeed, globalFunPointer.PullHisFX3RESET, globalFunPointer.PullHisFX3PWND, \
			globalFunPointer.PageWriteHisFX3IIC, globalFunPointer.PageReadHisFX3IIC, globalFunPointer.HisFX3PageWriteSPI, globalFunPointer.HisFX3PageReadSPI)) _CODE_AFC_MTF_EXIT1
			::Sleep(pstParameter->stTacticsBasic.usStepDelay);
	}
	else if(pstParameter->stTacticsBasic.ucTactics != _HisCCMAlg_Rolongo_AFC_Tactics_Single){
		if(iresult = setMotor(itemshareData.ccmhardwareParameter->motortype.toAscii().data(), itemshareData.previewParameter->ucSlave, \
			itemshareData.ccmhardwareParameter->projectname.toAscii().data(), iMotorPosNow, globalFunPointer.ReadHisFX3IIC, globalFunPointer.WriteHisFX3IIC, globalFunPointer.SetHisFX3IICSpeed, globalFunPointer.PullHisFX3RESET, globalFunPointer.PullHisFX3PWND, \
			globalFunPointer.PageWriteHisFX3IIC, globalFunPointer.PageReadHisFX3IIC, globalFunPointer.HisFX3PageWriteSPI, globalFunPointer.HisFX3PageReadSPI)) _CODE_AFC_MTF_EXIT1
			::Sleep(pstParameter->stTacticsBasic.usStepDelay);
	}

	_HisFX3_BaylorMode emDataFormat =	itemshareData.previewParameter->ucDataFormat;
	int iImgWidth =	itemshareData.previewParameter->iWidth, iImgHeight =	itemshareData.previewParameter->iHeight;
	unsigned int uiRawImgSize		=	itemshareData.previewParameter->iWidth * itemshareData.previewParameter->iHeight *3;
	unsigned char ucFrameType		=	_FrameType_RGB24;
	unsigned int uiPixelSize	=	iImgWidth *iImgHeight;
	pucBufRaw		=	(unsigned char*)_aligned_malloc(uiRawImgSize, _HisCacheLine_Aligned);
	if(!pucBufRaw){
		HisReleaseMalloc(pucBufRaw);
		HisReleaseMalloc(pucBufRaw10);
		itemshareData.itemparameterLock.unlock();
		return HisFX3Error_MallocBuffer;
	}

	std::vector<_itemDraw> vectorDraw;
	vectorDraw.reserve(50);
	std::vector<_itemDraw>::iterator iteratorDraw;
	std::vector<_HisCCMAlg_AFC_MTF_DataItem> vectorItemData;
	vectorItemData.reserve(30);
	std::vector<_HisCCMAlg_AFC_MTF_DataItem>::iterator iteratorItemData;

	float flvalue, flmax, flmin,flHvalue,flVvalue;
	RECT stMTFAutoROI;

	_HisCCMAlg_AFC_Linear_Result stLinearResult;
	bool bNext;

	int index=0;

	double flMarkInfo[5]={0}; // Mark 点信息

	for(unsigned int uistepcount=0; uistepcount < pstParameter->stTacticsBasic.usMaxSteps && hisglobalparameter.getrunflag() && threadshareData.GetHisPreviewflag(); ++uistepcount)
	{
		if(iresult	=	GetFreshframe(pucBufRaw, uiRawImgSize, ucFrameType, !uistepcount)) break;

		if(pstParameter->stMTFBasic.algswitch != 7){
			
		}else{
			/*unsigned int uiRawImgSize_raw10	=itemshareData.previewParameter->iWidth * itemshareData.previewParameter->iHeight*2;
			unsigned char ucFrameType_raw10	=_FrameType_Raw10;
			pucBufRaw10		=	(unsigned char*)_aligned_malloc(uiRawImgSize_raw10, _HisCacheLine_Aligned);
			if(!pucBufRaw10){
				HisReleaseMalloc(pucBufRaw);
				HisReleaseMalloc(pucBufRaw10);
				itemshareData.itemparameterLock.unlock();
				return HisFX3Error_MallocBuffer;
			}
			
			if(iresult	=	GetFreshframe(pucBufRaw10,uiRawImgSize_raw10, ucFrameType_raw10, !uistepcount)) break;*/
		}
		

		ROPLOW::AFCMTFItemDataInitial(vectorItemData, pstParameter, iMotorPosNow);
		iteratorItemData	=	vectorItemData.end() - 1;

		vectorDraw.clear();
		bNext	=	true;

		pstTemp	=	pstBlock;
		stMTFAutoROI	=	*pstTemp;
		if(pstParameter->stMTFBasic.bAutoSeartchROI)
			classRolongoTest.CRolongoBlockAutomaticSearching(stMTFAutoROI, pucBufRaw, iImgWidth, iImgHeight, pstParameter->stMTFBasic.iblockwith *4, stMTFAutoROI);
		//stMTFAutoROI.left+=global_ioc_x;stMTFAutoROI.right+=global_ioc_x;// 加OC偏移
		//stMTFAutoROI.top+=global_ioc_y;stMTFAutoROI.bottom+=global_ioc_y;// 加OC偏移

		if(pstParameter->stMTFBasic.algswitch <= 4)
		{
			if(iresult	=	classAlgorithm.HisCCMMTF(pucBufRaw, iImgWidth, iImgHeight, stMTFAutoROI, pstParameter->stMTFBasic.algswitch, flvalue)) break;
		}else if(pstParameter->stMTFBasic.algswitch == 7){
			funCalMarkDist(pucBufRaw,NULL,flMarkInfo,iImgWidth,iImgHeight,15,15000,50000,400,1000,hisglobalparameter.bDebugMode);
			if(iresult	=	classRolongoTest.HisCCMMTF(pucBufRaw, iImgWidth, iImgHeight, stMTFAutoROI, pstParameter->stMTFBasic.algswitch, flHvalue,flVvalue)) break;
		}
		else
		{
			if(iresult	=	classRolongoTest.HisCCMMTF(pucBufRaw, iImgWidth, iImgHeight, stMTFAutoROI, pstParameter->stMTFBasic.algswitch, flvalue)) break;
		}

		_HisCCMAlg_AFC_MTF_DataItem_EX stItemData_EX; //************** 2018.04.11 Add
		stItemData_EX.vectorFOV.resize(pstParameter->vectorMTFItem.size());

		iteratorItemData->stCenterBlock	=	stMTFAutoROI;
		stItemData_EX.stCenterBlock=stMTFAutoROI;

		if(pstParameter->stMTFBasic.algswitch != 7){
			iteratorItemData->flCenterValue		=	flvalue;
		}else{
			iteratorItemData->flCenterValue		=	(flHvalue+flVvalue)/2;
			stItemData_EX.flCenterValue=(flHvalue+flVvalue)/2;
			stItemData_EX.flHCenterValue=flHvalue;
			stItemData_EX.flVCenterValue=flVvalue;
		}


		pstTemp++;

		for(unsigned int y=0;	y<pstParameter->vectorMTFItem.size(); ++y){
			flmax	=	-99999.0f; flmin	=	99999.0f;
			for(unsigned int x=0;	x<pstParameter->vectorMTFItem.at(y).ucBlockCount; ++x){
				stMTFAutoROI	=	*pstTemp;
				if(pstParameter->stMTFBasic.bAutoSeartchROI)
					classRolongoTest.CRolongoBlockAutomaticSearching(stMTFAutoROI, pucBufRaw, iImgWidth, iImgHeight, pstParameter->stMTFBasic.iblockwith *4, stMTFAutoROI);
					stMTFAutoROI.left+=global_ioc_x;stMTFAutoROI.right+=global_ioc_x;// 加OC偏移
					stMTFAutoROI.top+=global_ioc_y;stMTFAutoROI.bottom+=global_ioc_y;// 加OC偏移
					
				if(pstParameter->stMTFBasic.algswitch <= 4)
				{
					if(iresult	=	classAlgorithm.HisCCMMTF(pucBufRaw, iImgWidth, iImgHeight, stMTFAutoROI, pstParameter->stMTFBasic.algswitch, flvalue)) break;
				}else if(pstParameter->stMTFBasic.algswitch == 7){

					if(iresult	=	classRolongoTest.HisCCMMTF(pucBufRaw, iImgWidth, iImgHeight, stMTFAutoROI, pstParameter->stMTFBasic.algswitch, flHvalue,flVvalue)) break;
				}
				else
				{
					if(iresult	=	classRolongoTest.HisCCMMTF(pucBufRaw, iImgWidth, iImgHeight, stMTFAutoROI, pstParameter->stMTFBasic.algswitch, flvalue)) break;
				}

				if(pstParameter->stMTFBasic.algswitch != 7){
					iteratorItemData->vectorFOV.at(y).flValue[x]		=	flvalue;
				}else{
					iteratorItemData->vectorFOV.at(y).flValue[x]		=	(flHvalue+flVvalue)/2;
					stItemData_EX.vectorFOV.at(y).flValue[x]=(flHvalue+flVvalue)/2;
					stItemData_EX.vectorFOV.at(y).flHValue[x]=flHvalue;
					stItemData_EX.vectorFOV.at(y).flVValue[x]=flVvalue;
				}

				iteratorItemData->vectorFOV.at(y).stBlock[x]	=	stMTFAutoROI;
				stItemData_EX.vectorFOV.at(y).stBlock[x]=stMTFAutoROI;
				pstTemp++;
				flmax	=	max(flmax, flvalue);
				flmin		=	min(flmin, flvalue);
			}
			if(iresult) break;
			iteratorItemData->vectorFOV.at(y).flUniformValue	=	flmax - flmin;
		}

		if(iresult) break;

		if(pstParameter->stMTFBasic.algswitch != 7){
			ROPLOW::AddDrawMTFHA(*iteratorItemData, iImgWidth, iImgHeight, vectorDraw, pstParameter->stMTFBasic.flGradeMultiple);
		}else{
			ROPLOW::AddDrawMTFHE(stItemData_EX, iImgWidth, iImgHeight, vectorDraw,*pstParameter,pstParameter->stMTFBasic.flGradeMultiple);
		}


		//************ 2018.04.11 判断 ************** 
		if(pstParameter->stTacticsBasic.ucTactics == _HisCCMAlg_Rolongo_AFC_Tactics_Single&&pstParameter->stMTFBasic.algswitch == 7){
			//Center
			if(stItemData_EX.flHCenterValue<pstParameter->stMTFBasic.flHcenterspec||stItemData_EX.flVCenterValue<pstParameter->stMTFBasic.flVcenterspec\
				||stItemData_EX.flCenterValue<pstParameter->stMTFBasic.flcenterspec){
				iresult=-1;
			}

			for (int i=0;i<pstParameter->vectorMTFItem.size();i++)
			{
				for (int y=0;y<pstParameter->vectorMTFItem.at(i).ucBlockCount;y++)
				{
					if(stItemData_EX.vectorFOV.at(i).flHValue[y] < pstParameter->vectorMTFItem.at(i).flHSpec||stItemData_EX.vectorFOV.at(i).flVValue[y] < pstParameter->vectorMTFItem.at(i).flVSpec\
						||stItemData_EX.vectorFOV.at(i).flValue[y] < pstParameter->vectorMTFItem.at(i).flSpec){
						iresult=-1;
					}
				}
			}

			_CODE_RJAFA_LP_ASIGNDRAW

			
				/*FILE *pfile;
				fopen_s(&pfile,"AFC_FAR_MTF.csv","rb+");
				if(!pfile){
				fopen_s(&pfile,"AFC_FAR_MTF.csv","w+");
				fprintf(pfile,"S/N,Center_H,Center_V,F0.3_LT_H,F0.3_LT_V,F0.3_RT_H,F0.3_RT_V,F0.3_RB_H,F0.3_RB_V,F0.3_LB_H,F0.3_LB_V,\
							  F0.4_R_H,F0.4_R_V,F0.4_L_H,F0.4_L_V,F0.7_LT_H,F0.7_LT_V,F0.7_RT_H,F0.7_RT_V,F0.7_RB_H,F0.7_RB_V,F0.7_LB_H,F0.7_LB_V,Distance,area1,area2,length1,length2,\n");
				}else{
					fseek(pfile,0,SEEK_END);
				}

				QString strSerialNumber;
				classLog->getserialnumber(strSerialNumber);

				fprintf(pfile,"%s,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f\n",strSerialNumber.toLatin1().data(),stItemData_EX.flHCenterValue,stItemData_EX.flVCenterValue,\
					stItemData_EX.vectorFOV.at(0).flHValue[0],stItemData_EX.vectorFOV.at(0).flVValue[0],\
					stItemData_EX.vectorFOV.at(0).flHValue[1],stItemData_EX.vectorFOV.at(0).flVValue[1],\
					stItemData_EX.vectorFOV.at(0).flHValue[2],stItemData_EX.vectorFOV.at(0).flVValue[2],\
					stItemData_EX.vectorFOV.at(0).flHValue[3],stItemData_EX.vectorFOV.at(0).flVValue[3],\
					stItemData_EX.vectorFOV.at(1).flHValue[0],stItemData_EX.vectorFOV.at(1).flVValue[0],\
					stItemData_EX.vectorFOV.at(1).flHValue[1],stItemData_EX.vectorFOV.at(1).flVValue[1],\
					stItemData_EX.vectorFOV.at(2).flHValue[0],stItemData_EX.vectorFOV.at(2).flVValue[0],\
					stItemData_EX.vectorFOV.at(2).flHValue[1],stItemData_EX.vectorFOV.at(2).flVValue[1],\
					stItemData_EX.vectorFOV.at(2).flHValue[2],stItemData_EX.vectorFOV.at(2).flVValue[2],\
					stItemData_EX.vectorFOV.at(2).flHValue[3],stItemData_EX.vectorFOV.at(2).flVValue[3],\
					flMarkInfo[0],flMarkInfo[1],flMarkInfo[2],flMarkInfo[3],flMarkInfo[4]
				);

				fclose(pfile);*/
				
				_CODE_AFC_MTF_EXIT1

		}else{
			iresult = classAlgorithm.HisAFCTactics_MTFHA_DB_HA(pstParameter->stTacticsBasic, vectorItemData, *pstAFCMTFDB, iMotorPosNow);
		}


		//*******************************************




		//******************  2018/01/09 ok2 Code ********************
		/*if(iresult){
		vectorItemData.at(0).flCenterSpec=vectorItemData.at(0).flCenterGradeB;
		for (int i=0;i<vectorItemData.at(0).vectorFOV.size();i++)
		{
		vectorItemData.at(0).vectorFOV.at(i).flSpec=vectorItemData.at(0).vectorFOV.at(i).flGradeB;
		}

		iresult=classAlgorithm.HisAFCTactics_MTFHA_DB_HA(pstParameter->stTacticsBasic, vectorItemData, *pstAFCMTFDB, iMotorPosNow);
		if(!iresult){
		vectorDraw.clear();
		ROPLOW::AddDrawMTFHA(*iteratorItemData, iImgWidth, iImgHeight, vectorDraw, pstParameter->stMTFBasic.flGradeMultiple);

		itemshareData.bOK2=true;

		iresult=0;
		}
		}else{
		break;
		}*/
		_CODE_RJAFA_LP_ASIGNDRAW
			if(iresult)	break;//
		emit information("next motor: " % QString::number(iMotorPosNow));

		if(iMotorPosNow == 0x00FFFFFF){
			iresult	=	0;//
			break;
		}

		if(iresult = setMotor(itemshareData.ccmhardwareParameter->motortype.toAscii().data(), itemshareData.previewParameter->ucSlave, \
			itemshareData.ccmhardwareParameter->projectname.toAscii().data(), iMotorPosNow, globalFunPointer.ReadHisFX3IIC, globalFunPointer.WriteHisFX3IIC, globalFunPointer.SetHisFX3IICSpeed, globalFunPointer.PullHisFX3RESET, globalFunPointer.PullHisFX3PWND, \
			globalFunPointer.PageWriteHisFX3IIC, globalFunPointer.PageReadHisFX3IIC, globalFunPointer.HisFX3PageWriteSPI, globalFunPointer.HisFX3PageReadSPI)) break;
		::Sleep(pstParameter->stTacticsBasic.usStepDelay);

		if(pstParameter->stTacticsBasic.ucTactics == _HisCCMAlg_Rolongo_AFC_Tactics_Single || \
			pstParameter->stTacticsBasic.ucTactics == _HisCCMAlg_Rolongo_AFC_Tactics_PASS){
				itemshareData.plotLock.lockForWrite();
				ROPLOW::fillMTFFABarChartDrawInfo(itemshareData.vecBarChartItem, *(vectorItemData.end()-1), \
					iImgWidth, iImgHeight, pstParameter->stMTFBasic.flGradeMultiple);
				itemshareData.dflBarChartYMin		=	0.0;
				itemshareData.dflBarChartYMax	=	1.0;
				itemshareData.plotLock.unlock();
				emit plotpainter(1);
		}
		else if(pstParameter->stTacticsBasic.ucTactics == _HisCCMAlg_Rolongo_AFC_Tactics_Linear){
			itemshareData.plotLock.lockForWrite();
			ROPLOW::curveMTFAFCCurveDraw(itemshareData.vecCurvePoint, itemshareData.vecCurveLineColor, itemshareData.vecCurveLegend, \
				vectorItemData, iImgWidth, iImgHeight);
			itemshareData.dflCurveYMin		=	0.0;
			itemshareData.dflCurveYMax		=	1.0;
			itemshareData.dflCurveXMin		=	pstParameter->stTacticsBasic.sMotorStart;
			itemshareData.dflCurveXMax		=	pstParameter->stTacticsBasic.sMotorEnd;
			itemshareData.bCurveXScaleAuto	=	false;
			itemshareData.ucCurveType			=	2;
			itemshareData.plotLock.unlock();
			emit plotpainter(2);
		}
		else{
			itemshareData.plotLock.lockForWrite();
			ROPLOW::curveMTFAFCCurveDraw(itemshareData.vecCurvePoint, itemshareData.vecCurveLineColor, itemshareData.vecCurveLegend, \
				vectorItemData, iImgWidth, iImgHeight);
			itemshareData.dflCurveYMin		=	0.0;
			itemshareData.dflCurveYMax		=	1.0;
			itemshareData.dflCurveXMin		=	pstParameter->stTacticsBasic.sMotorStart;
			itemshareData.dflCurveXMax		=	pstParameter->stTacticsBasic.sMotorEnd;
			itemshareData.bCurveXScaleAuto	=	false;
			itemshareData.ucCurveType			=	1;
			itemshareData.plotLock.unlock();
			emit plotpainter(2);
		}
	}
	/***************************************
	For end
	****************************************/  

	//********** 线性 *****************
	if(vectorItemData.size()>2){
		emit information(QString::fromLocal8Bit("开始检测线性。。。"));
		FILE *pfile;
		fopen_s(&pfile,"LineDebug.csv","wb+");
		fprintf(pfile,"step1,step2,mtf1,mtf2,dist\n");
		double dflMaxDist=0;
		for (int i=1;i<vectorItemData.size()-2;i++)
		{
			double xdist=(double)abs(vectorItemData.at(i).sMotorStep-vectorItemData.at(i+1).sMotorStep);
			double ydist=(double)abs(vectorItemData.at(i).flCenterValue-vectorItemData.at(i+1).flCenterValue);
			double dflDist=ydist/xdist;

			fprintf(pfile,"%d,%d,%f,%f,%f\n",vectorItemData.at(i).sMotorStep,vectorItemData.at(i+1).sMotorStep,\
				vectorItemData.at(i).flCenterValue,vectorItemData.at(i+1).flCenterValue,dflDist);

			if(vectorItemData.at(i).flCenterValue<vectorItemData.at(i-1).flCenterValue&&vectorItemData.at(i).flCenterValue<vectorItemData.at(i+1).flCenterValue){
				float fMaxMTF=vectorItemData.at(i-1).flCenterValue>vectorItemData.at(i+1).flCenterValue?vectorItemData.at(i-1).flCenterValue:vectorItemData.at(i+1).flCenterValue;
				emit information(QString::fromLocal8Bit("凹点高度差:")+QString::number(fMaxMTF-vectorItemData.at(i).flCenterValue));

				if(fMaxMTF-vectorItemData.at(i).flCenterValue>dflDist>vectorItemData.at(0).flCenterGradeB){
					emit information(QString::fromLocal8Bit("线性规格超标:")+QString::number(dflMaxDist));
					fclose(pfile);
					iresult=-1;
					_CODE_RJAFA_LP_ASIGNDRAW
						HisReleaseMalloc(pucBufRaw);
					_CODE_AFC_MTF_EXIT1
				}

			}

			if(0&&dflDist>vectorItemData.at(0).flCenterGradeB&&ydist>vectorItemData.at(0).flCenterWeight){
				emit information(QString::fromLocal8Bit("线性规格超标:")+QString::number(dflMaxDist));

				fclose(pfile);
				iresult=-1;
				_CODE_RJAFA_LP_ASIGNDRAW
					HisReleaseMalloc(pucBufRaw);
				_CODE_AFC_MTF_EXIT1
			}

			if(dflDist>dflMaxDist){
				dflMaxDist=dflDist;
			}
		}
		fclose(pfile);
	
	}
	//******************************************************


	if(pstParameter->stTacticsBasic.ucTactics == _HisCCMAlg_Rolongo_AFC_Tactics_Single || \
		pstParameter->stTacticsBasic.ucTactics == _HisCCMAlg_Rolongo_AFC_Tactics_PASS){
			itemshareData.plotLock.lockForWrite();
			ROPLOW::fillMTFFABarChartDrawInfo(itemshareData.vecBarChartItem, *(vectorItemData.end()-1), iImgWidth, \
				iImgHeight, pstParameter->stMTFBasic.flGradeMultiple);
			itemshareData.dflBarChartYMin		=	0.0;
			itemshareData.dflBarChartYMax	=	1.0;
			itemshareData.plotLock.unlock();
			emit plotpainter(1);
	}
	else if(pstParameter->stTacticsBasic.ucTactics == _HisCCMAlg_Rolongo_AFC_Tactics_Linear){
		itemshareData.plotLock.lockForWrite();
		ROPLOW::curveMTFAFCCurveDraw(itemshareData.vecCurvePoint, itemshareData.vecCurveLineColor, itemshareData.vecCurveLegend, \
			vectorItemData, iImgWidth, iImgHeight);
		itemshareData.dflCurveYMin		=	0.0;
		itemshareData.dflCurveYMax	=	1.0;
		itemshareData.dflCurveXMin		=	pstParameter->stTacticsBasic.sMotorStart;
		itemshareData.dflCurveXMax		=	pstParameter->stTacticsBasic.sMotorEnd;
		itemshareData.bCurveXScaleAuto	=	false;
		itemshareData.ucCurveType			=	2;
		itemshareData.plotLock.unlock();
		emit plotpainter(2);
	}
	else{
		itemshareData.plotLock.lockForWrite();
		ROPLOW::curveMTFAFCCurveDraw(itemshareData.vecCurvePoint, itemshareData.vecCurveLineColor, itemshareData.vecCurveLegend, \
			vectorItemData, iImgWidth, iImgHeight);
		itemshareData.dflCurveYMin		=	0.0;
		itemshareData.dflCurveYMax	=	1.0;
		itemshareData.dflCurveXMin		=	pstParameter->stTacticsBasic.sMotorStart;
		itemshareData.dflCurveXMax		=	pstParameter->stTacticsBasic.sMotorEnd;
		itemshareData.bCurveXScaleAuto	=	false;
		itemshareData.ucCurveType			=	1;
		itemshareData.plotLock.unlock();
		emit plotpainter(2);
	}

	//曲线拟合
	/*
	if (pstParameter->stTacticsBasic.bCurveFitting && \
	(pstParameter->stTacticsBasic.ucTactics == _HisCCMAlg_Rolongo_AFC_Tactics_PEAK || pstParameter->stTacticsBasic.ucTactics == _HisCCMAlg_Rolongo_AFC_Tactics_Inflexion))
	{
	float peak;

	if (peak > 30000.0f){
	emit information("curve fitting return error!!!");
	return HisFX3Error_Other;
	}

	iMotorPosNow = peak + 0.5f;
	if(iresult = setMotor(itemshareData.ccmhardwareParameter->motortype.toAscii().data(), itemshareData.previewParameter->ucSlave, \
	itemshareData.ccmhardwareParameter->projectname.toAscii().data(), iMotorPosNow, globalFunPointer.ReadHisFX3IIC, globalFunPointer.WriteHisFX3IIC, globalFunPointer.SetHisFX3IICSpeed, globalFunPointer.PullHisFX3RESET, globalFunPointer.PullHisFX3PWND, \
	globalFunPointer.PageWriteHisFX3IIC, globalFunPointer.PageReadHisFX3IIC, globalFunPointer.HisFX3PageWriteSPI, globalFunPointer.HisFX3PageReadSPI)) return iresult;
	::Sleep(pstParameter->stTacticsBasic.usStepDelay);
	}
	*/

	unsigned int uiSaveIndex	=	0xFFFFFFFF;
	float flMaxWeightValue	=	-10.0f;
	bool bTempResult	=	false;
	for(unsigned int x=0;	x<vectorItemData.size(); ++x){
		if(vectorItemData.at(x).ucFlag == 0x1){
			uiSaveIndex	=	x;
			break;
		}
		else if(bTempResult){
			if(vectorItemData.at(x).ucStatus == 0x1 && vectorItemData.at(x).flWeightValue > flMaxWeightValue){
				flMaxWeightValue	=	vectorItemData.at(x).flWeightValue;
				uiSaveIndex				=	x;
			}
		}
		else{
			if(vectorItemData.at(x).ucStatus == 0x1 || vectorItemData.at(x).flWeightValue > flMaxWeightValue){
				flMaxWeightValue	=	vectorItemData.at(x).flWeightValue;
				uiSaveIndex				=	x;
				bTempResult			=	(vectorItemData.at(x).ucStatus == 0x1);
			}
		}
	}
	if(vectorItemData.at(uiSaveIndex).ucStatus == 0x0)
	{
		iresult	=	HisCCMError_NoFocusStep;//
	}



 	if(uiSaveIndex != 0xFFFFFFFF && uiSaveIndex != vectorItemData.size() - 1){
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("马达运动到最优点:") % QString::number(vectorItemData.at(uiSaveIndex).sMotorStep));
		int iresult2 = iresult;
		if(iresult = setMotor(itemshareData.ccmhardwareParameter->motortype.toAscii().data(), itemshareData.previewParameter->ucSlave, \
			itemshareData.ccmhardwareParameter->projectname.toAscii().data(), vectorItemData.at(uiSaveIndex).sMotorStep, globalFunPointer.ReadHisFX3IIC, globalFunPointer.WriteHisFX3IIC, globalFunPointer.SetHisFX3IICSpeed, globalFunPointer.PullHisFX3RESET, globalFunPointer.PullHisFX3PWND, \
			globalFunPointer.PageWriteHisFX3IIC, globalFunPointer.PageReadHisFX3IIC, globalFunPointer.HisFX3PageWriteSPI, globalFunPointer.HisFX3PageReadSPI)) 
			_CODE_AFC_MTF_EXIT1
			iresult = iresult2;

		vectorDraw.clear();
		ROPLOW::AddDrawMTFHA(vectorItemData.at(uiSaveIndex), iImgWidth, iImgHeight, vectorDraw, pstParameter->stMTFBasic.flGradeMultiple);
		
		/*{  
			
			//Peak 点重新测试
			Sleep(400);
			if(iresult	=	GetFreshframe(pucBufRaw, uiRawImgSize, ucFrameType, false)) return iresult;
#if 1
			ROPLOW::AFCMTFItemDataInitial(vectorItemData, pstParameter, iMotorPosNow);
			iteratorItemData	=	vectorItemData.end()-1;

			

		vectorDraw.clear();
		bNext	=	true;

		pstTemp	=	pstBlock;
		stMTFAutoROI	=	*pstTemp;
		if(pstParameter->stMTFBasic.bAutoSeartchROI)
			classRolongoTest.CRolongoBlockAutomaticSearching(stMTFAutoROI, pucBufRaw, iImgWidth, iImgHeight, pstParameter->stMTFBasic.iblockwith *4, stMTFAutoROI);
		stMTFAutoROI.left+=global_ioc_x;stMTFAutoROI.right+=global_ioc_x;// 加OC偏移
		stMTFAutoROI.top+=global_ioc_y;stMTFAutoROI.bottom+=global_ioc_y;// 加OC偏移

		if(pstParameter->stMTFBasic.algswitch <= 4)
		{
			if(iresult	=	classAlgorithm.HisCCMMTF(pucBufRaw, iImgWidth, iImgHeight, stMTFAutoROI, pstParameter->stMTFBasic.algswitch, flvalue)) _CODE_AFC_MTF_EXIT1;
		}else if(pstParameter->stMTFBasic.algswitch == 7){
			if(iresult	=	classRolongoTest.HisCCMMTF(pucBufRaw, iImgWidth, iImgHeight, stMTFAutoROI, pstParameter->stMTFBasic.algswitch, flHvalue,flVvalue)) _CODE_AFC_MTF_EXIT1;
		}
		else
		{
			if(iresult	=	classRolongoTest.HisCCMMTF(pucBufRaw, iImgWidth, iImgHeight, stMTFAutoROI, pstParameter->stMTFBasic.algswitch, flvalue)) _CODE_AFC_MTF_EXIT1;
		}

		_HisCCMAlg_AFC_MTF_DataItem_EX stItemData_EX; //************** 2018.04.11 Add
		stItemData_EX.vectorFOV.resize(pstParameter->vectorMTFItem.size());

		iteratorItemData->stCenterBlock	=	stMTFAutoROI;
		stItemData_EX.stCenterBlock=stMTFAutoROI;

		if(pstParameter->stMTFBasic.algswitch != 7){
			iteratorItemData->flCenterValue		=	flvalue;
		}else{
			iteratorItemData->flCenterValue		=	(flHvalue+flVvalue)/2;
			stItemData_EX.flCenterValue=(flHvalue+flVvalue)/2;
			stItemData_EX.flHCenterValue=flHvalue;
			stItemData_EX.flVCenterValue=flVvalue;
		}


		pstTemp++;

		for(unsigned int y=0;	y<pstParameter->vectorMTFItem.size(); ++y){
			flmax	=	-99999.0f; flmin	=	99999.0f;
			for(unsigned int x=0;	x<pstParameter->vectorMTFItem.at(y).ucBlockCount; ++x){
				stMTFAutoROI	=	*pstTemp;
				if(pstParameter->stMTFBasic.bAutoSeartchROI)
					classRolongoTest.CRolongoBlockAutomaticSearching(stMTFAutoROI, pucBufRaw, iImgWidth, iImgHeight, pstParameter->stMTFBasic.iblockwith *4, stMTFAutoROI);
					stMTFAutoROI.left+=global_ioc_x;stMTFAutoROI.right+=global_ioc_x;// 加OC偏移
					stMTFAutoROI.top+=global_ioc_y;stMTFAutoROI.bottom+=global_ioc_y;// 加OC偏移
					
				if(pstParameter->stMTFBasic.algswitch <= 4)
				{
					if(iresult	=	classAlgorithm.HisCCMMTF(pucBufRaw, iImgWidth, iImgHeight, stMTFAutoROI, pstParameter->stMTFBasic.algswitch, flvalue)) _CODE_AFC_MTF_EXIT1;
				}else if(pstParameter->stMTFBasic.algswitch == 7){

					if(iresult	=	classRolongoTest.HisCCMMTF(pucBufRaw, iImgWidth, iImgHeight, stMTFAutoROI, pstParameter->stMTFBasic.algswitch, flHvalue,flVvalue)) _CODE_AFC_MTF_EXIT1;
				}
				else
				{
					if(iresult	=	classRolongoTest.HisCCMMTF(pucBufRaw, iImgWidth, iImgHeight, stMTFAutoROI, pstParameter->stMTFBasic.algswitch, flvalue)) _CODE_AFC_MTF_EXIT1;
				}

				if(pstParameter->stMTFBasic.algswitch != 7){
					iteratorItemData->vectorFOV.at(y).flValue[x]		=	flvalue;
				}else{
					iteratorItemData->vectorFOV.at(y).flValue[x]		=	(flHvalue+flVvalue)/2;
					stItemData_EX.vectorFOV.at(y).flValue[x]=(flHvalue+flVvalue)/2;
					stItemData_EX.vectorFOV.at(y).flHValue[x]=flHvalue;
					stItemData_EX.vectorFOV.at(y).flVValue[x]=flVvalue;
				}

				iteratorItemData->vectorFOV.at(y).stBlock[x]	=	stMTFAutoROI;
				stItemData_EX.vectorFOV.at(y).stBlock[x]=stMTFAutoROI;
				pstTemp++;
				flmax	=	max(flmax, flvalue);
				flmin		=	min(flmin, flvalue);
			}
			if(iresult) break;
			iteratorItemData->vectorFOV.at(y).flUniformValue	=	flmax - flmin;
		}
#endif
			iresult = classAlgorithm.HisAFCTactics_MTFHA_DB_HA(pstParameter->stTacticsBasic, vectorItemData, *pstAFCMTFDB, iMotorPosNow);
			
			if(pstParameter->stMTFBasic.algswitch != 7){
				ROPLOW::AddDrawMTFHA(*iteratorItemData, iImgWidth, iImgHeight, vectorDraw, pstParameter->stMTFBasic.flGradeMultiple);
			}else{
				ROPLOW::AddDrawMTFHE(stItemData_EX, iImgWidth, iImgHeight, vectorDraw,*pstParameter,pstParameter->stMTFBasic.flGradeMultiple);
			}

			if(iteratorItemData->ucStatus == 0x0)
			{
				emit information(QString::fromLocal8Bit("错误：Peak点规格不达标！"));
				iresult	=	HisCCMError_NoFocusStep;//
			}
			HisReleaseMalloc(pucBufRaw);
		}*/

		_CODE_RJAFA_LP_ASIGNDRAW
	}

	if(hisglobalparameter.bDebugMode && vectorItemData.size() > 1){
		QString strSerialNumber;
		classLog->getserialnumber(strSerialNumber);
		if(strSerialNumber.isEmpty()) strSerialNumber = "1";
		strSerialNumber	=	QDir::currentPath() % "/" % strSerialNumber;
		if(uctype == 0) strSerialNumber = strSerialNumber % " MTF AFC Near Curve.csv";
		else if(uctype == 1) strSerialNumber = strSerialNumber % " MTF AFC Middle Curve.csv";
		else strSerialNumber = strSerialNumber % " MTF AFC Far Curve.csv";
		ROPLOW::saveMTFHAAFCCurve2File(vectorItemData, pstParameter, strSerialNumber);
	}

	if(iresult){
		ROPLOW::saveMTFHAAFCResult(uctype, false, uiSaveIndex, vectorItemData, stLinearResult, pstParameter, *classLog, iImgWidth, iImgHeight);
		_CODE_AFC_MTF_EXIT1
	}



	if(pstParameter->stTacticsBasic.ucTactics == _HisCCMAlg_Rolongo_AFC_Tactics_PEAK || \
		pstParameter->stTacticsBasic.ucTactics == _HisCCMAlg_Rolongo_AFC_Tactics_Inflexion){
			if(uctype == 0)	emit information(QTextCodec::codecForName( "GBK")->toUnicode("近焦最优点马达坐标：") % QString::number(vectorItemData.at(uiSaveIndex).sMotorStep));
			else if(uctype == 1)	emit information(QTextCodec::codecForName( "GBK")->toUnicode("中焦最优点马达坐标：") % QString::number(vectorItemData.at(uiSaveIndex).sMotorStep));
			else emit information(QTextCodec::codecForName( "GBK")->toUnicode("远焦最优点马达坐标：") % QString::number(vectorItemData.at(uiSaveIndex).sMotorStep));

			
			if(vectorItemData.at(uiSaveIndex).sMotorStep < pstParameter->stTacticsBasic.sMotorSpecMin && \
				vectorItemData.at(uiSaveIndex).sMotorStep > pstParameter->stTacticsBasic.sMotorSpecMax){
					iresult	=	HisCCMError_Result;
					emit information(QTextCodec::codecForName( "GBK")->toUnicode("最优点点马达位置超出规格"));
			}

			if(uctype == 0)	iNearPeakMotorDec	=	vectorItemData.at(uiSaveIndex).sMotorStep;
			else if(uctype == 1)	iMiddlePeakMotorDec	=	vectorItemData.at(uiSaveIndex).sMotorStep;
			else iFarPeakMotorDec	=	vectorItemData.at(uiSaveIndex).sMotorStep;
	}
	else if(pstParameter->stTacticsBasic.ucTactics == _HisCCMAlg_Rolongo_AFC_Tactics_Linear){
		stLinearResult.bLinearBack		=	pstParameter->stTacticsBasic.bLinearBack;
		stLinearResult.bTestStartMotor	=	pstParameter->stTacticsBasic.bTestStartMotor;
		stLinearResult.flStartMotorDevDef	=	pstParameter->stTacticsBasic.flStartMotorDevDef;
		stLinearResult.iStartMotorMin		=	pstParameter->stTacticsBasic.sStartMotorMin;
		stLinearResult.iStartMotorMax	=	pstParameter->stTacticsBasic.sStartMotorMax;
		stLinearResult.vectorItemData.resize(vectorItemData.size());
		for(unsigned int x=0;	x<vectorItemData.size(); ++x){
			stLinearResult.vectorItemData.at(x).ucFlag	=	vectorItemData.at(x).ucFlag;
			stLinearResult.vectorItemData.at(x).iMotor	=	vectorItemData.at(x).sMotorStep;
			stLinearResult.vectorItemData.at(x).flValue	=	vectorItemData.at(x).flWeightValue;
		}

		ROPLOW::GetLinearResult(stLinearResult);
		if(!stLinearResult.bResult)	iresult	=	HisCCMError_Result;
		else if(stLinearResult.bTestStartMotor)	{
			iMotorStartDec		=	stLinearResult.iStartMotor;	
			emit information(QTextCodec::codecForName( "GBK")->toUnicode("启动电流位置：") % QString::number(iMotorStartDec));
		}

		if(uctype == 0)	iNearPeakMotorDec	=	vectorItemData.at(uiSaveIndex).sMotorStep;
		else if(uctype == 1)	iMiddlePeakMotorDec	=	vectorItemData.at(uiSaveIndex).sMotorStep;
		else iFarPeakMotorDec	=	vectorItemData.at(uiSaveIndex).sMotorStep;
	}

	ROPLOW::saveMTFHAAFCResult(uctype, !iresult, uiSaveIndex, vectorItemData, stLinearResult, pstParameter, *classLog, iImgWidth, iImgHeight);

	if(pstParameter->stTacticsBasic.bDataBase && !iresult){
		ROPLOW::AFCMTFToDB(uctype, pstParameter, pstAFCMTFDB, vectorItemData, uiSaveIndex, bBoxChannel1);
	}

	_CODE_AFC_MTF_EXIT1
}

void itemprocess::DrawMTFHAAFCPointCurve(std::vector<_HisCCMAlg_AFC_MTF_DataItem>& vectorDataItem, \
	_mtfAFCParameter* pstParameter, bool bCenter, bool bFOV)
{
	const int ciTotalWidth		=	770;
	const int ciTotalHeight		=	220;
	QImage imageBackgound(ciTotalWidth, ciTotalHeight, QImage::Format_RGB888);
	imageBackgound.fill(QColor::fromRgb(240, 240, 240));
	const int ciTitleLeft			=	30;
	const int ciTitleBottom		=	20;

	QPainter painer(&imageBackgound);
	painer.setPen(Qt::SolidLine);
	QPen thePen	=	painer.pen();
	thePen.setWidth(3);
	thePen.setColor(QColor::fromRgb(0, 255, 0));
	painer.setPen(thePen);

	painer.drawLine(ciTitleLeft, 0, ciTitleLeft, ciTotalHeight- ciTitleBottom);
	painer.drawLine(ciTitleLeft, ciTotalHeight- ciTitleBottom, ciTotalWidth-1, ciTotalHeight- ciTitleBottom);

	float flYN1	=	ciTotalHeight - ciTitleBottom -4;
	float flXN1	=	(float)(ciTotalWidth - ciTitleLeft - 4) / (float)(pstParameter->stTacticsBasic.sMotorEnd - pstParameter->stTacticsBasic.sMotorStart);
	QPointF* pstPoint	=	new QPointF[vectorDataItem.size()];

	for(unsigned int x=0;	x<vectorDataItem.size(); ++x){
		pstPoint[x].setX((vectorDataItem.at(x).sMotorStep - pstParameter->stTacticsBasic.sMotorStart) *flXN1 + ciTitleLeft);
		pstPoint[x].setY(ciTotalHeight - ciTitleBottom - vectorDataItem.at(x).flWeightValue *flYN1);
	}

	thePen.setColor(QColor::fromRgb(0, 0, 0));
	thePen.setWidth(5);
	painer.setPen(thePen);
	painer.drawPoints(pstPoint, vectorDataItem.size());

	if(bCenter){

	}

	if(bFOV){

	}

	delete[] pstPoint; pstPoint = NULL;


	itemshareData.plotLock.lockForWrite();
	itemshareData.plotimage	=	imageBackgound;
	itemshareData.plotLock.unlock();
	emit plotpainter(0);
}

int itemprocess::getSFRMFACAParameter(bool bupdate, bool bcheck)
{
	itemshareData.itemparameterLock.lockForRead();
	if(!bupdate && itemshareData.sfrfacaParameter){
		itemshareData.itemparameterLock.unlock();
		return 0;
	}

	QMutexLocker locker(&hisglobalparameter.mutexDatabase);

	itemshareData.itemparameterLock.unlock();
	itemshareData.itemparameterLock.lockForWrite();
	if(!itemshareData.sfrfacaParameter)	itemshareData.sfrfacaParameter		=	new _SFRFACAParameter;
	if(!itemshareData.sfrfacaParameter){
		itemshareData.itemparameterLock.unlock();
		return HisFX3Error_MallocBuffer;
	}

	itemshareData.sfrfacaParameter->vectorSFRItem.clear();
	QString strItemName	=	"sframfa";
	bool bparsesuccess	=	true, bItemExist = false;

	//读取，解析config
	for(int  w=0;	w<1;	++w){ //此处是有意义的,不要删除
		QSqlDatabase customdb = QSqlDatabase::addDatabase("QSQLITE", "querycustom");
		customdb.setDatabaseName(QDir::currentPath() % "/HisFX3Custom");
		if (!customdb.open()){
			bparsesuccess	=	false;
			break;
		}

		QString strData, strdata2;
		QStringList strname, strvalue;
		QSqlQuery query(customdb);
		query.prepare("SELECT itemsuffix2,key,value,reserve FROM " % itemshareData.currentTableName % \
			" WHERE classfy='algorithm' AND item='" % strItemName % "' AND itemsuffix1='basic' ORDER BY id ASC" );
		query.exec();

		//classfy = algorithm, item = sframfa itemsuffix1=basic,fovitem,statics
		/************basic**************/
		//(method:0)(channel:y)(fovoffset:100)(sidemin:60)(sidemax:120)(mincontrast:20)(weight:1.0)
		//(roiw:48)(roih:64)(usefreq2:true)(freq1:4)(freq2:8)(grademultiple:1.2)(onlyinner:false)
		//(mtf50h:0.0)(mtf50v:0.0)
		//(f1spech:0.0)(f1specv:0.0)(f2spech:0.0)(f2specv:0.0)
		while (query.next()){
			bItemExist = true;
			for(int y=0;	y<4;	++y){
				strData	=	query.value(y).toString();
				ROPLOW::patchconfigstring(strData, strname, strvalue);
				for(int x=0;	x<strname.size();	++x){
					if(strname.at(x) == "method")	itemshareData.sfrfacaParameter->stSFRBasic.ucMethod	=	strvalue.at(x).toInt();
					else if(strname.at(x) == "fovoffset")	itemshareData.sfrfacaParameter->stSFRBasic.usFOVOffset	=	strvalue.at(x).toInt();
					else if(strname.at(x) == "sidemin")	itemshareData.sfrfacaParameter->stSFRBasic.usMarkSideMin	=	strvalue.at(x).toInt();
					else if(strname.at(x) == "sidemax")	itemshareData.sfrfacaParameter->stSFRBasic.usMarkSideMax	=	strvalue.at(x).toInt();
					else if(strname.at(x) == "mincontrast")	itemshareData.sfrfacaParameter->stSFRBasic.ucMinCantrast	=	strvalue.at(x).toInt();
					else if(strname.at(x) == "roiw")	itemshareData.sfrfacaParameter->stSFRBasic.iROIWidth	=	strvalue.at(x).toInt();
					else if(strname.at(x) == "roih")	itemshareData.sfrfacaParameter->stSFRBasic.iROIHeght	=	strvalue.at(x).toInt();
					else if(strname.at(x) == "freq1")	itemshareData.sfrfacaParameter->stSFRBasic.uc1stFreq	=	strvalue.at(x).toInt();
					else if(strname.at(x) == "freq2")	itemshareData.sfrfacaParameter->stSFRBasic.uc2ndFreq	=	strvalue.at(x).toInt();
					else if(strname.at(x) == "onlyinner") itemshareData.sfrfacaParameter->stSFRBasic.bOnlyInner = (strvalue.at(x) == "true");
					else if(strname.at(x) == "weight")	itemshareData.sfrfacaParameter->stSFRBasic.flCenterWeight	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "mtf50h")	itemshareData.sfrfacaParameter->stSFRBasic.flCenterMTF50SpecH	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "mtf50v")	itemshareData.sfrfacaParameter->stSFRBasic.flCenterMTF50SpecV	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "f1spech")	itemshareData.sfrfacaParameter->stSFRBasic.flCenter1stFreqSpecH	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "f1specv")	itemshareData.sfrfacaParameter->stSFRBasic.flCenter1stFreqSpecV	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "f2spech")	itemshareData.sfrfacaParameter->stSFRBasic.flCenter2ndFreqSpecH	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "f2specv")	itemshareData.sfrfacaParameter->stSFRBasic.flCenter2ndFreqSpecV	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "usefreq2") itemshareData.sfrfacaParameter->stSFRBasic.b2ndFreq	=	(strvalue.at(x) == "true");
					else if(strname.at(x) == "channel")	{
						if(strvalue.at(x) == "r")		itemshareData.sfrfacaParameter->stSFRBasic.ucChannel	=	_HisCCMAlg_ImageBuffer_Channel_R;
						else if(strvalue.at(x) == "g")		itemshareData.sfrfacaParameter->stSFRBasic.ucChannel	=	_HisCCMAlg_ImageBuffer_Channel_Gr;
						else if(strvalue.at(x) == "b")		itemshareData.sfrfacaParameter->stSFRBasic.ucChannel	=	_HisCCMAlg_ImageBuffer_Channel_B;
						else itemshareData.sfrfacaParameter->stSFRBasic.ucChannel	=	_HisCCMAlg_ImageBuffer_Channel_Y;
					}
					else if(strname.at(x) == "grademultiple")	itemshareData.sfrfacaParameter->stSFRBasic.flGradeMultiple	=	strvalue.at(x).toFloat();
#if (defined USE_MANUAL_LENS_BIN)
					if(strname.at(x) == "gradecount")	itemshareData.sfrfacaParameter->stSFRBasic.ucGradeCount	=	strvalue.at(x).toUInt();
					else if(strname.at(x) == "grade_b_h")	itemshareData.sfrfacaParameter->stSFRBasic.flCenterMTF50GradeBH	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "grade_b_v")		itemshareData.sfrfacaParameter->stSFRBasic.flCenterMTF50GradeBV	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "grade_c_h")	itemshareData.sfrfacaParameter->stSFRBasic.flCenterMTF50GradeCH	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "grade_c_v")		itemshareData.sfrfacaParameter->stSFRBasic.flCenterMTF50GradeCV	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "grade_d_h")	itemshareData.sfrfacaParameter->stSFRBasic.flCenterMTF50GradeDH	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "grade_d_v")		itemshareData.sfrfacaParameter->stSFRBasic.flCenterMTF50GradeDV	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "grade_e_h")	itemshareData.sfrfacaParameter->stSFRBasic.flCenterMTF50GradeEH	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "grade_e_v")		itemshareData.sfrfacaParameter->stSFRBasic.flCenterMTF50GradeEV	=	strvalue.at(x).toFloat();
#endif
				}
			}
		}

		query.prepare("SELECT itemsuffix2,key,value,reserve FROM " % itemshareData.currentTableName % \
			" WHERE classfy='algorithm' AND item='" % strItemName % "' AND itemsuffix1='fovitem' ORDER BY id ASC" );
		query.exec();
		/************fovitem**************/
		//(fov:0.3)(angle:0)(weight:1.0)
		//(mtf50h:0.0)(mtf50v:0.0)(mtf50u:0.0)
		//(f1spech:0.0)(f1specv:0.0)(f1specu:0.0)
		//(f2spech:0.0)(f2specv:0.0)(f2specu:0.0)
		while (query.next()){
			bItemExist = true;
			_HisCCMAlg_SFRPlusHAItem_Info stcircleitem;
			for(int y=0;	y<4;	++y){
				strData	=	query.value(y).toString();
				ROPLOW::patchconfigstring(strData, strname, strvalue);
				for(int x=0;	x<strname.size();	++x){
					if(strname.at(x) == "fov")	 stcircleitem.flFOV	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "blockcount")	 stcircleitem.ucBlockCount	=	strvalue.at(x).toUInt() & 0xFF;
					else if(strname.at(x) == "weight")	 stcircleitem.flWeight	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "angle")		stcircleitem.flAngle		=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "mtf50h")	 stcircleitem.flMTF50SpecH		=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "mtf50v")	 stcircleitem.flMTF50SpecV		=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "mtf50u")	 stcircleitem.flMTF50SpecUnifH	=stcircleitem.flMTF50SpecUnifV	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "f1spech")	 stcircleitem.fl1stFreqSpecH		=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "f1specv")	 stcircleitem.fl1stFreqSpecV		=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "f1specu")	 stcircleitem.fl1stFreqSpecUnifH = stcircleitem.fl1stFreqSpecUnifV		=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "f2spech")	 stcircleitem.fl2ndFreqSpecH		=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "f2specv")	 stcircleitem.fl2ndFreqSpecV		=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "f2specu")	 stcircleitem.fl2ndFreqSpecUnifH	= stcircleitem.fl2ndFreqSpecUnifV	=	strvalue.at(x).toFloat();
#if (defined USE_MANUAL_LENS_BIN)
					if(strname.at(x) == "grade_b_h")	stcircleitem.flMTF50GradeBH				=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "grade_b_v")		stcircleitem.flMTF50GradeBV		=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "grade_c_h")	stcircleitem.flMTF50GradeCH	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "grade_c_v")		stcircleitem.flMTF50GradeCV		=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "grade_d_h")	stcircleitem.flMTF50GradeDH	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "grade_d_v")		stcircleitem.flMTF50GradeDV		=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "grade_e_h")	stcircleitem.flMTF50GradeEH		=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "grade_e_v")		stcircleitem.flMTF50GradeEV		=	strvalue.at(x).toFloat();
#endif
				}
			}

			itemshareData.sfrfacaParameter->vectorSFRItem.push_back(stcircleitem);	
		}

		customdb.close();
	}

	QSqlDatabase::removeDatabase("querycustom");
	if(!bparsesuccess || !bItemExist){
		HisReleaseNewO(itemshareData.sfrfacaParameter);
		itemshareData.itemparameterLock.unlock();
		return HisFX3Error_Parameter;
	}

	if(!bcheck) {itemshareData.itemparameterLock.unlock(); return 0; }

	if(itemshareData.sfrfacaParameter->stSFRBasic.iROIWidth < 16){
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("参数错误： ROI宽不能 < 16"));
		HisReleaseNewO(itemshareData.sfrfacaParameter);
		itemshareData.itemparameterLock.unlock();
		return HisFX3Error_Parameter;
	}

	if(itemshareData.sfrfacaParameter->stSFRBasic.iROIWidth >= itemshareData.sfrfacaParameter->stSFRBasic.iROIHeght){
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("参数错误： ROI宽必须 < ROI高"));
		HisReleaseNewO(itemshareData.sfrfacaParameter);
		itemshareData.itemparameterLock.unlock();
		return HisFX3Error_Parameter;
	}

	itemshareData.sfrfacaParameter->stSFRBasic.iROIWidth	=	((itemshareData.sfrfacaParameter->stSFRBasic.iROIWidth >>2) <<2);
	itemshareData.sfrfacaParameter->stSFRBasic.iROIHeght	=	((itemshareData.sfrfacaParameter->stSFRBasic.iROIHeght >>2) <<2);
	if(itemshareData.sfrfacaParameter->stSFRBasic.iROIWidth == itemshareData.sfrfacaParameter->stSFRBasic.iROIHeght) itemshareData.sfrfacaParameter->stSFRBasic.iROIHeght += 4;

	std::sort(itemshareData.sfrfacaParameter->vectorSFRItem.begin(), itemshareData.sfrfacaParameter->vectorSFRItem.end(), sort_sfraitem_fov);
	itemshareData.itemparameterLock.unlock();
	return 0;
}

int itemprocess::sfrFACA()
{
	_CODE_CLEAR_IMAGEDRAW

		//判断图像是否点亮
		if(!threadshareData.GetHisPreviewflag())	return HisCCMError_NotPreivew;

	//取得配置参数
	int iresult	=	getSFRMFACAParameter(false);
	if(iresult)	return iresult;

	unsigned char* pucBufRaw = NULL, *pucBufY = NULL;
	float* pflSFRBlock	=	NULL;
	double* pdflsfrvalue	=	NULL;

	itemshareData.itemparameterLock.lockForRead();

	_HisFX3_BaylorMode emDataFormat =	itemshareData.previewParameter->ucDataFormat;
	int iImgWidth =	itemshareData.previewParameter->iWidth, iImgHeight =	itemshareData.previewParameter->iHeight;
	unsigned int uiRawImgSize		=	itemshareData.previewParameter->iWidth * itemshareData.previewParameter->iHeight *3;
	unsigned char ucFrameType		=	_FrameType_RGB24;
	switch (itemshareData.previewParameter->ucDataFormat){
	case HisBaylor10_BGGR:
	case HisBaylor12_BGGR:
	case HisBaylor8_BGGR:	emDataFormat	=	HisBaylor8_BGGR;	break;
	case HisBaylor10_RGGB:
	case HisBaylor12_RGGB:
	case HisBaylor8_RGGB:	emDataFormat	=	HisBaylor8_RGGB;	break;
	case HisBaylor10_GRBG:
	case HisBaylor12_GRBG:
	case HisBaylor8_GRBG:	emDataFormat	=	HisBaylor8_GRBG;	break;
	case HisBaylor10_GBRG:
	case HisBaylor12_GBRG:
	case HisBaylor8_GBRG:	emDataFormat	=	HisBaylor8_GBRG;	break;
	case HisBaylor10_MONO:
	case HisBaylor12_MONO:
	case HisBaylor8_MONO:	emDataFormat	=	HisBaylor8_MONO;	break;
	case HisRGB_RGB24:		break;
	default:
		uiRawImgSize		=	itemshareData.previewParameter->iWidth * itemshareData.previewParameter->iHeight *2;
		ucFrameType		=	_FrameType_Raw;
		break;
	}

	int isftcurvelen	=	itemshareData.sfrfacaParameter->stSFRBasic.iROIWidth +1;
	float flmtf50;
	unsigned int uiPixelSize	=	iImgWidth *iImgHeight;
	pucBufRaw		=	(unsigned char*)_aligned_malloc(uiRawImgSize, _HisCacheLine_Aligned);
	pucBufY			=	(unsigned char*)_aligned_malloc(uiPixelSize, _HisCacheLine_Aligned);
	pflSFRBlock	=	(float*)_aligned_malloc(itemshareData.sfrfacaParameter->stSFRBasic.iROIWidth *itemshareData.sfrfacaParameter->stSFRBasic.iROIHeght *sizeof(float), _HisCacheLine_Aligned);
	pdflsfrvalue		=	(double*)_aligned_malloc(isftcurvelen *sizeof(double), _HisCacheLine_Aligned);
	if(!(pucBufRaw && pucBufY && pflSFRBlock && pdflsfrvalue)){
		HisReleaseMalloc(pucBufY);
		HisReleaseMalloc(pucBufRaw);
		HisReleaseMalloc(pflSFRBlock);
		HisReleaseMalloc(pdflsfrvalue);
		return HisFX3Error_MallocBuffer;
	}

	std::vector<_itemDraw> vectorDraw;
	vectorDraw.reserve(300);
	std::vector<_itemDraw>::iterator iteratorDraw;
	_HisCCMAlg_AFC_SFRHA_DataItem stItemData, stMaxItemData;
	std::vector<_SFRBlackItem> vecPos;
	vecPos.reserve(400);
	std::vector<_SFRBlackROI4> vecFOVROI;
	vecFOVROI.reserve(13);
	std::vector<_SFRBlackROI4>::iterator iteratorFOVROI;

	bool bUseYUV_Y	=	(emDataFormat>=HisYUV8_422_YUYV && emDataFormat<=HisYUV8_422_VYUY && itemshareData.sfrfacaParameter->stSFRBasic.ucChannel==_HisCCMAlg_ImageBuffer_Channel_Y)?(true):(false);
	float* pflValue1, *pflValue2, *pflValue3;
	RECT* pstBlock;
	bool bNext, bFirstFrame = true;
	_itemStatus itemstatus;
	itemstatus.ucstatus	=	_His_ItemStatus_NG;
	itemstatus.usitem		=	sfrfacaitem;

	ROPLOW::MFASFRHAItemDataInitial(stMaxItemData, itemshareData.sfrfacaParameter);

	QElapsedTimer classFATime;
	while(threadshareData.GetHisPreviewflag() && hisglobalparameter.getfaflag())
	{
		classFATime.restart();
		ROPLOW::MFASFRHAItemDataInitial(stItemData, itemshareData.sfrfacaParameter);

		if(iresult	=	GetFreshframe(pucBufRaw, uiRawImgSize, ucFrameType, bFirstFrame)) break;
		bFirstFrame	=	false;
		if(emDataFormat >= HisYUV8_422_YUYV && emDataFormat <= HisYUV8_422_VYUY)
			classAlgorithm.extactYfromYUV422U8(pucBufRaw, pucBufY, iImgWidth*iImgHeight, emDataFormat); //抽取Y通道
		else{ //抽取G通道作为Y通道
			unsigned char* pucSrc = pucBufRaw + 1, *pucDes = pucBufY;
			for(unsigned int x=0;	x<uiPixelSize;	++x){
				*pucDes	=	*pucSrc;
				++pucDes;
				pucSrc	+=	3;
			}
		}

		vectorDraw.clear();
		vecFOVROI.clear();
		bNext	=	true;
		if(iresult = classAlgorithm.decodeSFRChartTAHA(pucBufY, iImgWidth, iImgHeight, itemshareData.sfrfacaParameter->stSFRBasic.usMarkSideMin, \
			itemshareData.sfrfacaParameter->stSFRBasic.usMarkSideMax, vecPos)){
				emit information(QTextCodec::codecForName( "GBK")->toUnicode("无法提取出CHART轮廓信息"));
				bNext	=	false;
		}

		if(vecPos.size() < 1){
			emit information(QTextCodec::codecForName( "GBK")->toUnicode("无法提取出CHART轮廓信息"));
			bNext	=	false;
		}

		if(bNext){
			//center
			vecFOVROI.clear();
			iresult = classAlgorithm.getSFRFOVPos(vecPos, iImgWidth, iImgHeight, 0.0f, 0.0f, itemshareData.sfrfacaParameter->stSFRBasic.iROIWidth, \
				itemshareData.sfrfacaParameter->stSFRBasic.iROIHeght, itemshareData.sfrfacaParameter->stSFRBasic.usFOVOffset, vecFOVROI);
			if(iresult){
				emit information(QTextCodec::codecForName( "GBK")->toUnicode("无法提取中心位置信息"));
				bNext	=	false;
			}
			else{
				iteratorFOVROI	=	vecFOVROI.begin();
				stItemData.stCenterBlock	=	*iteratorFOVROI;
				for(unsigned int x=0;	x<4;	++x){
					switch (x){
					case 0: pstBlock = &(iteratorFOVROI->stLeft); pflValue1 = &(stItemData.stSFRCenterMTF50.flValueH_L); \
								pflValue2 = &(stItemData.stSFRCenterFreq1.flValueH_L); pflValue3 = &(stItemData.stSFRCenterFreq2.flValueH_L); break;
					case 1: pstBlock = &(iteratorFOVROI->stRight); pflValue1 = &(stItemData.stSFRCenterMTF50.flValueH_R); \
								pflValue2 = &(stItemData.stSFRCenterFreq1.flValueH_R); pflValue3 = &(stItemData.stSFRCenterFreq2.flValueH_R); break;
					case 2: pstBlock = &(iteratorFOVROI->stTop); pflValue1 = &(stItemData.stSFRCenterMTF50.flValueV_T); \
								pflValue2 = &(stItemData.stSFRCenterFreq1.flValueV_T); pflValue3 = &(stItemData.stSFRCenterFreq2.flValueV_T); break;
					default: pstBlock = &(iteratorFOVROI->stBottom); pflValue1 = &(stItemData.stSFRCenterMTF50.flValueV_B); \
								 pflValue2 = &(stItemData.stSFRCenterFreq1.flValueV_B); pflValue3 = &(stItemData.stSFRCenterFreq2.flValueV_B); break;
					}

					if(bUseYUV_Y)	ROPLOW::GetPartYFromY(pucBufY, iImgWidth, iImgHeight, *pstBlock, pflSFRBlock);
					else ROPLOW::GetPartImageFromRGB24(pucBufRaw, iImgWidth, iImgHeight, itemshareData.sfrfacaParameter->stSFRBasic.ucChannel, *pstBlock, pflSFRBlock);
					classAlgorithm.HisCCMSFROne(pflSFRBlock, itemshareData.sfrfacaParameter->stSFRBasic.iROIWidth, itemshareData.sfrfacaParameter->stSFRBasic.iROIHeght, \
						itemshareData.sfrfacaParameter->stSFRBasic.ucMinCantrast, pdflsfrvalue, isftcurvelen, flmtf50);
					if(itemshareData.sfrfacaParameter->stSFRBasic.ucMethod == _His_SFR_Method_2Freq){
						if(isftcurvelen){
							*pflValue2	= ROPLOW::GetSFRFreqValue(pdflsfrvalue, isftcurvelen, itemshareData.sfrfacaParameter->stSFRBasic.uc1stFreq);
							if(itemshareData.sfrfacaParameter->stSFRBasic.b2ndFreq)
								*pflValue3	= ROPLOW::GetSFRFreqValue(pdflsfrvalue, isftcurvelen, itemshareData.sfrfacaParameter->stSFRBasic.uc2ndFreq);
						}					
					}
					else{
						*pflValue1	=	flmtf50;
					}
				}

				ROPLOW::AddDrawSFRHAMFA(*iteratorFOVROI, stItemData.stSFRCenterMTF50, stItemData.stSFRCenterFreq1, \
					stItemData.stSFRCenterFreq2, itemshareData.sfrfacaParameter, 0xFFFFFFFF, vectorDraw, itemshareData.sfrfacaParameter->stSFRBasic.flGradeMultiple);
			}

			//FOV
			for(unsigned int w=0;	w<itemshareData.sfrfacaParameter->vectorSFRItem.size();	++w){
				vecFOVROI.clear();
				if(iresult = classAlgorithm.getSFRFOVPos(vecPos, iImgWidth, iImgHeight, itemshareData.sfrfacaParameter->vectorSFRItem.at(w).flFOV, \
					itemshareData.sfrfacaParameter->vectorSFRItem.at(w).flAngle, itemshareData.sfrfacaParameter->stSFRBasic.iROIWidth, itemshareData.sfrfacaParameter->stSFRBasic.iROIHeght, \
					itemshareData.sfrfacaParameter->stSFRBasic.usFOVOffset, vecFOVROI, itemshareData.sfrfacaParameter->vectorSFRItem.at(w).ucBlockCount, 0, itemshareData.sfrfacaParameter->stSFRBasic.bOnlyInner)){
						emit information(QTextCodec::codecForName( "GBK")->toUnicode("无法提取") % \
							QString::number(itemshareData.sfrfacaParameter->vectorSFRItem.at(w).flFOV, 'f', 2) % \
							QTextCodec::codecForName( "GBK")->toUnicode("FOV位置信息"));
						bNext	=	false;
				}
				else{
					iteratorFOVROI	=	vecFOVROI.begin();				
					for(unsigned int y=0;	y<itemshareData.sfrfacaParameter->vectorSFRItem.at(w).ucBlockCount;	++y)
					{				
						for(unsigned int x=0;	x<4;	++x){
							switch (x){
							case 0: pstBlock = &(iteratorFOVROI->stLeft); pflValue1 = &(stItemData.vectorFOV.at(w).stSFRMTF50[y].flValueH_L); \
										pflValue2 = &(stItemData.vectorFOV.at(w).stSFRFreq1[y].flValueH_L); pflValue3 = &(stItemData.vectorFOV.at(w).stSFRFreq2[y].flValueH_L); break;
							case 1: pstBlock = &(iteratorFOVROI->stRight); pflValue1 = &(stItemData.vectorFOV.at(w).stSFRMTF50[y].flValueH_R); \
										pflValue2 = &(stItemData.vectorFOV.at(w).stSFRFreq1[y].flValueH_R); pflValue3 = &(stItemData.vectorFOV.at(w).stSFRFreq2[y].flValueH_R); break;
							case 2: pstBlock = &(iteratorFOVROI->stTop); pflValue1 = &(stItemData.vectorFOV.at(w).stSFRMTF50[y].flValueV_T); \
										pflValue2 = &(stItemData.vectorFOV.at(w).stSFRFreq1[y].flValueV_T); pflValue3 = &(stItemData.vectorFOV.at(w).stSFRFreq2[y].flValueV_T); break;
							default: pstBlock = &(iteratorFOVROI->stBottom); pflValue1 = &(stItemData.vectorFOV.at(w).stSFRMTF50[y].flValueV_B); \
										 pflValue2 = &(stItemData.vectorFOV.at(w).stSFRFreq1[y].flValueV_B); pflValue3 = &(stItemData.vectorFOV.at(w).stSFRFreq2[y].flValueV_B); break;
							}

							if(itemshareData.sfrfacaParameter->stSFRBasic.bOnlyInner && !pstBlock->bottom){
								*pflValue1	=	*pflValue2	=	*pflValue3	=	10000.0f;
								continue;
							}

							if(bUseYUV_Y)	ROPLOW::GetPartYFromY(pucBufY, iImgWidth, iImgHeight, *pstBlock, pflSFRBlock);
							else ROPLOW::GetPartImageFromRGB24(pucBufRaw, iImgWidth, iImgHeight, itemshareData.sfrfacaParameter->stSFRBasic.ucChannel, *pstBlock, pflSFRBlock);
							classAlgorithm.HisCCMSFROne(pflSFRBlock, itemshareData.sfrfacaParameter->stSFRBasic.iROIWidth, itemshareData.sfrfacaParameter->stSFRBasic.iROIHeght, \
								itemshareData.sfrfacaParameter->stSFRBasic.ucMinCantrast, pdflsfrvalue, isftcurvelen, flmtf50);
							if(itemshareData.sfrfacaParameter->stSFRBasic.ucMethod == _His_SFR_Method_2Freq){
								//								emit information("curve length: " % QString::number(isftcurvelen));
								if(isftcurvelen){
									*pflValue2	= ROPLOW::GetSFRFreqValue(pdflsfrvalue, isftcurvelen, itemshareData.sfrfacaParameter->stSFRBasic.uc1stFreq);
									if(itemshareData.sfrfacaParameter->stSFRBasic.b2ndFreq)
										*pflValue3	= ROPLOW::GetSFRFreqValue(pdflsfrvalue, isftcurvelen, itemshareData.sfrfacaParameter->stSFRBasic.uc2ndFreq);
								}					
							}
							else{
								*pflValue1	=	flmtf50;
							}
						}

						ROPLOW::AddDrawSFRHAMFA(*iteratorFOVROI, stItemData.vectorFOV.at(w).stSFRMTF50[y], stItemData.vectorFOV.at(w).stSFRFreq1[y], \
							stItemData.vectorFOV.at(w).stSFRFreq2[y], itemshareData.sfrfacaParameter, w, vectorDraw, itemshareData.sfrfacaParameter->stSFRBasic.flGradeMultiple);
						stItemData.vectorFOV.at(w).stBlock[y]	=	*iteratorFOVROI;
						iteratorFOVROI++;
					}
				}
			}

		}

		_CODE_RJAFA_LP_ASIGNDRAW

			ROPLOW::SFRAMFACaculateResult(stItemData, itemshareData.sfrfacaParameter->stSFRBasic.flGradeMultiple, itemshareData.sfrfacaParameter);

		if(stItemData.flWeightValue > stMaxItemData.flWeightValue) stMaxItemData = stItemData;
		itemshareData.plotLock.lockForWrite();
#if (defined USE_MANUAL_LENS_BIN)	
		ROPLOW::fillSFRFALensBarChartDrawInfo(itemshareData.vecBarChartItem, stItemData, itemshareData.sfrfacaParameter, iImgWidth, iImgHeight, itemshareData.sfrfacaParameter->stSFRBasic.flGradeMultiple);
#else
		ROPLOW::fillSFRFABarChartDrawInfo(itemshareData.vecBarChartItem, stItemData, &(itemshareData.sfrfacaParameter->stSFRBasic), iImgWidth, iImgHeight, itemshareData.sfrfacaParameter->stSFRBasic.flGradeMultiple);
#endif
		itemshareData.dflBarChartYMin		=	0.0;
		itemshareData.dflBarChartYMax	=	0.5;
		itemshareData.plotLock.unlock();
		emit plotpainter(1);

		itemstatus.ucstatus	=	stItemData.ucStatus | 0x80;
		updateItemstatus(itemstatus);

		while(classFATime.elapsed() < 195) Sleep(10);
		Sleep(5);
	}

	if(!threadshareData.GetHisPreviewflag()){
		iresult	=	HisCCMError_NotPreivew;
		_CODE_AFC_SFRHA_EXIT1
	}

	iresult	=	(stItemData.ucStatus == 0x0)?(HisCCMError_Result):(0);
	ROPLOW::saveSHRHAMFAResult(stItemData, itemshareData.sfrfacaParameter, *classLog, iImgWidth, iImgHeight);
	_CODE_AFC_SFRHA_EXIT1
}

int itemprocess::getsfrAFCCAParameter(unsigned char uctype, bool bupdate, bool bcheck)
{
	QString strItemName;
	_SFRAFCCAParameter* pstTheParamter;
	if(uctype == 1){
		strItemName	=	"afcsframiddle";
		itemshareData.itemparameterLock.lockForRead();
		if(!bupdate && itemshareData.sfrmiddleafcParameter) { itemshareData.itemparameterLock.unlock(); return 0; }

		itemshareData.itemparameterLock.unlock();
		itemshareData.itemparameterLock.lockForWrite();
		if(!itemshareData.sfrmiddleafcParameter)	itemshareData.sfrmiddleafcParameter		=	new _SFRAFCCAParameter;
		if(!itemshareData.sfrmiddleafcParameter) {	itemshareData.itemparameterLock.unlock(); return HisFX3Error_MallocBuffer; }
		pstTheParamter	=	itemshareData.sfrmiddleafcParameter;
	}
	else if(uctype == 2){
		strItemName	=	"afcsfrafar";
		itemshareData.itemparameterLock.lockForRead();
		if(!bupdate && itemshareData.sfrfarafcParameter) { itemshareData.itemparameterLock.unlock(); return 0; }

		itemshareData.itemparameterLock.unlock();
		itemshareData.itemparameterLock.lockForWrite();
		if(!itemshareData.sfrfarafcParameter)	itemshareData.sfrfarafcParameter		=	new _SFRAFCCAParameter;
		if(!itemshareData.sfrfarafcParameter) {	itemshareData.itemparameterLock.unlock(); return HisFX3Error_MallocBuffer; }
		pstTheParamter	=	itemshareData.sfrfarafcParameter;
	}
	else{
		strItemName	=	"afcsfranear";
		itemshareData.itemparameterLock.lockForRead();
		if(!bupdate && itemshareData.sfrnearafcParameter) { itemshareData.itemparameterLock.unlock(); return 0; }

		itemshareData.itemparameterLock.unlock();
		itemshareData.itemparameterLock.lockForWrite();
		if(!itemshareData.sfrnearafcParameter)		itemshareData.sfrnearafcParameter		=	new _SFRAFCCAParameter;
		if(!itemshareData.sfrnearafcParameter) {	itemshareData.itemparameterLock.unlock(); return HisFX3Error_MallocBuffer; }
		pstTheParamter	=	itemshareData.sfrnearafcParameter;
	}

	pstTheParamter->vectorSFRItem.clear();
	QMutexLocker locker(&hisglobalparameter.mutexDatabase);

	bool bparsesuccess	=	true, bItemExist = false;

	//读取，解析config
	for(int  w=0;	w<1;	++w){ //此处是有意义的,不要删除
		QSqlDatabase customdb = QSqlDatabase::addDatabase("QSQLITE", "querycustom");
		customdb.setDatabaseName(QDir::currentPath() % "/HisFX3Custom");
		if (!customdb.open()){
			bparsesuccess	=	false;
			break;
		}

		QString strData, strdata2;
		QStringList strname, strvalue;
		QSqlQuery query(customdb);
		query.prepare("SELECT itemsuffix2,key,value,reserve FROM " % itemshareData.currentTableName % \
			" WHERE classfy='algorithm' AND item='" % strItemName % "' AND itemsuffix1='basic' ORDER BY id ASC" );
		query.exec();

		//classfy = algorithm, item = afcsfrafar itemsuffix1=basic,fovitem,statics
		/************basic**************/
		//(method:0)(channel:y)(fovoffset:100)(sidemin:60)(sidemax:120)(mincontrast:20)(weight:1.0)
		//(roiw:48)(roih:64)(usefreq2:true)(freq1:4)(freq2:8)(onlyinner:false)
		//(mtf50h:0.0)(mtf50v:0.0)
		//(f1spech:0.0)(f1specv:0.0)(f2spech:0.0)(f2specv:0.0)
		while (query.next()){
			bItemExist = true;
			for(int y=0;	y<4;	++y){
				strData	=	query.value(y).toString();
				ROPLOW::patchconfigstring(strData, strname, strvalue);
				for(int x=0;	x<strname.size();	++x){
					if(strname.at(x) == "method")	pstTheParamter->stSFRBasic.ucMethod	=	strvalue.at(x).toInt();
					else if(strname.at(x) == "fovoffset")	pstTheParamter->stSFRBasic.usFOVOffset	=	strvalue.at(x).toInt();
					else if(strname.at(x) == "sidemin")	pstTheParamter->stSFRBasic.usMarkSideMin	=	strvalue.at(x).toInt();
					else if(strname.at(x) == "sidemax")	pstTheParamter->stSFRBasic.usMarkSideMax	=	strvalue.at(x).toInt();
					else if(strname.at(x) == "mincontrast")	pstTheParamter->stSFRBasic.ucMinCantrast	=	strvalue.at(x).toInt();
					else if(strname.at(x) == "roiw")	pstTheParamter->stSFRBasic.iROIWidth	=	strvalue.at(x).toInt();
					else if(strname.at(x) == "roih")	pstTheParamter->stSFRBasic.iROIHeght	=	strvalue.at(x).toInt();
					else if(strname.at(x) == "freq1")	pstTheParamter->stSFRBasic.uc1stFreq	=	strvalue.at(x).toInt();
					else if(strname.at(x) == "freq2")	pstTheParamter->stSFRBasic.uc2ndFreq	=	strvalue.at(x).toInt();
					else if(strname.at(x) == "onlyinner") pstTheParamter->stSFRBasic.bOnlyInner = (strvalue.at(x) == "true");
					else if(strname.at(x) == "weight")	pstTheParamter->stSFRBasic.flCenterWeight	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "mtf50h")	pstTheParamter->stSFRBasic.flCenterMTF50SpecH	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "mtf50v")	pstTheParamter->stSFRBasic.flCenterMTF50SpecV	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "f1spech")	pstTheParamter->stSFRBasic.flCenter1stFreqSpecH	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "f1specv")	pstTheParamter->stSFRBasic.flCenter1stFreqSpecV	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "f2spech")	pstTheParamter->stSFRBasic.flCenter2ndFreqSpecH	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "f2specv")	pstTheParamter->stSFRBasic.flCenter2ndFreqSpecV	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "usefreq2") pstTheParamter->stSFRBasic.b2ndFreq	=	(strvalue.at(x) == "true");
					else if(strname.at(x) == "channel")	{
						if(strvalue.at(x) == "r")		pstTheParamter->stSFRBasic.ucChannel	=	_HisCCMAlg_ImageBuffer_Channel_R;
						else if(strvalue.at(x) == "g")		pstTheParamter->stSFRBasic.ucChannel	=	_HisCCMAlg_ImageBuffer_Channel_Gr;
						else if(strvalue.at(x) == "b")		pstTheParamter->stSFRBasic.ucChannel	=	_HisCCMAlg_ImageBuffer_Channel_B;
						else pstTheParamter->stSFRBasic.ucChannel	=	_HisCCMAlg_ImageBuffer_Channel_Y;
					}
				}
			}
		}

		query.prepare("SELECT itemsuffix2,key,value,reserve FROM " % itemshareData.currentTableName % \
			" WHERE classfy='algorithm' AND item='" % strItemName % "' AND itemsuffix1='fovitem' ORDER BY id ASC" );
		query.exec();
		/************fovitem**************/
		//(blockcount:4)(fov:0.3)(angle:0)(weight:1.0)
		//(mtf50h:0.0)(mtf50v:0.0)(mtf50u:0.0)
		//(f1spech:0.0)(f1specv:0.0)(f1specu:0.0)
		//(f2spech:0.0)(f2specv:0.0)(f2specu:0.0)
		while (query.next()){
			bItemExist = true;
			_HisCCMAlg_SFRPlusHAItem_Info stcircleitem;
			for(int y=0;	y<4;	++y){
				strData	=	query.value(y).toString();
				ROPLOW::patchconfigstring(strData, strname, strvalue);
				for(int x=0;	x<strname.size();	++x){
					if(strname.at(x) == "fov")	 stcircleitem.flFOV	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "blockcount")	 stcircleitem.ucBlockCount	=	strvalue.at(x).toUInt() & 0xFF;
					else if(strname.at(x) == "weight")	 stcircleitem.flWeight	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "angle")		stcircleitem.flAngle		=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "mtf50h")	 stcircleitem.flMTF50SpecH		=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "mtf50v")	 stcircleitem.flMTF50SpecV		=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "mtf50u")	 stcircleitem.flMTF50SpecUnifH	=stcircleitem.flMTF50SpecUnifV	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "f1spech")	 stcircleitem.fl1stFreqSpecH		=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "f1specv")	 stcircleitem.fl1stFreqSpecV		=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "f1specu")	 stcircleitem.fl1stFreqSpecUnifH = stcircleitem.fl1stFreqSpecUnifV		=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "f2spech")	 stcircleitem.fl2ndFreqSpecH		=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "f2specv")	 stcircleitem.fl2ndFreqSpecV		=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "f2specu")	 stcircleitem.fl2ndFreqSpecUnifH	= stcircleitem.fl2ndFreqSpecUnifV	=	strvalue.at(x).toFloat();
				}
			}

			pstTheParamter->vectorSFRItem.push_back(stcircleitem);	
		}


		query.prepare("SELECT itemsuffix2,key,value,reserve FROM " % itemshareData.currentTableName % \
			" WHERE classfy='algorithm' AND item='" % strItemName % "' AND itemsuffix1='statics' ORDER BY id ASC" );
		query.exec();
		/************statics**************/
		//(tactics:0)(usedb:true)(maxstep:10)(stepdelay:500)(valuechoose:0)(valuetype:0)
		//(motorstart:0)(motorend:1023)(motormin:0)(motormax:1023)(bigstep:20)(middlestep:10)(smallstep:5)
		//(curvedef:0.2)(falloffdef:0.1)(linearback:true)
		while (query.next()){
			bItemExist = true;
			for(int y=0;	y<4;	++y){
				strData	=	query.value(y).toString();
				ROPLOW::patchconfigstring(strData, strname, strvalue);
				for(int x=0;	x<strname.size();	++x){
					if(strname.at(x) == "tactics")	 pstTheParamter->stTacticsBasic.ucTactics	=	strvalue.at(x).toInt();
					else if(strname.at(x) == "maxstep")	 pstTheParamter->stTacticsBasic.usMaxSteps	=	strvalue.at(x).toInt();
					else if(strname.at(x) == "stepdelay")	 pstTheParamter->stTacticsBasic.usStepDelay	=	strvalue.at(x).toInt();
					else if(strname.at(x) == "valuechoose")	 pstTheParamter->stTacticsBasic.ucValueChoose	=	strvalue.at(x).toInt();
					else if(strname.at(x) == "valuetype")	 pstTheParamter->stTacticsBasic.ucValueTypeChoose	=	strvalue.at(x).toInt();
					else if(strname.at(x) == "motorstart")	 pstTheParamter->stTacticsBasic.sMotorStart	=	strvalue.at(x).toInt();
					else if(strname.at(x) == "motorend")	 pstTheParamter->stTacticsBasic.sMotorEnd	=	strvalue.at(x).toInt();
					else if(strname.at(x) == "motormin")	 pstTheParamter->stTacticsBasic.sMotorSpecMin	=	strvalue.at(x).toInt();
					else if(strname.at(x) == "motormax")	 pstTheParamter->stTacticsBasic.sMotorSpecMax	=	strvalue.at(x).toInt();
					else if(strname.at(x) == "bigstep")	 pstTheParamter->stTacticsBasic.ucBigStep	=	strvalue.at(x).toInt();
					else if(strname.at(x) == "middlestep")	 pstTheParamter->stTacticsBasic.ucMiddleStep	=	strvalue.at(x).toInt();
					else if(strname.at(x) == "smallstep")	 pstTheParamter->stTacticsBasic.ucSmallStep	=	strvalue.at(x).toInt();
					else if(strname.at(x) == "curvedef")	 pstTheParamter->stTacticsBasic.flCurveValidDef	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "falloffdef")	 pstTheParamter->stTacticsBasic.flCurveFalloffDef	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "usedb") pstTheParamter->stTacticsBasic.bDataBase = (strvalue.at(x) == "true");
					else if(strname.at(x) == "fitting") pstTheParamter->stTacticsBasic.bCurveFitting = (strvalue.at(x) == "true");
					else if(strname.at(x) == "linearback") pstTheParamter->stTacticsBasic.bLinearBack = (strvalue.at(x) == "true");
				}
			}
		}

		customdb.close();
	}

	QSqlDatabase::removeDatabase("querycustom");
	if(!bparsesuccess || !bItemExist){
		if(uctype == 0) {HisReleaseNewO(itemshareData.sfrnearafcParameter);}
		else if(uctype == 1) {HisReleaseNewO(itemshareData.sfrmiddleafcParameter);}
		else {HisReleaseNewO(itemshareData.sfrfarafcParameter);}
		itemshareData.itemparameterLock.unlock();
		return HisFX3Error_Parameter;
	}

	if(!bcheck) {itemshareData.itemparameterLock.unlock(); return 0; }

	if(pstTheParamter->stSFRBasic.iROIWidth < 16){
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("参数错误： ROI宽不能 < 16"));
		if(uctype == 0) {HisReleaseNewO(itemshareData.sfrnearafcParameter);}
		else if(uctype == 1) {HisReleaseNewO(itemshareData.sfrmiddleafcParameter);}
		else {HisReleaseNewO(itemshareData.sfrfarafcParameter);}
		itemshareData.itemparameterLock.unlock();
		return HisFX3Error_Parameter;
	}

	if(pstTheParamter->stSFRBasic.iROIWidth >= pstTheParamter->stSFRBasic.iROIHeght){
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("参数错误： ROI宽必须 < ROI高"));
		if(uctype == 0) {HisReleaseNewO(itemshareData.sfrnearafcParameter);}
		else if(uctype == 1) {HisReleaseNewO(itemshareData.sfrmiddleafcParameter);}
		else {HisReleaseNewO(itemshareData.sfrfarafcParameter);}
		itemshareData.itemparameterLock.unlock();
		return HisFX3Error_Parameter;
	}

	pstTheParamter->stSFRBasic.iROIWidth	=	((pstTheParamter->stSFRBasic.iROIWidth >>2) <<2);
	pstTheParamter->stSFRBasic.iROIHeght	=	((pstTheParamter->stSFRBasic.iROIHeght >>2) <<2);
	if(pstTheParamter->stSFRBasic.iROIWidth == pstTheParamter->stSFRBasic.iROIHeght) pstTheParamter->stSFRBasic.iROIHeght += 4;

	if(pstTheParamter->stTacticsBasic.ucTactics == _HisCCMAlg_Rolongo_AFC_Tactics_Linear || \
		pstTheParamter->stTacticsBasic.ucTactics == _HisCCMAlg_Rolongo_AFC_Tactics_Single)
		pstTheParamter->stTacticsBasic.bDataBase=	false;

	std::sort(pstTheParamter->vectorSFRItem.begin(), pstTheParamter->vectorSFRItem.end(), sort_sfraitem_fov);
	pstTheParamter->stSFRBasic.flGradeMultiple	=	1.0f;
	itemshareData.itemparameterLock.unlock();
	return 0;
}

int itemprocess::sfrAFCCA(unsigned char uctype, int iNewStactics, int& iOldStatics)
{
	_CODE_CLEAR_IMAGEDRAW

		bool bGetDB	=	false;
	if((uctype == 0 && itemshareData.sfrnearafcParameter == NULL) || \
		(uctype == 1 && itemshareData.sfrmiddleafcParameter == NULL) || \
		(uctype == 2 && itemshareData.sfrfarafcParameter == NULL)) bGetDB = true;

	int iresult	=	getsfrAFCCAParameter(uctype, false);
	if(iresult)	return iresult;
	if(iresult = getccmhardwareParameter(false))	return iresult;

	unsigned char* pucBufRaw = NULL, *pucBufY = NULL;
	float* pflSFRBlock	=	NULL;
	double* pdflsfrvalue	=	NULL;
	_HisCCMAlg_AFC_SFRHA_DB* pstAFCSFRDB;
	_SFRAFCCAParameter* pstParameter;
	if(uctype == 1)	{
		pstParameter	=	itemshareData.sfrmiddleafcParameter;
		pstAFCSFRDB	=	&stAFCSFRHAMiddleDB;
	}
	else if(uctype == 2) {
		pstParameter = itemshareData.sfrfarafcParameter;
		pstAFCSFRDB	=	&stAFCSFRHAFarDB;
	}
	else {
		pstParameter	=	itemshareData.sfrnearafcParameter;
		pstAFCSFRDB	=	&stAFCSFRHANearDB;
	}

	if(iNewStactics >= _HisCCMAlg_Rolongo_AFC_Tactics_PASS && iNewStactics <= _HisCCMAlg_Rolongo_AFC_Tactics_Inflexion){
		iOldStatics	=	pstParameter->stTacticsBasic.ucTactics;
		pstParameter->stTacticsBasic.ucTactics	=	iNewStactics;
	}

	if(bGetDB && pstParameter->stTacticsBasic.bDataBase){
		if(iresult = ROPLOW::AFCSFRHAFromDB(uctype, pstParameter, pstAFCSFRDB, bBoxChannel1)) return iresult;
	}

	itemshareData.itemparameterLock.lockForRead();

	emit information("db item: " % QString::number(pstAFCSFRDB->vectorItem.size()));
	std::vector<_HisCCMAlg_AFC_SFRHA_DB_Item>::iterator iteratordb;
	int iMotorPosNow	=	pstParameter->stTacticsBasic.sMotorStart;
	if(pstParameter->stTacticsBasic.bDataBase && pstAFCSFRDB->vectorItem.size() > 0){
		iMotorPosNow	=	0;
		for(iteratordb = pstAFCSFRDB->vectorItem.begin(); iteratordb != pstAFCSFRDB->vectorItem.end(); iteratordb++){
			iMotorPosNow	+=	iteratordb->sMotorEnd;
		}
		iMotorPosNow	/=	pstAFCSFRDB->vectorItem.size();

		emit information("db motor: " % QString::number(iMotorPosNow));

		if(iresult = setMotor(itemshareData.ccmhardwareParameter->motortype.toAscii().data(), itemshareData.previewParameter->ucSlave, \
			itemshareData.ccmhardwareParameter->projectname.toAscii().data(), iMotorPosNow, globalFunPointer.ReadHisFX3IIC, globalFunPointer.WriteHisFX3IIC, globalFunPointer.SetHisFX3IICSpeed, globalFunPointer.PullHisFX3RESET, globalFunPointer.PullHisFX3PWND, \
			globalFunPointer.PageWriteHisFX3IIC, globalFunPointer.PageReadHisFX3IIC, globalFunPointer.HisFX3PageWriteSPI, globalFunPointer.HisFX3PageReadSPI)) _CODE_AFC_SFRHA_EXIT1
			::Sleep(pstParameter->stTacticsBasic.usStepDelay);
	}
	else if(pstParameter->stTacticsBasic.ucTactics != _HisCCMAlg_Rolongo_AFC_Tactics_Single){
		if(iresult = setMotor(itemshareData.ccmhardwareParameter->motortype.toAscii().data(), itemshareData.previewParameter->ucSlave, \
			itemshareData.ccmhardwareParameter->projectname.toAscii().data(), iMotorPosNow, globalFunPointer.ReadHisFX3IIC, globalFunPointer.WriteHisFX3IIC, globalFunPointer.SetHisFX3IICSpeed, globalFunPointer.PullHisFX3RESET, globalFunPointer.PullHisFX3PWND, \
			globalFunPointer.PageWriteHisFX3IIC, globalFunPointer.PageReadHisFX3IIC, globalFunPointer.HisFX3PageWriteSPI, globalFunPointer.HisFX3PageReadSPI)) _CODE_AFC_SFRHA_EXIT1
			::Sleep(pstParameter->stTacticsBasic.usStepDelay);
	}

	_HisFX3_BaylorMode emDataFormat =	itemshareData.previewParameter->ucDataFormat;
	int iImgWidth =	itemshareData.previewParameter->iWidth, iImgHeight =	itemshareData.previewParameter->iHeight;
	unsigned int uiRawImgSize		=	itemshareData.previewParameter->iWidth * itemshareData.previewParameter->iHeight *3;
	unsigned char ucFrameType		=	_FrameType_RGB24;
	switch (itemshareData.previewParameter->ucDataFormat){
	case HisBaylor10_BGGR:
	case HisBaylor12_BGGR:
	case HisBaylor8_BGGR:	emDataFormat	=	HisBaylor8_BGGR;	break;
	case HisBaylor10_RGGB:
	case HisBaylor12_RGGB:
	case HisBaylor8_RGGB:	emDataFormat	=	HisBaylor8_RGGB;	break;
	case HisBaylor10_GRBG:
	case HisBaylor12_GRBG:
	case HisBaylor8_GRBG:	emDataFormat	=	HisBaylor8_GRBG;	break;
	case HisBaylor10_GBRG:
	case HisBaylor12_GBRG:
	case HisBaylor8_GBRG:	emDataFormat	=	HisBaylor8_GBRG;	break;
	case HisBaylor10_MONO:
	case HisBaylor12_MONO:
	case HisBaylor8_MONO:	emDataFormat	=	HisBaylor8_MONO;	break;
	case HisRGB_RGB24:		break;
	default:
		uiRawImgSize		=	itemshareData.previewParameter->iWidth * itemshareData.previewParameter->iHeight *2;
		ucFrameType		=	_FrameType_Raw;
		break;
	}

	int isftcurvelen	=	pstParameter->stSFRBasic.iROIWidth +1;
	float flmtf50;
	unsigned int uiPixelSize	=	iImgWidth *iImgHeight;
	pucBufRaw		=	(unsigned char*)_aligned_malloc(uiRawImgSize, _HisCacheLine_Aligned);
	pucBufY			=	(unsigned char*)_aligned_malloc(uiPixelSize, _HisCacheLine_Aligned);
	pflSFRBlock	=	(float*)_aligned_malloc(pstParameter->stSFRBasic.iROIWidth *pstParameter->stSFRBasic.iROIHeght *sizeof(float), _HisCacheLine_Aligned);
	pdflsfrvalue		=	(double*)_aligned_malloc(isftcurvelen *sizeof(double), _HisCacheLine_Aligned);
	if(!(pucBufRaw && pucBufY && pflSFRBlock && pdflsfrvalue)){
		HisReleaseMalloc(pucBufY);
		HisReleaseMalloc(pucBufRaw);
		HisReleaseMalloc(pflSFRBlock);
		HisReleaseMalloc(pdflsfrvalue);
		itemshareData.itemparameterLock.unlock();
		return HisFX3Error_MallocBuffer;
	}

	std::vector<_itemDraw> vectorDraw;
	vectorDraw.reserve(300);
	std::vector<_itemDraw>::iterator iteratorDraw;
	std::vector<_HisCCMAlg_AFC_SFRHA_DataItem> vectorItemData;
	vectorItemData.reserve(30);
	std::vector<_HisCCMAlg_AFC_SFRHA_DataItem>::iterator iteratorItemData;
	std::vector<_SFRBlackItem> vecPos;
	vecPos.reserve(400);
	std::vector<_SFRBlackROI4> vecFOVROI;
	vecFOVROI.reserve(13);
	std::vector<_SFRBlackROI4>::iterator iteratorFOVROI;

	bool bUseYUV_Y	=	(emDataFormat>=HisYUV8_422_YUYV && emDataFormat<=HisYUV8_422_VYUY && pstParameter->stSFRBasic.ucChannel==_HisCCMAlg_ImageBuffer_Channel_Y)?(true):(false);
	float* pflValue1, *pflValue2, *pflValue3;
	RECT* pstBlock;

	_HisCCMAlg_AFC_Linear_Result stLinearResult;
	bool bNext;

	for(unsigned int uistepcount=0; uistepcount < pstParameter->stTacticsBasic.usMaxSteps && hisglobalparameter.getrunflag() && threadshareData.GetHisPreviewflag(); ++uistepcount){
		if(iresult	=	GetFreshframe(pucBufRaw, uiRawImgSize, ucFrameType, !uistepcount)) break;
		if(emDataFormat >= HisYUV8_422_YUYV && emDataFormat <= HisYUV8_422_VYUY)
			classAlgorithm.extactYfromYUV422U8(pucBufRaw, pucBufY, iImgWidth*iImgHeight, emDataFormat); //抽取Y通道
		else{ //抽取G通道作为Y通道
			unsigned char* pucSrc = pucBufRaw + 1, *pucDes = pucBufY;
			for(unsigned int x=0;	x<uiPixelSize;	++x){
				*pucDes	=	*pucSrc;
				++pucDes;
				pucSrc	+=	3;
			}
		}

		ROPLOW::AFCSFRHAItemDataInitial(vectorItemData, pstParameter, iMotorPosNow);
		iteratorItemData	=	vectorItemData.end() - 1;

		vectorDraw.clear();
		vecFOVROI.clear();
		bNext	=	true;
		if(iresult = classAlgorithm.decodeSFRChartTAHA(pucBufY, iImgWidth, iImgHeight, pstParameter->stSFRBasic.usMarkSideMin, \
			pstParameter->stSFRBasic.usMarkSideMax, vecPos)){
				emit information(QTextCodec::codecForName( "GBK")->toUnicode("无法提取出CHART轮廓信息"));
				bNext	=	false;
		}

		if(vecPos.size() < 1){
			emit information(QTextCodec::codecForName( "GBK")->toUnicode("无法提取出CHART轮廓信息"));
			bNext	=	false;
		}

		if(bNext){
			//center
			vecFOVROI.clear();
			iresult = classAlgorithm.getSFRFOVPos(vecPos, iImgWidth, iImgHeight, 0.0f, 0.0f, pstParameter->stSFRBasic.iROIWidth, \
				pstParameter->stSFRBasic.iROIHeght, pstParameter->stSFRBasic.usFOVOffset, vecFOVROI);
			if(iresult){
				emit information(QTextCodec::codecForName( "GBK")->toUnicode("无法提取中心位置信息"));
				bNext	=	false;
			}
			else{
				iteratorFOVROI	=	vecFOVROI.begin();
				iteratorItemData->stCenterBlock	=	*iteratorFOVROI;
				for(unsigned int x=0;	x<4;	++x){
					switch (x){
					case 0: pstBlock = &(iteratorFOVROI->stLeft); pflValue1 = &(iteratorItemData->stSFRCenterMTF50.flValueH_L); \
								pflValue2 = &(iteratorItemData->stSFRCenterFreq1.flValueH_L); pflValue3 = &(iteratorItemData->stSFRCenterFreq2.flValueH_L); break;
					case 1: pstBlock = &(iteratorFOVROI->stRight); pflValue1 = &(iteratorItemData->stSFRCenterMTF50.flValueH_R); \
								pflValue2 = &(iteratorItemData->stSFRCenterFreq1.flValueH_R); pflValue3 = &(iteratorItemData->stSFRCenterFreq2.flValueH_R); break;
					case 2: pstBlock = &(iteratorFOVROI->stTop); pflValue1 = &(iteratorItemData->stSFRCenterMTF50.flValueV_T); \
								pflValue2 = &(iteratorItemData->stSFRCenterFreq1.flValueV_T); pflValue3 = &(iteratorItemData->stSFRCenterFreq2.flValueV_T); break;
					default: pstBlock = &(iteratorFOVROI->stBottom); pflValue1 = &(iteratorItemData->stSFRCenterMTF50.flValueV_B); \
								 pflValue2 = &(iteratorItemData->stSFRCenterFreq1.flValueV_B); pflValue3 = &(iteratorItemData->stSFRCenterFreq2.flValueV_B); break;
					}

					// 					emit information("left: " % QString::number(pstBlock->left) % "right: " % QString::number(pstBlock->right) % \
					//  						"top: " % QString::number(pstBlock->top) % "bottom: " % QString::number(pstBlock->bottom));

					if(bUseYUV_Y)	ROPLOW::GetPartYFromY(pucBufY, iImgWidth, iImgHeight, *pstBlock, pflSFRBlock);
					else ROPLOW::GetPartImageFromRGB24(pucBufRaw, iImgWidth, iImgHeight, pstParameter->stSFRBasic.ucChannel, *pstBlock, pflSFRBlock);
					classAlgorithm.HisCCMSFROne(pflSFRBlock, pstParameter->stSFRBasic.iROIWidth, pstParameter->stSFRBasic.iROIHeght, \
						pstParameter->stSFRBasic.ucMinCantrast, pdflsfrvalue, isftcurvelen, flmtf50);
					if(pstParameter->stSFRBasic.ucMethod == _His_SFR_Method_2Freq){
						if(isftcurvelen){
							*pflValue2	= ROPLOW::GetSFRFreqValue(pdflsfrvalue, isftcurvelen, pstParameter->stSFRBasic.uc1stFreq);
							if(pstParameter->stSFRBasic.b2ndFreq)
								*pflValue3	= ROPLOW::GetSFRFreqValue(pdflsfrvalue, isftcurvelen, pstParameter->stSFRBasic.uc2ndFreq);
						}					
					}
					else{
						*pflValue1	=	flmtf50;
					}
				}

				ROPLOW::AddDrawSFRHA(*iteratorFOVROI, iteratorItemData->stSFRCenterMTF50, iteratorItemData->stSFRCenterFreq1, \
					iteratorItemData->stSFRCenterFreq2, pstParameter, 0xFFFFFFFF, vectorDraw);
			}

			//FOV
			for(unsigned int w=0;	w<pstParameter->vectorSFRItem.size();	++w){
				vecFOVROI.clear();
				if(iresult = classAlgorithm.getSFRFOVPos(vecPos, iImgWidth, iImgHeight, pstParameter->vectorSFRItem.at(w).flFOV, \
					pstParameter->vectorSFRItem.at(w).flAngle, pstParameter->stSFRBasic.iROIWidth, pstParameter->stSFRBasic.iROIHeght, \
					pstParameter->stSFRBasic.usFOVOffset, vecFOVROI, pstParameter->vectorSFRItem.at(w).ucBlockCount, 0, pstParameter->stSFRBasic.bOnlyInner)){
						emit information(QTextCodec::codecForName( "GBK")->toUnicode("无法提取") % \
							QString::number(pstParameter->vectorSFRItem.at(w).flFOV, 'f', 2) % \
							QTextCodec::codecForName( "GBK")->toUnicode("FOV位置信息"));
						bNext	=	false;
				}
				else{
					iteratorFOVROI	=	vecFOVROI.begin();				
					for(unsigned int y=0;	y<pstParameter->vectorSFRItem.at(w).ucBlockCount;	++y)
					{				
						for(unsigned int x=0;	x<4;	++x){
							switch (x){
							case 0: pstBlock = &(iteratorFOVROI->stLeft); pflValue1 = &(iteratorItemData->vectorFOV.at(w).stSFRMTF50[y].flValueH_L); \
										pflValue2 = &(iteratorItemData->vectorFOV.at(w).stSFRFreq1[y].flValueH_L); pflValue3 = &(iteratorItemData->vectorFOV.at(w).stSFRFreq2[y].flValueH_L); break;
							case 1: pstBlock = &(iteratorFOVROI->stRight); pflValue1 = &(iteratorItemData->vectorFOV.at(w).stSFRMTF50[y].flValueH_R); \
										pflValue2 = &(iteratorItemData->vectorFOV.at(w).stSFRFreq1[y].flValueH_R); pflValue3 = &(iteratorItemData->vectorFOV.at(w).stSFRFreq2[y].flValueH_R); break;
							case 2: pstBlock = &(iteratorFOVROI->stTop); pflValue1 = &(iteratorItemData->vectorFOV.at(w).stSFRMTF50[y].flValueV_T); \
										pflValue2 = &(iteratorItemData->vectorFOV.at(w).stSFRFreq1[y].flValueV_T); pflValue3 = &(iteratorItemData->vectorFOV.at(w).stSFRFreq2[y].flValueV_T); break;
							default: pstBlock = &(iteratorFOVROI->stBottom); pflValue1 = &(iteratorItemData->vectorFOV.at(w).stSFRMTF50[y].flValueV_B); \
										 pflValue2 = &(iteratorItemData->vectorFOV.at(w).stSFRFreq1[y].flValueV_B); pflValue3 = &(iteratorItemData->vectorFOV.at(w).stSFRFreq2[y].flValueV_B); break;
							}

							if(pstParameter->stSFRBasic.bOnlyInner && !pstBlock->bottom){
								*pflValue1	=	*pflValue2	=	*pflValue3	=	10000.0f;
								continue;
							}

							// 							emit information("left: " % QString::number(pstBlock->left) % "right: " % QString::number(pstBlock->right) % \
							// 								"top: " % QString::number(pstBlock->top) % "bottom: " % QString::number(pstBlock->bottom));

							if(bUseYUV_Y)	ROPLOW::GetPartYFromY(pucBufY, iImgWidth, iImgHeight, *pstBlock, pflSFRBlock);
							else ROPLOW::GetPartImageFromRGB24(pucBufRaw, iImgWidth, iImgHeight, pstParameter->stSFRBasic.ucChannel, *pstBlock, pflSFRBlock);
							classAlgorithm.HisCCMSFROne(pflSFRBlock, pstParameter->stSFRBasic.iROIWidth, pstParameter->stSFRBasic.iROIHeght, \
								pstParameter->stSFRBasic.ucMinCantrast, pdflsfrvalue, isftcurvelen, flmtf50);
							if(pstParameter->stSFRBasic.ucMethod == _His_SFR_Method_2Freq){
								if(isftcurvelen){
									*pflValue2	= ROPLOW::GetSFRFreqValue(pdflsfrvalue, isftcurvelen, pstParameter->stSFRBasic.uc1stFreq);
									if(pstParameter->stSFRBasic.b2ndFreq)
										*pflValue3	= ROPLOW::GetSFRFreqValue(pdflsfrvalue, isftcurvelen, pstParameter->stSFRBasic.uc2ndFreq);
								}					
							}
							else{
								*pflValue1	=	flmtf50;
							}
						}

						ROPLOW::AddDrawSFRHA(*iteratorFOVROI, iteratorItemData->vectorFOV.at(w).stSFRMTF50[y], iteratorItemData->vectorFOV.at(w).stSFRFreq1[y], \
							iteratorItemData->vectorFOV.at(w).stSFRFreq2[y], pstParameter, w, vectorDraw);
						iteratorItemData->vectorFOV.at(w).stBlock[y]	=	*iteratorFOVROI;
						iteratorFOVROI++;
					}
				}
			}

		}

		_CODE_RJAFA_LP_ASIGNDRAW

			iresult = classAlgorithm.HisAFCTactics_SFRHA_DB_HA(pstParameter->stTacticsBasic, vectorItemData, *pstAFCSFRDB, iMotorPosNow);	
		if(iresult)	break;
		emit information("next motor: " % QString::number(iMotorPosNow));

		if(iMotorPosNow == 0x00FFFFFF){
			iresult	=	0;
			break;
		}

		if(iresult = setMotor(itemshareData.ccmhardwareParameter->motortype.toAscii().data(), itemshareData.previewParameter->ucSlave, \
			itemshareData.ccmhardwareParameter->projectname.toAscii().data(), iMotorPosNow, globalFunPointer.ReadHisFX3IIC, globalFunPointer.WriteHisFX3IIC, globalFunPointer.SetHisFX3IICSpeed, globalFunPointer.PullHisFX3RESET, globalFunPointer.PullHisFX3PWND, \
			globalFunPointer.PageWriteHisFX3IIC, globalFunPointer.PageReadHisFX3IIC, globalFunPointer.HisFX3PageWriteSPI, globalFunPointer.HisFX3PageReadSPI)) break;
		::Sleep(pstParameter->stTacticsBasic.usStepDelay);

		if(pstParameter->stTacticsBasic.ucTactics != _HisCCMAlg_Rolongo_AFC_Tactics_Single || \
			pstParameter->stTacticsBasic.ucTactics != _HisCCMAlg_Rolongo_AFC_Tactics_PASS){
				itemshareData.plotLock.lockForWrite();
				ROPLOW::fillSFRFABarChartDrawInfo(itemshareData.vecBarChartItem, *(vectorItemData.end()-1), &(pstParameter->stSFRBasic), iImgWidth, iImgHeight, pstParameter->stSFRBasic.flGradeMultiple);
				itemshareData.dflBarChartYMin		=	0.0;
				itemshareData.dflBarChartYMax	=	0.5;
				itemshareData.plotLock.unlock();
				emit plotpainter(1);
		}
		else if(pstParameter->stTacticsBasic.ucTactics != _HisCCMAlg_Rolongo_AFC_Tactics_Linear){
			itemshareData.plotLock.lockForWrite();
			ROPLOW::curveSFRAFCCurveDraw(itemshareData.vecCurvePoint, itemshareData.vecCurveLineColor, itemshareData.vecCurveLegend, \
				vectorItemData, pstParameter, iImgWidth, iImgHeight);
			itemshareData.dflCurveYMin		=	0.0;
			itemshareData.dflCurveYMax	=	0.5;
			itemshareData.dflCurveXMin		=	pstParameter->stTacticsBasic.sMotorStart;
			itemshareData.dflCurveXMax		=	pstParameter->stTacticsBasic.sMotorEnd;
			itemshareData.bCurveXScaleAuto	=	false;
			itemshareData.ucCurveType			=	2;
			itemshareData.plotLock.unlock();
			emit plotpainter(2);
		}
		else{
			itemshareData.plotLock.lockForWrite();
			ROPLOW::curveSFRAFCCurveDraw(itemshareData.vecCurvePoint, itemshareData.vecCurveLineColor, itemshareData.vecCurveLegend, \
				vectorItemData, pstParameter, iImgWidth, iImgHeight);
			itemshareData.dflCurveYMin		=	0.0;
			itemshareData.dflCurveYMax	=	0.5;
			itemshareData.dflCurveXMin		=	pstParameter->stTacticsBasic.sMotorStart;
			itemshareData.dflCurveXMax		=	pstParameter->stTacticsBasic.sMotorEnd;
			itemshareData.bCurveXScaleAuto	=	false;
			itemshareData.ucCurveType			=	1;
			itemshareData.plotLock.unlock();
			emit plotpainter(2);
		}
	}

	if(pstParameter->stTacticsBasic.ucTactics == _HisCCMAlg_Rolongo_AFC_Tactics_Single || \
		pstParameter->stTacticsBasic.ucTactics == _HisCCMAlg_Rolongo_AFC_Tactics_PASS){
			itemshareData.plotLock.lockForWrite();
			ROPLOW::fillSFRFABarChartDrawInfo(itemshareData.vecBarChartItem, *(vectorItemData.end()-1), &(pstParameter->stSFRBasic), iImgWidth, iImgHeight, pstParameter->stSFRBasic.flGradeMultiple);
			itemshareData.dflBarChartYMin		=	0.0;
			itemshareData.dflBarChartYMax	=	0.5;
			itemshareData.plotLock.unlock();
			emit plotpainter(1);
	}
	else if(pstParameter->stTacticsBasic.ucTactics == _HisCCMAlg_Rolongo_AFC_Tactics_Linear){
		itemshareData.plotLock.lockForWrite();
		ROPLOW::curveSFRAFCCurveDraw(itemshareData.vecCurvePoint, itemshareData.vecCurveLineColor, itemshareData.vecCurveLegend, \
			vectorItemData, pstParameter, iImgWidth, iImgHeight);
		itemshareData.dflCurveYMin		=	0.0;
		itemshareData.dflCurveYMax	=	0.5;
		itemshareData.dflCurveXMin		=	pstParameter->stTacticsBasic.sMotorStart;
		itemshareData.dflCurveXMax		=	pstParameter->stTacticsBasic.sMotorEnd;
		itemshareData.bCurveXScaleAuto	=	false;
		itemshareData.ucCurveType			=	2;
		itemshareData.plotLock.unlock();
		emit plotpainter(2);
	}
	else{
		itemshareData.plotLock.lockForWrite();
		ROPLOW::curveSFRAFCCurveDraw(itemshareData.vecCurvePoint, itemshareData.vecCurveLineColor, itemshareData.vecCurveLegend, \
			vectorItemData, pstParameter, iImgWidth, iImgHeight);
		itemshareData.dflCurveYMin		=	0.0;
		itemshareData.dflCurveYMax	=	0.5;
		itemshareData.dflCurveXMin		=	pstParameter->stTacticsBasic.sMotorStart;
		itemshareData.dflCurveXMax		=	pstParameter->stTacticsBasic.sMotorEnd;
		itemshareData.bCurveXScaleAuto	=	false;
		itemshareData.ucCurveType			=	1;
		itemshareData.plotLock.unlock();
		emit plotpainter(2);
	}

	unsigned int uiSaveIndex	=	0xFFFFFFFF;
	float flMaxWeightValue	=	-10.0f;
	bool bTempResult	=	false;
	for(unsigned int x=0;	x<vectorItemData.size(); ++x){
		if(vectorItemData.at(x).ucFlag == 0x1){
			uiSaveIndex	=	x;
			break;
		}
		else if(bTempResult){
			if(vectorItemData.at(x).ucStatus == 0x1 && vectorItemData.at(x).flWeightValue > flMaxWeightValue){
				flMaxWeightValue	=	vectorItemData.at(x).flWeightValue;
				uiSaveIndex				=	x;
			}
		}
		else{
			if(vectorItemData.at(x).ucStatus == 0x1 || vectorItemData.at(x).flWeightValue > flMaxWeightValue){
				flMaxWeightValue	=	vectorItemData.at(x).flWeightValue;
				uiSaveIndex				=	x;
				bTempResult			=	(vectorItemData.at(x).ucStatus == 0x1);
			}
		}
	}

	if(vectorItemData.at(uiSaveIndex).ucStatus == 0x0)	iresult	=	HisCCMError_NoFocusStep;

	if(uiSaveIndex != 0xFFFFFFFF && uiSaveIndex != vectorItemData.size() - 1){
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("马达运动到最优点:") % QString::number(vectorItemData.at(uiSaveIndex).sMotorStep));
		int iresult2 = iresult;
		if(iresult = setMotor(itemshareData.ccmhardwareParameter->motortype.toAscii().data(), itemshareData.previewParameter->ucSlave, \
			itemshareData.ccmhardwareParameter->projectname.toAscii().data(), vectorItemData.at(uiSaveIndex).sMotorStep, globalFunPointer.ReadHisFX3IIC, globalFunPointer.WriteHisFX3IIC, globalFunPointer.SetHisFX3IICSpeed, globalFunPointer.PullHisFX3RESET, globalFunPointer.PullHisFX3PWND, \
			globalFunPointer.PageWriteHisFX3IIC, globalFunPointer.PageReadHisFX3IIC, globalFunPointer.HisFX3PageWriteSPI, globalFunPointer.HisFX3PageReadSPI)) 
			_CODE_AFC_SFRHA_EXIT1
			iresult = iresult2;

		vectorDraw.clear();
		ROPLOW::AddDrawSFRHA(vectorItemData.at(uiSaveIndex).stCenterBlock, vectorItemData.at(uiSaveIndex).stSFRCenterMTF50, vectorItemData.at(uiSaveIndex).stSFRCenterFreq1, \
			vectorItemData.at(uiSaveIndex).stSFRCenterFreq2, pstParameter, 0xFFFFFFFF, vectorDraw);
		for(unsigned int w=0;	w<pstParameter->vectorSFRItem.size(); ++w){
			for(unsigned int y=0;	y<pstParameter->vectorSFRItem.at(w).ucBlockCount;	++y){
				ROPLOW::AddDrawSFRHA(vectorItemData.at(uiSaveIndex).vectorFOV.at(w).stBlock[y], vectorItemData.at(uiSaveIndex).vectorFOV.at(w).stSFRMTF50[y], \
					vectorItemData.at(uiSaveIndex).vectorFOV.at(w).stSFRFreq1[y], vectorItemData.at(uiSaveIndex).vectorFOV.at(w).stSFRFreq2[y], pstParameter, w, vectorDraw);
			}
		}
		_CODE_RJAFA_LP_ASIGNDRAW
	}

	if(hisglobalparameter.bDebugMode && vectorItemData.size() > 1){
		QString strSerialNumber;
		classLog->getserialnumber(strSerialNumber);
		if(strSerialNumber.isEmpty()) strSerialNumber = "SFR AFCCurve";
		strSerialNumber	=	QDir::currentPath() % "/" % strSerialNumber;
		if(uctype == 0) strSerialNumber = strSerialNumber % " SFR AFC Near Curve.csv";
		else if(uctype == 1) strSerialNumber = strSerialNumber % " SFR AFC Middle Curve.csv";
		else strSerialNumber = strSerialNumber % " SFR AFC Far Curve.csv";
		ROPLOW::saveSFRHAAFCCurve2File(vectorItemData, pstParameter, strSerialNumber);
	}

	if(iresult){
		ROPLOW::saveSHRHAAFCResult(uctype, false, uiSaveIndex, vectorItemData, pstParameter, *classLog, iImgWidth, iImgHeight);
		_CODE_AFC_SFRHA_EXIT1
	}

	if(pstParameter->stTacticsBasic.ucTactics == _HisCCMAlg_Rolongo_AFC_Tactics_PEAK || \
		pstParameter->stTacticsBasic.ucTactics == _HisCCMAlg_Rolongo_AFC_Tactics_Inflexion){
			if(uctype == 0)	emit information(QTextCodec::codecForName( "GBK")->toUnicode("近焦最优点马达坐标：") % QString::number(vectorItemData.at(uiSaveIndex).sMotorStep));
			else if(uctype == 1)	emit information(QTextCodec::codecForName( "GBK")->toUnicode("中焦最优点马达坐标：") % QString::number(vectorItemData.at(uiSaveIndex).sMotorStep));
			else emit information(QTextCodec::codecForName( "GBK")->toUnicode("远焦最优点马达坐标：") % QString::number(vectorItemData.at(uiSaveIndex).sMotorStep));

			if(vectorItemData.at(uiSaveIndex).sMotorStep < pstParameter->stTacticsBasic.sMotorSpecMin && \
				vectorItemData.at(uiSaveIndex).sMotorStep > pstParameter->stTacticsBasic.sMotorSpecMax){
					iresult	=	HisCCMError_Result;
					emit information(QTextCodec::codecForName( "GBK")->toUnicode("最优点点马达位置超出规格"));
					_CODE_AFC_SFRHA_EXIT1
			}

			if(uctype == 0)	iNearPeakMotorDec	=	vectorItemData.at(uiSaveIndex).sMotorStep;
			else if(uctype == 1)	iMiddlePeakMotorDec	=	vectorItemData.at(uiSaveIndex).sMotorStep;
			else iFarPeakMotorDec	=	vectorItemData.at(uiSaveIndex).sMotorStep;
	}
	else if(pstParameter->stTacticsBasic.ucTactics == _HisCCMAlg_Rolongo_AFC_Tactics_Linear){

	}

	ROPLOW::saveSHRHAAFCResult(uctype, !iresult, uiSaveIndex, vectorItemData, pstParameter, *classLog, iImgWidth, iImgHeight);

	if(pstParameter->stTacticsBasic.bDataBase && !iresult){
		ROPLOW::AFCSFRHAToDB(uctype, pstParameter, pstAFCSFRDB, vectorItemData, uiSaveIndex, bBoxChannel1);
	}

	_CODE_AFC_SFRHA_EXIT1
}



void itemprocess::DrawSFRHAAFCPointCurve(std::vector<_HisCCMAlg_AFC_SFRHA_DataItem>& vectorDataItem, \
	_SFRAFCCAParameter* pstParameter, bool bCenter, bool bFOV)
{
	const int ciTotalWidth		=	770;
	const int ciTotalHeight		=	220;
	QImage imageBackgound(ciTotalWidth, ciTotalHeight, QImage::Format_RGB888);
	imageBackgound.fill(QColor::fromRgb(240, 240, 240));
	const int ciTitleLeft			=	30;
	const int ciTitleBottom		=	20;

	QPainter painer(&imageBackgound);
	painer.setPen(Qt::SolidLine);
	QPen thePen	=	painer.pen();
	thePen.setWidth(3);
	thePen.setColor(QColor::fromRgb(0, 255, 0));
	painer.setPen(thePen);

	painer.drawLine(ciTitleLeft, 0, ciTitleLeft, ciTotalHeight- ciTitleBottom);
	painer.drawLine(ciTitleLeft, ciTotalHeight- ciTitleBottom, ciTotalWidth-1, ciTotalHeight- ciTitleBottom);

	float flYN1	=	ciTotalHeight - ciTitleBottom -4;
	float flXN1	=	(float)(ciTotalWidth - ciTitleLeft - 4) / (float)(pstParameter->stTacticsBasic.sMotorEnd - pstParameter->stTacticsBasic.sMotorStart);
	QPointF* pstPoint	=	new QPointF[vectorDataItem.size()];

	for(unsigned int x=0;	x<vectorDataItem.size(); ++x){
		pstPoint[x].setX((vectorDataItem.at(x).sMotorStep - pstParameter->stTacticsBasic.sMotorStart) *flXN1 + ciTitleLeft);
		pstPoint[x].setY(ciTotalHeight - ciTitleBottom - vectorDataItem.at(x).flWeightValue *flYN1);
	}

	thePen.setColor(QColor::fromRgb(0, 0, 0));
	thePen.setWidth(5);
	painer.setPen(thePen);
	painer.drawPoints(pstPoint, vectorDataItem.size());

	if(bCenter){

	}

	if(bFOV){

	}

	delete[] pstPoint; pstPoint = NULL;

	itemshareData.plotLock.lockForWrite();
	itemshareData.plotimage	=	imageBackgound;
	itemshareData.plotLock.unlock();
	emit plotpainter(0);
}

int itemprocess::getautoexposuredata(_autoExposreData *pstTheData)
{
	//tabletype
	//value0----group
	//value1----database table name
	//value2----create time
	//value3----config table name 
	//value4----database index
	//value5----block
	//value6----spec
	//value7----bchannel
	//value8----baverage

	QMutexLocker locker(&hisglobalparameter.mutexDBUser);

	pstTheData->usdatacount	=	0;
	pstTheData->uiidmax			=	0x0;
	pstTheData->uiidmin			=	0xFFFFFFFF;
	bool bparsesuccess	=	true;
	for(int w=0;	w<1;	++w){
		QSqlDatabase cdatadb = QSqlDatabase::addDatabase("QSQLITE", "querydata");
		cdatadb.setDatabaseName(QDir::currentPath() % "/HisFX3Data");
		if (!cdatadb.open()){
			bparsesuccess	=	false;
			break;
		}

		QString strTable = "autoexposure" % QString::number(pstTheData->unIndex);
		QString strSpec	=	QString::number(pstTheData->uimin) % "," % QString::number(pstTheData->uimax);
		QString strRoi	=	QString::number(pstTheData->stroi.left) % "," % QString::number(pstTheData->stroi.right) % \
			"," % QString::number(pstTheData->stroi.top) % "," % QString::number(pstTheData->stroi.bottom);
		QString strChannel	=	(pstTheData->bChannel_Gr)?("true"):("false");
		QString strAverage	=	(pstTheData->bAverage)?("true"):("false");

		QSqlQuery query(cdatadb);
		query.prepare("SELECT value3, value5, value6, value7, value8 FROM datatablemanage WHERE value1='" % strTable % "'");
		query.exec();

		bool bok;
		bool bproject	=	true;

		while (query.next()){
			if(pstTheData->strTableName != query.value(0).toString())	bproject	=	false;
			if(query.value(1).toString() != strRoi)			bproject	=	false;
			if(query.value(2).toString() != strSpec)		bproject	=	false;
			if(query.value(3).toString() != strChannel)	bproject	=	false;
			if(query.value(4).toString() != strAverage)	bproject	=	false;
			break;
		}

		if(bproject){
			query.prepare("SELECT id, firstet, firstlux, finalet, finallux FROM " % strTable % " ORDER BY id DESC");
			query.exec();

			unsigned __int32* piid				=	pstTheData->uiid;
			_autoexposureItem* tempae	=	pstTheData->stAEData;
			while (query.next() && pstTheData->usdatacount < _AE_DATA_MAX){
				*piid								=	query.value(0).toUInt(&bok);
				pstTheData->uiidmin	=	min(pstTheData->uiidmin, *piid);
				pstTheData->uiidmax	=	max(pstTheData->uiidmax, *piid);
				++piid;
				tempae->uifirstet			=	query.value(1).toUInt(&bok);
				tempae->flfirstlux		=	query.value(2).toFloat(&bok);
				tempae->uifinalet		=	query.value(3).toUInt(&bok);
				tempae->flfinallux		=	query.value(4).toFloat(&bok);
				tempae++;
				++(pstTheData->usdatacount);
			}
		}
		else{
			query.prepare("UPDATE datatablemanage SET value3=:value3, value5=:value5, value6=:value6, value7=:value7, value8=:value8 WHERE value1=:value1");
			query.bindValue(":value3", pstTheData->strTableName);
			query.bindValue(":value1", strTable);
			query.bindValue(":value5", strRoi);
			query.bindValue(":value6", strSpec);
			query.bindValue(":value7", strChannel);
			query.bindValue(":value8", strAverage);
			query.exec();

			query.prepare("DELETE FROM " % strTable);
			query.exec();
		}

		cdatadb.close();
	}

	QSqlDatabase::removeDatabase("querydata");
	if(!bparsesuccess)	return HisCCMError_Database;
	return 0;
}

int itemprocess::updateautoexposuredata(_autoExposreData *pstTheData, _autoexposureItem* newdata)
{
	QMutexLocker locker(&hisglobalparameter.mutexDBUser);

	bool bparsesuccess	=	true;
	for(int w=0;	w<1;	++w){
		QSqlDatabase cdatadb = QSqlDatabase::addDatabase("QSQLITE", "querydata");
		cdatadb.setDatabaseName(QDir::currentPath() % "/HisFX3Data");
		if (!cdatadb.open()){
			bparsesuccess	=	false;
			break;
		}

		QSqlQuery query(cdatadb);

		if(pstTheData->usdatacount >= _AE_DATA_MAX){
			QString strTable	=	"autoexposure" % QString::number(pstTheData->unIndex);
			++(pstTheData->uiidmax);

			query.prepare("UPDATE " % strTable % " SET id=:id, firstet=:firstet, firstlux=:firstlux, finalet=:finalet, finallux=:finallux WHERE id=:id2");
			query.bindValue(":id", pstTheData->uiidmax);
			query.bindValue(":firstet", newdata->uifirstet);
			query.bindValue(":firstlux", newdata->flfirstlux);
			query.bindValue(":finalet", newdata->uifinalet);
			query.bindValue(":finallux", newdata->flfinallux);
			query.bindValue(":id2", pstTheData->uiidmin);
			query.exec();

			unsigned __int32 uiid	=	pstTheData->uiidmin;
			unsigned __int32 * piid	=	pstTheData->uiid;
			for(unsigned int x=0;	x<pstTheData->usdatacount;	++x){
				if(*piid	==	uiid){
					pstTheData->stAEData[x]	=	*newdata;
					*piid										=	pstTheData->uiidmax;
					break;
				}
			}

			++(pstTheData->uiidmin);
		}
		else{
			QString strTable	=	"autoexposure" % QString::number(pstTheData->unIndex);
			unsigned __int32 uiid;
			if(pstTheData->usdatacount){
				++(pstTheData->uiidmax);
				uiid	=	pstTheData->uiidmax;
			}
			else{
				pstTheData->uiidmin	=	0;
				pstTheData->uiidmax	=	0;
				uiid									=	0;
			}

			pstTheData->stAEData[pstTheData->usdatacount]	=	*newdata;
			pstTheData->uiid[pstTheData->usdatacount]			=	uiid;
			++(pstTheData->usdatacount);

			query.prepare("INSERT INTO " % strTable % "(id,firstet,firstlux,finalet,finallux) VALUES(:id, :firstet, :firstlux, :finalet, :finallux)");
			query.bindValue(":id", uiid);
			query.bindValue(":firstet", newdata->uifirstet);
			query.bindValue(":firstlux", newdata->flfirstlux);
			query.bindValue(":finalet", newdata->uifinalet);
			query.bindValue(":finallux", newdata->flfinallux);
			query.exec();
		}

		cdatadb.close();
	}

	QSqlDatabase::removeDatabase("querydata");
	if(!bparsesuccess)	return HisCCMError_Database;
	return 0;
}


int itemprocess::QualcommAWBLSCGoldenSelection(unsigned int uimodulecount, unsigned int uiblacklevel, unsigned int uiroidivisor,unsigned int GChannelMin, unsigned int GChannelMax)
{
	//判断图像是否点亮
	if(!threadshareData.GetHisPreviewflag())	return HisCCMError_NotPreivew;
	if(uimodulecount<1 ) 
	{
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("挑选Golden模组数量没有设置"));
		return HisFX3Error_Parameter;
	}
	int iresult	=		getccmhardwareParameter(false);
	if(iresult)	return iresult;
	itemshareData.itemparameterLock.lockForRead();

	int iWidth=itemshareData.previewParameter->iWidth;
	int iHeight=itemshareData.previewParameter->iHeight;

	unsigned char* pRAW	=	(unsigned char*)_aligned_malloc(itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight , _HisCacheLine_Aligned);
	if(!pRAW){
		itemshareData.itemparameterLock.unlock();
		return HisFX3Error_MallocBuffer;
	}

	iresult = GetFreshframe(pRAW, itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight , _FrameType_Raw, true);
	if(iresult){
		HisReleaseMalloc(pRAW);
		itemshareData.itemparameterLock.unlock();
		return iresult;
	}

	int ix	=	iWidth/uiroidivisor;
	int iy	=	iHeight/uiroidivisor;
	ix		=	((ix >>1) <<1);
	iy		=	((iy >>1) <<1);

	RECT stCenterBlock;
	stCenterBlock.left			=	((iWidth- ix) >>1);
	stCenterBlock.top			=	((iHeight - iy) >>1);
	stCenterBlock.left			=	((stCenterBlock.left >> 1) <<1);
	stCenterBlock.top			=	((stCenterBlock.top >> 1) <<1);
	stCenterBlock.right		=	stCenterBlock.left + ix;
	stCenterBlock.bottom	=	stCenterBlock.top + iy;
	double dflCenterR, dflCenterB, dflCenterGr, dflCenterGb, dAWBRGr,dAWBBGr;
	ROPLOW::bylorraw8average(pRAW, iWidth, iHeight,itemshareData.previewParameter->ucDataFormat, \
		stCenterBlock, dflCenterR, dflCenterB, dflCenterGr, dflCenterGb);

	unsigned int uiGValue=unsigned int((dflCenterGr+dflCenterGb)/2.0f);
	if(uiGValue<GChannelMin ||uiGValue>GChannelMax)
	{
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("图像亮度不正确"));
		HisReleaseMalloc(pRAW);
		itemshareData.itemparameterLock.unlock();
		if(uiGValue<GChannelMin ) return HisCCMError_luxtooLow;
		if(uiGValue>GChannelMax) return HisCCMError_luxtooHigh;
	}

	dflCenterR		=	dflCenterR		-	uiblacklevel;
	dflCenterB		=	dflCenterB		-	uiblacklevel;
	dflCenterGr		=	dflCenterGr	-uiblacklevel;
	dflCenterGb		=	dflCenterGb	-uiblacklevel;
	dAWBRGr=dflCenterR/dflCenterGr;
	dAWBBGr=dflCenterB/dflCenterGr;
	emit information(QTextCodec::codecForName( "GBK")->toUnicode("R")%QString::number(dflCenterR,'f',3)%"Gr:"%QString::number(dflCenterGr,'f',3)%"Gb:"%QString::number(dflCenterGb,'f',3)%"B:"%QString::number(dflCenterB,'f',3));
	emit information(QTextCodec::codecForName( "GBK")->toUnicode("RG:")%QString::number(dAWBRGr,'f',3)%"BG:"%QString::number(dAWBBGr,'f',3));
	//
	emit information(QTextCodec::codecForName( "GBK")->toUnicode("执行Qualcomm库"));
	CalibrationDataStruct stCalData;
	ImageBlcokData stBlockData;
	iresult=ROPLOW::QualcommAWBLSCCaculation(pRAW,itemshareData.previewParameter->ucDataFormat, iWidth, iHeight,uiblacklevel,stCalData,stBlockData);
	if(iresult!=0)
	{
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("高通库执行失败"));
		HisReleaseMalloc(pRAW);
		itemshareData.itemparameterLock.unlock();
		return HisFX3Error_Parameter;
	}
	emit information(QTextCodec::codecForName( "GBK")->toUnicode("开始计算R Gr Gb B Shading值"));
	CalibrationprocessDataStruct stCalProcessData;
	memset(&stCalProcessData,0,sizeof(CalibrationprocessDataStruct));
	int iBlockSize=17*13;
	float fmaxRValue=0.0f,fmaxGrValue=0.0f,fmaxGbValue=0.0f,fmaxBValue=0.0f;

	for(int i=0;i<iBlockSize;i++)
	{
		if(stBlockData.R_LSC[i]>fmaxRValue) fmaxRValue=stBlockData.R_LSC[i];
		if(stBlockData.Gr_LSC[i]>fmaxGrValue) fmaxGrValue=stBlockData.Gr_LSC[i];
		if(stBlockData.Gb_LSC[i]>fmaxGbValue) fmaxGbValue=stBlockData.Gb_LSC[i];
		if(stBlockData.B_LSC[i]>fmaxBValue) fmaxBValue=stBlockData.B_LSC[i];
	}

	for(int i=0;i<iBlockSize;i++)
	{
		stCalProcessData.R_LSC[i]=stBlockData.R_LSC[i]/fmaxRValue;
		stCalProcessData.Gr_LSC[i]=stBlockData.Gr_LSC[i]/fmaxGrValue;
		stCalProcessData.Gb_LSC[i]=stBlockData.Gb_LSC[i]/fmaxGbValue;
		stCalProcessData.B_LSC[i]=stBlockData.B_LSC[i]/fmaxBValue;
	}

	stCalProcessData.AWB[0]=float(stCalData.AWB[0])/1023.0f;
	stCalProcessData.AWB[1]=float(stCalData.AWB[1])/1023.0f;
	//
	QDir  classDir;
	QString strlogPath	=	QDir::currentPath() % "/GoldenSelectlog";
	classDir.mkpath(strlogPath);
	QString strlogPath1	=	strlogPath % "/Qualcomm_AWBLSC_Data_"%(QDate::currentDate()).toString("yyyyMMdd")%".csv";
	QString strSerialNumber;
	classLog->getserialnumber(strSerialNumber);
	ROPLOW::savequalcomAWBLSCData(strSerialNumber,stCalData,stBlockData,strlogPath1);
	strlogPath1	=	strlogPath % "/Qualcomm_AWBLSC_ProcessData_"%(QDate::currentDate()).toString("yyyyMMdd")%".csv";
	ROPLOW::savequalcomAWBLSCprocessData(strSerialNumber,stCalProcessData,strlogPath1);
	itemshareData.itemparameterLock.unlock();
	return iresult;
}

int  itemprocess::AutoRAWCaputre(char * FileName, unsigned int CaptureCount, unsigned int uisleep,unsigned int ROIW, unsigned int ROIH, bool bSavelog)
{
	char cline[128]={0};
	char temp[128]={0};
	int iresult=0;
	int iCaptureIndex=0;
	int iCaptureIndexBefore=0;
	//unsigned char uSensorSlave=0x00;
	//unsignedint iRegaddr=0x0000;
	//unsignedint iRegData=0x0000;
	//unsigned short uRegType=0x1616;
	unsigned int iI2CIndex=0;
	unsigned short uI2CDelay=1000;
	unsigned char uSensorSlaveArrary[128]={0};
	unsigned int iRegaddrArrary[128]={0};
	unsigned int iRegDataArrary[128]={0};
	unsigned short uRegTypeArrary[128]={0};
	//判断图像是否点亮
	if(!threadshareData.GetHisPreviewflag())	return HisCCMError_NotPreivew;

	if(iresult	=	getccmhardwareParameter(false))	return iresult;
	itemshareData.itemparameterLock.lockForRead();

	QDir classDir;
	QString strRAWPath	=	QDir::currentPath() % "/RAW10Image";
	classDir.mkpath(strRAWPath);

	QString strRegFilePath = QCoreApplication::applicationDirPath();
	//QString strFileName = QString(QLatin1String(FileName)); 
	strRegFilePath.append("//Register.sset");

	if(!QFile::exists(strRegFilePath))
	{
		emit information("File not exists, please configured");     
		return HisFX3Error_Parameter;
	}

	int iWidth=itemshareData.previewParameter->iWidth;
	int iHeight=itemshareData.previewParameter->iHeight;

	unsigned short* pusRaw10	=	(unsigned short*)_aligned_malloc(itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight *sizeof(unsigned short), _HisCacheLine_Aligned);
	if(!pusRaw10){
		itemshareData.itemparameterLock.unlock();
		return HisFX3Error_MallocBuffer;
	}

	QFile file(strRegFilePath);    
	if(!file.open(QIODevice::ReadOnly | QIODevice::Text)) {       
		emit information("Can't Open File->Path:"%strRegFilePath);
	}    
	while(!file.atEnd()) {    
		QByteArray line = file.readLine();    
		QString str(line);
		memset(cline,0,128);
		strcpy_s(cline,128,str.toLatin1().data());
		if(str.indexOf("Register")==0 || str.indexOf("END")==0)
		{
			iCaptureIndexBefore=iCaptureIndex;
			if(str.indexOf("Register")==0)
			{ 
				sscanf(cline,"%s %d",temp,&iCaptureIndex);
				if(strcmp(temp,"Register")!=0){emit information("File Format not Correct eg: Register 1");iCaptureIndex=iCaptureIndexBefore;continue;}
				emit information("Parse Register:"%QString::number(iCaptureIndex,10));
			}
			if(iI2CIndex!=0)
			{
				//I2C Write
				iresult=globalFunPointer.BatchWriteHisFX3IICNoLimit(iI2CIndex,uSensorSlaveArrary,iRegaddrArrary,iRegDataArrary,uRegTypeArrary,uI2CDelay);
				iI2CIndex=0;
				if(iresult)
				{
					emit information("Write I2C sensor command fail, please check sensor device");             
					HisReleaseMalloc(pusRaw10);
					itemshareData.itemparameterLock.unlock();
					return iresult;
				}
				Sleep(uisleep);
				//
				iresult = GetFreshframe((unsigned char*)(pusRaw10), itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight *2, _FrameType_Raw10, true);
				if(iresult){
					emit information("Capture RAW10 failed, please check sensor device");
					HisReleaseMalloc(pusRaw10);
					itemshareData.itemparameterLock.unlock();
					return iresult;
				}
				//Calculate R Gr Gb B &log
				if(bSavelog)
				{
					int l=(iWidth>>1)-(ROIW>>1);
					int t=(iHeight>>1)-(ROIH>>1);
					sBayerColorDouble sBayerValue;
					memset(&sBayerValue,0,sizeof(sBayerColorDouble));
					ROPLOW::GetMeanFrom10BitBayer(pusRaw10,iWidth,iHeight,l,t,ROIW,ROIH,&sBayerValue,itemshareData.previewParameter->ucDataFormat);
					emit information("Register:"%QString::number(iCaptureIndexBefore)%"RAW Bayer(R Gr Gb B):"%QString::number(sBayerValue.R,'f',3)%","%QString::number(sBayerValue.Gr,'f',3)%","%QString::number(sBayerValue.Gb,'f',3)%","%QString::number(sBayerValue.B,'f',3));   
					char clogPath[MAX_PATH]={0};
					strcpy_s(clogPath,MAX_PATH,strRAWPath.toLatin1().data());
					strcat_s(clogPath,MAX_PATH,"\\BayerValueResult.csv");
					FILE *fp=fopen(clogPath,"a+");
					if(fp==NULL){ emit information(QString(QLatin1String(clogPath)%"is opened")); return HisFX3Error_Parameter;}	
					fseek(fp,0,SEEK_END);
					long fileLength=ftell(fp);
					SYSTEMTIME time;
					GetLocalTime(&time);
					if(fileLength<3) fprintf(fp,"Time,RegIndex,R,Gr,Gb,B\n");
					fprintf(fp,"%04d%02d%02d-%02d%02d%02d%03d,%d,%f,%f,%f,%f\n",time.wYear,time.wMonth,time.wDay,time.wHour,time.wMinute,time.wSecond,time.wMilliseconds,iCaptureIndexBefore,sBayerValue.R,sBayerValue.Gr,sBayerValue.Gb,sBayerValue.B);
					fclose(fp);
				}
				//Save RAW
				ROPLOW::saveRaw10(strRAWPath, QString(QLatin1String(itemshareData.previewParameter->strSensorName))%"_Capture_RAW10_Register_"%QString::number(iCaptureIndexBefore)%"_"%(QDateTime::currentDateTime()).toString("yyyyMMdd_hhmmss"), itemshareData.previewParameter->ucDataFormat,iWidth, iHeight, (void*)(pusRaw10));
				iI2CIndex=0;
			}
		}
		else if(str.indexOf("0x")==0)
		{  
			sscanf(cline,"%x %x %x %x",&uSensorSlaveArrary[iI2CIndex],&iRegaddrArrary[iI2CIndex],&iRegDataArrary[iI2CIndex],&uRegTypeArrary[iI2CIndex]);		
			emit information("I2C Slave:0x"%QString::number(uSensorSlaveArrary[iI2CIndex],16)%"Reg:0x"%QString::number(iRegaddrArrary[iI2CIndex],16)%"Data:0x"%QString::number(iRegDataArrary[iI2CIndex],16)%"I2C Type:0x"%QString::number(uRegTypeArrary[iI2CIndex],16));
			iI2CIndex++;
		}	
	}  
	HisReleaseMalloc(pusRaw10);
	itemshareData.itemparameterLock.unlock();
	return 0;
}

int itemprocess::autoExposure(RECT stroi,unsigned int uimin, unsigned int uimax, unsigned int uisleep, unsigned int uiindex, bool bG, bool bWhite,bool bCenterImage, float dCenterROIRatio)
{
	itemshareData.drawLock.lockForWrite();
	itemshareData.itemdrawList.clear();
	itemshareData.drawLock.unlock();

	if(!threadshareData.GetHisPreviewflag())	return HisCCMError_NotPreivew;

	int iresult	=		getccmhardwareParameter(false);
	if(iresult)	return iresult;

	itemshareData.itemparameterLock.lockForRead();
	unsigned int iwidth	=	itemshareData.previewParameter->iWidth;
	unsigned int iheight	=	itemshareData.previewParameter->iHeight;
	QString sensortype	=	itemshareData.ccmhardwareParameter->sensortype.toLower();
	QString tablename	=	itemshareData.currentTableName;
	_HisFX3_BaylorMode enDataFormat	=	 itemshareData.previewParameter->ucDataFormat;
	itemshareData.itemparameterLock.unlock();

	if(bCenterImage)
	{
		int Width=itemshareData.previewParameter->iWidth;
		int Height=itemshareData.previewParameter->iHeight;
		int iAEROIW=int(((double)Width*dCenterROIRatio)/2.0f);
		int iAEROIH=int(((double)Height*dCenterROIRatio)/2.0f);
		stroi.left=Width/2-iAEROIW;stroi.top=Height/2-iAEROIH;
		stroi.right=Width/2+iAEROIW;stroi.bottom=Height/2+iAEROIH;
	}

	stroi.left		=	((stroi.left >>1) <<1);
	stroi.right		=	((stroi.right >>1) <<1);
	stroi.top		=	((stroi.top >>1) <<1);
	stroi.bottom	=	((stroi.bottom >>1) <<1);

	if(sensortype.size() < 1){
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("sensor类型设置不正确"));
		return HisFX3Error_Parameter;
	}
	if(uimin > uimax || uimax > 0xFF){
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("自动曝光目标区间设置不正确"));
		return HisFX3Error_Parameter;
	}
	if(stroi.left+20 >= stroi.right || stroi.top+20 >= stroi.bottom || stroi.left < 0 || \
		stroi.top < 0 || stroi.right > iwidth || stroi.bottom > iheight){
			emit information(QTextCodec::codecForName( "GBK")->toUnicode("自动曝光ROI设置不正确"));
			return HisFX3Error_Parameter;
	}
	if(!uisleep || uisleep > 5000){
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("自动曝光延迟时间设置不正确"));
		return HisFX3Error_Parameter;
	}
	if(uiindex == 0 || uiindex > 45){
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("自动曝光数据库设置不正确"));
		return HisFX3Error_Parameter;
	}

	unsigned char ucFrameType	=	_FrameType_RGB24;
	int iROIW	=	stroi.right - stroi.left, iROIH = stroi.bottom - stroi.top;

	if(pstAeData[uiindex-1] != NULL){
		if(pstAeData[uiindex-1]->uimin != uimin || pstAeData[uiindex-1]->uimax != uimax || \
			pstAeData[uiindex-1]->strTableName != tablename || pstAeData[uiindex-1]->stroi.left != stroi.left || \
			pstAeData[uiindex-1]->stroi.right != stroi.right || pstAeData[uiindex-1]->stroi.top != stroi.top || \
			pstAeData[uiindex-1]->stroi.bottom != stroi.bottom ||  pstAeData[uiindex-1]->bChannel_Gr != bG || pstAeData[uiindex-1]->bAverage != (!bWhite))
			HisReleaseNewO(pstAeData[uiindex-1]);
	}

	if(pstAeData[uiindex-1] == NULL){
		pstAeData[uiindex-1]	=	new _autoExposreData;
		if(pstAeData[uiindex-1] == NULL)		return HisFX3Error_MallocBuffer;

		pstAeData[uiindex-1]->strTableName			=	tablename;
		pstAeData[uiindex-1]->stroi						=	stroi;
		pstAeData[uiindex-1]->uimin						=	uimin;
		pstAeData[uiindex-1]->uimax						=	uimax;
		pstAeData[uiindex-1]->unIndex					=	uiindex;
		pstAeData[uiindex-1]->usdatacount			=	0;
		pstAeData[uiindex-1]->bChannel_Gr			= bG;
		pstAeData[uiindex-1]->bAverage				=	!bWhite;

		if(iresult	=	getautoexposuredata(pstAeData[uiindex-1])) { HisReleaseNewO(pstAeData[uiindex-1]); return iresult; }
	}

	_autoExposreData *pstTheData	=	pstAeData[uiindex-1];

	// 	emit information("data count:  " % QString::number(pstTheData->usdatacount));

	unsigned int uibuffersize	=	iwidth *iheight *3;
	unsigned char* pucrgb	=	(unsigned char*)_aligned_malloc(uibuffersize, _HisCacheLine_Aligned);
	unsigned char* pucY		=	(unsigned char*)_aligned_malloc(iROIW *iROIH, _HisCacheLine_Aligned);
	if(!(pucY && pucrgb))	{
		HisReleaseMalloc(pucrgb);
		HisReleaseMalloc(pucY);
		return HisFX3Error_MallocBuffer;
	}

	iresult	=	HisFX3Error_Timeout;

	float flgrayValue;
	unsigned int uivalue, uimin_s, uimax_s, uispect;
	_autoexposureItem stnewdata;
	stnewdata.uifirstet	=	0;

	std::vector<_itemDraw>::iterator theIterator;
	itemshareData.drawLock.lockForWrite();
	itemshareData.itemdrawList.resize(3);
	theIterator=itemshareData.itemdrawList.begin();

	theIterator->uctype				=	HisDrawType_Block;
	theIterator->strinfo.stblock	=	stroi;
	theIterator->stcolor				=	QColor::fromRgb(255, 0, 0);
	theIterator++;

	theIterator->uctype				=	0;
	theIterator->idata[0]				=	stroi.left;
	theIterator->idata[1]				=	stroi.top;
	theIterator->stcolor				=	QColor::fromRgb(255, 0, 0);
	theIterator++;

	theIterator->uctype				=	HisDrawType_Text;
	theIterator->stcolor				=	QColor::fromRgb(255, 255, 0);
	theIterator->idata[0]	=	stroi.left;
	theIterator->idata[1]	=	stroi.bottom;
	sprintf_s(theIterator->strinfo.strtext,	15, "spec:(%d,%d)", uimin, uimax);
	itemshareData.drawLock.unlock();

	for(int i=0;	i<_AE_MaxTimes && threadshareData.GetHisPreviewflag(); ++i){
		if(iresult = GetFreshframe(pucrgb, uibuffersize, ucFrameType, !i))	break;

		if(bG){
			unsigned char* pucData;
			unsigned int uiLineByte	=	(iwidth <<1) + iwidth;
			unsigned char* pucLine	=	pucrgb + (stroi.top *uiLineByte + stroi.left *3 +1);
			unsigned char* pucDes	=	pucY;
			for(unsigned int y=0;	y<iROIH;	++y){
				pucData	=	pucLine;	
				pucLine	+=	uiLineByte;
				for(unsigned int x=0;	x<iROIW;	++x){
					*pucDes = *pucData;
					++pucDes;
					pucData	+=	3;
				}
			}
		}
		else{
			unsigned char* pucData;
			unsigned int uiLineByte	=	(iwidth <<1) + iwidth;
			unsigned char* pucLine	=	pucrgb + (stroi.top *uiLineByte + stroi.left *3);
			unsigned char* pucDes	=	pucY;
			for(unsigned int y=0;	y<iROIH;	++y){
				pucData	=	pucLine;	
				pucLine	+=	uiLineByte;
				for(unsigned int x=0;	x<iROIW;	++x){
					*pucDes = (unsigned char)(*pucData *0.299f + *(pucData+1) *0.587f + *(pucData+2) *0.114f);
					++pucDes;
					pucData	+=	3;
				}
			}
		}

		if(!bWhite){
			unsigned int uiPixelCount	=	iROIW *iROIH;
			unsigned int uiSum	=	0;
			unsigned char* pucSrc	=	pucY;
			for(unsigned int x=0;	x<uiPixelCount;	++x){
				uiSum	+=	(unsigned int)(*pucSrc);
				++pucSrc;
			}
			flgrayValue	=	(double)(uiSum) / (double)(uiPixelCount);
		}
		else{
			flgrayValue = classAlgorithm.HisCCMWhitePartAverageU8(pucY, iROIW, iROIH);
		}

		iresult	=	getExposureTime((sensortype.toAscii()).data(), itemshareData.previewParameter->ucSlave, \
			uivalue, uimin_s, uimax_s, globalFunPointer.ReadHisFX3IIC, globalFunPointer.WriteHisFX3IIC, globalFunPointer.SetHisFX3IICSpeed, globalFunPointer.PullHisFX3RESET, globalFunPointer.PullHisFX3PWND, \
			globalFunPointer.PageWriteHisFX3IIC, globalFunPointer.PageReadHisFX3IIC, globalFunPointer.HisFX3PageWriteSPI, globalFunPointer.HisFX3PageReadSPI);
		if(iresult)
			iresult	=	getExposureTime((sensortype.toAscii()).data(), itemshareData.previewParameter->ucSlave, \
			uivalue, uimin_s, uimax_s, globalFunPointer.ReadHisFX3IIC, globalFunPointer.WriteHisFX3IIC, globalFunPointer.SetHisFX3IICSpeed, globalFunPointer.PullHisFX3RESET, globalFunPointer.PullHisFX3PWND, \
			globalFunPointer.PageWriteHisFX3IIC, globalFunPointer.PageReadHisFX3IIC, globalFunPointer.HisFX3PageWriteSPI, globalFunPointer.HisFX3PageReadSPI);
		if(iresult)	break;

		if(!uivalue || uimin_s >= uimax_s || uivalue == 0xFFFFFFFF){
			emit information(QTextCodec::codecForName( "GBK")->toUnicode("当前曝光值：") % QString::number(uivalue, 10));
			emit information(QTextCodec::codecForName( "GBK")->toUnicode("最小曝光值：") % QString::number(uimin_s, 10));
			emit information(QTextCodec::codecForName( "GBK")->toUnicode("最大曝光值：") % QString::number(uimax_s, 10));
			iresult	=	HisCCMError_readIIC;
			break;
		}

		if(flgrayValue > static_cast<float>(uimin) && flgrayValue < static_cast<float>(uimax)){
			iresult						=	0;
			itemshareData.drawLock.lockForWrite();
			theIterator=itemshareData.itemdrawList.begin();
			theIterator->stcolor	=	QColor::fromRgb(0, 255, 0);
			theIterator++;
			theIterator->stcolor	=	QColor::fromRgb(0, 255, 0);
			theIterator->uctype	=	HisDrawType_Text;
			sprintf_s(theIterator->strinfo.strtext,	15, "Lux:%.2f", flgrayValue);
			itemshareData.drawLock.unlock();

			if(bG)
				emit information(QTextCodec::codecForName( "GBK")->toUnicode("曝光值：") % QString::number(uivalue, 10) % \
				QTextCodec::codecForName( "GBK")->toUnicode("        亮度(Gr)：") %  QString::number(static_cast<double>(flgrayValue), 'f', 6));
			else
				emit information(QTextCodec::codecForName( "GBK")->toUnicode("曝光值：") % QString::number(uivalue, 10) % \
				QTextCodec::codecForName( "GBK")->toUnicode("        亮度(Y)：") %  QString::number(static_cast<double>(flgrayValue), 'f', 6));

			stnewdata.flfinallux		=	flgrayValue;
			stnewdata.uifinalet		=	uivalue;

			break;
		}

		iresult	=	classAlgorithm.HisCCMGetnextet(pstTheData->stAEData, pstTheData->usdatacount, flgrayValue, uivalue, \
			static_cast<float>(uimin), static_cast<float>(uimax), uimin_s, uimax_s, uispect, i);
		if(iresult)	break;

		iresult	=	setExposureTime((sensortype.toAscii()).data(), itemshareData.previewParameter->ucSlave, \
			uispect, globalFunPointer.ReadHisFX3IIC, globalFunPointer.WriteHisFX3IIC, globalFunPointer.SetHisFX3IICSpeed, globalFunPointer.PullHisFX3RESET, globalFunPointer.PullHisFX3PWND, \
			globalFunPointer.PageWriteHisFX3IIC, globalFunPointer.PageReadHisFX3IIC, globalFunPointer.HisFX3PageWriteSPI, globalFunPointer.HisFX3PageReadSPI);
		if(iresult)
			iresult	=	setExposureTime((sensortype.toAscii()).data(), itemshareData.previewParameter->ucSlave, \
			uispect, globalFunPointer.ReadHisFX3IIC, globalFunPointer.WriteHisFX3IIC, globalFunPointer.SetHisFX3IICSpeed, globalFunPointer.PullHisFX3RESET, globalFunPointer.PullHisFX3PWND, \
			globalFunPointer.PageWriteHisFX3IIC, globalFunPointer.PageReadHisFX3IIC, globalFunPointer.HisFX3PageWriteSPI, globalFunPointer.HisFX3PageReadSPI);
		if(iresult)	break;

		DWORD dwstart	=	GetTickCount();
		iresult	=	HisFX3Error_Timeout;

		if(!i){
			stnewdata.flfirstlux	=	flgrayValue;
			stnewdata.uifirstet	=	uivalue;
		}

		if(!i && flgrayValue < 10)
			emit information(QTextCodec::codecForName( "GBK")->toUnicode("警告：自动曝光的初始亮度过低，可能会影响自动曝光的效率"));
		else if(!i && flgrayValue > 240)
			emit information(QTextCodec::codecForName( "GBK")->toUnicode("警告：自动曝光的初始亮度过高，可能会影响自动曝光的效率"));

		if(i && (flgrayValue + 15< uimin || flgrayValue  > uimax + 15)){
			emit information(QTextCodec::codecForName( "GBK")->toUnicode("警告：自动曝光效率偏低，原因可能如下："));
			emit information(QTextCodec::codecForName( "GBK")->toUnicode("              1. 环境亮度在不断变化；"));
			emit information(QTextCodec::codecForName( "GBK")->toUnicode("              2. 模组在不断移动；"));
			emit information(QTextCodec::codecForName( "GBK")->toUnicode("              3. 对模组曝光值的操作可能有误；"));
			emit information(QTextCodec::codecForName( "GBK")->toUnicode("              4. 延时时间偏短；"));
		}

		itemshareData.drawLock.lockForWrite();
		itemshareData.itemdrawList.at(1).uctype	=	HisDrawType_Text;
		sprintf_s(itemshareData.itemdrawList.at(1).strinfo.strtext,	15, "Lux:%.2f", flgrayValue);
		itemshareData.drawLock.unlock();

		dwstart	=	GetTickCount() - dwstart;
		if(uisleep + _FRAME_SLEEP_ADVANCE > dwstart)
			::Sleep(uisleep + _FRAME_SLEEP_ADVANCE - dwstart);
	}

	if(!iresult && stnewdata.uifirstet){
		if(iresult	=	updateautoexposuredata(pstTheData, &stnewdata))	emit information(QTextCodec::codecForName( "GBK")->toUnicode("更新自动曝光数据库失败"));
	}

	if(iresult)	emit information(QTextCodec::codecForName( "GBK")->toUnicode("自动曝光失败"));

	HisReleaseMalloc(pucrgb);
	HisReleaseMalloc(pucY);
	return iresult;
}

bool __cdecl SAMSUNGR_AF_IIC_Read(unsigned short Addr, unsigned short *Data)
{
	*Data = 0;
	return true;

	char strText[64];
	unsigned __int64 ui64Data;
	int iresult	=	classPlatform.HisFX3ReadI2C(0x18,Addr, &ui64Data,0x0808);
	sprintf(strText, "SAMSUNGR_AF_IIC_Read Reg: %x  Data: %x", (unsigned int)Addr, ui64Data);
	OutputDebugStringA(strText);
	if (iresult)
	{
		OutputDebugStringA("HisFX3ReadI2C false");
		return false;
	}

	*Data = ui64Data & 0xFFFF;
	return true;
}

bool __cdecl SAMSUNGR_AF_IIC_Write(unsigned short Addr, unsigned short Data)
{
	return true;

	char strText[64];
	sprintf(strText, "SAMSUNGR_AF_IIC_Write Reg:%x  Data:%x", (unsigned int)Addr, (unsigned int)Data);
	OutputDebugStringA(strText);	

	int iresult;
	if(iresult = classPlatform.HisFX3WriteIIC(0x18,Addr,Data,0x0808))
	{
		OutputDebugStringA("SAMSUNGR_AF_IIC_Write Write Fail");
		return false;
	}

	/*
	static unsigned int suiAddr4 = 0;
	if(Addr == 3)
	{
	Data	=	(Data << 2);
	if(iresult	=	classPlatform.HisFX3WriteIIC(0x18,0x04,Data & 0xFF,0x0808)) return false;
	if(iresult	=	classPlatform.HisFX3WriteIIC(0x18,0x03,(Data >>8) & 0xFF,0x0808)) return false;
	suiAddr4 = Data & 0xFF;
	}
	else if(Addr == 4)
	{
	Data = (Data >> 6);
	if(Data)
	{
	Data += suiAddr4;
	if(iresult	=	classPlatform.HisFX3WriteIIC(0x18,0x04,Data & 0xFF,0x0808)) return false;
	}
	}
	else
	{
	if(iresult	=	classPlatform.HisFX3WriteIIC(0x18,Addr,Data,0x0808)) return false;
	}
	*/

	return true;
}

int itemprocess::autoFocus(unsigned int uiAlg, unsigned int uiChart, unsigned int uiTimeOut, unsigned int uiROILeft, unsigned int uiROITop, unsigned int uiROIRight, \
	unsigned int uiROIBottom, int iStartPos, unsigned int uiPedestal, unsigned int uiFrameSleep)
{
	uiROILeft			=	((uiROILeft >> 1) <<1);
	uiROITop			=	((uiROITop >> 1) <<1);
	uiROIRight		=	((uiROIRight >> 1) <<1);
	uiROIBottom	=	((uiROIBottom >> 1) <<1);
	uiTimeOut		=	max(1, uiTimeOut);
	int iresult = 0;

	//判断图像是否点亮中
	if(!threadshareData.GetHisPreviewflag())	return HisCCMError_NotPreivew;
	itemshareData.clearDrawList();

	itemshareData.drawLock.lockForWrite();
	itemshareData.itemdrawList.resize(1);
	itemshareData.itemdrawList[0].stcolor	=	QColor::fromRgb(255, 255, 0);
	itemshareData.itemdrawList[0].usitem	=	autofocusitem;
	itemshareData.itemdrawList[0].uctype	=	HisDrawType_Block;
	itemshareData.itemdrawList[0].strinfo.stblock.left			=	uiROILeft;
	itemshareData.itemdrawList[0].strinfo.stblock.right		=	uiROIRight;
	itemshareData.itemdrawList[0].strinfo.stblock.top			=	uiROITop;
	itemshareData.itemdrawList[0].strinfo.stblock.bottom	=	uiROIBottom;
	itemshareData.drawLock.unlock();

	QHReadWriteLockManage classitemparameterLock(&(itemshareData.itemparameterLock));
	if(uiChart == 0)
	{
		stLogItem.itemtype		=	classLog->getmaxtypeindex(_HISLOG_CLASSIFY_AFMacro);
		stLogItem.itemkey		=	"AF_Macro_Result";
	}
	else if(uiChart == 1)
	{
		stLogItem.itemtype		=	classLog->getmaxtypeindex(_HISLOG_CLASSIFY_AFFar);
		stLogItem.itemkey		=	"AF_Far_Result";
	}
	stLogItem.itemvalue	=	"OK";
	QHDefaultLogManage classstLogItem(classLog, &stLogItem, "NG");

	if(uiAlg == 0) //三星相对对焦算法
	{
		enum AF_R_STATUS_TYPE
		{
			AF_R_RUN					= 0,
			AF_R_SUCCESS				= 1,
			AF_R_OVER_RANGE				= 2,
			AF_R_IIC_WRITE_ERROR,
			AF_R_FRAME_DELAY_ERROR,
			AF_R_LOG_FAIL_RAW_BUF,
			AF_R_LOG_FAIL_RAW_OPTION,
			AF_R_LOG_FAIL_ROI,
			AF_R_LOG_FAIL_PARAMETER,
			AF_R_LOG_FAIL_PEDESTAL,
			AF_R_LOG_FILE,
			AF_R_SYSTEM_IMG_FAIL,
			AF_R_ACT_SET_FAIL,
			AF_R_FAIL
		};

		enum AF_R_CIS_ORDER_TYPE
		{
			R_FIRST,
			GR_FIRST,
			GB_FIRST,
			B_FIRST
		};

		enum AF_R_ACT_MODEL_TYPE
		{
			AK7371,
			AK7345,
			DW9807
		};

		typedef struct __AF_R_ACT_setting
		{
			unsigned short i_run_mode; // 0: no set, 1: Ring mode, 2: SAC mode
			unsigned short SAC_set;        // for SAC mode
			unsigned short resonance;      // for SAC resonance
		}AF_R_ACT_control;

		typedef struct __AF_R_info_type
		{
			unsigned int 		i_Width;
			unsigned int 		i_Height;
			AF_R_CIS_ORDER_TYPE i_Order;
			unsigned int 		i_Pedestal;
			unsigned int 		Roi_SX;
			unsigned int 		Roi_SY;
			unsigned int 		Roi_EX;
			unsigned int 		Roi_EY;
			AF_R_ACT_MODEL_TYPE Act_Model;
			AF_R_ACT_control    Act_set;
		}AF_R_info_type;

		QString strDllPath = QDir::currentPath() % "/SRITDLL/RAFL_DLL";
		typedef enum AF_R_STATUS_TYPE (*RRT_AutoFocus_R)(unsigned short *,struct __AF_R_info_type,bool (*)(unsigned short,unsigned short),bool (*)(unsigned short,unsigned short *),int *,int,bool,int);
#ifdef _WIN64
		RRT_AutoFocus_R  AutoFocus_R = (RRT_AutoFocus_R)(QLibrary::resolve(strDllPath, "?AutoFocus_R@@YA?AW4AF_R_STATUS_TYPE@@PEAGU__AF_R_info_type@@P6A_NGG@ZP6A_NG0@ZPEAHH_NH@Z"));
#else
		RRT_AutoFocus_R  AutoFocus_R = (RRT_AutoFocus_R)(QLibrary::resolve(strDllPath, "?AutoFocus_R@@YA?AW4AF_R_STATUS_TYPE@@PAGU__AF_R_info_type@@P6A_NGG@ZP6A_NG0@ZPAHH_NH@Z"));
#endif
		if(!AutoFocus_R){
			emit information(strDllPath % " load AutoFocus_R fail");
			return HisCCMError_LoadDLLFuc;
		}

		unsigned short* pusBaylor	=	(unsigned short*)HisAlignedMalloc(itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight *2);
		if(!pusBaylor) return HisFX3Error_MallocBuffer;
		QHisFX3MallocAlignedManage classpusBaylor(pusBaylor);

		char strText[64];

		int af_mode = 0;
		if(uiChart == 0) af_mode = 1;
		AF_R_STATUS_TYPE af_state	=	AF_R_RUN;
		AF_R_info_type af_info;
		af_info.i_Width		=	itemshareData.previewParameter->iWidth;
		af_info.i_Height		=	itemshareData.previewParameter->iHeight;
		af_info.Roi_SX		=	uiROILeft;
		af_info.Roi_EX		=	uiROIRight;
		af_info.Roi_SY		=	uiROITop;
		af_info.Roi_EY		=	uiROIBottom;
		af_info.i_Pedestal	=	uiPedestal;
		af_info.Act_Model	=	DW9807;
		af_info.Act_set.i_run_mode	=	1;

		switch (itemshareData.previewParameter->ucDataFormat)
		{
		case HisBaylor8_BGGR:
		case HisBaylor10_BGGR:
		case HisBaylor12_BGGR:
			af_info.i_Order	=	B_FIRST;
			break;
		case HisBaylor8_RGGB:
		case HisBaylor10_RGGB:
		case HisBaylor12_RGGB:
			af_info.i_Order	=	R_FIRST;
			break;
		case HisBaylor8_GRBG:
		case HisBaylor10_GRBG:
		case HisBaylor12_GRBG:
			af_info.i_Order	=	GR_FIRST;
			break;
		case HisBaylor8_GBRG:
		case HisBaylor10_GBRG:
		case HisBaylor12_GBRG:
			af_info.i_Order	=	GB_FIRST;
			break;
		default:
			emit information("Data format is not supported: " % QString::number(itemshareData.previewParameter->ucDataFormat));
			return HisFX3Error_Parameter;
			break;
		}

		int Lens_Pos	=0, iLastLensPosition = iStartPos;
		if(iresult = setMotor(itemshareData.ccmhardwareParameter->motortype.toAscii().data(), itemshareData.previewParameter->ucSlave, \
			itemshareData.ccmhardwareParameter->projectname.toAscii().data(), iLastLensPosition, globalFunPointer.ReadHisFX3IIC, globalFunPointer.WriteHisFX3IIC, globalFunPointer.SetHisFX3IICSpeed, globalFunPointer.PullHisFX3RESET, globalFunPointer.PullHisFX3PWND, \
			globalFunPointer.PageWriteHisFX3IIC, globalFunPointer.PageReadHisFX3IIC, globalFunPointer.HisFX3PageWriteSPI, globalFunPointer.HisFX3PageReadSPI))
		{
			emit information("Set Motor Fail");
			return iresult;
		}

		if(uiFrameSleep) Sleep(uiFrameSleep);

		QElapsedTimer classTime;
		classTime.start();
		bool bFirst	=	true;
		while(classTime.elapsed() < uiTimeOut *1000)
		{
			//取得raw图像数据
			if(iresult	=	GetFreshframe((unsigned char*)pusBaylor, itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight *2, _FrameType_Raw10, bFirst))
				return iresult;

			// * In infinity mode - initial position can be 0 ~ 512
			//   In Macro mode    - initial position can be 768 ~ 1023
			af_state = AutoFocus_R(pusBaylor, af_info, SAMSUNGR_AF_IIC_Write, SAMSUNGR_AF_IIC_Read, &Lens_Pos, iStartPos, bFirst, af_mode);
			sprintf(strText, "Lens_Pos: %d", Lens_Pos);
			OutputDebugStringA(strText);

			emit information("Lens Pos: " % QString::number(Lens_Pos));
			if(iresult = setMotor(itemshareData.ccmhardwareParameter->motortype.toAscii().data(), itemshareData.previewParameter->ucSlave, \
				itemshareData.ccmhardwareParameter->projectname.toAscii().data(), Lens_Pos, globalFunPointer.ReadHisFX3IIC, globalFunPointer.WriteHisFX3IIC, globalFunPointer.SetHisFX3IICSpeed, globalFunPointer.PullHisFX3RESET, globalFunPointer.PullHisFX3PWND, \
				globalFunPointer.PageWriteHisFX3IIC, globalFunPointer.PageReadHisFX3IIC, globalFunPointer.HisFX3PageWriteSPI, globalFunPointer.HisFX3PageReadSPI))
			{
				emit information("Set Motor Fail");
				return iresult;
			}

			if(af_state == AF_R_SUCCESS) 
			{
				if(uiChart == 0)	iNearPeakMotorDec	=	Lens_Pos;
				else if(uiChart == 1)	iFarPeakMotorDec	=	Lens_Pos;
				break;
			}

			if(af_state != AF_R_RUN) emit information("AutoFocus_R return(error): " % QString::number(af_state));

			bFirst	=	false;

			if(iLastLensPosition != Lens_Pos && uiFrameSleep)
				Sleep(uiFrameSleep);

			iLastLensPosition	=	Lens_Pos;
		}

		if(af_state != AF_R_SUCCESS) iresult = HisCCMError_Result;

		if(iresult) stLogItem.itemvalue	=	"NG";
		classstLogItem.SubRef();
		classLog->push_back(stLogItem);

		if(uiChart == 0){
			++(stLogItem.itemtype); stLogItem.itemkey = "AF_Macro_Code"; stLogItem.itemvalue = Lens_Pos; classLog->push_back(stLogItem);
		}
		else if(uiChart == 1){
			++(stLogItem.itemtype); stLogItem.itemkey = "AF_Far_Code"; stLogItem.itemvalue = Lens_Pos; classLog->push_back(stLogItem);
		}
	}

	return iresult;
}

#if 0

int itemprocess::getwhitepanelParameter(bool bupdate, bool bcheck)
{
	QMutexLocker locker(&hisglobalparameter.mutexDatabase);

	itemshareData.itemparameterLock.lockForRead();
	if(!bupdate && itemshareData.whitepanelParameter)	{	itemshareData.itemparameterLock.unlock();	return 0;	}
	itemshareData.itemparameterLock.unlock();

	itemshareData.itemparameterLock.lockForWrite();
	if(!itemshareData.whitepanelParameter)	itemshareData.whitepanelParameter		=	new _whitepanelParameter;
	if(!itemshareData.whitepanelParameter)	{	itemshareData.itemparameterLock.unlock();	return HisFX3Error_MallocBuffer;	}

	bool bItemExist = false;
	{
		QSqlDatabase customdb = QSqlDatabase::addDatabase("QSQLITE", "querycustom");
		customdb.setDatabaseName(QDir::currentPath() % "/HisFX3Custom");
		if (!customdb.open()){
			itemshareData.itemparameterLock.unlock();
			return HisCCMError_Database;
		}

		QStringList strname, strvalue;
		QString strData, strData2;
		bool bok;
		QSqlQuery query(customdb);
		query.prepare("SELECT itemsuffix2,key,value,reserve FROM " % itemshareData.currentTableName % \
			" WHERE classfy='algorithm' AND item='whitepanel' AND itemsuffix1='total' ORDER BY id ASC" );
		query.exec();

		//(opticalcenter:on)(defectpixel:on)(defectline:on)
		//(belmish:on)(color:on)(shading:on)(vignetting:on)
		//(opticalcenteralg:a)(defectpixelalg:a)(defectlinealg:a)
		//(belmishalg:a)(coloralg:a)(shadingalg:a)(vignettingalg:a)
		while (query.next()){
			bItemExist = true;
			for(int y=0;	y<4;	++y){
				strData	=	query.value(y).toString();
				ROPLOW::patchconfigstring(strData, strname, strvalue);
				for(int x=0;	x<strname.size();	++x){
					if(strname.at(x) == "opticalcenter")	itemshareData.whitepanelParameter->usopticalcenter	=	(strvalue.at(x) == "on")?(_WhitePanel_OpticalCenter):(0);
					else if(strname.at(x) == "belmish")	itemshareData.whitepanelParameter->usblemish	=	(strvalue.at(x) == "on")?(_WhitePanel_Blemish):(0);
					else if(strname.at(x) == "color")			itemshareData.whitepanelParameter->uscolor	=	(strvalue.at(x) == "on")?(_WhitePanel_Color):(0);
					else if(strname.at(x) == "defectline")	itemshareData.whitepanelParameter->usdefectline	=	(strvalue.at(x) == "on")?(_WhitePanel_Line):(0);
					else if(strname.at(x) == "defectpixel")	itemshareData.whitepanelParameter->usdefectpixel	=	(strvalue.at(x) == "on")?(_WhitePanel_DefectPixel):(0);
					else if(strname.at(x) == "shading")	itemshareData.whitepanelParameter->usShadingOn	=	(strvalue.at(x) == "on")?(0x1):(0);
					else if(strname.at(x) == "vignetting")	itemshareData.whitepanelParameter->usVignettingOn	=	(strvalue.at(x) == "on")?(0x1):(0);
					else if(strname.at(x) == "opticalcenteralg"){
						if(strvalue.at(x) == "a")	itemshareData.whitepanelParameter->opticalcenterAlg	=	_HisAlg_SWITCH_A;
					}
					else if(strname.at(x) == "defectpixelalg"){
						if(strvalue.at(x) == "a")	itemshareData.whitepanelParameter->defectpixelAlg	=	_HisAlg_SWITCH_A;
						else if(strvalue.at(x) == "b")	itemshareData.whitepanelParameter->defectpixelAlg	=	_HisAlg_SWITCH_B;
					}
					else if(strname.at(x) == "defectlinealg"){
						if(strvalue.at(x) == "a")	itemshareData.whitepanelParameter->defectlineAlg	=	_HisAlg_SWITCH_A;
					}
					else if(strname.at(x) == "belmishalg"){
						if(strvalue.at(x) == "a")	itemshareData.whitepanelParameter->blemishAlg	=	_HisAlg_SWITCH_A;
						else if(strvalue.at(x) == "b")	itemshareData.whitepanelParameter->blemishAlg	=	_HisAlg_SWITCH_B;
						else if(strvalue.at(x) == "c")	itemshareData.whitepanelParameter->blemishAlg	=	_HisAlg_SWITCH_C;
					}
					else if(strname.at(x) == "coloralg"){
						if(strvalue.at(x) == "a")	itemshareData.whitepanelParameter->colorAlg	=	_HisAlg_SWITCH_A;
					}
					else if(strname.at(x) == "vignettingalg"){
						if(strvalue.at(x) == "a")	itemshareData.whitepanelParameter->vignettingAlg	=	_HisAlg_SWITCH_A;
					}
					else if(strname.at(x) == "shadingalg"){
						if(strvalue.at(x) == "a")	itemshareData.whitepanelParameter->shadingAlg	=	_HisAlg_SWITCH_A;
						else if(strvalue.at(x) == "b")	itemshareData.whitepanelParameter->shadingAlg	=	_HisAlg_SWITCH_B;
					}
				}
			}
		}

		query.prepare("SELECT itemsuffix2,key,value,reserve FROM " % itemshareData.currentTableName % \
			" WHERE classfy='algorithm' AND item='whitepanel' AND itemsuffix1='blemish' ORDER BY id ASC" );
		query.exec();

		//(range:0.9)(filter:12,24)
		//(amplitude:70)(dev:43)(cornerspec:0.15)
		while (query.next()){
			bItemExist = true;
			for(int y=0;	y<4;	++y){
				strData	=	query.value(y).toString();
				ROPLOW::patchconfigstring(strData, strname, strvalue);
				for(int x=0;	x<strname.size();	++x){
					if(strname.at(x) == "range")
						itemshareData.whitepanelParameter->blemish_flrange	=	strvalue.at(x).toFloat(&bok);
					else if(strname.at(x) == "cornerspec")
						itemshareData.whitepanelParameter->blemish_corner	=	strvalue.at(x).toFloat(&bok);
					else if(strname.at(x) == "amplitude")
						itemshareData.whitepanelParameter->blemish_iamplitude	=	strvalue.at(x).toInt(&bok, 10);
					else if(strname.at(x) == "dev")
						itemshareData.whitepanelParameter->blemish_idev	=	strvalue.at(x).toInt(&bok, 10);
					else if(strname.at(x) == "filter"){
						strData	=	strvalue.at(x);
						int iindex	=	strData.indexOf(",");
						strData2	=	strData.left(iindex);
						strData	=	strData.right(strData.size() - iindex -1);
						if(iindex > 0 && !strData.isEmpty() && !strData2.isEmpty()){
							itemshareData.whitepanelParameter->blemish_ihighpass	=	strData2.toInt(&bok, 10);
							itemshareData.whitepanelParameter->blemish_ilowpass	=	strData.toInt(&bok, 10);
						}
					}
				}
			}
		}

		query.prepare("SELECT itemsuffix2,key,value,reserve FROM " % itemshareData.currentTableName % \
			" WHERE classfy='algorithm' AND item='whitepanel' AND itemsuffix1='blemishhb' ORDER BY id ASC" );
		query.exec();
		//(z1r1:0.1)(z1r2:0.1)
		//(z2r1:0.1)(z2r2:0.1)
		//(z3r1:0.1)(z3r2:0.1)
		//(zone1range:0.2)(zone3x:300)(zone3y:300)(removedefect:false)
		while (query.next()){
			bItemExist = true;
			for(int y=0;	y<4;	++y){
				strData	=	query.value(y).toString();
				ROPLOW::patchconfigstring(strData, strname, strvalue);
				for(int x=0;	x<strname.size();	++x){
					if(strname.at(x) == "zone1range")
						itemshareData.whitepanelParameter->blemishhb_Zone1Range	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "zone3x")
						itemshareData.whitepanelParameter->blemishhb_Zone3X	=	strvalue.at(x).toUInt();
					else if(strname.at(x) == "zone3y")
						itemshareData.whitepanelParameter->blemishhb_Zone3Y	=	strvalue.at(x).toUInt();
					else if(strname.at(x) == "removedefect")
						itemshareData.whitepanelParameter->blemishhb_RemoveDefectPixel	=	(strvalue.at(x) == "true");
					else if(strname.at(x) == "z1r1")
						itemshareData.whitepanelParameter->blemishhb_Zone1Spec[0]	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "z1r2")
						itemshareData.whitepanelParameter->blemishhb_Zone1Spec[1]	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "z1r3")
						itemshareData.whitepanelParameter->blemishhb_Zone1Spec[2]	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "z1r4")
						itemshareData.whitepanelParameter->blemishhb_Zone1Spec[3]	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "z1r5")
						itemshareData.whitepanelParameter->blemishhb_Zone1Spec[4]	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "z1r6")
						itemshareData.whitepanelParameter->blemishhb_Zone1Spec[5]	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "z1r7")
						itemshareData.whitepanelParameter->blemishhb_Zone1Spec[6]	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "z1r8")
						itemshareData.whitepanelParameter->blemishhb_Zone1Spec[7]	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "z1r9")
						itemshareData.whitepanelParameter->blemishhb_Zone1Spec[8]	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "z1r10")
						itemshareData.whitepanelParameter->blemishhb_Zone1Spec[9]	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "z1r11")
						itemshareData.whitepanelParameter->blemishhb_Zone1Spec[10]	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "z1r12")
						itemshareData.whitepanelParameter->blemishhb_Zone1Spec[11]	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "z1r13")
						itemshareData.whitepanelParameter->blemishhb_Zone1Spec[12]	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "z1r14")
						itemshareData.whitepanelParameter->blemishhb_Zone1Spec[13]	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "z1r15")
						itemshareData.whitepanelParameter->blemishhb_Zone1Spec[14]	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "z2r1")
						itemshareData.whitepanelParameter->blemishhb_Zone2Spec[0]	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "z2r2")
						itemshareData.whitepanelParameter->blemishhb_Zone2Spec[1]	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "z2r3")
						itemshareData.whitepanelParameter->blemishhb_Zone2Spec[2]	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "z2r4")
						itemshareData.whitepanelParameter->blemishhb_Zone2Spec[3]	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "z2r5")
						itemshareData.whitepanelParameter->blemishhb_Zone2Spec[4]	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "z2r6")
						itemshareData.whitepanelParameter->blemishhb_Zone2Spec[5]	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "z2r7")
						itemshareData.whitepanelParameter->blemishhb_Zone2Spec[6]	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "z2r8")
						itemshareData.whitepanelParameter->blemishhb_Zone2Spec[7]	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "z2r9")
						itemshareData.whitepanelParameter->blemishhb_Zone2Spec[8]	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "z2r10")
						itemshareData.whitepanelParameter->blemishhb_Zone2Spec[9]	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "z2r11")
						itemshareData.whitepanelParameter->blemishhb_Zone2Spec[10]	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "z2r12")
						itemshareData.whitepanelParameter->blemishhb_Zone2Spec[11]	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "z2r13")
						itemshareData.whitepanelParameter->blemishhb_Zone2Spec[12]	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "z2r14")
						itemshareData.whitepanelParameter->blemishhb_Zone2Spec[13]	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "z2r15")
						itemshareData.whitepanelParameter->blemishhb_Zone2Spec[14]	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "z3r1")
						itemshareData.whitepanelParameter->blemishhb_Zone3Spec[0]	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "z3r2")
						itemshareData.whitepanelParameter->blemishhb_Zone3Spec[1]	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "z3r3")
						itemshareData.whitepanelParameter->blemishhb_Zone3Spec[2]	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "z3r4")
						itemshareData.whitepanelParameter->blemishhb_Zone3Spec[3]	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "z3r5")
						itemshareData.whitepanelParameter->blemishhb_Zone3Spec[4]	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "z3r6")
						itemshareData.whitepanelParameter->blemishhb_Zone3Spec[5]	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "z3r7")
						itemshareData.whitepanelParameter->blemishhb_Zone3Spec[6]	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "z3r8")
						itemshareData.whitepanelParameter->blemishhb_Zone3Spec[7]	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "z3r9")
						itemshareData.whitepanelParameter->blemishhb_Zone3Spec[8]	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "z3r10")
						itemshareData.whitepanelParameter->blemishhb_Zone3Spec[9]	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "z3r11")
						itemshareData.whitepanelParameter->blemishhb_Zone3Spec[10]	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "z3r12")
						itemshareData.whitepanelParameter->blemishhb_Zone3Spec[11]	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "z3r13")
						itemshareData.whitepanelParameter->blemishhb_Zone3Spec[12]	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "z3r14")
						itemshareData.whitepanelParameter->blemishhb_Zone3Spec[13]	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "z3r15")
						itemshareData.whitepanelParameter->blemishhb_Zone3Spec[14]	=	strvalue.at(x).toFloat();
				}
			}
		}

		query.prepare("SELECT itemsuffix2,key,value,reserve FROM " % itemshareData.currentTableName % \
			" WHERE classfy='algorithm' AND item='whitepanel' AND itemsuffix1='blemishhc' ORDER BY id ASC" );
		query.exec();
		//(minarea:0.1)(maxarea:0.1)(edgezone:0.05)(tuning:2.0)(lsc:false)(wb:false)
		//(z1b:0.009)(z2b:0.009)(z3b:0.009)(z4b:0.009)(z5b:0.009)(z6b:0.009)(z7b:0.009)(z8b:0.009)(z9b:0.009)(z10b:0.009)(zdgeb:0.009)
		while (query.next()){
			bItemExist = true;
			for(int y=0;	y<4;	++y){
				strData	=	query.value(y).toString();
				ROPLOW::patchconfigstring(strData, strname, strvalue);
				for(int x=0;	x<strname.size();	++x){
					if(strname.at(x) == "minarea") itemshareData.whitepanelParameter->stBlemishHC.flAreaMin	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "maxarea") itemshareData.whitepanelParameter->stBlemishHC.flAreaMax	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "edgezone") itemshareData.whitepanelParameter->stBlemishHC.flEdgeZone	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "cornerzone") itemshareData.whitepanelParameter->stBlemishHC.flCornerZone	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "tuning") itemshareData.whitepanelParameter->stBlemishHC.flTuning	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "lsc") itemshareData.whitepanelParameter->stBlemishHC.bLSC	=	(strvalue.at(x) == "true");
					else if(strname.at(x) == "wb") itemshareData.whitepanelParameter->stBlemishHC.bWB	=	(strvalue.at(x) == "true");
					else if(strname.at(x) == "z1b") itemshareData.whitepanelParameter->stBlemishHC.stSpec[0].flLux	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "z2b") itemshareData.whitepanelParameter->stBlemishHC.stSpec[1].flLux	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "z3b") itemshareData.whitepanelParameter->stBlemishHC.stSpec[2].flLux	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "z4b") itemshareData.whitepanelParameter->stBlemishHC.stSpec[3].flLux	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "z5b") itemshareData.whitepanelParameter->stBlemishHC.stSpec[4].flLux	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "z6b") itemshareData.whitepanelParameter->stBlemishHC.stSpec[5].flLux	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "z7b") itemshareData.whitepanelParameter->stBlemishHC.stSpec[6].flLux	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "z8b") itemshareData.whitepanelParameter->stBlemishHC.stSpec[7].flLux	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "z9b") itemshareData.whitepanelParameter->stBlemishHC.stSpec[8].flLux	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "z10b") itemshareData.whitepanelParameter->stBlemishHC.stSpec[9].flLux	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "zdgeb") itemshareData.whitepanelParameter->stBlemishHC.stSpec[10].flLux	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "cornerb") itemshareData.whitepanelParameter->stBlemishHC.stSpec[11].flLux	=	strvalue.at(x).toFloat();
				}
			}
		}

		query.prepare("SELECT itemsuffix2,key,value,reserve FROM " % itemshareData.currentTableName % \
			" WHERE classfy='algorithm' AND item='whitepanel' AND itemsuffix1='color' ORDER BY id ASC" );
		query.exec();

		//(a:0.0)(b:0.0)(centerrange:0.08)(widthblocks:32)
		//(uniform:2.8)(aberration:1.0)(sym:1.0)(falloff:3.0)
		while (query.next()){
			bItemExist = true;
			for(int y=0;	y<4;	++y){
				strData	=	query.value(y).toString();
				ROPLOW::patchconfigstring(strData, strname, strvalue);
				for(int x=0;	x<strname.size();	++x){
					if(strname.at(x) == "a")
						itemshareData.whitepanelParameter->color_flideala			=	strvalue.at(x).toFloat(&bok);
					else if(strname.at(x) == "b")
						itemshareData.whitepanelParameter->color_flidealb			=	strvalue.at(x).toFloat(&bok);
					else if(strname.at(x) == "centerrange")
						itemshareData.whitepanelParameter->color_flcenterrange	=	strvalue.at(x).toFloat(&bok);
					else if(strname.at(x) == "uniform")
						itemshareData.whitepanelParameter->color_fluniform			=	strvalue.at(x).toFloat(&bok);
					else if(strname.at(x) == "aberration")
						itemshareData.whitepanelParameter->color_flaberration		=	strvalue.at(x).toFloat(&bok);
					else if(strname.at(x) == "sym")
						itemshareData.whitepanelParameter->color_flsym				=	strvalue.at(x).toFloat(&bok);
					else if(strname.at(x) == "falloff")
						itemshareData.whitepanelParameter->color_flfalloff				=	strvalue.at(x).toFloat(&bok);
					else if(strname.at(x) == "widthblocks")
						itemshareData.whitepanelParameter->color_iwithblocks		=	strvalue.at(x).toInt(&bok, 10);
				}
			}
		}

		query.prepare("SELECT itemsuffix2,key,value,reserve FROM " % itemshareData.currentTableName % \
			" WHERE classfy='algorithm' AND item='whitepanel' AND itemsuffix1='opticalcenter' ORDER BY id ASC" );
		query.exec();

		//(deviation:10.0)
		//(pixelratio:0.09)
		while (query.next()){
			bItemExist = true;
			for(int y=0;	y<4;	++y){
				strData	=	query.value(y).toString();
				ROPLOW::patchconfigstring(strData, strname, strvalue);
				for(int x=0;	x<strname.size();	++x){
					if(strname.at(x) == "deviation")
						itemshareData.whitepanelParameter->oc_fldeviation	=	strvalue.at(x).toFloat(&bok);
					else if(strname.at(x) == "pixelratio")
						itemshareData.whitepanelParameter->oc_flpixelratio	=	strvalue.at(x).toFloat(&bok);
				}
			}
		}

		query.prepare("SELECT itemsuffix2,key,value,reserve FROM " % itemshareData.currentTableName % \
			" WHERE classfy='algorithm' AND item='whitepanel' AND itemsuffix1='vignettingha' ORDER BY id ASC" );
		query.exec();
		//(roi1w:32)(roi1h:32)
		//(specr2min:0.9)(specr2max:1.1)
		//(specr3min:0.9)(specr3max:1.1)
		while (query.next()){
			bItemExist = true;
			for(int y=0;	y<4;	++y){
				strData	=	query.value(y).toString();
				ROPLOW::patchconfigstring(strData, strname, strvalue);
				for(int x=0;	x<strname.size();	++x){
					if(strname.at(x) == "roi1w")	 itemshareData.whitepanelParameter->stVignettingConfigHA.uiROIW = strvalue.at(x).toUInt();
					else if(strname.at(x) == "roi1h")	 itemshareData.whitepanelParameter->stVignettingConfigHA.uiROIH = strvalue.at(x).toUInt();
					else if(strname.at(x) == "specr2min")	 itemshareData.whitepanelParameter->stVignettingConfigHA.flSpecR2Min = strvalue.at(x).toFloat();
					else if(strname.at(x) == "specr2max")	 itemshareData.whitepanelParameter->stVignettingConfigHA.flSpecR2Max = strvalue.at(x).toFloat();
					else if(strname.at(x) == "specr3min")	 itemshareData.whitepanelParameter->stVignettingConfigHA.flSpecR3Min = strvalue.at(x).toFloat();
					else if(strname.at(x) == "specr3max")	 itemshareData.whitepanelParameter->stVignettingConfigHA.flSpecR3Max = strvalue.at(x).toFloat();
				}
			}
		}

		query.prepare("SELECT itemsuffix2,key,value,reserve FROM " % itemshareData.currentTableName % \
			" WHERE classfy='algorithm' AND item='whitepanel' AND itemsuffix1='shandingha' ORDER BY id ASC" );
		query.exec();
		//(channel:y)(roiw:0.2)(roih:0.2)
		//(specmin:0.5)(specmax:0.8)(specdev:0.05)
		while (query.next()){
			bItemExist = true;
			for(int y=0;	y<4;	++y){
				strData	=	query.value(y).toString();
				ROPLOW::patchconfigstring(strData, strname, strvalue);
				for(int x=0;	x<strname.size();	++x){
					if(strname.at(x) == "roiw")	 itemshareData.whitepanelParameter->stShadingConfigHA.flRatioW = strvalue.at(x).toFloat();
					else if(strname.at(x) == "roih")	 itemshareData.whitepanelParameter->stShadingConfigHA.flRatioH = strvalue.at(x).toFloat();
					else if(strname.at(x) == "specmin")	 itemshareData.whitepanelParameter->stShadingConfigHA.flShadingSpecMin = strvalue.at(x).toFloat();
					else if(strname.at(x) == "specmax")	 itemshareData.whitepanelParameter->stShadingConfigHA.flShadingSpecMax = strvalue.at(x).toFloat();
					else if(strname.at(x) == "specdev")	 itemshareData.whitepanelParameter->stShadingConfigHA.flShadingSpecDev = strvalue.at(x).toFloat();
					else if(strname.at(x) == "channel")	{
						if(strvalue.at(x) == "r")	itemshareData.whitepanelParameter->stShadingConfigHA.imgChannel	=	_HisCCMAlg_ImageBuffer_Channel_R;
						else if(strvalue.at(x) == "g")	itemshareData.whitepanelParameter->stShadingConfigHA.imgChannel	=	_HisCCMAlg_ImageBuffer_Channel_Gr;
						else if(strvalue.at(x) == "b")	itemshareData.whitepanelParameter->stShadingConfigHA.imgChannel	=	_HisCCMAlg_ImageBuffer_Channel_B;
						else	itemshareData.whitepanelParameter->stShadingConfigHA.imgChannel	=	_HisCCMAlg_ImageBuffer_Channel_Y;
					}
				}
			}
		}

		query.prepare("SELECT itemsuffix2,key,value,reserve FROM " % itemshareData.currentTableName % \
			" WHERE classfy='algorithm' AND item='whitepanel' AND itemsuffix1='shandinghb' ORDER BY id ASC" );
		query.exec();
		//(rgmin:0.0)(rgmax:4.0)(bgmin:0.0)(bgmax:4.0)
		//(specmin:50.0)(specmax:80.0)(specdev:5.0)
		//(ppmin:0.0)(ppmax:4.0)(bgoffset:0.0)(rgoffset:0.0)(ppoffset:0.0)(yyoffset:0.0)
		while (query.next()){
			bItemExist = true;
			for(int y=0;	y<4;	++y){
				strData	=	query.value(y).toString();
				ROPLOW::patchconfigstring(strData, strname, strvalue);
				for(int x=0;	x<strname.size();	++x){
					if(strname.at(x) == "rgmin")	 itemshareData.whitepanelParameter->stShadingConfigHB.flSpecRGMin = strvalue.at(x).toFloat();
					else if(strname.at(x) == "rgmax")	 itemshareData.whitepanelParameter->stShadingConfigHB.flSpecRGMax = strvalue.at(x).toFloat();
					else if(strname.at(x) == "bgmin")	 itemshareData.whitepanelParameter->stShadingConfigHB.flSpecBGMin = strvalue.at(x).toFloat();
					else if(strname.at(x) == "bgmax")	 itemshareData.whitepanelParameter->stShadingConfigHB.flSpecBGMax = strvalue.at(x).toFloat();
					else if(strname.at(x) == "specmin")	 itemshareData.whitepanelParameter->stShadingConfigHB.flShadingSpecMin = strvalue.at(x).toFloat();
					else if(strname.at(x) == "specmax")	 itemshareData.whitepanelParameter->stShadingConfigHB.flShadingSpecMax = strvalue.at(x).toFloat();
					else if(strname.at(x) == "specdev")	 itemshareData.whitepanelParameter->stShadingConfigHB.flShadingSpecDev = strvalue.at(x).toFloat();
					else if(strname.at(x) == "ppmin")	 itemshareData.whitepanelParameter->stShadingConfigHB.flSpecPPMin = strvalue.at(x).toFloat();
					else if(strname.at(x) == "ppmax")	 itemshareData.whitepanelParameter->stShadingConfigHB.flSpecPPMax = strvalue.at(x).toFloat();
					else if(strname.at(x) == "bgoffset")	 itemshareData.whitepanelParameter->stShadingConfigHB.flBGOffset = strvalue.at(x).toFloat();
					else if(strname.at(x) == "rgoffset")	 itemshareData.whitepanelParameter->stShadingConfigHB.flRGOffset = strvalue.at(x).toFloat();
					else if(strname.at(x) == "ppoffset")	 itemshareData.whitepanelParameter->stShadingConfigHB.flPPOffset = strvalue.at(x).toFloat();
					else if(strname.at(x) == "yyoffset")	 itemshareData.whitepanelParameter->stShadingConfigHB.flYYOffset = strvalue.at(x).toFloat();
				}
			}
		}

		query.prepare("SELECT itemsuffix2,key,value,reserve FROM " % itemshareData.currentTableName % \
			" WHERE classfy='algorithm' AND item='whitepanel' AND itemsuffix1='defectline' ORDER BY id ASC" );
		query.exec();
		//(spec_r:0.03)(spec_b:0.03)(spec_g:0.03)
		while (query.next()){
			bItemExist = true;
			for(int y=0;	y<4;	++y){
				strData	=	query.value(y).toString();
				ROPLOW::patchconfigstring(strData, strname, strvalue);
				for(int x=0;	x<strname.size();	++x){
					if(strname.at(x) == "spec_r")
						itemshareData.whitepanelParameter->line_flspec_r	=	strvalue.at(x).toFloat(&bok);
					else if(strname.at(x) == "spec_g")
						itemshareData.whitepanelParameter->line_flspec_g	=	strvalue.at(x).toFloat(&bok);
					else if(strname.at(x) == "spec_b")
						itemshareData.whitepanelParameter->line_flspec_b	=	strvalue.at(x).toFloat(&bok);
				}
			}
		}

		query.prepare("SELECT itemsuffix2,key,value,reserve FROM " % itemshareData.currentTableName % \
			" WHERE classfy='algorithm' AND item='whitepanel' AND itemsuffix1='defectpixel' ORDER BY id ASC" );
		query.exec();

		//(defectratio:0.1)(woundratio:0.2)(defectscore:1)(woundscore:2)(deadscore:3)
		//(clusterscore:50)(widthblocks:180)(deadratio:0.3)
		//(defectspec:20)(woundspec:20)(deadspec:20)
		//(totalscorespec:1000)(clusterspec:0)(clustermaxscore:20)
		while (query.next()){
			bItemExist = true;
			for(int y=0;	y<4;	++y){
				strData	=	query.value(y).toString();
				ROPLOW::patchconfigstring(strData, strname, strvalue);
				for(int x=0;	x<strname.size();	++x){
					if(strname.at(x) == "defectratio")
						itemshareData.whitepanelParameter->defectpixel_fldefect	=	strvalue.at(x).toFloat(&bok);
					else if(strname.at(x) == "woundratio")
						itemshareData.whitepanelParameter->defectpixel_flwound	=	strvalue.at(x).toFloat(&bok);
					else if(strname.at(x) == "deadratio")
						itemshareData.whitepanelParameter->defectpixel_fldead	=	strvalue.at(x).toFloat(&bok);
					else if(strname.at(x) == "defectscore")
						itemshareData.whitepanelParameter->defectpixel_ucdefectscore	=	strvalue.at(x).toInt(&bok, 10);
					else if(strname.at(x) == "woundscore")
						itemshareData.whitepanelParameter->defectpixel_ucwoundscore	=	strvalue.at(x).toInt(&bok, 10);
					else if(strname.at(x) == "deadscore")
						itemshareData.whitepanelParameter->defectpixel_ucdeadscore	=	strvalue.at(x).toInt(&bok, 10);
					else if(strname.at(x) == "clusterscore")
						itemshareData.whitepanelParameter->defectpixel_iclusterscore	=	strvalue.at(x).toInt(&bok, 10);
					else if(strname.at(x) == "widthblocks")
						itemshareData.whitepanelParameter->defectpixel_iwidthblocks	=	strvalue.at(x).toInt(&bok, 10);
					else if(strname.at(x) == "defectspec")
						itemshareData.whitepanelParameter->defectpixel_ispecdefect	=	strvalue.at(x).toInt(&bok, 10);
					else if(strname.at(x) == "woundspec")
						itemshareData.whitepanelParameter->defectpixel_ispecwound	=	strvalue.at(x).toInt(&bok, 10);
					else if(strname.at(x) == "deadspec")
						itemshareData.whitepanelParameter->defectpixel_ispecdead	=	strvalue.at(x).toInt(&bok, 10);
					else if(strname.at(x) == "totalscorespec")
						itemshareData.whitepanelParameter->defectpixel_itotalscore	=	strvalue.at(x).toInt(&bok, 10);
					else if(strname.at(x) == "clusterspec")
						itemshareData.whitepanelParameter->defectpixel_ispeccluster	=	strvalue.at(x).toInt(&bok, 10);
					else if(strname.at(x) == "clustermaxscore")
						itemshareData.whitepanelParameter->defectpixel_iclustermaxscore	=	strvalue.at(x).toInt(&bok, 10);
				}
			}
		}

		query.prepare("SELECT itemsuffix2,key,value,reserve FROM " % itemshareData.currentTableName % \
			" WHERE classfy='algorithm' AND item='whitepanel' AND itemsuffix1='defectpixelhb' ORDER BY id ASC" );
		query.exec();

		//(defectratio:0.3)(woundratio:0.5)(deadratio:0.7)(centerrange:0.7)(blocksize:11)(perchannel:true)
		//(centerdefectsingle:1000)(centerwoundsingle:100)(centerdeadsingle:100)(centerdefectclustersize:4)(centerwoundclustersize:3)(centerdeadclustersize:2)
		//(edgedefectsingle:1000)(edgewoundsingle:100)(edgedeadsingle:100)(edgedefectclustersize:4)(edgewoundclustersize:3)(edgedeadclustersize:2)
		while (query.next()){
			bItemExist = true;
			for(int y=0;	y<4;	++y){
				strData	=	query.value(y).toString();
				ROPLOW::patchconfigstring(strData, strname, strvalue);
				for(int x=0;	x<strname.size();	++x){
					if(strname.at(x) == "defectratio")
						itemshareData.whitepanelParameter->defectpixelhb_fldefect	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "woundratio")
						itemshareData.whitepanelParameter->defectpixelhb_flwound	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "deadratio")
						itemshareData.whitepanelParameter->defectpixelhb_fldead	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "centerrange")
						itemshareData.whitepanelParameter->defectpixelhb_flCenterRange	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "blocksize")
						itemshareData.whitepanelParameter->defectpixelhb_uiBlockSize	=	strvalue.at(x).toUInt();
					else if(strname.at(x) == "perchannel")
						itemshareData.whitepanelParameter->defectpixelhb_bPerChannel	=	(strvalue.at(x) == "true")?(true):(false);
					else if(strname.at(x) == "centerdefectsingle")
						itemshareData.whitepanelParameter->defectpixelhb_uiCenterDefectSingle	=	strvalue.at(x).toUInt();
					else if(strname.at(x) == "centerwoundsingle")
						itemshareData.whitepanelParameter->defectpixelhb_uiCenterWoundSingle	=	strvalue.at(x).toUInt();
					else if(strname.at(x) == "centerdeadsingle")
						itemshareData.whitepanelParameter->defectpixelhb_uiCenterDeadSingle	=	strvalue.at(x).toUInt();
					else if(strname.at(x) == "centerdefectclustersize")
						itemshareData.whitepanelParameter->defectpixelhb_uiCenterDefectClusterMax	=	strvalue.at(x).toUInt();
					else if(strname.at(x) == "centerwoundclustersize")
						itemshareData.whitepanelParameter->defectpixelhb_uiCenterWoundClusterMax	=	strvalue.at(x).toUInt();
					else if(strname.at(x) == "centerdeadclustersize")
						itemshareData.whitepanelParameter->defectpixelhb_uiCenterDeadClusterMax	=	strvalue.at(x).toUInt();
					else if(strname.at(x) == "edgedefectsingle")
						itemshareData.whitepanelParameter->defectpixelhb_uiEdgeDefectSingle	=	strvalue.at(x).toUInt();
					else if(strname.at(x) == "edgewoundsingle")
						itemshareData.whitepanelParameter->defectpixelhb_uiEdgeWoundSingle	=	strvalue.at(x).toUInt();
					else if(strname.at(x) == "edgedeadsingle")
						itemshareData.whitepanelParameter->defectpixelhb_uiEdgeDeadSingle	=	strvalue.at(x).toUInt();
					else if(strname.at(x) == "edgedefectclustersize")
						itemshareData.whitepanelParameter->defectpixelhb_uiEdgeDefectClusterMax	=	strvalue.at(x).toUInt();
					else if(strname.at(x) == "edgewoundclustersize")
						itemshareData.whitepanelParameter->defectpixelhb_uiEdgeWoundClusterMax	=	strvalue.at(x).toUInt();
					else if(strname.at(x) == "edgedeadclustersize")
						itemshareData.whitepanelParameter->defectpixelhb_uiEdgeDeadClusterMax	=	strvalue.at(x).toUInt();
				}
			}
		}

		customdb.close();
	}

	QSqlDatabase::removeDatabase("querycustom");

	if(!bItemExist)
	{
		HisReleaseNewO(itemshareData.whitepanelParameter);
		itemshareData.itemparameterLock.unlock();
		return HisFX3Error_Parameter;
	}

	if(!bcheck) {itemshareData.itemparameterLock.unlock(); return 0; }

	int iresult	=	0;
	if(!(itemshareData.whitepanelParameter->usblemish || itemshareData.whitepanelParameter->uscolor || \
		itemshareData.whitepanelParameter->usdefectline || itemshareData.whitepanelParameter->usdefectpixel || \
		itemshareData.whitepanelParameter->usopticalcenter || itemshareData.whitepanelParameter->usVignettingOn || itemshareData.whitepanelParameter->usShadingOn)){
			emit information(QTextCodec::codecForName( "GBK")->toUnicode("白板参数错误：没有测试项开启"));
			iresult	=	HisFX3Error_Parameter;
	}

	if(iresult)	HisReleaseNewO(itemshareData.whitepanelParameter);
	itemshareData.itemparameterLock.unlock();
	return iresult;
}

int itemprocess::whitepanel()
{

	QElapsedTimer testtimer;
	testtimer.start();
	std::vector<_itemDraw>::iterator theIterator;
	itemshareData.drawLock.lockForWrite();
	itemshareData.itemdrawList.clear();
	itemshareData.drawLock.unlock();

	_itemStatus itemstatus;
	QString strinfo;
	int itotalresult	=	0;
	QColor stblemishcolor		=	QColor::fromRgb(255, 0, 0);
	QColor stcolorcolor				=	QColor::fromRgb(255, 255, 0);
	QColor stdefectcluster		=	QColor::fromRgb(0, 255, 255);

	//判断图像是否点亮中
	if(!threadshareData.GetHisPreviewflag())	return HisCCMError_NotPreivew;

	//取得配置参数和规格
	int iresult	=	getwhitepanelParameter(false);
	if(iresult)	return iresult;

	//分配足够的图像数据内存
	unsigned char*pucbalor = NULL, * pucrgb = NULL, *pucr=NULL, *pucb=NULL, *pucgr=NULL, *pucgb = NULL, *pucYUV422U8_Y = NULL;
	unsigned char* pucrgb_r = NULL, *pucrgb_b = NULL, *pucrgb_g = NULL;

	itemshareData.itemparameterLock.lockForRead();

	_HisFX3_BaylorMode ucDataFormat;
	ROPLOW::BaylorXForamt2Baloy8(itemshareData.previewParameter->ucDataFormat, ucDataFormat);

	if(ucDataFormat >= HisYUV8_422_YUYV && ucDataFormat <= HisYUV8_420P){
		if(NULL == (pucbalor	=	(unsigned char*)_aligned_malloc(itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight *2, _HisCacheLine_Aligned))){
			_CODE_WHITEPANEL_EXIT
				return HisFX3Error_MallocBuffer;
		}
		//取得raw图像数据
		if(iresult	=	GetFreshframe(pucbalor, itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight*2, _FrameType_Raw, true)){
			_CODE_WHITEPANEL_EXIT
				return iresult;
		}

		if(NULL == (pucYUV422U8_Y	=	(unsigned char*)_aligned_malloc(itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight, _HisCacheLine_Aligned))){
			_CODE_WHITEPANEL_EXIT
				return HisFX3Error_MallocBuffer;
		}
		classAlgorithm.extactYfromYUV422U8(pucbalor, pucYUV422U8_Y, itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight, itemshareData.previewParameter->ucDataFormat);
	}
	else if(ucDataFormat < HisYUV8_422_YUYV){
		if(NULL == (pucbalor	=	(unsigned char*)_aligned_malloc(itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight, _HisCacheLine_Aligned))){
			_CODE_WHITEPANEL_EXIT
				return HisFX3Error_MallocBuffer;
		}
		//取得raw图像数据
		if(iresult	=	GetFreshframe(pucbalor, itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight, _FrameType_Raw, true)){
			_CODE_WHITEPANEL_EXIT
				return iresult;
		}

		pucr		=	(unsigned char*)_aligned_malloc(((itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight) >>2), _HisCacheLine_Aligned);
		pucb	=	(unsigned char*)_aligned_malloc(((itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight) >>2), _HisCacheLine_Aligned);
		pucgr	=	(unsigned char*)_aligned_malloc(((itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight) >>2), _HisCacheLine_Aligned);
		pucgb	=	(unsigned char*)_aligned_malloc(((itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight) >>2), _HisCacheLine_Aligned);
		if(!(pucr && pucb && pucgr && pucgb)){
			_CODE_WHITEPANEL_EXIT
				return HisFX3Error_MallocBuffer;
		}
		classAlgorithm.patchbaylor(pucbalor, itemshareData.previewParameter->iWidth, itemshareData.previewParameter->iHeight, pucb, pucr, pucgr, pucgb, ucDataFormat);
	}

	if(NULL == (pucrgb	=	(unsigned char*)_aligned_malloc(itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight *3, _HisCacheLine_Aligned))){
		_CODE_WHITEPANEL_EXIT
			return HisFX3Error_MallocBuffer;
	}
	if(iresult	=	GetFreshframe(pucrgb, itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight *3, _FrameType_RGB24, true)){
		_CODE_WHITEPANEL_EXIT
			return iresult;
	}
	if(ucDataFormat == HisRGB_RGB24){
		pucrgb_r		=	(unsigned char*)_aligned_malloc(itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight, _HisCacheLine_Aligned);
		pucrgb_g	=	(unsigned char*)_aligned_malloc(itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight, _HisCacheLine_Aligned);
		pucrgb_b	=	(unsigned char*)_aligned_malloc(itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight, _HisCacheLine_Aligned);
		if(!(pucrgb_r && pucrgb_g && pucrgb_b)){
			_CODE_WHITEPANEL_EXIT
				return HisFX3Error_MallocBuffer;
		}
		ROPLOW::extractrgb24(pucrgb, pucrgb_r, pucrgb_g, pucrgb_b, itemshareData.previewParameter->iWidth, itemshareData.previewParameter->iHeight);
	}

	_HisAlg_Debug stdebug;
	stdebug.uipt_x	=	static_cast<unsigned int>(hisglobalparameter.mouse_ptx *static_cast<double>(itemshareData.previewParameter->iWidth));
	stdebug.uipt_y	=	static_cast<unsigned int>(hisglobalparameter.mouse_pty *static_cast<double>(itemshareData.previewParameter->iHeight));

	//blemish test
	if(itemshareData.whitepanelParameter->usblemish){
		std::vector<RECT> stblemish;
		if(itemshareData.whitepanelParameter->blemishAlg == _HisAlg_SWITCH_A){ //alg A
			iresult	=	classAlgorithm.HisCCMWhitePanel_BlemishHA(pucrgb, itemshareData.previewParameter->iWidth, \
				itemshareData.previewParameter->iHeight,stblemish, stdebug, \
				itemshareData.whitepanelParameter->blemish_flrange, itemshareData.whitepanelParameter->blemish_ihighpass,\
				itemshareData.whitepanelParameter->blemish_ilowpass, itemshareData.whitepanelParameter->blemish_iamplitude, \
				itemshareData.whitepanelParameter->blemish_idev, itemshareData.whitepanelParameter->blemish_corner);
			if(iresult){
				_CODE_WHITEPANEL_EXIT
					return iresult;
			}
		}
		else if(itemshareData.whitepanelParameter->blemishAlg == _HisAlg_SWITCH_B){
			_HisAlg_BlemishHA_DebugInfo stZone1Debug[15], stZone2Debug[15], stZone3Debug[15];
			unsigned char* pucBlemish	=	pucgr, *pucBlemishT = NULL;
			if(ucDataFormat >= HisYUV8_422_YUYV && ucDataFormat <= HisYUV8_420P){
				if(NULL == (pucBlemishT	=	(unsigned char*)_aligned_malloc(((itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight) >>2), _HisCacheLine_Aligned))){
					_CODE_WHITEPANEL_EXIT
						return HisFX3Error_MallocBuffer;
				}
				ROPLOW::FastResize2(pucYUV422U8_Y, pucBlemishT, itemshareData.previewParameter->iWidth, itemshareData.previewParameter->iHeight);
				pucBlemish		=	pucBlemishT;
			}
			else if(ucDataFormat == HisRGB_RGB24){
				if(NULL == (pucBlemishT	=	(unsigned char*)_aligned_malloc(((itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight) >>2), _HisCacheLine_Aligned))){
					_CODE_WHITEPANEL_EXIT
						return HisFX3Error_MallocBuffer;
				}
				ROPLOW::FastResize2(pucrgb_g, pucBlemishT, itemshareData.previewParameter->iWidth, itemshareData.previewParameter->iHeight);
				pucBlemish		=	pucBlemishT;
			}
			iresult = classAlgorithm.HisCCMWhitePanel_BlemishHB(pucBlemish, (itemshareData.previewParameter->iWidth>>1), \
				(itemshareData.previewParameter->iHeight>>1), itemshareData.whitepanelParameter->blemishhb_Zone1Range, \
				(itemshareData.whitepanelParameter->blemishhb_Zone3X>>1), (itemshareData.whitepanelParameter->blemishhb_Zone3Y>>1), \
				itemshareData.whitepanelParameter->blemishhb_Zone1Spec, itemshareData.whitepanelParameter->blemishhb_Zone3Spec, \
				itemshareData.whitepanelParameter->blemishhb_Zone2Spec, stblemish, itemshareData.whitepanelParameter->blemishhb_RemoveDefectPixel, \
				hisglobalparameter.bDebugMode,stZone1Debug, stZone2Debug, stZone3Debug);
			HisReleaseMalloc(pucBlemishT);
			if(iresult){
				_CODE_WHITEPANEL_EXIT
					return iresult;
			}

			if(hisglobalparameter.bDebugMode){
				QString strTempText;
				RECT stCenter;
				int x	=	static_cast<int>(itemshareData.previewParameter->iWidth *itemshareData.whitepanelParameter->blemishhb_Zone1Range);
				int y	=	static_cast<int>(itemshareData.previewParameter->iHeight *itemshareData.whitepanelParameter->blemishhb_Zone1Range);
				stCenter.left				=	((itemshareData.previewParameter->iWidth - x) >>1);
				stCenter.right			=	((itemshareData.previewParameter->iWidth + x) >>1);
				stCenter.top			=	((itemshareData.previewParameter->iHeight - y) >>1);
				stCenter.bottom		=	((itemshareData.previewParameter->iHeight + y) >>1);
				emit information(QTextCodec::codecForName( "GBK")->toUnicode("污点中心测试区域位置:(ROI:") % \
					QString::number(stCenter.left) % "," % QString::number(stCenter.top) % "," % \
					QString::number(stCenter.right) % "," % QString::number(stCenter.bottom) % ")");
				for(unsigned int x=0;	x<15;	++x){
					strTempText		=	QString::number((x+1)*8) % "x" % QString::number((x+1)*8);
					emit information(QTextCodec::codecForName( "GBK")->toUnicode("污点中心区域") % \
						strTempText % QTextCodec::codecForName( "GBK")->toUnicode("调试信息：") % " (ROI:" % \
						QString::number(stZone1Debug[x].stroi.left) % "," % QString::number(stZone1Debug[x].stroi.top) % \
						"," % QString::number(stZone1Debug[x].stroi.right) % "," %QString::number(stZone1Debug[x].stroi.bottom) % \
						") " % QTextCodec::codecForName( "GBK")->toUnicode("值：") % QString::number(stZone1Debug[x].flvalue));
				}
				for(unsigned int x=0;	x<15;	++x){
					strTempText		=	QString::number((x+1)*8) % "x" % QString::number((x+1)*8);
					emit information(QTextCodec::codecForName( "GBK")->toUnicode("污点其余区域") % \
						strTempText % QTextCodec::codecForName( "GBK")->toUnicode("调试信息：") % " (ROI:" % \
						QString::number(stZone2Debug[x].stroi.left) % "," % QString::number(stZone2Debug[x].stroi.top) % \
						"," % QString::number(stZone2Debug[x].stroi.right) % "," %QString::number(stZone2Debug[x].stroi.bottom) % \
						") " % QTextCodec::codecForName( "GBK")->toUnicode("值：") % QString::number(stZone2Debug[x].flvalue));
				}
				stCenter.left			=	stCenter.top	=	0;
				stCenter.right		=	itemshareData.whitepanelParameter->blemishhb_Zone3X;
				stCenter.bottom	=	itemshareData.whitepanelParameter->blemishhb_Zone3Y;
				emit information(QTextCodec::codecForName( "GBK")->toUnicode("污点左上角测试区域位置:(ROI:") % \
					QString::number(stCenter.left) % "," % QString::number(stCenter.top) % "," % \
					QString::number(stCenter.right) % "," % QString::number(stCenter.bottom) % ")");				
				stCenter.left			=	itemshareData.previewParameter->iWidth - itemshareData.whitepanelParameter->blemishhb_Zone3X;
				stCenter.right		=	itemshareData.previewParameter->iWidth;
				stCenter.top		=	0;
				stCenter.bottom	=	itemshareData.whitepanelParameter->blemishhb_Zone3Y;
				emit information(QTextCodec::codecForName( "GBK")->toUnicode("污点右上角测试区域位置:(ROI:") % \
					QString::number(stCenter.left) % "," % QString::number(stCenter.top) % "," % \
					QString::number(stCenter.right) % "," % QString::number(stCenter.bottom) % ")");	
				stCenter.left			=	0;
				stCenter.right		=	itemshareData.whitepanelParameter->blemishhb_Zone3X;
				stCenter.top		=	itemshareData.previewParameter->iHeight - itemshareData.whitepanelParameter->blemishhb_Zone3Y;
				stCenter.bottom	=	itemshareData.previewParameter->iHeight;
				emit information(QTextCodec::codecForName( "GBK")->toUnicode("污点左下角测试区域位置:(ROI:") % \
					QString::number(stCenter.left) % "," % QString::number(stCenter.top) % "," % \
					QString::number(stCenter.right) % "," % QString::number(stCenter.bottom) % ")");	
				stCenter.left			=	itemshareData.previewParameter->iWidth - itemshareData.whitepanelParameter->blemishhb_Zone3X;
				stCenter.right		=	itemshareData.previewParameter->iWidth;
				stCenter.top		=	itemshareData.previewParameter->iHeight - itemshareData.whitepanelParameter->blemishhb_Zone3Y;
				stCenter.bottom	=	itemshareData.previewParameter->iHeight;
				emit information(QTextCodec::codecForName( "GBK")->toUnicode("污点右下角测试区域位置:(ROI:") % \
					QString::number(stCenter.left) % "," % QString::number(stCenter.top) % "," % \
					QString::number(stCenter.right) % "," % QString::number(stCenter.bottom) % ")");	
				for(unsigned int x=0;	x<15;	++x){
					strTempText		=	QString::number((x+1)*8) % "x" % QString::number((x+1)*8);
					emit information(QTextCodec::codecForName( "GBK")->toUnicode("污点四角区域") % \
						strTempText % QTextCodec::codecForName( "GBK")->toUnicode("调试信息：") % " (ROI:" % \
						QString::number(stZone3Debug[x].stroi.left) % "," % QString::number(stZone3Debug[x].stroi.top) % \
						"," % QString::number(stZone3Debug[x].stroi.right) % "," %QString::number(stZone3Debug[x].stroi.bottom) % \
						") " % QTextCodec::codecForName( "GBK")->toUnicode("值：") % QString::number(stZone3Debug[x].flvalue));
				}
			}
		}
		else if(itemshareData.whitepanelParameter->blemishAlg == _HisAlg_SWITCH_C){
			iresult	=	whitepanel_BlemishHC();
		}

		itemstatus.usitem		=	whitepanelitem_blemish;
		itemstatus.ucstatus	=	_His_ItemStatus_PASS;
		stLogItem.itemtype		=	classLog->getmaxtypeindex(_HISLOG_CLASSIFY_WHITEPANEL);
		stLogItem.itemkey		=	"Blemish Result";
		stLogItem.itemvalue	=	"OK";

		if(stblemish.size() && itemshareData.whitepanelParameter->blemishAlg != _HisAlg_SWITCH_C){
			itemshareData.drawLock.lockForWrite();
			int ilastcount	=	itemshareData.itemdrawList.size();
			itemshareData.itemdrawList.resize(ilastcount + stblemish.size());
			theIterator	=	itemshareData.itemdrawList.begin() +ilastcount;
			for(int i=0;	i<stblemish.size();	++i){
				theIterator->usitem	=	whitepanelitem_blemish;
				theIterator->uctype	=	HisDrawType_Block;
				theIterator->stcolor	=	stblemishcolor;
				theIterator->strinfo.stblock	=	stblemish.at(i);
				emit information(QTextCodec::codecForName( "GBK")->toUnicode("污点") % QString::number(i+1, 10) % ":    " % \
					QTextCodec::codecForName( "GBK")->toUnicode("左上(") % QString::number(theIterator->strinfo.stblock.left, 10) % \
					"," % QString::number(theIterator->strinfo.stblock.top, 10) % QTextCodec::codecForName( "GBK")->toUnicode(")    右下(") % \
					QString::number(theIterator->strinfo.stblock.right, 10) % "," % QString::number(theIterator->strinfo.stblock.bottom, 10) % ")");
				theIterator++;
			}
			itemshareData.drawLock.unlock();
			itemstatus.ucstatus	=	_His_ItemStatus_NG;
			itotalresult					=	HisCCMError_Result;
			stLogItem.itemvalue	=	"NG";
		}

		if(itemshareData.whitepanelParameter->blemishAlg == _HisAlg_SWITCH_C && iresult){
			itemstatus.ucstatus	=	_His_ItemStatus_NG;
			itotalresult					=	HisCCMError_Result;
			stLogItem.itemvalue	=	"NG";
		}

		classLog->push_back(stLogItem);
		itemstatus.ustime	=	testtimer.restart();
		updateItemstatus(itemstatus);
	}

	//output debug info
	if(stdebug.stlist.size() > 0){
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("点(") % QString::number(stdebug.uipt_x, 10) % \
			"," % QString::number(stdebug.uipt_y, 10) % QTextCodec::codecForName( "GBK")->toUnicode(")调试信息："));
		for(int i=0;	i<stdebug.stlist.size(); ++i){
			switch (stdebug.stlist.at(i).ustype){
			case HisAlg_WhitePanel_Blemish_Corner:
				break;
			case HisAlg_WhitePanel_Blemish_Amplitude:
				emit information(QTextCodec::codecForName( "GBK")->toUnicode("      污点测试-振幅：") % \
					QString::number(static_cast<double>(stdebug.stlist.at(i).dflvalue), 'f', 6));
				break;
			case HisAlg_WhitePanel_Blemish_Dev:
				emit information(QTextCodec::codecForName( "GBK")->toUnicode("      污点测试-方差：") % \
					QString::number(static_cast<double>(stdebug.stlist.at(i).dflvalue), 'f', 6));
				break;
			case HisAlg_WhitePanel_Color_Uniform:
				emit information(QTextCodec::codecForName( "GBK")->toUnicode("      颜色均匀测试-差异：") % \
					QString::number(static_cast<double>(stdebug.stlist.at(i).dflvalue), 'f', 6));
				break;
			default:
				break;
			}
		}
		stdebug.stlist.clear();
	}

	//color test
	if(itemshareData.whitepanelParameter->uscolor){
		if(itemshareData.whitepanelParameter->colorAlg == _HisAlg_SWITCH_A){ //alg A
			RECT stcoloruniform	=	{0};
			float centera, centerb, symmetrymax, falloffmax;
			iresult	=	classAlgorithm.HisCCMWhitePanel_ColorHA(pucrgb, itemshareData.previewParameter->iWidth, itemshareData.previewParameter->iHeight, \
				stcoloruniform, centera, centerb, symmetrymax, falloffmax, stdebug, \
				itemshareData.whitepanelParameter->color_flcenterrange,itemshareData.whitepanelParameter->color_iwithblocks, \
				itemshareData.whitepanelParameter->color_fluniform);
			if(iresult){
				_CODE_WHITEPANEL_EXIT
					return iresult;
			}

			itemstatus.ucstatus	=	_His_ItemStatus_PASS;
			itemstatus.usitem		=	whitepanelitem_color;
			stLogItem.itemtype		=	classLog->getmaxtypeindex(_HISLOG_CLASSIFY_WHITEPANEL);
			stLogItem.itemkey		=	"Color Result";
			stLogItem.itemvalue	=	"OK";

			float fldistance	=	sqrtf((centera-itemshareData.whitepanelParameter->color_flideala)*(centera-itemshareData.whitepanelParameter->color_flideala) + \
				(centerb-itemshareData.whitepanelParameter->color_flidealb)*(centerb-itemshareData.whitepanelParameter->color_flidealb));

			emit information(QTextCodec::codecForName( "GBK")->toUnicode("白板颜色测试数据："));
			emit information(QTextCodec::codecForName( "GBK")->toUnicode("         中心色差：") % QString::number(static_cast<double>(fldistance), 'f', 6));
			emit information(QTextCodec::codecForName( "GBK")->toUnicode("         对称色差：") % QString::number(static_cast<double>(symmetrymax), 'f', 6));
			emit information(QTextCodec::codecForName( "GBK")->toUnicode("         四角色差：") % QString::number(static_cast<double>(falloffmax), 'f', 6));

			if(fldistance>itemshareData.whitepanelParameter->color_flaberration){
				emit information(QTextCodec::codecForName( "GBK")->toUnicode("中心色差---NG"));
				itemstatus.ucstatus	=	_His_ItemStatus_NG;
				itotalresult					=	HisCCMError_Result;
				stLogItem.itemvalue	=	"NG";
			}

			if(symmetrymax > itemshareData.whitepanelParameter->color_flsym){
				emit information(QTextCodec::codecForName( "GBK")->toUnicode("对称色差---NG"));
				itemstatus.ucstatus	=	_His_ItemStatus_NG;
				itotalresult					=	HisCCMError_Result;
				stLogItem.itemvalue	=	"NG";
			}

			if(falloffmax > itemshareData.whitepanelParameter->color_flfalloff){
				emit information(QTextCodec::codecForName( "GBK")->toUnicode("四角色差---NG"));
				itemstatus.ucstatus	=	_His_ItemStatus_NG;
				itotalresult					=	HisCCMError_Result;
				stLogItem.itemvalue	=	"NG";
			}

			if(stcoloruniform.bottom){
				itemshareData.drawLock.lockForWrite();
				int ilastcount	=	itemshareData.itemdrawList.size();
				itemshareData.itemdrawList.resize(ilastcount + 1);
				theIterator	=	itemshareData.itemdrawList.begin() +ilastcount;
				theIterator->usitem				=	whitepanelitem_color;
				theIterator->uctype				=	HisDrawType_Block;
				theIterator->stcolor				=	stcolorcolor;
				theIterator->strinfo.stblock	=	stcoloruniform;
				itemshareData.drawLock.unlock();
				emit information(QTextCodec::codecForName( "GBK")->toUnicode("         颜色不均匀位置：") % \
					QTextCodec::codecForName( "GBK")->toUnicode("左上(") % QString::number(stcoloruniform.left, 10) % \
					"," % QString::number(stcoloruniform.top, 10) % QTextCodec::codecForName( "GBK")->toUnicode(")    右下(") % \
					QString::number(stcoloruniform.right, 10) % "," % QString::number(stcoloruniform.bottom, 10) % ")");

				itemstatus.ucstatus	=	_His_ItemStatus_NG;
				itotalresult					=	HisCCMError_Result;
				stLogItem.itemvalue	=	"NG";
			}

			itemstatus.ustime	=	testtimer.restart();
			updateItemstatus(itemstatus);

			classLog->push_back(stLogItem);
			++(stLogItem.itemtype);
			stLogItem.itemkey		=	"Color Aberration";
			stLogItem.itemvalue	=	fldistance;
			classLog->push_back(stLogItem);
			++(stLogItem.itemtype);
			stLogItem.itemkey		=	"Color Symmetry";
			stLogItem.itemvalue	=	symmetrymax;
			classLog->push_back(stLogItem);
			++(stLogItem.itemtype);
			stLogItem.itemkey		=	"Color Falloff";
			stLogItem.itemvalue	=	falloffmax;
			classLog->push_back(stLogItem);
			++(stLogItem.itemtype);
			stLogItem.itemkey		=	"Color Uniform";
			stLogItem.itemvalue	=	(stcoloruniform.bottom)?("NG"):("OK");
			classLog->push_back(stLogItem);
		}
	}

	if(stdebug.stlist.size() > 0){
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("点(") % QString::number(stdebug.uipt_x, 10) % \
			"," % QString::number(stdebug.uipt_y, 10) % QTextCodec::codecForName( "GBK")->toUnicode(")调试信息："));
		for(int i=0;	i<stdebug.stlist.size(); ++i){
			switch (stdebug.stlist.at(i).ustype){
			case HisAlg_WhitePanel_Blemish_Corner:
				break;
			case HisAlg_WhitePanel_Blemish_Amplitude:
				emit information(QTextCodec::codecForName( "GBK")->toUnicode("      污点测试-振幅：") % \
					QString::number(static_cast<double>(stdebug.stlist.at(i).dflvalue), 'f', 6));
				break;
			case HisAlg_WhitePanel_Blemish_Dev:
				emit information(QTextCodec::codecForName( "GBK")->toUnicode("      污点测试-方差：") % \
					QString::number(static_cast<double>(stdebug.stlist.at(i).dflvalue), 'f', 6));
				break;
			case HisAlg_WhitePanel_Color_Uniform:
				emit information(QTextCodec::codecForName( "GBK")->toUnicode("      颜色均匀测试-差异：") % \
					QString::number(static_cast<double>(stdebug.stlist.at(i).dflvalue), 'f', 6));
				break;
			default:
				break;
			}
		}
		stdebug.stlist.clear();
	}


	testtimer.restart();


	//optical center test
	if(itemshareData.whitepanelParameter->usopticalcenter){
		if(itemshareData.whitepanelParameter->opticalcenterAlg == _HisAlg_SWITCH_A){
			int ioc_x, ioc_y, iWdithT, iHeightT;
			unsigned char* pucBufferOC;
			if(ucDataFormat >= HisYUV8_422_YUYV && ucDataFormat <= HisYUV8_420P){
				pucBufferOC	=	pucYUV422U8_Y;
				iWdithT			=	itemshareData.previewParameter->iWidth;
				iHeightT			=	itemshareData.previewParameter->iHeight;
			}
			else if(ucDataFormat == HisRGB_RGB24){
				pucBufferOC	=	pucrgb_g;
				iWdithT			=	itemshareData.previewParameter->iWidth;
				iHeightT			=	itemshareData.previewParameter->iHeight;
			}
			else{
				pucBufferOC	=	pucgr;
				iWdithT			=	(itemshareData.previewParameter->iWidth >>1);
				iHeightT			=	(itemshareData.previewParameter->iHeight >>1);
			}

			iresult	=	classAlgorithm.HisCCMWhitePanel_OCHA(pucBufferOC,iWdithT, iHeightT, ioc_x, ioc_y, itemshareData.whitepanelParameter->oc_flpixelratio);
			if(iresult){
				_CODE_WHITEPANEL_EXIT
					return iresult;
			}

			if((ucDataFormat >= HisYUV8_422_YUYV && ucDataFormat <= HisYUV8_420P) || (ucDataFormat == HisRGB_RGB24)){
				iWdithT	=	(iWdithT >>1);
				iHeightT	=	(iHeightT >>1);
				ioc_x		=	(ioc_x >>1);
				ioc_y		=	(ioc_y >>1);
			}

			float fldistance	=	sqrtf((ioc_x-itemshareData.previewParameter->iWidth/2)*(ioc_x-itemshareData.previewParameter->iWidth/2) + \
				(ioc_y-itemshareData.previewParameter->iHeight/2)*(ioc_y-itemshareData.previewParameter->iHeight/2));
			emit information(QTextCodec::codecForName( "GBK")->toUnicode("光心测试数据："));
			emit information(QTextCodec::codecForName( "GBK")->toUnicode("          测试光心坐标(x,y)：") % \
				QString::number(ioc_x, 10) % ",  " % QString::number(ioc_y, 10) );
			emit information(QTextCodec::codecForName( "GBK")->toUnicode("         与物理中心距离：") % \
				QString::number(static_cast<double>(fldistance), 'f', 3) % "pixel");

			itemshareData.drawLock.lockForWrite();
			int ilastcount	=	itemshareData.itemdrawList.size();
			itemshareData.itemdrawList.resize(ilastcount + 2);
			theIterator	=	itemshareData.itemdrawList.begin() +ilastcount;
			theIterator->usitem							=	whitepanelitem_oc;
			theIterator->uctype							=	HisDrawType_Line;
			theIterator->stcolor							=	QColor::fromRgb(0, 255, 0);
			theIterator->strinfo.stblock.left			=	ioc_x - 100;
			theIterator->strinfo.stblock.right		=	ioc_x + 100;
			theIterator->strinfo.stblock.top			=	ioc_y;
			theIterator->strinfo.stblock.bottom	=	ioc_y;
			theIterator++;
			theIterator->usitem							=	whitepanelitem_oc;
			theIterator->uctype							=	HisDrawType_Line;
			theIterator->stcolor							=	QColor::fromRgb(0, 255, 0);
			theIterator->strinfo.stblock.left			=	ioc_x;
			theIterator->strinfo.stblock.right		=	ioc_x;
			theIterator->strinfo.stblock.top			=	ioc_y - 100;
			theIterator->strinfo.stblock.bottom	=	ioc_y + 100;
			itemshareData.drawLock.unlock();

			stLogItem.itemtype		=	classLog->getmaxtypeindex(_HISLOG_CLASSIFY_WHITEPANEL);
			stLogItem.itemkey		=	"OC Result";
			stLogItem.itemvalue	=	"OK";

			itemstatus.usitem		=	whitepanelitem_oc;
			itemstatus.ucstatus	=	_His_ItemStatus_PASS;
			if(fldistance > itemshareData.whitepanelParameter->oc_fldeviation){
				itemstatus.ucstatus	=	_His_ItemStatus_NG;
				itotalresult					=	HisCCMError_Result;
				stLogItem.itemvalue	=	"NG";
				itemshareData.drawLock.lockForWrite();
				theIterator	=	itemshareData.itemdrawList.begin() +ilastcount;
				theIterator->stcolor	=	QColor::fromRgb(255, 0, 0);
				theIterator++;
				theIterator->stcolor	=	QColor::fromRgb(255, 0, 0);
				itemshareData.drawLock.unlock();
			}

			itemstatus.ustime	=	testtimer.restart();
			updateItemstatus(itemstatus);

			classLog->push_back(stLogItem);
			++(stLogItem.itemtype);
			stLogItem.itemkey		=	"OC_X";
			stLogItem.itemvalue	=	ioc_x;
			classLog->push_back(stLogItem);
			++(stLogItem.itemtype);
			stLogItem.itemkey		=	"OC_Y";
			stLogItem.itemvalue	=	ioc_y;
			classLog->push_back(stLogItem);
			++(stLogItem.itemtype);
			stLogItem.itemkey		=	"OC_Distance";
			stLogItem.itemvalue	=	fldistance;
			classLog->push_back(stLogItem);
		}
	}

	if(itemshareData.whitepanelParameter->usdefectline){
		if(itemshareData.whitepanelParameter->defectlineAlg == _HisAlg_SWITCH_A){
			std::vector<_WhitePanel_DefectLine_Result> stmaxline;
			unsigned char* pucBaylorR	=	pucr, *pucBaylorB = pucb, *pucBaylorGr = pucgr, *pucBaylorGb = pucgb;
			int iWidthT = (itemshareData.previewParameter->iWidth >>1), iHeightT = (itemshareData.previewParameter->iHeight >>1);
			if(ucDataFormat >= HisYUV8_422_YUYV && ucDataFormat <= HisYUV8_420P){
				pucBaylorR	=	pucYUV422U8_Y;
				pucBaylorB	=	pucBaylorGr = pucBaylorGb = NULL;
				iWidthT		=	itemshareData.previewParameter->iWidth;
				iHeightT		=	itemshareData.previewParameter->iHeight;
			}
			else if(ucDataFormat == HisRGB_RGB24){
				pucBaylorR	=	pucrgb_r;
				pucBaylorB	=	pucrgb_b;
				pucBaylorGr = pucrgb_g;
				pucBaylorGb	=	NULL;
				iWidthT		=	itemshareData.previewParameter->iWidth;
				iHeightT		=	itemshareData.previewParameter->iHeight;
			}

			if(iresult	=	classAlgorithm.HisCCMWhitePanel_DefectLineHA(pucBaylorR, pucBaylorB, pucBaylorGr, pucBaylorGb, iWidthT, iHeightT, stmaxline)){
				_CODE_WHITEPANEL_EXIT
					return iresult;
			}

			if(ucDataFormat >= HisYUV8_422_YUYV && ucDataFormat <= HisYUV8_420P){
				for(unsigned int x=0;	x<stmaxline.size(); ++x)
					stmaxline.at(x).bufferType	=	_HisFX3_BufferFormat_Y;
			}
			else if(ucDataFormat == HisRGB_RGB24){
				for(unsigned int x=0;	x<stmaxline.size(); ++x)
					if(stmaxline.at(x).bufferType == _HisFX3_BufferFormat_BayloyGr || stmaxline.at(x).bufferType == _HisFX3_BufferFormat_BaylorGb) stmaxline.at(x).bufferType = _HisFX3_BufferFormat_G;
			}
			else{
				for(unsigned int x=0;	x<stmaxline.size(); ++x)
					stmaxline.at(x).uiLineIndex	=	(stmaxline.at(x).uiLineIndex <<1);
			}

			QString strInfo;
			emit information(QTextCodec::codecForName( "GBK")->toUnicode("线条测试数据："));
			for(unsigned int x=0;	x<stmaxline.size(); ++x){
				switch (stmaxline.at(x).bufferType){
				case _HisFX3_BufferFormat_BayloyGr:	strInfo = QTextCodec::codecForName( "GBK")->toUnicode("         Gr通道("); break;
				case _HisFX3_BufferFormat_BaylorGb:	strInfo = QTextCodec::codecForName( "GBK")->toUnicode("         Gb通道("); break;
				case _HisFX3_BufferFormat_BaylorR:		strInfo = QTextCodec::codecForName( "GBK")->toUnicode("         R通道("); break;
				case _HisFX3_BufferFormat_BaylorB:		strInfo = QTextCodec::codecForName( "GBK")->toUnicode("         B通道("); break;
				case _HisFX3_BufferFormat_G:				strInfo = QTextCodec::codecForName( "GBK")->toUnicode("         G通道("); break;
				case _HisFX3_BufferFormat_Y:	
				default:															strInfo = QTextCodec::codecForName( "GBK")->toUnicode("         Y通道("); break;
				}
				strInfo	=	strInfo % QString::number(stmaxline.at(x).uiLineIndex) % ((stmaxline.at(x).lineType==_HisAlg_LineType_Vertical)?(QTextCodec::codecForName( "GBK")->toUnicode("列)浓度： ")):(QTextCodec::codecForName( "GBK")->toUnicode("行)浓度： "))) %\
					QString::number(stmaxline.at(x).flPercent, 'f', 3);
				emit information(strInfo);
			}

			itemstatus.usitem		=	whitepanelitem_line;
			itemstatus.ucstatus	=	_His_ItemStatus_PASS;
			stLogItem.itemtype		=	classLog->getmaxtypeindex(_HISLOG_CLASSIFY_WHITEPANEL);
			stLogItem.itemkey		=	"Defect_Line Result";
			stLogItem.itemvalue	=	"OK";

			bool bDefectLineResult	=	(stmaxline.size() < 1)?(false):(true);
			for(unsigned int x=0;	x<stmaxline.size(); ++x){
				switch (stmaxline.at(x).bufferType){
				case _HisFX3_BufferFormat_BayloyGr:	bDefectLineResult = (stmaxline.at(x).flPercent >  itemshareData.whitepanelParameter->line_flspec_g)?(false):(bDefectLineResult); break;
				case _HisFX3_BufferFormat_BaylorGb:	bDefectLineResult = (stmaxline.at(x).flPercent >  itemshareData.whitepanelParameter->line_flspec_g)?(false):(bDefectLineResult); break;
				case _HisFX3_BufferFormat_G:				bDefectLineResult = (stmaxline.at(x).flPercent >  itemshareData.whitepanelParameter->line_flspec_g)?(false):(bDefectLineResult); break;
				case _HisFX3_BufferFormat_BaylorR:		bDefectLineResult = (stmaxline.at(x).flPercent >  itemshareData.whitepanelParameter->line_flspec_r)?(false):(bDefectLineResult); break;
				case _HisFX3_BufferFormat_BaylorB:		bDefectLineResult = (stmaxline.at(x).flPercent >  itemshareData.whitepanelParameter->line_flspec_b)?(false):(bDefectLineResult); break;
				case _HisFX3_BufferFormat_Y:	
				default:															bDefectLineResult = (stmaxline.at(x).flPercent >  max(itemshareData.whitepanelParameter->line_flspec_b, max(itemshareData.whitepanelParameter->line_flspec_g,  itemshareData.whitepanelParameter->line_flspec_r)))?(false):(bDefectLineResult); break;
				}
			}
			if(!bDefectLineResult){
				itotalresult					=	HisCCMError_Result;
				itemstatus.ucstatus	=	_His_ItemStatus_NG;
				stLogItem.itemvalue	=	"NG";
			}

			itemstatus.ustime	=	testtimer.restart();
			updateItemstatus(itemstatus);

			classLog->push_back(stLogItem);
		}
	}

	if(itemshareData.whitepanelParameter->usShadingOn){
		if(itemshareData.whitepanelParameter->shadingAlg == _HisAlg_SWITCH_A){
			_HisAlg_Shading_HA_Data stShadingData;
			if(iresult = classAlgorithm.HisCCMWhitePanel_ShadingHA(pucrgb, itemshareData.previewParameter->iWidth, \
				itemshareData.previewParameter->iHeight, itemshareData.whitepanelParameter->stShadingConfigHA, stShadingData, hisglobalparameter.bDebugMode)){
					_CODE_UPDATE_ITEMDATA1(whitepanelitem_shading, _His_ItemStatus_NG);
					_CODE_WHITEPANEL_EXIT
						emit information(QString::fromWCharArray(classAlgorithm.GetLastError()));
					return iresult;
			}

			if(!stShadingData.bResult)	itotalresult	=	HisCCMError_Result;

			emit information(QTextCodec::codecForName( "GBK")->toUnicode("左上角shanding: ") % QString::number(stShadingData.flLT));
			emit information(QTextCodec::codecForName( "GBK")->toUnicode("右上角shanding: ") % QString::number(stShadingData.flRT));
			emit information(QTextCodec::codecForName( "GBK")->toUnicode("左下角shanding: ") % QString::number(stShadingData.flLB));
			emit information(QTextCodec::codecForName( "GBK")->toUnicode("右下角shanding: ") % QString::number(stShadingData.flRB));
			emit information(QTextCodec::codecForName( "GBK")->toUnicode("四角shanding差异: ") % QString::number(stShadingData.flDev));

			ROPLOW::saveShadingHALog(stShadingData, *classLog);
			ROPLOW::addDrawShadingHA(itemshareData.whitepanelParameter->stShadingConfigHA, stShadingData, itemshareData.itemdrawList);
			_CODE_UPDATE_ITEMDATA1(whitepanelitem_shading, (stShadingData.bResult)?(_His_ItemStatus_PASS):(_His_ItemStatus_NG));
		}
		else if(itemshareData.whitepanelParameter->shadingAlg == _HisAlg_SWITCH_B){
			_HisAlg_Shading_HB_Data stShadingData,stShadingDataOffset;
			if(iresult = classAlgorithm.HisCCMWhitePanel_ShadingHB(pucrgb, itemshareData.previewParameter->iWidth, \
				itemshareData.previewParameter->iHeight, stShadingData, hisglobalparameter.bDebugMode)){
					_CODE_UPDATE_ITEMDATA1(whitepanelitem_shading, _His_ItemStatus_NG);
					_CODE_WHITEPANEL_EXIT
						emit information(QString::fromWCharArray(classAlgorithm.GetLastError()));
					return iresult;
			}

			stShadingDataOffset				=	stShadingData;
			stShadingDataOffset.Y			+=	itemshareData.whitepanelParameter->stShadingConfigHB.flYYOffset;
			stShadingDataOffset.RG		+=	itemshareData.whitepanelParameter->stShadingConfigHB.flRGOffset;
			stShadingDataOffset.BG		+=	itemshareData.whitepanelParameter->stShadingConfigHB.flBGOffset;
			stShadingDataOffset.PP		+=	itemshareData.whitepanelParameter->stShadingConfigHB.flPPOffset;

			if(stShadingDataOffset.Y_0 > itemshareData.whitepanelParameter->stShadingConfigHB.flShadingSpecMax || stShadingDataOffset.Y_0 < itemshareData.whitepanelParameter->stShadingConfigHB.flShadingSpecMin || \
				stShadingDataOffset.Y_6 > itemshareData.whitepanelParameter->stShadingConfigHB.flShadingSpecMax || stShadingDataOffset.Y_6 < itemshareData.whitepanelParameter->stShadingConfigHB.flShadingSpecMin || \
				stShadingDataOffset.Y_42 > itemshareData.whitepanelParameter->stShadingConfigHB.flShadingSpecMax || stShadingDataOffset.Y_42 < itemshareData.whitepanelParameter->stShadingConfigHB.flShadingSpecMin || \
				stShadingDataOffset.Y_48 > itemshareData.whitepanelParameter->stShadingConfigHB.flShadingSpecMax || stShadingDataOffset.Y_48 < itemshareData.whitepanelParameter->stShadingConfigHB.flShadingSpecMin || \
				stShadingDataOffset.Y > itemshareData.whitepanelParameter->stShadingConfigHB.flShadingSpecDev || \
				stShadingDataOffset.RG > itemshareData.whitepanelParameter->stShadingConfigHB.flSpecRGMax || stShadingDataOffset.RG < itemshareData.whitepanelParameter->stShadingConfigHB.flSpecRGMin || \
				stShadingDataOffset.BG > itemshareData.whitepanelParameter->stShadingConfigHB.flSpecBGMax || stShadingDataOffset.BG < itemshareData.whitepanelParameter->stShadingConfigHB.flSpecBGMin || \
				stShadingDataOffset.PP > itemshareData.whitepanelParameter->stShadingConfigHB.flSpecPPMax || stShadingDataOffset.PP < itemshareData.whitepanelParameter->stShadingConfigHB.flSpecPPMin)
				stShadingDataOffset.bResult	=	false;
			else
				stShadingDataOffset.bResult	=	true;

			if(!stShadingDataOffset.bResult)	itotalresult	=	HisCCMError_Result;
			emit information(QTextCodec::codecForName( "GBK")->toUnicode("左上角shanding: ") % QString::number(stShadingData.Y_0));
			emit information(QTextCodec::codecForName( "GBK")->toUnicode("右上角shanding: ") % QString::number(stShadingData.Y_6));
			emit information(QTextCodec::codecForName( "GBK")->toUnicode("左下角shanding: ") % QString::number(stShadingData.Y_42));
			emit information(QTextCodec::codecForName( "GBK")->toUnicode("右下角shanding: ") % QString::number(stShadingData.Y_48));
			emit information("YY   Original: " % QString::number(stShadingData.Y, 'f', 3) % "  Offset: " % QString::number(itemshareData.whitepanelParameter->stShadingConfigHB.flYYOffset, 'f', 3) % \
				"  Final: " % QString::number(stShadingDataOffset.Y, 'f', 3));
			emit information("RG   Original: " % QString::number(stShadingData.RG, 'f', 3) % "  Offset: " % QString::number(itemshareData.whitepanelParameter->stShadingConfigHB.flRGOffset, 'f', 3) % \
				"  Final: " % QString::number(stShadingDataOffset.RG, 'f', 3));
			emit information("BG   Original: " % QString::number(stShadingData.BG, 'f', 3) % "  Offset: " % QString::number(itemshareData.whitepanelParameter->stShadingConfigHB.flBGOffset, 'f', 3) % \
				"  Final: " % QString::number(stShadingDataOffset.BG, 'f', 3));
			emit information("PP   Original: " % QString::number(stShadingData.PP, 'f', 3) % "  Offset: " % QString::number(itemshareData.whitepanelParameter->stShadingConfigHB.flPPOffset, 'f', 3) % \
				"  Final: " % QString::number(stShadingDataOffset.PP, 'f', 3));

			ROPLOW::saveShadingHBLog(stShadingData, stShadingDataOffset, itemshareData.whitepanelParameter->stShadingConfigHB.flYYOffset, \
				itemshareData.whitepanelParameter->stShadingConfigHB.flRGOffset, itemshareData.whitepanelParameter->stShadingConfigHB.flBGOffset, \
				itemshareData.whitepanelParameter->stShadingConfigHB.flPPOffset, *classLog);
			ROPLOW::addDrawShadingHB(itemshareData.whitepanelParameter->stShadingConfigHB, stShadingData, itemshareData.itemdrawList);
			_CODE_UPDATE_ITEMDATA1(whitepanelitem_shading, (stShadingDataOffset.bResult)?(_His_ItemStatus_PASS):(_His_ItemStatus_NG));
		}
	}

	if(itemshareData.whitepanelParameter->usVignettingOn){
		if(itemshareData.whitepanelParameter->vignettingAlg == _HisAlg_SWITCH_A){
			_HisAlg_Vignetting_HA_Data stVignettingData;
			if(iresult = classAlgorithm.HisCCMWhitePanel_VignettingHA(pucrgb, itemshareData.previewParameter->iWidth, \
				itemshareData.previewParameter->iHeight, itemshareData.whitepanelParameter->stVignettingConfigHA, stVignettingData, hisglobalparameter.bDebugMode)){
					_CODE_UPDATE_ITEMDATA1(whitepanelitem_vignetting, _His_ItemStatus_NG);
					_CODE_WHITEPANEL_EXIT
						emit information(QString::fromWCharArray(classAlgorithm.GetLastError()));
					return iresult;
			}

			if(!stVignettingData.bResult)	itotalresult	=	HisCCMError_Result;
			emit information(QTextCodec::codecForName( "GBK")->toUnicode("Vignetting(Y)左上角R1 /R2: ") % QString::number(stVignettingData.flLTR2));
			emit information(QTextCodec::codecForName( "GBK")->toUnicode("Vignetting(Y)左上角R1 /R3: ") % QString::number(stVignettingData.flLTR3));
			emit information(QTextCodec::codecForName( "GBK")->toUnicode("Vignetting(Y)右上角R1 /R2: ") % QString::number(stVignettingData.flRTR2));
			emit information(QTextCodec::codecForName( "GBK")->toUnicode("Vignetting(Y)右上角R1 /R3: ") % QString::number(stVignettingData.flRTR3));
			emit information(QTextCodec::codecForName( "GBK")->toUnicode("Vignetting(Y)左下角R1 /R2: ") % QString::number(stVignettingData.flLBR2));
			emit information(QTextCodec::codecForName( "GBK")->toUnicode("Vignetting(Y)左下角R1 /R3: ") % QString::number(stVignettingData.flLBR3));
			emit information(QTextCodec::codecForName( "GBK")->toUnicode("Vignetting(Y)右下角R1 /R2: ") % QString::number(stVignettingData.flRBR2));
			emit information(QTextCodec::codecForName( "GBK")->toUnicode("Vignetting(Y)右下角R1 /R3: ") % QString::number(stVignettingData.flRBR3));

			emit information(QTextCodec::codecForName( "GBK")->toUnicode("Vignetting(R)左上角R1 /R2: ") % QString::number(stVignettingData.flLTR2_R));
			emit information(QTextCodec::codecForName( "GBK")->toUnicode("Vignetting(R)左上角R1 /R3: ") % QString::number(stVignettingData.flLTR3_R));
			emit information(QTextCodec::codecForName( "GBK")->toUnicode("Vignetting(R)右上角R1 /R2: ") % QString::number(stVignettingData.flRTR2_R));
			emit information(QTextCodec::codecForName( "GBK")->toUnicode("Vignetting(R)右上角R1 /R3: ") % QString::number(stVignettingData.flRTR3_R));
			emit information(QTextCodec::codecForName( "GBK")->toUnicode("Vignetting(R)左下角R1 /R2: ") % QString::number(stVignettingData.flLBR2_R));
			emit information(QTextCodec::codecForName( "GBK")->toUnicode("Vignetting(R)左下角R1 /R3: ") % QString::number(stVignettingData.flLBR3_R));
			emit information(QTextCodec::codecForName( "GBK")->toUnicode("Vignetting(R)右下角R1 /R2: ") % QString::number(stVignettingData.flRBR2_R));
			emit information(QTextCodec::codecForName( "GBK")->toUnicode("Vignetting(R)右下角R1 /R3: ") % QString::number(stVignettingData.flRBR3_R));

			emit information(QTextCodec::codecForName( "GBK")->toUnicode("Vignetting(G)左上角R1 /R2: ") % QString::number(stVignettingData.flLTR2_G));
			emit information(QTextCodec::codecForName( "GBK")->toUnicode("Vignetting(G)左上角R1 /R3: ") % QString::number(stVignettingData.flLTR3_G));
			emit information(QTextCodec::codecForName( "GBK")->toUnicode("Vignetting(G)右上角R1 /R2: ") % QString::number(stVignettingData.flRTR2_G));
			emit information(QTextCodec::codecForName( "GBK")->toUnicode("Vignetting(G)右上角R1 /R3: ") % QString::number(stVignettingData.flRTR3_G));
			emit information(QTextCodec::codecForName( "GBK")->toUnicode("Vignetting(G)左下角R1 /R2: ") % QString::number(stVignettingData.flLBR2_G));
			emit information(QTextCodec::codecForName( "GBK")->toUnicode("Vignetting(G)左下角R1 /R3: ") % QString::number(stVignettingData.flLBR3_G));
			emit information(QTextCodec::codecForName( "GBK")->toUnicode("Vignetting(G)右下角R1 /R2: ") % QString::number(stVignettingData.flRBR2_G));
			emit information(QTextCodec::codecForName( "GBK")->toUnicode("Vignetting(G)右下角R1 /R3: ") % QString::number(stVignettingData.flRBR3_G));

			emit information(QTextCodec::codecForName( "GBK")->toUnicode("Vignetting(B)左上角R1 /R2: ") % QString::number(stVignettingData.flLTR2_B));
			emit information(QTextCodec::codecForName( "GBK")->toUnicode("Vignetting(B)左上角R1 /R3: ") % QString::number(stVignettingData.flLTR3_B));
			emit information(QTextCodec::codecForName( "GBK")->toUnicode("Vignetting(B)右上角R1 /R2: ") % QString::number(stVignettingData.flRTR2_B));
			emit information(QTextCodec::codecForName( "GBK")->toUnicode("Vignetting(B)右上角R1 /R3: ") % QString::number(stVignettingData.flRTR3_B));
			emit information(QTextCodec::codecForName( "GBK")->toUnicode("Vignetting(B)左下角R1 /R2: ") % QString::number(stVignettingData.flLBR2_B));
			emit information(QTextCodec::codecForName( "GBK")->toUnicode("Vignetting(B)左下角R1 /R3: ") % QString::number(stVignettingData.flLBR3_B));
			emit information(QTextCodec::codecForName( "GBK")->toUnicode("Vignetting(B)右下角R1 /R2: ") % QString::number(stVignettingData.flRBR2_B));
			emit information(QTextCodec::codecForName( "GBK")->toUnicode("Vignetting(B)右下角R1 /R3: ") % QString::number(stVignettingData.flRBR3_B));

			ROPLOW::saveVignettingHALog(stVignettingData, *classLog);
			_CODE_UPDATE_ITEMDATA1(whitepanelitem_vignetting, (stVignettingData.bResult)?(_His_ItemStatus_PASS):(_His_ItemStatus_NG));
		}
	}

	//defect pixel test
	if(itemshareData.whitepanelParameter->usdefectpixel){
		if(itemshareData.whitepanelParameter->defectpixelAlg == _HisAlg_SWITCH_A){ //alg A
			int idefectpixel=0, iwoundpixel=0, ideadpixel=0, itotalscore=0, iclustercount=0;
			std::vector<_HisAlg_Cluster> stCluster;
			unsigned char* pucBaylorR = pucr, *pucBaylorB = pucb, *pucBaylorGr = pucgr, *pucBaylorGb = pucgb;
			int iWidthT = (itemshareData.previewParameter->iWidth >>1), iHeightT = (itemshareData.previewParameter->iHeight >>1);
			if(ucDataFormat >= HisYUV8_422_YUYV && ucDataFormat <= HisYUV8_420P){
				pucBaylorR	=	pucYUV422U8_Y;
				pucBaylorB = pucBaylorGb = pucBaylorGr = NULL;
				iWidthT		=	itemshareData.previewParameter->iWidth;
				iHeightT		=	itemshareData.previewParameter->iHeight;
			}
			else if(ucDataFormat == HisRGB_RGB24){
				pucBaylorR		=	pucrgb_r;
				pucBaylorB		=	pucrgb_b;
				pucBaylorGr	=	pucrgb_g;
				pucBaylorGb	=	NULL;
				iWidthT			=	itemshareData.previewParameter->iWidth;
				iHeightT			=	itemshareData.previewParameter->iHeight;
			}

			iresult	=	classAlgorithm.HisCCMWhitePanel_PartIIIHA(pucBaylorR, pucBaylorB, pucBaylorGr, pucBaylorGb, \
				iWidthT, iHeightT, idefectpixel, iwoundpixel, ideadpixel, \
				itotalscore, stCluster, iclustercount, itemshareData.whitepanelParameter->defectpixel_fldefect, itemshareData.whitepanelParameter->defectpixel_flwound, \
				itemshareData.whitepanelParameter->defectpixel_fldead, \
				itemshareData.whitepanelParameter->defectpixel_iclusterscore, itemshareData.whitepanelParameter->defectpixel_iwidthblocks, \
				itemshareData.whitepanelParameter->defectpixel_ucdefectscore, itemshareData.whitepanelParameter->defectpixel_ucwoundscore, \
				itemshareData.whitepanelParameter->defectpixel_ucdeadscore);
			if(iresult){
				_CODE_WHITEPANEL_EXIT
					return iresult;
			}

			emit information(QTextCodec::codecForName( "GBK")->toUnicode("坏点/伤点/死点测试数据："));
			emit information(QTextCodec::codecForName( "GBK")->toUnicode("         坏点总个数：") % QString::number(idefectpixel, 10));
			emit information(QTextCodec::codecForName( "GBK")->toUnicode("         伤点总个数：") % QString::number(iwoundpixel, 10));
			emit information(QTextCodec::codecForName( "GBK")->toUnicode("         死点总个数：") % QString::number(ideadpixel, 10));
			emit information(QTextCodec::codecForName( "GBK")->toUnicode("         权重叠加总分数：") % QString::number(itotalscore, 10));
			emit information(QTextCodec::codecForName( "GBK")->toUnicode("         聚簇个数：") % QString::number(iclustercount, 10));

			itemstatus.usitem		=	whitepanelitem_pixel;
			itemstatus.ucstatus	=	_His_ItemStatus_PASS;
			stLogItem.itemtype		=	classLog->getmaxtypeindex(_HISLOG_CLASSIFY_WHITEPANEL);
			stLogItem.itemkey		=	"Defect_Pixel Result";
			stLogItem.itemvalue	=	"OK";

			int iClusterMaxScore	=	0;

			if(idefectpixel > itemshareData.whitepanelParameter->defectpixel_ispecdefect || \
				iwoundpixel > itemshareData.whitepanelParameter->defectpixel_ispecwound || \
				ideadpixel > itemshareData.whitepanelParameter->defectpixel_ispecdead || \
				itotalscore > itemshareData.whitepanelParameter->defectpixel_itotalscore || \
				iclustercount > itemshareData.whitepanelParameter->defectpixel_ispeccluster){
					itemstatus.ucstatus	=	_His_ItemStatus_NG;
					itotalresult					=	HisCCMError_Result;
					stLogItem.itemvalue	=	"NG";

					if(iclustercount > itemshareData.whitepanelParameter->defectpixel_ispeccluster){
						std::vector<_HisAlg_Cluster>::iterator clusterIndex;
						int idefectscore	=	0;
						for(std::vector<_HisAlg_Cluster>::iterator clusterIterator	=	stCluster.begin();	clusterIterator != stCluster.end();	clusterIterator++){
							if(clusterIterator->iscore > idefectscore){
								idefectscore	=	clusterIterator->iscore;
								clusterIndex	=	clusterIterator;
							}
						}

						itemshareData.drawLock.lockForWrite();
						int ilastcount	=	itemshareData.itemdrawList.size();
						itemshareData.itemdrawList.resize(ilastcount + 1);
						theIterator	=	itemshareData.itemdrawList.begin() +ilastcount;
						theIterator->usitem							=	whitepanelitem_pixel;
						theIterator->uctype							=	HisDrawType_Block;
						theIterator->stcolor							=	stdefectcluster;
						theIterator->strinfo.stblock				=	clusterIndex->stRange;
						if(ucDataFormat < HisYUV8_422_YUYV){
							theIterator->strinfo.stblock.left			=	(theIterator->strinfo.stblock.left <<1);
							theIterator->strinfo.stblock.top			=	(theIterator->strinfo.stblock.top <<1);
							theIterator->strinfo.stblock.right			=	(theIterator->strinfo.stblock.right <<1);
							theIterator->strinfo.stblock.bottom		=	(theIterator->strinfo.stblock.bottom <<1);
						}
						itemshareData.drawLock.unlock();
					}
			}
			else if(stCluster.size() > 0){
				std::vector<_HisAlg_Cluster>::iterator clusterIndex;
				for(std::vector<_HisAlg_Cluster>::iterator clusterIterator	=	stCluster.begin();	clusterIterator != stCluster.end();	clusterIterator++){
					if(clusterIterator->iscore > iClusterMaxScore){
						iClusterMaxScore	=	clusterIterator->iscore;
						clusterIndex				=	clusterIterator;
					}
				}

				if(clusterIndex->iscore > itemshareData.whitepanelParameter->defectpixel_iclustermaxscore){
					itemstatus.ucstatus	=	_His_ItemStatus_NG;
					itotalresult					=	HisCCMError_Result;
					stLogItem.itemvalue	=	"NG";

					itemshareData.drawLock.lockForWrite();
					int ilastcount	=	itemshareData.itemdrawList.size();
					itemshareData.itemdrawList.resize(ilastcount + 1);
					theIterator	=	itemshareData.itemdrawList.begin() +ilastcount;
					theIterator->usitem							=	whitepanelitem_pixel;
					theIterator->uctype							=	HisDrawType_Block;
					theIterator->stcolor							=	stdefectcluster;
					theIterator->strinfo.stblock				=	clusterIndex->stRange;
					if(ucDataFormat < HisYUV8_422_YUYV){
						theIterator->strinfo.stblock.left			=	(theIterator->strinfo.stblock.left <<1);
						theIterator->strinfo.stblock.top			=	(theIterator->strinfo.stblock.top <<1);
						theIterator->strinfo.stblock.right			=	(theIterator->strinfo.stblock.right <<1);
						theIterator->strinfo.stblock.bottom		=	(theIterator->strinfo.stblock.bottom <<1);
					}
					itemshareData.drawLock.unlock();
				}
			}

			itemstatus.ustime	=	testtimer.restart();
			updateItemstatus(itemstatus);

			classLog->push_back(stLogItem);
			++(stLogItem.itemtype);
			stLogItem.itemkey		=	"Defect_Pixel Number";
			stLogItem.itemvalue	=	idefectpixel;
			classLog->push_back(stLogItem);
			++(stLogItem.itemtype);
			stLogItem.itemkey		=	"Wound_Pixel Number";
			stLogItem.itemvalue	=	iwoundpixel;
			classLog->push_back(stLogItem);
			++(stLogItem.itemtype);
			stLogItem.itemkey		=	"Dead_Pixel Number";
			stLogItem.itemvalue	=	ideadpixel;
			classLog->push_back(stLogItem);
			++(stLogItem.itemtype);
			stLogItem.itemkey		=	"Defect_Cluster Number";
			stLogItem.itemvalue	=	iclustercount;
			classLog->push_back(stLogItem);
			++(stLogItem.itemtype);
			stLogItem.itemkey		=	"Defect_Score Sum";
			stLogItem.itemvalue	=	itotalscore;
			classLog->push_back(stLogItem);
			++(stLogItem.itemtype);
			stLogItem.itemkey		=	"Defect_Cluster_Max_Score";
			stLogItem.itemvalue	=	iClusterMaxScore;
			classLog->push_back(stLogItem);
		}
		else if(itemshareData.whitepanelParameter->defectpixelAlg == _HisAlg_SWITCH_B){
			int iCenterDefectTotal, iCenterWoundTotal, iCenterDeadTotal, iEdgeDefectTotal, iEdgeWoundTotal, iEdgeDeadTotal;
			int iCenterDefectClusterMax=0, iCenterWoundClusterMax=0,iCenterDeadClusterMax=0;
			int iEdgeDefectClusterMax=0, iEdgeWoundClusterMax=0,iEdgeDeadClusterMax=0;
			RECT stMaxCluster;
			std::vector<_HisAlg_DefectPixelHB_Cluster> vectorClsuter;
			unsigned char* pucBaylorR = pucr, *pucBaylorB = pucb, *pucBaylorGr = pucgr, *pucBaylorGb = pucgb;
			int iWidthT = (itemshareData.previewParameter->iWidth >>1), iHeightT = (itemshareData.previewParameter->iHeight >>1);
			bool bPerChannel = itemshareData.whitepanelParameter->defectpixelhb_bPerChannel;
			if(ucDataFormat >= HisYUV8_422_YUYV && ucDataFormat <= HisYUV8_420P){
				pucBaylorR	=	pucYUV422U8_Y;
				pucBaylorGb = pucBaylorGr = pucBaylorB = NULL;
				iWidthT		=	itemshareData.previewParameter->iWidth;
				iHeightT		=	itemshareData.previewParameter->iHeight;
				bPerChannel	=	true;
			}
			else if(ucDataFormat == HisRGB_RGB24){
				pucBaylorR		=	pucrgb_r;
				pucBaylorB		=	pucrgb_b;
				pucBaylorGr	=	pucrgb_g;
				pucBaylorGb	=	NULL;
				iWidthT			=	itemshareData.previewParameter->iWidth;
				iHeightT			=	itemshareData.previewParameter->iHeight;
				bPerChannel	=	true;
			}

			iresult	=	classAlgorithm.HisCCMWhitePanel_DefectPixelHB(pucBaylorR, pucBaylorB, pucBaylorGr,pucBaylorGb,iWidthT, \
				iHeightT, itemshareData.whitepanelParameter->defectpixelhb_fldefect, \
				itemshareData.whitepanelParameter->defectpixelhb_flwound, itemshareData.whitepanelParameter->defectpixelhb_fldead, \
				itemshareData.whitepanelParameter->defectpixelhb_flCenterRange, itemshareData.whitepanelParameter->defectpixelhb_uiBlockSize, \
				ucDataFormat, bPerChannel, iCenterDefectTotal, iCenterWoundTotal, iCenterDeadTotal, iEdgeDefectTotal, iEdgeWoundTotal, iEdgeDeadTotal, \
				stMaxCluster,vectorClsuter,hisglobalparameter.bDebugMode);
			if(iresult){
				_CODE_WHITEPANEL_EXIT
					return iresult;
			}

			emit information(QTextCodec::codecForName( "GBK")->toUnicode("中心总坏点个数：") % QString::number(iCenterDefectTotal));
			emit information(QTextCodec::codecForName( "GBK")->toUnicode("中心总伤点个数：") % QString::number(iCenterWoundTotal));
			emit information(QTextCodec::codecForName( "GBK")->toUnicode("中心总死点个数：") % QString::number(iCenterDeadTotal));
			emit information(QTextCodec::codecForName( "GBK")->toUnicode("周边总坏点个数：") % QString::number(iEdgeDefectTotal));
			emit information(QTextCodec::codecForName( "GBK")->toUnicode("周边总伤点个数：") % QString::number(iEdgeWoundTotal));
			emit information(QTextCodec::codecForName( "GBK")->toUnicode("周边总死点个数：") % QString::number(iEdgeDeadTotal));

			itemstatus.usitem		=	whitepanelitem_pixel;
			itemstatus.ucstatus		=	_His_ItemStatus_PASS;
			stLogItem.itemtype		=	classLog->getmaxtypeindex(_HISLOG_CLASSIFY_WHITEPANEL);
			stLogItem.itemkey		=	"Defect_Pixel Result";
			stLogItem.itemvalue	=	"OK";

			for(int x=0;	x<vectorClsuter.size();	++x){
				if(vectorClsuter.at(x).bCenter){
					switch (vectorClsuter.at(x).ucType){
					case 3:	iCenterDeadClusterMax	=	max(iCenterDeadClusterMax, vectorClsuter.at(x).uiPixelCount);break;
					case 2: iCenterWoundClusterMax	=	max(iCenterWoundClusterMax, vectorClsuter.at(x).uiPixelCount);break;
					default: iCenterDefectClusterMax	=	max(iCenterDefectClusterMax, vectorClsuter.at(x).uiPixelCount);break;
					}
				}
				else{
					switch (vectorClsuter.at(x).ucType){
					case 3: iEdgeDeadClusterMax	=	max(iEdgeDeadClusterMax, vectorClsuter.at(x).uiPixelCount);break;
					case 2: iEdgeWoundClusterMax	=	max(iEdgeWoundClusterMax, vectorClsuter.at(x).uiPixelCount);break;
					default: iEdgeDefectClusterMax	=	max(iEdgeDefectClusterMax, vectorClsuter.at(x).uiPixelCount);break;
					}
				}
			}

			if(iCenterDefectTotal>itemshareData.whitepanelParameter->defectpixelhb_uiCenterDefectSingle || \
				iCenterWoundTotal>itemshareData.whitepanelParameter->defectpixelhb_uiCenterWoundSingle || \
				iCenterDeadTotal>itemshareData.whitepanelParameter->defectpixelhb_uiCenterDeadSingle || \
				iEdgeDefectTotal>itemshareData.whitepanelParameter->defectpixelhb_uiEdgeDefectSingle || \
				iEdgeWoundTotal>itemshareData.whitepanelParameter->defectpixelhb_uiEdgeWoundSingle || \
				iEdgeDeadTotal>itemshareData.whitepanelParameter->defectpixelhb_uiEdgeDeadSingle){
					itemstatus.ucstatus	=	_His_ItemStatus_NG;
					itotalresult					=	HisCCMError_Result;
					stLogItem.itemvalue	=	"NG";

					if(vectorClsuter.size() > 0){
						itemshareData.drawLock.lockForWrite();
						int ilastcount	=	itemshareData.itemdrawList.size();
						itemshareData.itemdrawList.resize(ilastcount + 1);
						theIterator	=	itemshareData.itemdrawList.begin() +ilastcount;
						theIterator->usitem							=	whitepanelitem_pixel;
						theIterator->uctype							=	HisDrawType_Block;
						theIterator->stcolor							=	stdefectcluster;
						theIterator->strinfo.stblock				=	stMaxCluster;
						ROPLOW::expand2minrect(theIterator->strinfo.stblock, itemshareData.previewParameter->iWidth, itemshareData.previewParameter->iHeight, \
							itemshareData.previewParameter->iWidth *0.1f, itemshareData.previewParameter->iHeight *0.1f);
						itemshareData.drawLock.unlock();
					}
			}
			else if(vectorClsuter.size() > 0){
				if(iCenterDefectClusterMax > itemshareData.whitepanelParameter->defectpixelhb_uiCenterDefectClusterMax || \
					iCenterWoundClusterMax > itemshareData.whitepanelParameter->defectpixelhb_uiCenterWoundClusterMax || \
					iCenterDeadClusterMax > itemshareData.whitepanelParameter->defectpixelhb_uiCenterDeadClusterMax || \
					iEdgeDefectClusterMax > itemshareData.whitepanelParameter->defectpixelhb_uiEdgeDefectClusterMax || \
					iEdgeWoundClusterMax > itemshareData.whitepanelParameter->defectpixelhb_uiEdgeWoundClusterMax || \
					iEdgeDeadClusterMax > itemshareData.whitepanelParameter->defectpixelhb_uiEdgeDeadClusterMax){
						itemstatus.ucstatus	=	_His_ItemStatus_NG;
						itotalresult					=	HisCCMError_Result;
						stLogItem.itemvalue	=	"NG";

						itemshareData.drawLock.lockForWrite();
						int ilastcount	=	itemshareData.itemdrawList.size();
						itemshareData.itemdrawList.resize(ilastcount + 1);
						theIterator	=	itemshareData.itemdrawList.begin() +ilastcount;
						theIterator->usitem							=	whitepanelitem_pixel;
						theIterator->uctype							=	HisDrawType_Block;
						theIterator->stcolor							=	stdefectcluster;
						theIterator->strinfo.stblock				=	stMaxCluster;
						ROPLOW::expand2minrect(theIterator->strinfo.stblock, itemshareData.previewParameter->iWidth, itemshareData.previewParameter->iHeight, \
							itemshareData.previewParameter->iWidth *0.1f, itemshareData.previewParameter->iHeight *0.1f);
						itemshareData.drawLock.unlock();
				}
			}

			emit information(QTextCodec::codecForName( "GBK")->toUnicode("中心最大坏点簇像素个数：") % QString::number(iCenterDefectClusterMax));
			emit information(QTextCodec::codecForName( "GBK")->toUnicode("中心最大伤点簇像素个数：") % QString::number(iCenterWoundClusterMax));
			emit information(QTextCodec::codecForName( "GBK")->toUnicode("中心最大死点簇像素个数：") % QString::number(iCenterDeadClusterMax));
			emit information(QTextCodec::codecForName( "GBK")->toUnicode("周边最大坏点簇像素个数：") % QString::number(iEdgeDefectClusterMax));
			emit information(QTextCodec::codecForName( "GBK")->toUnicode("周边最大伤点簇像素个数：") % QString::number(iEdgeWoundClusterMax));
			emit information(QTextCodec::codecForName( "GBK")->toUnicode("周边最大死点簇像素个数：") % QString::number(iEdgeDeadClusterMax));

			itemstatus.ustime	=	testtimer.restart();
			updateItemstatus(itemstatus);

			classLog->push_back(stLogItem);
			++(stLogItem.itemtype);
			stLogItem.itemkey		=	"Center_Defect_Pixel_Number";
			stLogItem.itemvalue	=	iCenterDefectTotal;
			classLog->push_back(stLogItem);
			++(stLogItem.itemtype);
			stLogItem.itemkey		=	"Center_Wound_Pixel_Number";
			stLogItem.itemvalue	=	iCenterWoundTotal;
			classLog->push_back(stLogItem);
			++(stLogItem.itemtype);
			stLogItem.itemkey		=	"Center_Dead_Pixel_Number";
			stLogItem.itemvalue	=	iCenterDeadTotal;
			classLog->push_back(stLogItem);
			++(stLogItem.itemtype);
			stLogItem.itemkey		=	"Center_DefectCluster_Max";
			stLogItem.itemvalue	=	iCenterDefectClusterMax;
			classLog->push_back(stLogItem);
			++(stLogItem.itemtype);
			stLogItem.itemkey		=	"Center_WoundCluster_Max";
			stLogItem.itemvalue	=	iCenterWoundClusterMax;
			classLog->push_back(stLogItem);
			++(stLogItem.itemtype);
			stLogItem.itemkey		=	"Center_DeadCluster_Max";
			stLogItem.itemvalue	=	iCenterDeadClusterMax;
			classLog->push_back(stLogItem);
			++(stLogItem.itemtype);
			stLogItem.itemkey		=	"Edge_Defect_Pixel_Number";
			stLogItem.itemvalue	=	iEdgeDefectTotal;
			classLog->push_back(stLogItem);
			++(stLogItem.itemtype);
			stLogItem.itemkey		=	"Edge_Wound_Pixel_Number";
			stLogItem.itemvalue	=	iEdgeWoundTotal;
			classLog->push_back(stLogItem);
			++(stLogItem.itemtype);
			stLogItem.itemkey		=	"Edge_Dead_Pixel_Number";
			stLogItem.itemvalue	=	iEdgeDeadTotal;
			classLog->push_back(stLogItem);
			++(stLogItem.itemtype);
			stLogItem.itemkey		=	"Edge_DefectCluster_Max";
			stLogItem.itemvalue	=	iEdgeDefectClusterMax;
			classLog->push_back(stLogItem);
			++(stLogItem.itemtype);
			stLogItem.itemkey		=	"Edge_WoundCluster_Max";
			stLogItem.itemvalue	=	iEdgeWoundClusterMax;
			classLog->push_back(stLogItem);
			++(stLogItem.itemtype);
			stLogItem.itemkey		=	"Edge_DeadCluster_Max";
			stLogItem.itemvalue	=	iEdgeDeadClusterMax;
			classLog->push_back(stLogItem);

			if(hisglobalparameter.bDebugMode){
				emit information(QTextCodec::codecForName( "GBK")->toUnicode("坏点位置信息保存在DefectPixelDebug.bmp"));
				RECT stCenter;
				int x	=	static_cast<int>(itemshareData.previewParameter->iWidth *itemshareData.whitepanelParameter->defectpixelhb_flCenterRange);
				int y	=	static_cast<int>(itemshareData.previewParameter->iHeight *itemshareData.whitepanelParameter->defectpixelhb_flCenterRange);
				stCenter.left				=	((itemshareData.previewParameter->iWidth - x) >>1);
				stCenter.right			=	((itemshareData.previewParameter->iWidth + x) >>1);
				stCenter.top			=	((itemshareData.previewParameter->iHeight - y) >>1);
				stCenter.bottom		=	((itemshareData.previewParameter->iHeight + y) >>1);
				emit information(QTextCodec::codecForName( "GBK")->toUnicode("坏点中心区域位置:(ROI:") % \
					QString::number(stCenter.left) % "," % QString::number(stCenter.top) % "," % \
					QString::number(stCenter.right) % "," % QString::number(stCenter.bottom) % ")");

				unsigned char* pucSaveImage	=	(unsigned char*)_aligned_malloc(itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight*3, _HisCacheLine_Aligned);
				if(pucSaveImage && ucDataFormat < HisYUV8_422_YUYV){
					for(unsigned int ty=0;	ty<5;	++ty){
						QString strSaveFileName, strSaveInfo;
						unsigned int uiSaveWidth, uiSaveHeight;
						unsigned char *pucSaveSrc, *pucSaveDes	=	pucSaveImage;
						switch (ty){
						case 0:
							uiSaveWidth		=	itemshareData.previewParameter->iWidth;
							uiSaveHeight		=	itemshareData.previewParameter->iHeight;
							pucSaveSrc		=	pucbalor;
							strSaveFileName=	".\\DefectPixelDebug_Baylor.bmp";
							strSaveInfo			=	QTextCodec::codecForName( "GBK")->toUnicode("坏点测试原始RAW图保存在DefectPixelDebug_Baylor.bmp");
							break;
						case 1:
							uiSaveWidth		=	(itemshareData.previewParameter->iWidth >>1);
							uiSaveHeight		=	(itemshareData.previewParameter->iHeight >>1);
							pucSaveSrc		=	pucr;
							strSaveFileName=	".\\DefectPixelDebug_R.bmp";
							strSaveInfo			=	QTextCodec::codecForName( "GBK")->toUnicode("坏点测试原始RAW_R图保存在DefectPixelDebug_R.bmp");
							break;
						case 2:
							uiSaveWidth		=	(itemshareData.previewParameter->iWidth >>1);
							uiSaveHeight		=	(itemshareData.previewParameter->iHeight >>1);
							pucSaveSrc		=	pucgr;
							strSaveFileName=	".\\DefectPixelDebug_Gr.bmp";
							strSaveInfo			=	QTextCodec::codecForName( "GBK")->toUnicode("坏点测试原始RAW_Gr图保存在DefectPixelDebug_Gr.bmp");
							break;
						case 3:
							uiSaveWidth		=	(itemshareData.previewParameter->iWidth >>1);
							uiSaveHeight		=	(itemshareData.previewParameter->iHeight >>1);
							pucSaveSrc		=	pucgb;
							strSaveFileName=	".\\DefectPixelDebug_Gb.bmp";
							strSaveInfo			=	QTextCodec::codecForName( "GBK")->toUnicode("坏点测试原始RAW_Gb图保存在DefectPixelDebug_Gb.bmp");
							break;
						default:
							uiSaveWidth		=	(itemshareData.previewParameter->iWidth >>1);
							uiSaveHeight		=	(itemshareData.previewParameter->iHeight >>1);
							pucSaveSrc		=	pucb;
							strSaveFileName=	".\\DefectPixelDebug_B.bmp";
							strSaveInfo			=	QTextCodec::codecForName( "GBK")->toUnicode("坏点测试原始RAW_B图保存在DefectPixelDebug_B.bmp");
							break;
						}

						unsigned int uiSaveSize			=	uiSaveWidth *uiSaveHeight;
						for(unsigned int tx=0;	tx<uiSaveSize;	++tx){
							*pucSaveDes = *(pucSaveDes+1) = *(pucSaveDes+2)	=	*pucSaveSrc;
							++pucSaveSrc;
							pucSaveDes	+=	3;
						}
						QImage image2(pucSaveImage, uiSaveWidth, uiSaveHeight, uiSaveWidth *3, QImage::Format_RGB888);
						image2.save(strSaveFileName, 0, 100);
						emit information(strSaveInfo);
					}
				}
				HisReleaseMalloc(pucSaveImage);
			}
		}
	}

	_CODE_WHITEPANEL_EXIT
		return itotalresult;
}
#endif

int itemprocess::getwhitePanelColorParameter(bool bupdate, bool bcheck)
{
	QMutexLocker locker(&hisglobalparameter.mutexDatabase);

	itemshareData.itemparameterLock.lockForRead();
	if(!bupdate && itemshareData.wpColorParameter)	{	itemshareData.itemparameterLock.unlock();	return 0;	}
	itemshareData.itemparameterLock.unlock();

	itemshareData.itemparameterLock.lockForWrite();
	if(!itemshareData.wpColorParameter)	itemshareData.wpColorParameter		=	new _wpColorParameter;
	if(!itemshareData.wpColorParameter)	{	itemshareData.itemparameterLock.unlock();	return HisFX3Error_MallocBuffer;	}

	bool bItemExist = false;
	{
		QSqlDatabase customdb = QSqlDatabase::addDatabase("QSQLITE", "querycustom");
		customdb.setDatabaseName(QDir::currentPath() % "/HisFX3Custom");
		if (!customdb.open()){
			itemshareData.itemparameterLock.unlock();
			return HisCCMError_Database;
		}

		QStringList strname, strvalue;
		QString strData, strData2;
		QSqlQuery query(customdb);
		query.prepare("SELECT itemsuffix2,key,value,reserve FROM " % itemshareData.currentTableName % \
			" WHERE classfy='algorithm' AND item='whitepanel' AND itemsuffix1='total' ORDER BY id ASC" );
		query.exec();

		//
		//
		//(opticalcenteralg:a)(defectpixelalg:a)(defectlinealg:a)
		//(belmishalg:a)(coloralg:a)(shadingalg:a)(vignettingalg:a)
		while (query.next())
		{
			bItemExist = true;
			for(int y=0;	y<4;	++y)
			{
				strData	=	query.value(y).toString();
				ROPLOW::patchconfigstring(strData, strname, strvalue);
				for(int x=0;	x<strname.size();	++x){
					if(strname.at(x) == "coloralg"){
						if(strvalue.at(x) == "a")	itemshareData.wpColorParameter->colorAlg	=	_HisAlg_SWITCH_A;
						else if(strvalue.at(x) == "b")	itemshareData.wpColorParameter->colorAlg	=	_HisAlg_SWITCH_B;
					}
				}
			}
		}

		if(itemshareData.wpColorParameter->colorAlg	==	_HisAlg_SWITCH_A)
		{
			query.prepare("SELECT itemsuffix2,key,value,reserve FROM " % itemshareData.currentTableName % \
				" WHERE classfy='algorithm' AND item='whitepanel' AND itemsuffix1='color' ORDER BY id ASC" );
			query.exec();

			//(a:0.0)(b:0.0)(centerrange:0.08)(widthblocks:32)
			//(uniform:2.8)(aberration:1.0)(sym:1.0)(falloff:3.0)
			while (query.next()){
				bItemExist = true;
				for(int y=0;	y<4;	++y){
					strData	=	query.value(y).toString();
					ROPLOW::patchconfigstring(strData, strname, strvalue);
					for(int x=0;	x<strname.size();	++x){
						if(strname.at(x) == "a")							itemshareData.wpColorParameter->stAlgHA.color_flideala			=	strvalue.at(x).toFloat();
						else if(strname.at(x) == "b")					itemshareData.wpColorParameter->stAlgHA.color_flidealb			=	strvalue.at(x).toFloat();
						else if(strname.at(x) == "centerrange")	itemshareData.wpColorParameter->stAlgHA.color_flcenterrange	=	strvalue.at(x).toFloat();
						else if(strname.at(x) == "uniform")			itemshareData.wpColorParameter->stAlgHA.color_fluniform			=	strvalue.at(x).toFloat();
						else if(strname.at(x) == "aberration")		itemshareData.wpColorParameter->stAlgHA.color_flaberration		=	strvalue.at(x).toFloat();
						else if(strname.at(x) == "sym")				itemshareData.wpColorParameter->stAlgHA.color_flsym				=	strvalue.at(x).toFloat();
						else if(strname.at(x) == "falloff")				itemshareData.wpColorParameter->stAlgHA.color_flfalloff				=	strvalue.at(x).toFloat();
						else if(strname.at(x) == "widthblocks")	itemshareData.wpColorParameter->stAlgHA.color_iwithblocks		=	strvalue.at(x).toInt();
					}
				}
			}
		}
		else if(itemshareData.wpColorParameter->colorAlg	==	_HisAlg_SWITCH_B)
		{
			query.prepare("SELECT itemsuffix2,key,value,reserve FROM " % itemshareData.currentTableName % \
				" WHERE classfy='algorithm' AND item='whitepanel' AND itemsuffix1='colorhb' ORDER BY id ASC" );
			query.exec();

			//(centerratio:0.1)(gmin:170)(gmax:180)(rgmin:0.6)(rgmax:0.7)(bgmin:0.6)(bgmax:0.7)
			//(ccrgmin:0.9)(ccrgmax:1.1)(ccbgmin:0.9)(ccbgmax:1.1)
			//(cpprgmin:0.9)(cpprgmax:1.1)(cppbgmin:0.9)(cppbgmax:1.1)
			//(roinumw:17)(roinumh:13)(apprgmin:0.9)(apprgmax:1.1)(appbgmin:0.9)(appbgmax:1.1)
			while (query.next())
			{
				bItemExist = true;
				for(int y=0;	y<4;	++y)
				{
					strData	=	query.value(y).toString();
					ROPLOW::patchconfigstring(strData, strname, strvalue);
					for(int x=0;	x<strname.size();	++x)
					{
						if(strname.at(x) == "centerratio")				itemshareData.wpColorParameter->stAlgHB.flCenterRatio			=	strvalue.at(x).toFloat();
						else if(strname.at(x) == "gmin")					itemshareData.wpColorParameter->stAlgHB.ucGMin			=	strvalue.at(x).toUInt() & 0xFF;
						else if(strname.at(x) == "gmax")					itemshareData.wpColorParameter->stAlgHB.ucGMax			=	strvalue.at(x).toUInt() & 0xFF;
						else if(strname.at(x) == "rgmin")				itemshareData.wpColorParameter->stAlgHB.flRGMin			=	strvalue.at(x).toFloat();
						else if(strname.at(x) == "rgmax")				itemshareData.wpColorParameter->stAlgHB.flRGMax			=	strvalue.at(x).toFloat();
						else if(strname.at(x) == "bgmin")				itemshareData.wpColorParameter->stAlgHB.flBGMin			=	strvalue.at(x).toFloat();
						else if(strname.at(x) == "bgmax")				itemshareData.wpColorParameter->stAlgHB.flBGMax			=	strvalue.at(x).toFloat();
						else if(strname.at(x) == "ccrgmin")			itemshareData.wpColorParameter->stAlgHB.flCCRGMin			=	strvalue.at(x).toFloat();
						else if(strname.at(x) == "ccrgmax")			itemshareData.wpColorParameter->stAlgHB.flCCRGMax			=	strvalue.at(x).toFloat();
						else if(strname.at(x) == "ccbgmin")			itemshareData.wpColorParameter->stAlgHB.flCCBGMin			=	strvalue.at(x).toFloat();
						else if(strname.at(x) == "ccbgmax")			itemshareData.wpColorParameter->stAlgHB.flCCBGMax			=	strvalue.at(x).toFloat();
						else if(strname.at(x) == "cpprgmin")			itemshareData.wpColorParameter->stAlgHB.flConerPP_RGMin			=	strvalue.at(x).toFloat();
						else if(strname.at(x) == "cpprgmax")			itemshareData.wpColorParameter->stAlgHB.flConerPP_RGMax			=	strvalue.at(x).toFloat();
						else if(strname.at(x) == "cppbgmin")			itemshareData.wpColorParameter->stAlgHB.flConerPP_BGMin			=	strvalue.at(x).toFloat();
						else if(strname.at(x) == "cppbgmax")			itemshareData.wpColorParameter->stAlgHB.flConerPP_BGMax			=	strvalue.at(x).toFloat();
						else if(strname.at(x) == "apprgmin")			itemshareData.wpColorParameter->stAlgHB.flAllPP_RGMin			=	strvalue.at(x).toFloat();
						else if(strname.at(x) == "apprgmax")			itemshareData.wpColorParameter->stAlgHB.flAllPP_RGMax			=	strvalue.at(x).toFloat();
						else if(strname.at(x) == "appbgmin")			itemshareData.wpColorParameter->stAlgHB.flAllPP_BGMin			=	strvalue.at(x).toFloat();
						else if(strname.at(x) == "appbgmax")			itemshareData.wpColorParameter->stAlgHB.flAllPP_BGMax			=	strvalue.at(x).toFloat();
						else if(strname.at(x) == "roinumw")			itemshareData.wpColorParameter->stAlgHB.ucROINumW			=	strvalue.at(x).toUInt() & 0xFF;
						else if(strname.at(x) == "roinumh")			itemshareData.wpColorParameter->stAlgHB.ucROINumH			=	strvalue.at(x).toUInt() & 0xFF;
					}
				}
			}
		}

		customdb.close();
	}

	QSqlDatabase::removeDatabase("querycustom");

	if(!bItemExist)
	{
		HisReleaseNewO(itemshareData.wpColorParameter);
		itemshareData.itemparameterLock.unlock();
		return HisFX3Error_Parameter;
	}

	if(!bcheck) {itemshareData.itemparameterLock.unlock(); return 0; }

	itemshareData.itemparameterLock.unlock();
	return 0;
}

int itemprocess::whitePanelColor()
{
	//判断图像是否点亮中
	if(!threadshareData.GetHisPreviewflag())	return HisCCMError_NotPreivew;

	std::vector<_itemDraw>::iterator theIterator;
	itemshareData.clearDrawList();
	QColor stcolorcolor				=	QColor::fromRgb(255, 255, 0);

	//取得配置参数和规格
	int iresult	=	getwhitePanelColorParameter(false);
	if(iresult)	return iresult;


	QHReadWriteLockManage classitemparameterLock(&(itemshareData.itemparameterLock));
	stLogItem.itemtype		=	classLog->getmaxtypeindex(_HISLOG_CLASSIFY_WHITECOLOR);
	stLogItem.itemkey		=	"WP Color Result";
	stLogItem.itemvalue	=	"OK";
	QHDefaultLogManage classstLogItem(classLog, &stLogItem, "NG");

	if(itemshareData.wpColorParameter->colorAlg == _HisAlg_SWITCH_A)
	{ 
		_HisAlg_Debug stdebug;
		stdebug.uipt_x	=	static_cast<unsigned int>(hisglobalparameter.mouse_ptx *static_cast<double>(itemshareData.previewParameter->iWidth));
		stdebug.uipt_y	=	static_cast<unsigned int>(hisglobalparameter.mouse_pty *static_cast<double>(itemshareData.previewParameter->iHeight));

		unsigned char* pucRGB24	=	(unsigned char*)HisAlignedMalloc(itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight *3);
		if(!pucRGB24) return HisFX3Error_MallocBuffer;
		QHisFX3MallocAlignedManage classpucRGB24(pucRGB24);

		if(iresult	=	GetFreshframe(pucRGB24, itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight *3, _FrameType_RGB24, true))
			return iresult;

		RECT stcoloruniform	=	{0};
		float centera, centerb, symmetrymax, falloffmax;
		iresult	=	classAlgorithm.HisCCMWhitePanel_ColorHA(pucRGB24, itemshareData.previewParameter->iWidth, itemshareData.previewParameter->iHeight, \
			stcoloruniform, centera, centerb, symmetrymax, falloffmax, stdebug, \
			itemshareData.wpColorParameter->stAlgHA.color_flcenterrange,itemshareData.wpColorParameter->stAlgHA.color_iwithblocks, \
			itemshareData.wpColorParameter->stAlgHA.color_fluniform);
		if(iresult)	return iresult;

		float fldistance	=	sqrtf((centera-itemshareData.wpColorParameter->stAlgHA.color_flideala)*(centera-itemshareData.wpColorParameter->stAlgHA.color_flideala) + \
			(centerb-itemshareData.wpColorParameter->stAlgHA.color_flidealb)*(centerb-itemshareData.wpColorParameter->stAlgHA.color_flidealb));

		emit information(QTextCodec::codecForName( "GBK")->toUnicode("白板颜色测试数据："));
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("         中心色差：") % QString::number(static_cast<double>(fldistance), 'f', 6));
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("         对称色差：") % QString::number(static_cast<double>(symmetrymax), 'f', 6));
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("         四角色差：") % QString::number(static_cast<double>(falloffmax), 'f', 6));

		if(fldistance>itemshareData.wpColorParameter->stAlgHA.color_flaberration){
			emit information(QTextCodec::codecForName( "GBK")->toUnicode("中心色差---NG"));
			iresult					=	HisCCMError_Result;
			stLogItem.itemvalue	=	"NG";
		}

		if(symmetrymax > itemshareData.wpColorParameter->stAlgHA.color_flsym){
			emit information(QTextCodec::codecForName( "GBK")->toUnicode("对称色差---NG"));
			iresult					=	HisCCMError_Result;
			stLogItem.itemvalue	=	"NG";
		}

		if(falloffmax > itemshareData.wpColorParameter->stAlgHA.color_flfalloff){
			emit information(QTextCodec::codecForName( "GBK")->toUnicode("四角色差---NG"));
			iresult					=	HisCCMError_Result;
			stLogItem.itemvalue	=	"NG";
		}

		if(stcoloruniform.bottom)
		{
			itemshareData.drawLock.lockForWrite();
			int ilastcount	=	itemshareData.itemdrawList.size();
			itemshareData.itemdrawList.resize(ilastcount + 1);
			theIterator	=	itemshareData.itemdrawList.begin() +ilastcount;
			theIterator->usitem				=	whitepanelitem_color;
			theIterator->uctype				=	HisDrawType_Block;
			theIterator->stcolor				=	stcolorcolor;
			theIterator->strinfo.stblock	=	stcoloruniform;
			itemshareData.drawLock.unlock();
			emit information(QTextCodec::codecForName( "GBK")->toUnicode("         颜色不均匀位置：") % \
				QTextCodec::codecForName( "GBK")->toUnicode("左上(") % QString::number(stcoloruniform.left, 10) % \
				"," % QString::number(stcoloruniform.top, 10) % QTextCodec::codecForName( "GBK")->toUnicode(")    右下(") % \
				QString::number(stcoloruniform.right, 10) % "," % QString::number(stcoloruniform.bottom, 10) % ")");

			iresult					=	HisCCMError_Result;
			stLogItem.itemvalue	=	"NG";
		}

		classstLogItem.SubRef();
		classLog->push_back(stLogItem);
		++(stLogItem.itemtype);
		stLogItem.itemkey		=	"Color Aberration";
		stLogItem.itemvalue	=	fldistance;
		classLog->push_back(stLogItem);
		++(stLogItem.itemtype);
		stLogItem.itemkey		=	"Color Symmetry";
		stLogItem.itemvalue	=	symmetrymax;
		classLog->push_back(stLogItem);
		++(stLogItem.itemtype);
		stLogItem.itemkey		=	"Color Falloff";
		stLogItem.itemvalue	=	falloffmax;
		classLog->push_back(stLogItem);
		++(stLogItem.itemtype);
		stLogItem.itemkey		=	"Color Uniform";
		stLogItem.itemvalue	=	(stcoloruniform.bottom)?("NG"):("OK");
		classLog->push_back(stLogItem);
	}
	else if(itemshareData.wpColorParameter->colorAlg == _HisAlg_SWITCH_B)
	{
		unsigned char* pucRGB24	=	(unsigned char*)HisAlignedMalloc(itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight *3);
		if(!pucRGB24) return HisFX3Error_MallocBuffer;
		QHisFX3MallocAlignedManage classpucRGB24(pucRGB24);

		if(iresult	=	GetFreshframe(pucRGB24, itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight *3, _FrameType_RGB24, true))
			return iresult;

		_HisWhiteColorHB_Result stRel;
		iresult = classRolongoTest.WhiteColorHB(pucRGB24, itemshareData.previewParameter->iWidth, itemshareData.previewParameter->iHeight, \
			itemshareData.wpColorParameter->stAlgHB.flCenterRatio, itemshareData.wpColorParameter->stAlgHB.ucROINumW, itemshareData.wpColorParameter->stAlgHB.ucROINumH, \
			itemshareData.previewParameter->iWidth /itemshareData.wpColorParameter->stAlgHB.ucROINumW, itemshareData.previewParameter->iHeight /itemshareData.wpColorParameter->stAlgHB.ucROINumH, stRel);
		if(iresult)
		{
			emit information("WhiteColorHB return(error): 0x" % QString::number(iresult, 16));
			emit information(QString::fromAscii(classRolongoTest.GetLastError()));
			return iresult;
		}

		char strText[100];
		sprintf_s(strText, 99, "Center R:%.2f G:%.2f B:%.2f R/G:%.2f B/G:%.2f", stRel.center.r, stRel.center.g, stRel.center.b, stRel.center.rg, stRel.center.bg);
		emit information(QString::fromAscii(strText));
		sprintf_s(strText, 99, "Left-Top Corner R:%.2f G:%.2f B:%.2f R/G:%.2f B/G:%.2f", stRel.LT.r, stRel.LT.g, stRel.LT.b, stRel.LT.rg, stRel.LT.bg);	
		emit information(QString::fromAscii(strText));
		sprintf_s(strText, 99, "Right-Top Corner R:%.2f G:%.2f B:%.2f R/G:%.2f B/G:%.2f", stRel.RT.r, stRel.RT.g, stRel.RT.b, stRel.RT.rg, stRel.RT.bg);	
		emit information(QString::fromAscii(strText));
		sprintf_s(strText, 99, "Left-Bottom Corner R:%.2f G:%.2f B:%.2f R/G:%.2f B/G:%.2f", stRel.LB.r, stRel.LB.g, stRel.LB.b, stRel.LB.rg, stRel.LB.bg);	
		emit information(QString::fromAscii(strText));
		sprintf_s(strText, 99, "Right-Bottom Corner R:%.2f G:%.2f B:%.2f R/G:%.2f B/G:%.2f", stRel.RB.r, stRel.RB.g, stRel.RB.b, stRel.RB.rg, stRel.RB.bg);	
		emit information(QString::fromAscii(strText));

		float flCCRG_LT = 0.0f, flCCBG_LT = 0.0f, flCCRG_RT = 0.0f, flCCBG_RT = 0.0f, flCCRG_LB = 0.0f, flCCBG_LB = 0.0f, flCCRG_RB = 0.0f, flCCBG_RB = 0.0f;
		float flCornerPPRG = 0.0f, flCornerPPBG = 0.0f;
		if(stRel.center.rg > 0.01f)
		{
			flCCRG_LT		=	stRel.LT.rg / stRel.center.rg;
			flCCRG_RT		=	stRel.RT.rg / stRel.center.rg;
			flCCRG_LB		=	stRel.LB.rg / stRel.center.rg;
			flCCRG_RB	=	stRel.RB.rg / stRel.center.rg;
		}

		if(stRel.center.bg > 0.01f)
		{
			flCCBG_LT		=	stRel.LT.bg / stRel.center.bg;
			flCCBG_RT		=	stRel.RT.bg / stRel.center.bg;
			flCCBG_LB		=	stRel.LB.bg / stRel.center.bg;
			flCCBG_RB	=	stRel.RB.bg / stRel.center.bg;
		}

		float flMaxR = maxv4(stRel.LT.rg, stRel.RT.rg, stRel.LB.rg, stRel.RB.rg);
		float flMinR	= minv4(stRel.LT.rg, stRel.RT.rg, stRel.LB.rg, stRel.RB.rg);
		float flMaxB = maxv4(stRel.LT.bg, stRel.RT.bg, stRel.LB.bg, stRel.RB.bg);
		float flMinB	= minv4(stRel.LT.bg, stRel.RT.bg, stRel.LB.bg, stRel.RB.bg);
		if(flMaxR > 0.01f) flCornerPPRG = flMinR / flMaxR;
		if(flMaxB > 0.01f) flCornerPPBG = flMinB / flMaxB;

		sprintf_s(strText, 99, "Left-Top/Center R/G:%.2f B/G:%.2f", flCCRG_LT, flCCBG_LT);	
		emit information(QString::fromAscii(strText));
		sprintf_s(strText, 99, "Right-Top/Center R/G:%.2f B/G:%.2f", flCCRG_RT, flCCBG_RT);	
		emit information(QString::fromAscii(strText));
		sprintf_s(strText, 99, "Left-Bottom/Center R/G:%.2f B/G:%.2f", flCCRG_LB, flCCBG_LB);	
		emit information(QString::fromAscii(strText));
		sprintf_s(strText, 99, "Right-Bottom/Center R/G:%.2f B/G:%.2f", flCCRG_RB, flCCBG_RB);	
		emit information(QString::fromAscii(strText));

		sprintf_s(strText, 99, "Corner Uniform PP_R/G:%.2f PP_B/G:%.2f", flCornerPPRG, flCornerPPBG);	
		emit information(QString::fromAscii(strText));
		sprintf_s(strText, 99, "Total Uniform PP_R/G:%.2f PP_B/G:%.2f", stRel.PP_RG, stRel.PP_BG);	
		emit information(QString::fromAscii(strText));

		iresult = 0;
		if(stRel.center.g < itemshareData.wpColorParameter->stAlgHB.ucGMin || stRel.center.g > itemshareData.wpColorParameter->stAlgHB.ucGMax || \
			stRel.center.rg < itemshareData.wpColorParameter->stAlgHB.flRGMin || stRel.center.rg > itemshareData.wpColorParameter->stAlgHB.flRGMax || \
			stRel.center.bg < itemshareData.wpColorParameter->stAlgHB.flBGMin || stRel.center.bg > itemshareData.wpColorParameter->stAlgHB.flBGMax || \
			flCCRG_LT < itemshareData.wpColorParameter->stAlgHB.flCCRGMin || flCCRG_LT > itemshareData.wpColorParameter->stAlgHB.flCCRGMax || \
			flCCRG_RT < itemshareData.wpColorParameter->stAlgHB.flCCRGMin || flCCRG_RT > itemshareData.wpColorParameter->stAlgHB.flCCRGMax || \
			flCCRG_LB < itemshareData.wpColorParameter->stAlgHB.flCCRGMin || flCCRG_LB > itemshareData.wpColorParameter->stAlgHB.flCCRGMax || \
			flCCRG_RB < itemshareData.wpColorParameter->stAlgHB.flCCRGMin || flCCRG_RB > itemshareData.wpColorParameter->stAlgHB.flCCRGMax || \
			flCCBG_LT < itemshareData.wpColorParameter->stAlgHB.flCCBGMin || flCCBG_LT > itemshareData.wpColorParameter->stAlgHB.flCCBGMax || \
			flCCBG_RT < itemshareData.wpColorParameter->stAlgHB.flCCBGMin || flCCBG_RT > itemshareData.wpColorParameter->stAlgHB.flCCBGMax || \
			flCCBG_LB < itemshareData.wpColorParameter->stAlgHB.flCCBGMin || flCCBG_LB > itemshareData.wpColorParameter->stAlgHB.flCCBGMax || \
			flCCBG_RB < itemshareData.wpColorParameter->stAlgHB.flCCBGMin || flCCBG_RB > itemshareData.wpColorParameter->stAlgHB.flCCBGMax || \
			flCornerPPRG < itemshareData.wpColorParameter->stAlgHB.flConerPP_RGMin || flCornerPPRG > itemshareData.wpColorParameter->stAlgHB.flConerPP_RGMax || \
			flCornerPPBG < itemshareData.wpColorParameter->stAlgHB.flConerPP_BGMin || flCornerPPBG > itemshareData.wpColorParameter->stAlgHB.flConerPP_BGMax || \
			stRel.PP_RG < itemshareData.wpColorParameter->stAlgHB.flAllPP_RGMin || stRel.PP_RG > itemshareData.wpColorParameter->stAlgHB.flAllPP_RGMax || \
			stRel.PP_BG < itemshareData.wpColorParameter->stAlgHB.flAllPP_BGMin || stRel.PP_BG > itemshareData.wpColorParameter->stAlgHB.flAllPP_BGMax)
		{
			iresult = HisCCMError_Result;
		}

		_HisWhiteColorHB_Result_item* pstItem;
		itemshareData.drawLock.lockForWrite();
		int ilastcount	=	itemshareData.itemdrawList.size();
		itemshareData.itemdrawList.resize(ilastcount + 5 *3);
		theIterator	=	itemshareData.itemdrawList.begin() +ilastcount;
		for(unsigned int w=0;	w<5;	++w)
		{
			switch (w)
			{
			case 0: pstItem = &(stRel.center);	break;
			case 1: pstItem = &(stRel.LT);	break;
			case 2: pstItem = &(stRel.RT);	break;
			case 3: pstItem = &(stRel.LB);	break;
			case 4: 
			default: pstItem = &(stRel.RB);	break;
			}

			theIterator->usitem				=	whitepanelitem_color;
			theIterator->uctype				=	HisDrawType_Block;
			theIterator->stcolor				=	stcolorcolor;
			theIterator->strinfo.stblock	=	pstItem->roi;
			theIterator++;

			theIterator->usitem				=	whitepanelitem_color;
			theIterator->uctype				=	HisDrawType_Text;
			theIterator->stcolor				=	stcolorcolor;
			theIterator->idata[0]				=	pstItem->roi.left;
			theIterator->idata[1]				=	(pstItem->roi.top + pstItem->roi.bottom) /2;
			sprintf_s(theIterator->strinfo.strtext, 15, "R/G:%.2f", pstItem->rg);
			theIterator++;

			theIterator->usitem				=	whitepanelitem_color;
			theIterator->uctype				=	HisDrawType_Text;
			theIterator->stcolor				=	stcolorcolor;
			theIterator->idata[0]				=	pstItem->roi.left;
			theIterator->idata[1]				=	pstItem->roi.bottom;
			sprintf_s(theIterator->strinfo.strtext, 15, "B/G:%.2f", pstItem->bg);
			theIterator++;
		}
		itemshareData.drawLock.unlock();

		classstLogItem.SubRef();
		if(iresult) stLogItem.itemvalue = "NG";
		classLog->push_back(stLogItem);
		_CODE_LOG_PUSHBACK("WPColor Center G", stRel.center.g);
		_CODE_LOG_PUSHBACK("WPColor Center R/G", stRel.center.rg);
		_CODE_LOG_PUSHBACK("WPColor Center B/G", stRel.center.bg);
		_CODE_LOG_PUSHBACK("WPColor LT/C R/G", flCCRG_LT);
		_CODE_LOG_PUSHBACK("WPColor RT/C R/G", flCCRG_RT);
		_CODE_LOG_PUSHBACK("WPColor LB/C R/G", flCCRG_LB);
		_CODE_LOG_PUSHBACK("WPColor RB/C R/G", flCCRG_RB);
		_CODE_LOG_PUSHBACK("WPColor LT/C B/G", flCCBG_LT);
		_CODE_LOG_PUSHBACK("WPColor RT/C B/G", flCCBG_RT);
		_CODE_LOG_PUSHBACK("WPColor LB/C B/G", flCCBG_LB);
		_CODE_LOG_PUSHBACK("WPColor RB/C B/G", flCCBG_RB);
		_CODE_LOG_PUSHBACK("WPColor Corner PP_R/G", flCornerPPRG);
		_CODE_LOG_PUSHBACK("WPColor Corner PP_B/G", flCornerPPBG);
		_CODE_LOG_PUSHBACK("WPColor Total PP_R/G", stRel.PP_RG);
		_CODE_LOG_PUSHBACK("WPColor Total PP_B/G", stRel.PP_BG);

		if(hisglobalparameter.bDebugMode)
		{
			QDir classDir;
			classDir.mkpath(QDir::currentPath() % "/savelog");
			QFile classFile(QDir::currentPath() % "/savelog/wp_Colorhb_Log.txt");
			if(classFile.open(QIODevice::WriteOnly | QIODevice::Truncate | QIODevice::Text))
			{
				QTextStream out(&classFile);
				out << "Index\t" << "[Left,Top]\t" << "[Right,Bottom]\t" << "[R,G,B]\t" << "[R/G,B/G]\n";
				QString strIndex;
				for(unsigned int w=0;	w<stRel.vecUnion.size() + 5;	++w)
				{
					switch (w)
					{
					case 0: pstItem = &(stRel.center);	strIndex = "Center"; break;
					case 1: pstItem = &(stRel.LT);	strIndex = "LT"; break;
					case 2: pstItem = &(stRel.RT);	strIndex = "RT"; break;
					case 3: pstItem = &(stRel.LB);	strIndex = "LB"; break;
					case 4: pstItem = &(stRel.RB);	strIndex = "RB"; break;
					default: pstItem = &(stRel.vecUnion[w-5]); strIndex = QString::number(w-5); break;
					}

					out << strIndex << "\t[" << pstItem->roi.left << "," << pstItem->roi.top << "]\t[" << pstItem->roi.right << "," << \
						pstItem->roi.bottom << "]\t[" << pstItem->r << "," << pstItem->g << "," << pstItem->b << "]\t[" << \
						pstItem->rg << "," << pstItem->bg << "]\n";
				}
				classFile.close();
			}
		}


	}

	return iresult;
}

int itemprocess::getwhitePanelSNRParameter(bool bupdate, bool bcheck)
{
	return 0;
}

int itemprocess::whitePanelSNR()
{
	return 0;
}

int itemprocess::getwhitePanelOCParameter(bool bupdate, bool bcheck)
{
	QMutexLocker locker(&hisglobalparameter.mutexDatabase);

	itemshareData.itemparameterLock.lockForRead();
	if(!bupdate && itemshareData.wpOCParameter)	{	itemshareData.itemparameterLock.unlock();	return 0;	}
	itemshareData.itemparameterLock.unlock();

	itemshareData.itemparameterLock.lockForWrite();
	if(!itemshareData.wpOCParameter)	itemshareData.wpOCParameter		=	new _wpOCParameter;
	if(!itemshareData.wpOCParameter)	{	itemshareData.itemparameterLock.unlock();	return HisFX3Error_MallocBuffer;	}

	bool bItemExist = false;
	{
		QSqlDatabase customdb = QSqlDatabase::addDatabase("QSQLITE", "querycustom");
		customdb.setDatabaseName(QDir::currentPath() % "/HisFX3Custom");
		if (!customdb.open()){
			itemshareData.itemparameterLock.unlock();
			return HisCCMError_Database;
		}

		QStringList strname, strvalue;
		QString strData, strData2;
		QSqlQuery query(customdb);
		query.prepare("SELECT itemsuffix2,key,value,reserve FROM " % itemshareData.currentTableName % \
			" WHERE classfy='algorithm' AND item='whitepanel' AND itemsuffix1='total' ORDER BY id ASC" );
		query.exec();

		//
		//
		//(opticalcenteralg:a)(defectpixelalg:a)(defectlinealg:a)
		//(belmishalg:a)(coloralg:a)(shadingalg:a)(vignettingalg:a)
		while (query.next()){
			bItemExist = true;
			for(int y=0;	y<4;	++y){
				strData	=	query.value(y).toString();
				ROPLOW::patchconfigstring(strData, strname, strvalue);
				for(int x=0;	x<strname.size();	++x){
					if(strname.at(x) == "opticalcenteralg"){
						if(strvalue.at(x) == "a")	itemshareData.wpOCParameter->opticalcenterAlg	=	_HisAlg_SWITCH_A;
						else if(strvalue.at(x) == "b")	itemshareData.wpOCParameter->opticalcenterAlg	=	_HisAlg_SWITCH_B;
						else if(strvalue.at(x) == "c")	itemshareData.wpOCParameter->opticalcenterAlg	=	_HisAlg_SWITCH_C;
						else if(strvalue.at(x) == "d")	itemshareData.wpOCParameter->opticalcenterAlg	=	_HisAlg_SWITCH_D;
					}
				}
			}
		}

		query.prepare("SELECT itemsuffix2,key,value,reserve FROM " % itemshareData.currentTableName % \
			" WHERE classfy='algorithm' AND item='whitepanel' AND itemsuffix1='opticalcenter' ORDER BY id ASC" );
		query.exec();

		//(deviation:10.0)
		//(pixelratio:0.09)
		while (query.next())
		{
			bItemExist = true;
			for(int y=0;	y<4;	++y){
				strData	=	query.value(y).toString();
				ROPLOW::patchconfigstring(strData, strname, strvalue);
				for(int x=0;	x<strname.size();	++x){
					if(strname.at(x) == "deviation")			itemshareData.wpOCParameter->stAlgHA.oc_fldeviation	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "pixelratio")	itemshareData.wpOCParameter->stAlgHA.oc_flpixelratio	=	strvalue.at(x).toFloat();
				}
			}
		}

		query.prepare("SELECT itemsuffix2,key,value,reserve FROM " % itemshareData.currentTableName % \
			" WHERE classfy='algorithm' AND item='whitepanel' AND itemsuffix1='opticalcenterhb' ORDER BY id ASC" );
		query.exec();

		//(deviation:10.0)
		//(pixelratio:0.09)
		while (query.next())
		{
			bItemExist = true;
			for(int y=0;	y<4;	++y){
				strData	=	query.value(y).toString();
				ROPLOW::patchconfigstring(strData, strname, strvalue);
				for(int x=0;	x<strname.size();	++x){
					if(strname.at(x) == "deviation")			itemshareData.wpOCParameter->stAlgHB.oc_fldeviation	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "pixelratio")	itemshareData.wpOCParameter->stAlgHB.oc_flpixelratio	=	strvalue.at(x).toFloat();
				}
			}
		}

		customdb.close();
	}

	QSqlDatabase::removeDatabase("querycustom");

	if(!bItemExist)
	{
		HisReleaseNewO(itemshareData.wpOCParameter);
		itemshareData.itemparameterLock.unlock();
		return HisFX3Error_Parameter;
	}

	if(!bcheck) {itemshareData.itemparameterLock.unlock(); return 0; }

	itemshareData.itemparameterLock.unlock();
	return 0;
}

int itemprocess::whitePanelOC()
{
	std::vector<_itemDraw>::iterator theIterator;
	itemshareData.clearDrawList();

	//判断图像是否点亮中
	if(!threadshareData.GetHisPreviewflag())	return HisCCMError_NotPreivew;

	//取得配置参数和规格
	int iresult	=	getwhitePanelOCParameter(false);
	if(iresult)	return iresult;

#ifdef _DEBUG
		fnMTF_Q fnMTF=(fnMTF_Q)QLibrary::resolve("cvImageToold.dll","fnMTF");
		getMarkDistance_RGB24 funCalMarkDist=(getMarkDistance_RGB24)QLibrary::resolve("fqqImageToolD.dll","getMarkDistance_RGB24");
		polyfit funPolyfit=(polyfit)QLibrary::resolve("fqqImageToolD.dll","polyfit");
		opticalCenter funOC=(opticalCenter)QLibrary::resolve("fqqImageToolD.dll","opticalCenter");
#else
		fnMTF_Q fnMTF=(fnMTF_Q)QLibrary::resolve("cvImageTool.dll","fnMTF");
		getMarkDistance_RGB24 funCalMarkDist=(getMarkDistance_RGB24)QLibrary::resolve("fqqImageTool.dll","getMarkDistance_RGB24");
		polyfit funPolyfit=(polyfit)QLibrary::resolve("fqqImageTool.dll","polyfit");
		opticalCenter funOC=(opticalCenter)QLibrary::resolve("fqqImageTool.dll","opticalCenter");
#endif

	/*if(!fnMTF){
		emit information(QString::fromLocal8Bit("!载入cvImageTool.dll失败，请检查是否存在"));
		return -1;
	}*/
	if(!funCalMarkDist){
		emit information(QString::fromLocal8Bit("!载入fqqImageTool.dll失败，请检查是否存在"));
		return -1;
	}

	QHReadWriteLockManage classitemparameterLock(&(itemshareData.itemparameterLock));
	stLogItem.itemtype		=	classLog->getmaxtypeindex(_HISLOG_CLASSIFY_OC);
	stLogItem.itemkey		=	"OC Result";
	stLogItem.itemvalue	=	"OK";
	QHDefaultLogManage classstLogItem(classLog, &stLogItem, "NG");

	//optical center test
	if(itemshareData.wpOCParameter->opticalcenterAlg == _HisAlg_SWITCH_A)
	{
		int ioc_x, ioc_y;
		unsigned char* pucRGB24	=	(unsigned char*)HisAlignedMalloc(itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight *3);
		if(!pucRGB24) return HisFX3Error_MallocBuffer;
		QHisFX3MallocAlignedManage classpucRGB24(pucRGB24);

		if(iresult	=	GetFreshframe(pucRGB24, itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight *3, _FrameType_RGB24, true))
			return iresult;

		if(hisglobalparameter.bDebugMode){
			double out1[5]={0};
			funCalMarkDist(pucRGB24,NULL,out1,itemshareData.previewParameter->iWidth,itemshareData.previewParameter->iHeight,15,15000,25000,700,1200,false);

			QImage image(pucRGB24,itemshareData.previewParameter->iWidth,itemshareData.previewParameter->iHeight,itemshareData.previewParameter->iWidth*3,QImage::Format_RGB888);
			QString strSerialNumber;
			classLog->getserialnumber(strSerialNumber);
			if(image.save(strSerialNumber+"_OC.BMP")){
				emit information(QString("Save Image Success:%1").arg(strSerialNumber+"_OC.BMP"));
			}
		}
		unsigned int uiPixel = itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight;
		unsigned char* pucDes = pucRGB24, *pucSrc = pucRGB24 +1;
		for(unsigned int x=0; x<uiPixel; ++x){
			*pucDes++	=	*pucSrc;
			pucSrc			+=	3;
		}

		iresult	=	classAlgorithm.HisCCMWhitePanel_OCHA(pucRGB24,itemshareData.previewParameter->iWidth, \
			itemshareData.previewParameter->iHeight, ioc_x, ioc_y, itemshareData.wpOCParameter->stAlgHA.oc_flpixelratio);
		if(iresult)	return iresult;

		global_ioc_x = ioc_x		=	(ioc_x >>1);
		global_ioc_y = ioc_y		=	(ioc_y >>1);

		global_ioc_x=global_ioc_x-itemshareData.previewParameter->iWidth/2;
		global_ioc_y=global_ioc_y-itemshareData.previewParameter->iHeight/2;

		float fldistance	=	sqrtf((ioc_x-itemshareData.previewParameter->iWidth/2)*(ioc_x-itemshareData.previewParameter->iWidth/2) + \
			(ioc_y-itemshareData.previewParameter->iHeight/2)*(ioc_y-itemshareData.previewParameter->iHeight/2));
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("光心测试数据："));
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("          测试光心坐标(x,y)：") % \
			QString::number(ioc_x, 10) % ",  " % QString::number(ioc_y, 10) );
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("         与物理中心距离：") % \
			QString::number(static_cast<double>(fldistance), 'f', 3) % "pixel");

		itemshareData.drawLock.lockForWrite();
		int ilastcount	=	itemshareData.itemdrawList.size();
		itemshareData.itemdrawList.resize(ilastcount + 2);
		theIterator	=	itemshareData.itemdrawList.begin() +ilastcount;
		theIterator->usitem							=	whitepanelitem_oc;
		theIterator->uctype							=	HisDrawType_Line;
		theIterator->stcolor							=	QColor::fromRgb(0, 255, 0);
		theIterator->strinfo.stblock.left			=	ioc_x - 100;
		theIterator->strinfo.stblock.right		=	ioc_x + 100;
		theIterator->strinfo.stblock.top			=	ioc_y;
		theIterator->strinfo.stblock.bottom	=	ioc_y;
		theIterator++;
		theIterator->usitem							=	whitepanelitem_oc;
		theIterator->uctype							=	HisDrawType_Line;
		theIterator->stcolor							=	QColor::fromRgb(0, 255, 0);
		theIterator->strinfo.stblock.left			=	ioc_x;
		theIterator->strinfo.stblock.right		=	ioc_x;
		theIterator->strinfo.stblock.top			=	ioc_y - 100;
		theIterator->strinfo.stblock.bottom	=	ioc_y + 100;
		itemshareData.drawLock.unlock();

		if(fldistance > itemshareData.wpOCParameter->stAlgHA.oc_fldeviation){
			iresult							=	HisCCMError_Result;
			stLogItem.itemvalue	=	"NG";
			itemshareData.drawLock.lockForWrite();
			theIterator	=	itemshareData.itemdrawList.begin() +ilastcount;
			theIterator->stcolor	=	QColor::fromRgb(255, 0, 0);
			theIterator++;
			theIterator->stcolor	=	QColor::fromRgb(255, 0, 0);
			itemshareData.drawLock.unlock();
		}

		classstLogItem.SubRef();
		classLog->push_back(stLogItem);
		++(stLogItem.itemtype);
		stLogItem.itemkey		=	"OC_X";
		stLogItem.itemvalue	=	ioc_x;
		classLog->push_back(stLogItem);
		++(stLogItem.itemtype);
		stLogItem.itemkey		=	"OC_Y";
		stLogItem.itemvalue	=	ioc_y;
		classLog->push_back(stLogItem);
		++(stLogItem.itemtype);
		stLogItem.itemkey		=	"OC_Distance";
		stLogItem.itemvalue	=	fldistance;
		classLog->push_back(stLogItem);
	}
	else if(itemshareData.wpOCParameter->opticalcenterAlg == _HisAlg_SWITCH_B)
	{
		unsigned char* pucRGB24	=	(unsigned char*)HisAlignedMalloc(itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight *3);
		if(!pucRGB24) return HisFX3Error_MallocBuffer;
		QHisFX3MallocAlignedManage classpucRGB24(pucRGB24);

		if(iresult	=	GetFreshframe(pucRGB24, itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight *3, _FrameType_RGB24, true))
			return iresult;

		unsigned int uiPixel = itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight;
		unsigned char* pucDes = pucRGB24, *pucSrc = pucRGB24 +1;
		for(unsigned int x=0; x<uiPixel; ++x){
			*pucDes++	=	*pucSrc;
			pucSrc			+=	3;
		}

		float ocx, ocy;
		if (iresult = classAlgorithm.HisCCMWhitePanel_OCHB(pucRGB24,itemshareData.previewParameter->iWidth, \
			itemshareData.previewParameter->iHeight, itemshareData.wpOCParameter->stAlgHB.oc_flpixelratio, ocx, ocy))
			return iresult;

		float fldistance	=	sqrtf((ocx-itemshareData.previewParameter->iWidth/2)*(ocx-itemshareData.previewParameter->iWidth/2) + \
			(ocy-itemshareData.previewParameter->iHeight/2)*(ocy-itemshareData.previewParameter->iHeight/2));
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("光心测试数据："));
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("          测试光心坐标(x,y)：") % \
			QString::number(ocx) % ",  " % QString::number(ocy) );
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("         与物理中心距离：") % \
			QString::number(static_cast<double>(fldistance), 'f', 3) % "pixel");

		itemshareData.drawLock.lockForWrite();
		int ilastcount	=	itemshareData.itemdrawList.size();
		itemshareData.itemdrawList.resize(ilastcount + 2);
		theIterator	=	itemshareData.itemdrawList.begin() +ilastcount;
		theIterator->usitem							=	whitepanelitem_oc;
		theIterator->uctype							=	HisDrawType_Line;
		theIterator->stcolor							=	QColor::fromRgb(0, 255, 0);
		theIterator->strinfo.stblock.left			=	ocx - 100;
		theIterator->strinfo.stblock.right		=	ocx + 100;
		theIterator->strinfo.stblock.top			=	ocy;
		theIterator->strinfo.stblock.bottom	=	ocy;
		theIterator++;
		theIterator->usitem							=	whitepanelitem_oc;
		theIterator->uctype							=	HisDrawType_Line;
		theIterator->stcolor							=	QColor::fromRgb(0, 255, 0);
		theIterator->strinfo.stblock.left			=	ocx;
		theIterator->strinfo.stblock.right		=	ocx;
		theIterator->strinfo.stblock.top			=	ocy - 100;
		theIterator->strinfo.stblock.bottom	=	ocy + 100;
		itemshareData.drawLock.unlock();

		if(fldistance > itemshareData.wpOCParameter->stAlgHB.oc_fldeviation){
			iresult							=	HisCCMError_Result;
			stLogItem.itemvalue	=	"NG";
			itemshareData.drawLock.lockForWrite();
			theIterator	=	itemshareData.itemdrawList.begin() +ilastcount;
			theIterator->stcolor	=	QColor::fromRgb(255, 0, 0);
			theIterator++;
			theIterator->stcolor	=	QColor::fromRgb(255, 0, 0);
			itemshareData.drawLock.unlock();
		}

		classstLogItem.SubRef();
		classLog->push_back(stLogItem);
		++(stLogItem.itemtype);
		stLogItem.itemkey		=	"OC_X";
		stLogItem.itemvalue	=	ocx;
		classLog->push_back(stLogItem);
		++(stLogItem.itemtype);
		stLogItem.itemkey		=	"OC_Y";
		stLogItem.itemvalue	=	ocy;
		classLog->push_back(stLogItem);
		++(stLogItem.itemtype);
		stLogItem.itemkey		=	"OC_Distance";
		stLogItem.itemvalue	=	fldistance;
		classLog->push_back(stLogItem);
	}else if(itemshareData.wpOCParameter->opticalcenterAlg == _HisAlg_SWITCH_C)
	{
		int ioc_x, ioc_y;
		unsigned char* pucRGB24	=	(unsigned char*)HisAlignedMalloc(itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight *3);
		if(!pucRGB24) return HisFX3Error_MallocBuffer;
		QHisFX3MallocAlignedManage classpucRGB24(pucRGB24);

		if(iresult	=	GetFreshframe(pucRGB24, itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight *3, _FrameType_RGB24, true))
			return iresult;

		if(hisglobalparameter.bDebugMode){
			double out1[5]={0};
			funCalMarkDist(pucRGB24,NULL,out1,itemshareData.previewParameter->iWidth,itemshareData.previewParameter->iHeight,15,15000,25000,700,1200,false);

			QImage image(pucRGB24,itemshareData.previewParameter->iWidth,itemshareData.previewParameter->iHeight,itemshareData.previewParameter->iWidth*3,QImage::Format_RGB888);
			QString strSerialNumber;
			classLog->getserialnumber(strSerialNumber);
			if(image.save(strSerialNumber+"_OC.BMP")){
				emit information(QString("Save Image Success:%1").arg(strSerialNumber+"_OC.BMP"));
			}
		}
		unsigned int uiPixel = itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight;
		unsigned char* pucDes = pucRGB24, *pucSrc = pucRGB24 +1;
		for(unsigned int x=0; x<uiPixel; ++x){
			*pucDes++	=	*pucSrc;
			pucSrc			+=	3;
		}

		iresult	=	funOC(pucRGB24,itemshareData.previewParameter->iWidth,itemshareData.previewParameter->iHeight, ioc_x, ioc_y,hisglobalparameter.bDebugMode);

		if(iresult)	return iresult;

		global_ioc_x = ioc_x;
		global_ioc_y = ioc_y;

		global_ioc_x=global_ioc_x-itemshareData.previewParameter->iWidth/2;
		global_ioc_y=global_ioc_y-itemshareData.previewParameter->iHeight/2;

		float fldistance	=	sqrtf((ioc_x-itemshareData.previewParameter->iWidth/2)*(ioc_x-itemshareData.previewParameter->iWidth/2) + \
			(ioc_y-itemshareData.previewParameter->iHeight/2)*(ioc_y-itemshareData.previewParameter->iHeight/2));
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("光心测试数据："));
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("          测试光心坐标(x,y)：") % \
			QString::number(ioc_x, 10) % ",  " % QString::number(ioc_y, 10) );
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("         与物理中心距离：") % \
			QString::number(static_cast<double>(fldistance), 'f', 3) % "pixel");

		itemshareData.drawLock.lockForWrite();
		int ilastcount	=	itemshareData.itemdrawList.size();
		itemshareData.itemdrawList.resize(ilastcount + 2);
		theIterator	=	itemshareData.itemdrawList.begin() +ilastcount;
		theIterator->usitem							=	whitepanelitem_oc;
		theIterator->uctype							=	HisDrawType_Line;
		theIterator->stcolor							=	QColor::fromRgb(0, 255, 0);
		theIterator->strinfo.stblock.left			=	ioc_x - 100;
		theIterator->strinfo.stblock.right		=	ioc_x + 100;
		theIterator->strinfo.stblock.top			=	ioc_y;
		theIterator->strinfo.stblock.bottom	=	ioc_y;
		theIterator++;
		theIterator->usitem							=	whitepanelitem_oc;
		theIterator->uctype							=	HisDrawType_Line;
		theIterator->stcolor							=	QColor::fromRgb(0, 255, 0);
		theIterator->strinfo.stblock.left			=	ioc_x;
		theIterator->strinfo.stblock.right		=	ioc_x;
		theIterator->strinfo.stblock.top			=	ioc_y - 100;
		theIterator->strinfo.stblock.bottom	=	ioc_y + 100;
		itemshareData.drawLock.unlock();

		if(fldistance > itemshareData.wpOCParameter->stAlgHA.oc_fldeviation){
			iresult							=	HisCCMError_Result;
			stLogItem.itemvalue	=	"NG";
			itemshareData.drawLock.lockForWrite();
			theIterator	=	itemshareData.itemdrawList.begin() +ilastcount;
			theIterator->stcolor	=	QColor::fromRgb(255, 0, 0);
			theIterator++;
			theIterator->stcolor	=	QColor::fromRgb(255, 0, 0);
			itemshareData.drawLock.unlock();
		}

		classstLogItem.SubRef();
		classLog->push_back(stLogItem);
		++(stLogItem.itemtype);
		stLogItem.itemkey		=	"OC_X";
		stLogItem.itemvalue	=	ioc_x;
		classLog->push_back(stLogItem);
		++(stLogItem.itemtype);
		stLogItem.itemkey		=	"OC_Y";
		stLogItem.itemvalue	=	ioc_y;
		classLog->push_back(stLogItem);
		++(stLogItem.itemtype);
		stLogItem.itemkey		=	"OC_Distance";
		stLogItem.itemvalue	=	fldistance;
		classLog->push_back(stLogItem);
	}else if(itemshareData.wpOCParameter->opticalcenterAlg == _HisAlg_SWITCH_D)
	{
		int ioc_x, ioc_y;
		unsigned char* pucRaw8	=	(unsigned char*)HisAlignedMalloc(itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight);
		if(!pucRaw8) return HisFX3Error_MallocBuffer;

		if(iresult	=	GetFreshframe(pucRaw8, itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight *2, _FrameType_Raw, true))
			return iresult;

		if(hisglobalparameter.bDebugMode){
			double out1[5]={0};
			//funCalMarkDist(pucRaw10,NULL,out1,itemshareData.previewParameter->iWidth,itemshareData.previewParameter->iHeight,15,15000,25000,700,1200,false);
			QImage image(pucRaw8,itemshareData.previewParameter->iWidth,itemshareData.previewParameter->iHeight,itemshareData.previewParameter->iWidth,QImage::Format_RGB888);
			QString strSerialNumber;
			classLog->getserialnumber(strSerialNumber);
			if(image.save(strSerialNumber+"_OC.BMP")){
				emit information(QString("Save Image Success:%1").arg(strSerialNumber+"_OC.BMP"));
			}
		}
		unsigned int uiChannelPixel = itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight/2;
		unsigned char* pucDes = pucRaw8;
		
		unsigned char *pucRawChannel1,*pucRawChannel2,*pucRawChannel3,*pucRawChannel4;
		pucRawChannel1=(BYTE*)_aligned_malloc(uiChannelPixel,64);
		pucRawChannel2=(BYTE*)_aligned_malloc(uiChannelPixel,64);
		pucRawChannel3=(BYTE*)_aligned_malloc(uiChannelPixel,64);
		pucRawChannel4=(BYTE*)_aligned_malloc(uiChannelPixel,64);

		int PosIndex=0;
		unsigned int uiRowStep=itemshareData.previewParameter->iWidth;
		for (int row=0;row<itemshareData.previewParameter->iHeight;row+=2)
		{
			for (int col=0;col<itemshareData.previewParameter->iWidth;col+=2)
			{
				pucRawChannel1[PosIndex]=pucRaw8[(row*uiRowStep)+(col)];
				pucRawChannel2[PosIndex]=pucRaw8[(row*uiRowStep)+(col+1)];
				pucRawChannel3[PosIndex]=pucRaw8[((row+1)*uiRowStep)+(col)];
				pucRawChannel4[PosIndex]=pucRaw8[((row+1)*uiRowStep)+(col+1)];
				PosIndex++;
			}
		}

		int ioc_x1,ioc_x2,ioc_x3,ioc_x4;
		int ioc_y1,ioc_y2,ioc_y3,ioc_y4;

		int iresult_temp=0;
		iresult_temp	=	funOC(pucRawChannel1,itemshareData.previewParameter->iWidth/2,itemshareData.previewParameter->iHeight/2, ioc_x1, ioc_y1,hisglobalparameter.bDebugMode);
		iresult_temp	=	funOC(pucRawChannel2,itemshareData.previewParameter->iWidth/2,itemshareData.previewParameter->iHeight/2, ioc_x2, ioc_y2,hisglobalparameter.bDebugMode);
		iresult_temp	=	funOC(pucRawChannel3,itemshareData.previewParameter->iWidth/2,itemshareData.previewParameter->iHeight/2, ioc_x3, ioc_y3,hisglobalparameter.bDebugMode);
		iresult_temp	=	funOC(pucRawChannel4,itemshareData.previewParameter->iWidth/2,itemshareData.previewParameter->iHeight/2, ioc_x4, ioc_y4,hisglobalparameter.bDebugMode);
		
		_aligned_free(pucRawChannel1);
		_aligned_free(pucRawChannel2);
		_aligned_free(pucRawChannel3);
		_aligned_free(pucRawChannel4);

		int ioc_x_R,ioc_y_R,ioc_x_Gr,ioc_y_Gr,ioc_x_Gb,ioc_y_Gb,ioc_x_B,ioc_y_B;
		switch (itemshareData.previewParameter->ucDataFormat)
		{
		case HisBaylor8_RGGB:
		case HisBaylor10_RGGB:
			ioc_x_R=ioc_x1;ioc_y_R=ioc_y1;
			ioc_x_Gr=ioc_x2;ioc_y_Gr=ioc_y2;
			ioc_x_Gb=ioc_x3;ioc_y_Gb=ioc_y3;
			ioc_x_B=ioc_x4;ioc_y_B=ioc_y4;
			break;
		case HisBaylor8_GRBG:
		case HisBaylor10_GRBG:
			ioc_x_Gr=ioc_x1;ioc_y_Gr=ioc_y1;
			ioc_x_R=ioc_x2;ioc_y_R=ioc_y2;
			ioc_x_B=ioc_x3;ioc_y_B=ioc_y3;
			ioc_x_Gb=ioc_x4;ioc_y_Gb=ioc_y4;
			break;
		case HisBaylor8_GBRG:
		case HisBaylor10_GBRG:
			ioc_x_Gb=ioc_x1;ioc_y_Gb=ioc_y1;
			ioc_x_B=ioc_x2;ioc_y_B=ioc_y2;
			ioc_x_R=ioc_x3;ioc_y_R=ioc_y3;
			ioc_x_Gr=ioc_x4;ioc_y_Gr=ioc_y4;
			break;
		case HisBaylor8_BGGR:
		case HisBaylor10_BGGR:
			ioc_x_B=ioc_x1;ioc_y_B=ioc_y1;
			ioc_x_Gb=ioc_x2;ioc_y_Gb=ioc_y2;
			ioc_x_Gr=ioc_x3;ioc_y_Gr=ioc_y3;
			ioc_x_R=ioc_x4;ioc_y_R=ioc_y4;
			break;
		}


		ioc_x_R*=2;ioc_x_Gr*=2;ioc_x_Gb*=2;ioc_x_B*=2;
		ioc_y_R*=2;ioc_y_Gr*=2;ioc_y_Gb*=2;ioc_y_B*=2;
		ioc_x=max(max(max(ioc_x1,ioc_x2),ioc_x3),ioc_x4)*2;
		ioc_y=max(max(max(ioc_y1,ioc_y2),ioc_y3),ioc_y4)*2;
		global_ioc_x = ioc_x;
		global_ioc_y = ioc_y;
		global_ioc_x=global_ioc_x-itemshareData.previewParameter->iWidth/2;
		global_ioc_y=global_ioc_y-itemshareData.previewParameter->iHeight/2;

		emit information(QString::fromLocal8Bit("R Channel X:%1 Y:%2").arg(ioc_x_R).arg(ioc_y_R));
		emit information(QString::fromLocal8Bit("Gr Channel X:%1 Y:%2").arg(ioc_x_Gr).arg(ioc_y_Gr));
		emit information(QString::fromLocal8Bit("Gb Channel X:%1 Y:%2").arg(ioc_x_Gb).arg(ioc_y_Gb));
		emit information(QString::fromLocal8Bit("B Channel X:%1 Y:%2").arg(ioc_x_B).arg(ioc_y_B));

		float fldistance	=	sqrtf((ioc_x-itemshareData.previewParameter->iWidth/2)*(ioc_x-itemshareData.previewParameter->iWidth/2) + \
			(ioc_y-itemshareData.previewParameter->iHeight/2)*(ioc_y-itemshareData.previewParameter->iHeight/2));

		emit information(QTextCodec::codecForName( "GBK")->toUnicode("光心测试数据："));
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("测试光心坐标(x,y)：") % \
			QString::number(ioc_x, 10) % ",  " % QString::number(ioc_y, 10) );
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("与物理中心距离：") % \
			QString::number(static_cast<double>(fldistance), 'f', 3) % "pixel");

		itemshareData.drawLock.lockForWrite();
		int ilastcount	=	itemshareData.itemdrawList.size();
		itemshareData.itemdrawList.resize(ilastcount + 2);
		theIterator	=	itemshareData.itemdrawList.begin() +ilastcount;
		theIterator->usitem							=	whitepanelitem_oc;
		theIterator->uctype							=	HisDrawType_Line;
		theIterator->stcolor							=	QColor::fromRgb(0, 255, 0);
		theIterator->strinfo.stblock.left			=	ioc_x - 100;
		theIterator->strinfo.stblock.right		=	ioc_x + 100;
		theIterator->strinfo.stblock.top			=	ioc_y;
		theIterator->strinfo.stblock.bottom	=	ioc_y;
		theIterator++;
		theIterator->usitem							=	whitepanelitem_oc;
		theIterator->uctype							=	HisDrawType_Line;
		theIterator->stcolor							=	QColor::fromRgb(0, 255, 0);
		theIterator->strinfo.stblock.left			=	ioc_x;
		theIterator->strinfo.stblock.right		=	ioc_x;
		theIterator->strinfo.stblock.top			=	ioc_y - 100;
		theIterator->strinfo.stblock.bottom	=	ioc_y + 100;
		itemshareData.drawLock.unlock();

		if(fldistance > itemshareData.wpOCParameter->stAlgHA.oc_fldeviation){
			iresult							=	HisCCMError_Result;
			stLogItem.itemvalue	=	"NG";
			itemshareData.drawLock.lockForWrite();
			theIterator	=	itemshareData.itemdrawList.begin() +ilastcount;
			theIterator->stcolor	=	QColor::fromRgb(255, 0, 0);
			theIterator++;
			theIterator->stcolor	=	QColor::fromRgb(255, 0, 0);
			itemshareData.drawLock.unlock();
		}

		classstLogItem.SubRef();
		classLog->push_back(stLogItem);

		++(stLogItem.itemtype);
		stLogItem.itemkey		=	"ChannelR_OC_X";
		stLogItem.itemvalue	=	ioc_x_R;
		classLog->push_back(stLogItem);
		++(stLogItem.itemtype);
		stLogItem.itemkey		=	"ChannelR_OC_Y";
		stLogItem.itemvalue	=	ioc_y_R;
		classLog->push_back(stLogItem);
		++(stLogItem.itemtype);
		stLogItem.itemkey		=	"ChannelGr_OC_X";
		stLogItem.itemvalue	=	ioc_x_Gr;
		classLog->push_back(stLogItem);
		++(stLogItem.itemtype);
		stLogItem.itemkey		=	"ChannelGr_OC_Y";
		stLogItem.itemvalue	=	ioc_y_Gr;
		classLog->push_back(stLogItem);
		++(stLogItem.itemtype);
		stLogItem.itemkey		=	"ChannelGb_OC_X";
		stLogItem.itemvalue	=	ioc_x_Gb;
		classLog->push_back(stLogItem);
		++(stLogItem.itemtype);
		stLogItem.itemkey		=	"ChannelGb_OC_Y";
		stLogItem.itemvalue	=	ioc_y_Gb;
		classLog->push_back(stLogItem);
		++(stLogItem.itemtype);
		stLogItem.itemkey		=	"ChannelB_OC_X";
		stLogItem.itemvalue	=	ioc_x_B;
		classLog->push_back(stLogItem);
		++(stLogItem.itemtype);
		stLogItem.itemkey		=	"ChannelB_OC_Y";
		stLogItem.itemvalue	=	ioc_y_B;
		classLog->push_back(stLogItem);

		++(stLogItem.itemtype);
		stLogItem.itemkey		=	"Max_OC_X";
		stLogItem.itemvalue	=	ioc_x;
		classLog->push_back(stLogItem);
		++(stLogItem.itemtype);
		stLogItem.itemkey		=	"Max_OC_Y";
		stLogItem.itemvalue	=	ioc_y;
		classLog->push_back(stLogItem);
		++(stLogItem.itemtype);
		stLogItem.itemkey		=	"Max_OC_Distance";
		stLogItem.itemvalue	=	fldistance;
		classLog->push_back(stLogItem);
	}

	return iresult;
}

int itemprocess::getwhitePanelDefectLineParameter(bool bupdate, bool bcheck)
{
	QMutexLocker locker(&hisglobalparameter.mutexDatabase);

	itemshareData.itemparameterLock.lockForRead();
	if(!bupdate && itemshareData.wpDefectLineParameter)	{	itemshareData.itemparameterLock.unlock();	return 0;	}
	itemshareData.itemparameterLock.unlock();

	itemshareData.itemparameterLock.lockForWrite();
	if(!itemshareData.wpDefectLineParameter)	itemshareData.wpDefectLineParameter		=	new _wpDefectLineParameter;
	if(!itemshareData.wpDefectLineParameter)	{	itemshareData.itemparameterLock.unlock();	return HisFX3Error_MallocBuffer;	}

	bool bItemExist = false;
	{
		QSqlDatabase customdb = QSqlDatabase::addDatabase("QSQLITE", "querycustom");
		customdb.setDatabaseName(QDir::currentPath() % "/HisFX3Custom");
		if (!customdb.open()){
			itemshareData.itemparameterLock.unlock();
			return HisCCMError_Database;
		}

		QStringList strname, strvalue;
		QString strData, strData2;
		QSqlQuery query(customdb);
		query.prepare("SELECT itemsuffix2,key,value,reserve FROM " % itemshareData.currentTableName % \
			" WHERE classfy='algorithm' AND item='whitepanel' AND itemsuffix1='total' ORDER BY id ASC" );
		query.exec();

		//
		//
		//(opticalcenteralg:a)(defectpixelalg:a)(defectlinealg:a)
		//(belmishalg:a)(coloralg:a)(shadingalg:a)(vignettingalg:a)
		while (query.next()){
			bItemExist = true;
			for(int y=0;	y<4;	++y){
				strData	=	query.value(y).toString();
				ROPLOW::patchconfigstring(strData, strname, strvalue);
				for(int x=0;	x<strname.size();	++x){
					if(strname.at(x) == "defectlinealg"){
						if(strvalue.at(x) == "a")	itemshareData.wpDefectLineParameter->defectlineAlg	=	_HisAlg_SWITCH_A;
					}
				}
			}
		}

		query.prepare("SELECT itemsuffix2,key,value,reserve FROM " % itemshareData.currentTableName % \
			" WHERE classfy='algorithm' AND item='whitepanel' AND itemsuffix1='defectline' ORDER BY id ASC" );
		query.exec();
		//(spec_r:0.03)(spec_b:0.03)(spec_g:0.03)
		while (query.next()){
			bItemExist = true;
			for(int y=0;	y<4;	++y){
				strData	=	query.value(y).toString();
				ROPLOW::patchconfigstring(strData, strname, strvalue);
				for(int x=0;	x<strname.size();	++x){
					if(strname.at(x) == "spec_r")				itemshareData.wpDefectLineParameter->stAlgHA.line_flspec_r	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "spec_g")		itemshareData.wpDefectLineParameter->stAlgHA.line_flspec_g	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "spec_b")		itemshareData.wpDefectLineParameter->stAlgHA.line_flspec_b	=	strvalue.at(x).toFloat();
				}
			}
		}

		customdb.close();
	}

	QSqlDatabase::removeDatabase("querycustom");

	if(!bItemExist)
	{
		HisReleaseNewO(itemshareData.wpDefectLineParameter);
		itemshareData.itemparameterLock.unlock();
		return HisFX3Error_Parameter;
	}

	if(!bcheck) {itemshareData.itemparameterLock.unlock(); return 0; }

	itemshareData.itemparameterLock.unlock();
	return 0;
}

int itemprocess::whitePanelDefectLine()
{
	std::vector<_itemDraw>::iterator theIterator;
	itemshareData.clearDrawList();

	//判断图像是否点亮中
	if(!threadshareData.GetHisPreviewflag())	return HisCCMError_NotPreivew;

	//取得配置参数和规格
	int iresult	=	getwhitePanelDefectLineParameter(false);
	if(iresult)	return iresult;

	QHReadWriteLockManage classitemparameterLock(&(itemshareData.itemparameterLock));
	stLogItem.itemtype		=	classLog->getmaxtypeindex(_HISLOG_CLASSIFY_DEFECTLINE);
	stLogItem.itemkey		=	"Defect_Line Result";
	stLogItem.itemvalue	=	"OK";
	QHDefaultLogManage classstLogItem(classLog, &stLogItem, "NG");

	_HisFX3_BaylorMode ucDataFormat;
	ROPLOW::BaylorXForamt2Baloy8(itemshareData.previewParameter->ucDataFormat, ucDataFormat);

	if(itemshareData.wpDefectLineParameter->defectlineAlg == _HisAlg_SWITCH_A)
	{
		std::vector<_WhitePanel_DefectLine_Result> stmaxline;
		unsigned char* pucBaylorR	=	0, *pucBaylorB = 0, *pucBaylorGr = 0, *pucBaylorGb = 0;
		int iWidthT = (itemshareData.previewParameter->iWidth >>1), iHeightT = (itemshareData.previewParameter->iHeight >>1);

		if(ucDataFormat >= HisYUV8_422_YUYV && ucDataFormat <= HisYUV8_420P)
		{
			unsigned char* pucYUV	=	(unsigned char*)HisAlignedMalloc(itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight *2);
			if(!pucYUV) return HisFX3Error_MallocBuffer;

			//取得raw图像数据
			if(iresult	=	GetFreshframe(pucYUV, itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight*2, _FrameType_Raw, true)){
				HisReleaseMalloc(pucYUV);
				return iresult;
			}

			classAlgorithm.extactYfromYUV422U8(pucYUV, pucYUV, itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight, itemshareData.previewParameter->ucDataFormat);

			pucBaylorR	=	pucYUV;
			iWidthT		=	itemshareData.previewParameter->iWidth;
			iHeightT		=	itemshareData.previewParameter->iHeight;
		}
		else if(ucDataFormat == HisRGB_RGB24)
		{
			unsigned char* pucRGB24	=	(unsigned char*)HisAlignedMalloc(itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight *3);
			QHisFX3MallocAlignedManage classpucRGB24(pucRGB24);
			if(!pucRGB24) return HisFX3Error_MallocBuffer;

			if(iresult	=	GetFreshframe(pucRGB24, itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight *3, _FrameType_RGB24, true))
				return iresult;

			pucBaylorR		=	(unsigned char*)HisAlignedMalloc(itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight);
			pucBaylorB		=	(unsigned char*)HisAlignedMalloc(itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight);
			pucBaylorGr	=	(unsigned char*)HisAlignedMalloc(itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight);
			if(!pucBaylorR || !pucBaylorB || !pucBaylorGr) {
				HisReleaseMalloc(pucBaylorR);
				HisReleaseMalloc(pucBaylorB);
				HisReleaseMalloc(pucBaylorGr);
				return HisFX3Error_MallocBuffer;
			}

			ROPLOW::extractrgb24(pucRGB24, pucBaylorR, pucBaylorGr, pucBaylorB, itemshareData.previewParameter->iWidth, itemshareData.previewParameter->iHeight);
			iWidthT		=	itemshareData.previewParameter->iWidth;
			iHeightT		=	itemshareData.previewParameter->iHeight;
		}
		else
		{
			unsigned char* pucBaylor	=	(unsigned char*)HisAlignedMalloc(itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight);
			if(!pucBaylor) return HisFX3Error_MallocBuffer;
			QHisFX3MallocAlignedManage classpucBaylor(pucBaylor);

			//取得raw图像数据
			if(iresult	=	GetFreshframe(pucBaylor, itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight, _FrameType_Raw, true))
				return iresult;

			pucBaylorR		=	(unsigned char*)HisAlignedMalloc(itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight /4);
			pucBaylorB		=	(unsigned char*)HisAlignedMalloc(itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight /4);
			pucBaylorGr	=	(unsigned char*)HisAlignedMalloc(itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight /4);
			pucBaylorGb	=	(unsigned char*)HisAlignedMalloc(itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight /4);
			if(!pucBaylorR || !pucBaylorB || !pucBaylorGr || !pucBaylorGb) {
				HisReleaseMalloc(pucBaylorR);
				HisReleaseMalloc(pucBaylorB);
				HisReleaseMalloc(pucBaylorGr);
				HisReleaseMalloc(pucBaylorGb);
				return HisFX3Error_MallocBuffer;
			}

			classAlgorithm.patchbaylor(pucBaylor, itemshareData.previewParameter->iWidth, itemshareData.previewParameter->iHeight, pucBaylorB, pucBaylorR, pucBaylorGr, pucBaylorGb, ucDataFormat);
		}

		QHisFX3MallocAlignedManage classpucBaylorR(pucBaylorR);
		QHisFX3MallocAlignedManage classpucBaylorB(pucBaylorB);
		QHisFX3MallocAlignedManage classpucBaylorGr(pucBaylorGr);
		QHisFX3MallocAlignedManage classpucBaylorGb(pucBaylorGb);

		if(iresult	=	classAlgorithm.HisCCMWhitePanel_DefectLineHA(pucBaylorR, pucBaylorB, pucBaylorGr, pucBaylorGb, iWidthT, iHeightT, stmaxline))	
			return iresult;


		if(ucDataFormat >= HisYUV8_422_YUYV && ucDataFormat <= HisYUV8_420P){
			for(unsigned int x=0;	x<stmaxline.size(); ++x)
				stmaxline.at(x).bufferType	=	_HisFX3_BufferFormat_Y;
		}
		else if(ucDataFormat == HisRGB_RGB24){
			for(unsigned int x=0;	x<stmaxline.size(); ++x)
				if(stmaxline.at(x).bufferType == _HisFX3_BufferFormat_BayloyGr || stmaxline.at(x).bufferType == _HisFX3_BufferFormat_BaylorGb) stmaxline.at(x).bufferType = _HisFX3_BufferFormat_G;
		}
		else{
			for(unsigned int x=0;	x<stmaxline.size(); ++x)
				stmaxline.at(x).uiLineIndex	=	(stmaxline.at(x).uiLineIndex <<1);
		}

		QString strInfo;
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("线条测试数据："));
		for(unsigned int x=0;	x<stmaxline.size(); ++x){
			switch (stmaxline.at(x).bufferType){
			case _HisFX3_BufferFormat_BayloyGr:	strInfo = QTextCodec::codecForName( "GBK")->toUnicode("         Gr通道("); break;
			case _HisFX3_BufferFormat_BaylorGb:	strInfo = QTextCodec::codecForName( "GBK")->toUnicode("         Gb通道("); break;
			case _HisFX3_BufferFormat_BaylorR:		strInfo = QTextCodec::codecForName( "GBK")->toUnicode("         R通道("); break;
			case _HisFX3_BufferFormat_BaylorB:		strInfo = QTextCodec::codecForName( "GBK")->toUnicode("         B通道("); break;
			case _HisFX3_BufferFormat_G:				strInfo = QTextCodec::codecForName( "GBK")->toUnicode("         G通道("); break;
			case _HisFX3_BufferFormat_Y:	
			default:															strInfo = QTextCodec::codecForName( "GBK")->toUnicode("         Y通道("); break;
			}
			strInfo	=	strInfo % QString::number(stmaxline.at(x).uiLineIndex) % ((stmaxline.at(x).lineType==_HisAlg_LineType_Vertical)?(QTextCodec::codecForName( "GBK")->toUnicode("列)浓度： ")):(QTextCodec::codecForName( "GBK")->toUnicode("行)浓度： "))) %\
				QString::number(stmaxline.at(x).flPercent, 'f', 3);
			emit information(strInfo);
		}


		bool bDefectLineResult	=	(stmaxline.size() < 1)?(false):(true);
		for(unsigned int x=0;	x<stmaxline.size(); ++x){
			switch (stmaxline.at(x).bufferType){
			case _HisFX3_BufferFormat_BayloyGr:	bDefectLineResult = (stmaxline.at(x).flPercent >  itemshareData.wpDefectLineParameter->stAlgHA.line_flspec_g)?(false):(bDefectLineResult); break;
			case _HisFX3_BufferFormat_BaylorGb:	bDefectLineResult = (stmaxline.at(x).flPercent >  itemshareData.wpDefectLineParameter->stAlgHA.line_flspec_g)?(false):(bDefectLineResult); break;
			case _HisFX3_BufferFormat_G:				bDefectLineResult = (stmaxline.at(x).flPercent >  itemshareData.wpDefectLineParameter->stAlgHA.line_flspec_g)?(false):(bDefectLineResult); break;
			case _HisFX3_BufferFormat_BaylorR:		bDefectLineResult = (stmaxline.at(x).flPercent >  itemshareData.wpDefectLineParameter->stAlgHA.line_flspec_r)?(false):(bDefectLineResult); break;
			case _HisFX3_BufferFormat_BaylorB:		bDefectLineResult = (stmaxline.at(x).flPercent >  itemshareData.wpDefectLineParameter->stAlgHA.line_flspec_b)?(false):(bDefectLineResult); break;
			case _HisFX3_BufferFormat_Y:	
			default:															bDefectLineResult = (stmaxline.at(x).flPercent >  max(itemshareData.wpDefectLineParameter->stAlgHA.line_flspec_b, max(itemshareData.wpDefectLineParameter->stAlgHA.line_flspec_g,  itemshareData.wpDefectLineParameter->stAlgHA.line_flspec_r)))?(false):(bDefectLineResult); break;
			}
		}
		if(!bDefectLineResult){
			iresult					=	HisCCMError_Result;
			stLogItem.itemvalue	=	"NG";
		}

		classstLogItem.SubRef();
		classLog->push_back(stLogItem);
	}

	return iresult;
}

int itemprocess::getwhitePanelDefectPixelParameter(bool bupdate, bool bcheck)
{
	QMutexLocker locker(&hisglobalparameter.mutexDatabase);

	itemshareData.itemparameterLock.lockForRead();
	if(!bupdate && itemshareData.wpDefectPixelParameter)	{	itemshareData.itemparameterLock.unlock();	return 0;	}
	itemshareData.itemparameterLock.unlock();

	itemshareData.itemparameterLock.lockForWrite();
	if(!itemshareData.wpDefectPixelParameter)	itemshareData.wpDefectPixelParameter		=	new _wpDefectPixelParameter;
	if(!itemshareData.wpDefectPixelParameter)	{	itemshareData.itemparameterLock.unlock();	return HisFX3Error_MallocBuffer;	}

	bool bItemExist = false;
	{
		QSqlDatabase customdb = QSqlDatabase::addDatabase("QSQLITE", "querycustom");
		customdb.setDatabaseName(QDir::currentPath() % "/HisFX3Custom");
		if (!customdb.open()){
			itemshareData.itemparameterLock.unlock();
			return HisCCMError_Database;
		}

		QStringList strname, strvalue;
		QString strData, strData2;
		bool bok;
		QSqlQuery query(customdb);
		query.prepare("SELECT itemsuffix2,key,value,reserve FROM " % itemshareData.currentTableName % \
			" WHERE classfy='algorithm' AND item='whitepanel' AND itemsuffix1='total' ORDER BY id ASC" );
		query.exec();

		//
		//
		//(opticalcenteralg:a)(defectpixelalg:a)(defectlinealg:a)
		//(belmishalg:a)(coloralg:a)(shadingalg:a)(vignettingalg:a)
		while (query.next()){
			bItemExist = true;
			for(int y=0;	y<4;	++y){
				strData	=	query.value(y).toString();
				ROPLOW::patchconfigstring(strData, strname, strvalue);
				for(int x=0;	x<strname.size();	++x){
					if(strname.at(x) == "defectpixelalg"){
						if(strvalue.at(x) == "a")	itemshareData.wpDefectPixelParameter->defectpixelAlg	=	_HisAlg_SWITCH_A;
						else if(strvalue.at(x) == "b")	itemshareData.wpDefectPixelParameter->defectpixelAlg	=	_HisAlg_SWITCH_B;
					}
				}
			}
		}

		query.prepare("SELECT itemsuffix2,key,value,reserve FROM " % itemshareData.currentTableName % \
			" WHERE classfy='algorithm' AND item='whitepanel' AND itemsuffix1='defectpixel' ORDER BY id ASC" );
		query.exec();

		//(defectratio:0.1)(woundratio:0.2)(defectscore:1)(woundscore:2)(deadscore:3)
		//(clusterscore:50)(widthblocks:180)(deadratio:0.3)
		//(defectspec:20)(woundspec:20)(deadspec:20)
		//(totalscorespec:1000)(clusterspec:0)(clustermaxscore:20)
		while (query.next()){
			bItemExist = true;
			for(int y=0;	y<4;	++y){
				strData	=	query.value(y).toString();
				ROPLOW::patchconfigstring(strData, strname, strvalue);
				for(int x=0;	x<strname.size();	++x){
					if(strname.at(x) == "defectratio")
						itemshareData.wpDefectPixelParameter->stAlgHA.defectpixel_fldefect	=	strvalue.at(x).toFloat(&bok);
					else if(strname.at(x) == "woundratio")
						itemshareData.wpDefectPixelParameter->stAlgHA.defectpixel_flwound	=	strvalue.at(x).toFloat(&bok);
					else if(strname.at(x) == "deadratio")
						itemshareData.wpDefectPixelParameter->stAlgHA.defectpixel_fldead	=	strvalue.at(x).toFloat(&bok);
					else if(strname.at(x) == "defectscore")
						itemshareData.wpDefectPixelParameter->stAlgHA.defectpixel_ucdefectscore	=	strvalue.at(x).toInt(&bok, 10);
					else if(strname.at(x) == "woundscore")
						itemshareData.wpDefectPixelParameter->stAlgHA.defectpixel_ucwoundscore	=	strvalue.at(x).toInt(&bok, 10);
					else if(strname.at(x) == "deadscore")
						itemshareData.wpDefectPixelParameter->stAlgHA.defectpixel_ucdeadscore	=	strvalue.at(x).toInt(&bok, 10);
					else if(strname.at(x) == "clusterscore")
						itemshareData.wpDefectPixelParameter->stAlgHA.defectpixel_iclusterscore	=	strvalue.at(x).toInt(&bok, 10);
					else if(strname.at(x) == "widthblocks")
						itemshareData.wpDefectPixelParameter->stAlgHA.defectpixel_iwidthblocks	=	strvalue.at(x).toInt(&bok, 10);
					else if(strname.at(x) == "defectspec")
						itemshareData.wpDefectPixelParameter->stAlgHA.defectpixel_ispecdefect	=	strvalue.at(x).toInt(&bok, 10);
					else if(strname.at(x) == "woundspec")
						itemshareData.wpDefectPixelParameter->stAlgHA.defectpixel_ispecwound	=	strvalue.at(x).toInt(&bok, 10);
					else if(strname.at(x) == "deadspec")
						itemshareData.wpDefectPixelParameter->stAlgHA.defectpixel_ispecdead	=	strvalue.at(x).toInt(&bok, 10);
					else if(strname.at(x) == "totalscorespec")
						itemshareData.wpDefectPixelParameter->stAlgHA.defectpixel_itotalscore	=	strvalue.at(x).toInt(&bok, 10);
					else if(strname.at(x) == "clusterspec")
						itemshareData.wpDefectPixelParameter->stAlgHA.defectpixel_ispeccluster	=	strvalue.at(x).toInt(&bok, 10);
					else if(strname.at(x) == "clustermaxscore")
						itemshareData.wpDefectPixelParameter->stAlgHA.defectpixel_iclustermaxscore	=	strvalue.at(x).toInt(&bok, 10);
				}
			}
		}

		query.prepare("SELECT itemsuffix2,key,value,reserve FROM " % itemshareData.currentTableName % \
			" WHERE classfy='algorithm' AND item='whitepanel' AND itemsuffix1='defectpixelhb' ORDER BY id ASC" );
		query.exec();

		//(defectmin:-0.3)(defectmax:0.3)(woundmin:-0.3)(woundmax:0.3)(deadmin:-0.3)(deadmax:0.3)(centerrange:0.7)(blocksize:11)(perchannel:true)
		//(centerdefectsingle:1000)(centerwoundsingle:100)(centerdeadsingle:100)(centerdefectclustersize:4)(centerwoundclustersize:3)(centerdeadclustersize:2)
		//(edgedefectsingle:1000)(edgewoundsingle:100)(edgedeadsingle:100)(edgedefectclustersize:4)(edgewoundclustersize:3)(edgedeadclustersize:2)
		while (query.next())
		{
			bItemExist = true;
			for(int y=0;	y<4;	++y){
				strData	=	query.value(y).toString();
				ROPLOW::patchconfigstring(strData, strname, strvalue);
				for(int x=0;	x<strname.size();	++x){
					if(strname.at(x) == "defectmin")				itemshareData.wpDefectPixelParameter->stAlgHB.flDefectMin	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "defectmax")		itemshareData.wpDefectPixelParameter->stAlgHB.flDefectMax	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "woundmin")		itemshareData.wpDefectPixelParameter->stAlgHB.flWoundMin	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "woundmax")	itemshareData.wpDefectPixelParameter->stAlgHB.flWoundMax	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "deadmin")		itemshareData.wpDefectPixelParameter->stAlgHB.flDeadMin		=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "deadmax")		itemshareData.wpDefectPixelParameter->stAlgHB.flDeadMax	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "centerrange")
						itemshareData.wpDefectPixelParameter->stAlgHB.defectpixelhb_flCenterRange	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "blocksize")
						itemshareData.wpDefectPixelParameter->stAlgHB.defectpixelhb_uiBlockSize	=	strvalue.at(x).toUInt();
					else if(strname.at(x) == "perchannel")
						itemshareData.wpDefectPixelParameter->stAlgHB.defectpixelhb_bPerChannel	=	(strvalue.at(x) == "true")?(true):(false);
					else if(strname.at(x) == "centerdefectsingle")
						itemshareData.wpDefectPixelParameter->stAlgHB.defectpixelhb_uiCenterDefectSingle	=	strvalue.at(x).toUInt();
					else if(strname.at(x) == "centerwoundsingle")
						itemshareData.wpDefectPixelParameter->stAlgHB.defectpixelhb_uiCenterWoundSingle	=	strvalue.at(x).toUInt();
					else if(strname.at(x) == "centerdeadsingle")
						itemshareData.wpDefectPixelParameter->stAlgHB.defectpixelhb_uiCenterDeadSingle	=	strvalue.at(x).toUInt();
					else if(strname.at(x) == "centerdefectclustersize")
						itemshareData.wpDefectPixelParameter->stAlgHB.defectpixelhb_uiCenterDefectClusterMax	=	strvalue.at(x).toUInt();
					else if(strname.at(x) == "centerwoundclustersize")
						itemshareData.wpDefectPixelParameter->stAlgHB.defectpixelhb_uiCenterWoundClusterMax	=	strvalue.at(x).toUInt();
					else if(strname.at(x) == "centerdeadclustersize")
						itemshareData.wpDefectPixelParameter->stAlgHB.defectpixelhb_uiCenterDeadClusterMax	=	strvalue.at(x).toUInt();
					else if(strname.at(x) == "edgedefectsingle")
						itemshareData.wpDefectPixelParameter->stAlgHB.defectpixelhb_uiEdgeDefectSingle	=	strvalue.at(x).toUInt();
					else if(strname.at(x) == "edgewoundsingle")
						itemshareData.wpDefectPixelParameter->stAlgHB.defectpixelhb_uiEdgeWoundSingle	=	strvalue.at(x).toUInt();
					else if(strname.at(x) == "edgedeadsingle")
						itemshareData.wpDefectPixelParameter->stAlgHB.defectpixelhb_uiEdgeDeadSingle	=	strvalue.at(x).toUInt();
					else if(strname.at(x) == "edgedefectclustersize")
						itemshareData.wpDefectPixelParameter->stAlgHB.defectpixelhb_uiEdgeDefectClusterMax	=	strvalue.at(x).toUInt();
					else if(strname.at(x) == "edgewoundclustersize")
						itemshareData.wpDefectPixelParameter->stAlgHB.defectpixelhb_uiEdgeWoundClusterMax	=	strvalue.at(x).toUInt();
					else if(strname.at(x) == "edgedeadclustersize")
						itemshareData.wpDefectPixelParameter->stAlgHB.defectpixelhb_uiEdgeDeadClusterMax	=	strvalue.at(x).toUInt();
					else if(strname.at(x) == "savedefectcalimage")
						itemshareData.wpDefectPixelParameter->bSaveDefectPixelCalImage=(strvalue.at(x) == "true")?(true):(false);
				}
			}
		}

		customdb.close();
	}

	QSqlDatabase::removeDatabase("querycustom");

	if(!bItemExist)
	{
		HisReleaseNewO(itemshareData.wpDefectPixelParameter);
		itemshareData.itemparameterLock.unlock();
		return HisFX3Error_Parameter;
	}

	if(!bcheck) {itemshareData.itemparameterLock.unlock(); return 0; }

	itemshareData.itemparameterLock.unlock();
	return 0;
}

int itemprocess::whitePanelDefectPixel()
{
	std::vector<_itemDraw>::iterator theIterator;
	itemshareData.clearDrawList();
	QColor stdefectcluster		=	QColor::fromRgb(0, 255, 255);

	//判断图像是否点亮中
	if(!threadshareData.GetHisPreviewflag())	return HisCCMError_NotPreivew;

	//取得配置参数和规格
	int iresult	=	getwhitePanelDefectPixelParameter(false);
	if(iresult)	return iresult;

	QHReadWriteLockManage classitemparameterLock(&(itemshareData.itemparameterLock));
	stLogItem.itemtype		=	classLog->getmaxtypeindex(_HISLOG_CLASSIFY_DEFECTPIXEL);
	stLogItem.itemkey		=	"Defect_Pixel Result";
	stLogItem.itemvalue	=	"OK";
	QHDefaultLogManage classstLogItem(classLog, &stLogItem, "NG");

	_HisFX3_BaylorMode ucDataFormat;
	ROPLOW::BaylorXForamt2Baloy8(itemshareData.previewParameter->ucDataFormat, ucDataFormat);

	if(itemshareData.wpDefectPixelParameter->defectpixelAlg == _HisAlg_SWITCH_A)
	{
		int idefectpixel=0, iwoundpixel=0, ideadpixel=0, itotalscore=0, iclustercount=0;
		std::vector<_HisAlg_Cluster> stCluster;
		unsigned char* pucBaylorR = 0, *pucBaylorB = 0, *pucBaylorGr = 0, *pucBaylorGb = 0;
		int iWidthT = (itemshareData.previewParameter->iWidth >>1), iHeightT = (itemshareData.previewParameter->iHeight >>1);
		if(ucDataFormat >= HisYUV8_422_YUYV && ucDataFormat <= HisYUV8_420P)
		{
			unsigned char* pucYUV	=	(unsigned char*)HisAlignedMalloc(itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight *2);
			if(!pucYUV) return HisFX3Error_MallocBuffer;

			//取得raw图像数据
			if(iresult	=	GetFreshframe(pucYUV, itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight*2, _FrameType_Raw, true)){
				HisReleaseMalloc(pucYUV);
				return iresult;
			}

			classAlgorithm.extactYfromYUV422U8(pucYUV, pucYUV, itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight, itemshareData.previewParameter->ucDataFormat);

			pucBaylorR	=	pucYUV;
			iWidthT		=	itemshareData.previewParameter->iWidth;
			iHeightT		=	itemshareData.previewParameter->iHeight;
		}
		else if(ucDataFormat == HisRGB_RGB24)
		{
			unsigned char* pucRGB24	=	(unsigned char*)HisAlignedMalloc(itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight *3);
			QHisFX3MallocAlignedManage classpucRGB24(pucRGB24);
			if(!pucRGB24) return HisFX3Error_MallocBuffer;

			if(iresult	=	GetFreshframe(pucRGB24, itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight *3, _FrameType_RGB24, true))
				return iresult;

			pucBaylorR		=	(unsigned char*)HisAlignedMalloc(itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight);
			pucBaylorB		=	(unsigned char*)HisAlignedMalloc(itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight);
			pucBaylorGr	=	(unsigned char*)HisAlignedMalloc(itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight);
			if(!pucBaylorR || !pucBaylorB || !pucBaylorGr) {
				HisReleaseMalloc(pucBaylorR);
				HisReleaseMalloc(pucBaylorB);
				HisReleaseMalloc(pucBaylorGr);
				return HisFX3Error_MallocBuffer;
			}

			ROPLOW::extractrgb24(pucRGB24, pucBaylorR, pucBaylorGr, pucBaylorB, itemshareData.previewParameter->iWidth, itemshareData.previewParameter->iHeight);
			iWidthT		=	itemshareData.previewParameter->iWidth;
			iHeightT		=	itemshareData.previewParameter->iHeight;
		}
		else
		{
			unsigned char* pucBaylor	=	(unsigned char*)HisAlignedMalloc(itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight);
			if(!pucBaylor) return HisFX3Error_MallocBuffer;
			QHisFX3MallocAlignedManage classpucBaylor(pucBaylor);

			//取得raw图像数据
			if(iresult	=	GetFreshframe(pucBaylor, itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight, _FrameType_Raw, true))
				return iresult;

			pucBaylorR		=	(unsigned char*)HisAlignedMalloc(itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight /4);
			pucBaylorB		=	(unsigned char*)HisAlignedMalloc(itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight /4);
			pucBaylorGr	=	(unsigned char*)HisAlignedMalloc(itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight /4);
			pucBaylorGb	=	(unsigned char*)HisAlignedMalloc(itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight /4);
			if(!pucBaylorR || !pucBaylorB || !pucBaylorGr || !pucBaylorGb) {
				HisReleaseMalloc(pucBaylorR);
				HisReleaseMalloc(pucBaylorB);
				HisReleaseMalloc(pucBaylorGr);
				HisReleaseMalloc(pucBaylorGb);
				return HisFX3Error_MallocBuffer;
			}

			classAlgorithm.patchbaylor(pucBaylor, itemshareData.previewParameter->iWidth, itemshareData.previewParameter->iHeight, pucBaylorB, pucBaylorR, pucBaylorGr, pucBaylorGb, ucDataFormat);

			if( itemshareData.wpDefectPixelParameter->bSaveDefectPixelCalImage)
			{	
				QString strSerialNumber;
				QDir classDir;
				classLog->getserialnumber(strSerialNumber);
				QString strIniPath	=	QDir::currentPath() % "/WhitePanel_DefectPixelImage";
				classDir.mkpath(strIniPath);
				ROPLOW::saveRaw10(strIniPath, strSerialNumber % "_DefectPixel"%(QDateTime::currentDateTime()).toString("yyyyMMdd_hhmmss"), itemshareData.previewParameter->ucDataFormat, \
					itemshareData.previewParameter->iWidth, itemshareData.previewParameter->iHeight, (void*)(pucBaylor));
			}
		}

		QHisFX3MallocAlignedManage classpucBaylorR(pucBaylorR);
		QHisFX3MallocAlignedManage classpucBaylorB(pucBaylorB);
		QHisFX3MallocAlignedManage classpucBaylorGr(pucBaylorGr);
		QHisFX3MallocAlignedManage classpucBaylorGb(pucBaylorGb);

		iresult	=	classAlgorithm.HisCCMWhitePanel_PartIIIHA(pucBaylorR, pucBaylorB, pucBaylorGr, pucBaylorGb, \
			iWidthT, iHeightT, idefectpixel, iwoundpixel, ideadpixel, \
			itotalscore, stCluster, iclustercount, itemshareData.wpDefectPixelParameter->stAlgHA.defectpixel_fldefect, itemshareData.wpDefectPixelParameter->stAlgHA.defectpixel_flwound, \
			itemshareData.wpDefectPixelParameter->stAlgHA.defectpixel_fldead, \
			itemshareData.wpDefectPixelParameter->stAlgHA.defectpixel_iclusterscore, itemshareData.wpDefectPixelParameter->stAlgHA.defectpixel_iwidthblocks, \
			itemshareData.wpDefectPixelParameter->stAlgHA.defectpixel_ucdefectscore, itemshareData.wpDefectPixelParameter->stAlgHA.defectpixel_ucwoundscore, \
			itemshareData.wpDefectPixelParameter->stAlgHA.defectpixel_ucdeadscore);
		if(iresult)	return iresult;

		emit information(QTextCodec::codecForName( "GBK")->toUnicode("坏点/伤点/死点测试数据："));
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("         坏点总个数：") % QString::number(idefectpixel, 10));
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("         伤点总个数：") % QString::number(iwoundpixel, 10));
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("         死点总个数：") % QString::number(ideadpixel, 10));
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("         权重叠加总分数：") % QString::number(itotalscore, 10));
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("         聚簇个数：") % QString::number(iclustercount, 10));

		int iClusterMaxScore	=	0;

		if(idefectpixel > itemshareData.wpDefectPixelParameter->stAlgHA.defectpixel_ispecdefect || \
			iwoundpixel > itemshareData.wpDefectPixelParameter->stAlgHA.defectpixel_ispecwound || \
			ideadpixel > itemshareData.wpDefectPixelParameter->stAlgHA.defectpixel_ispecdead || \
			itotalscore > itemshareData.wpDefectPixelParameter->stAlgHA.defectpixel_itotalscore || \
			iclustercount > itemshareData.wpDefectPixelParameter->stAlgHA.defectpixel_ispeccluster)
		{
			iresult					=	HisCCMError_Result;
			stLogItem.itemvalue	=	"NG";

			if(iclustercount > itemshareData.wpDefectPixelParameter->stAlgHA.defectpixel_ispeccluster){
				std::vector<_HisAlg_Cluster>::iterator clusterIndex;
				int idefectscore	=	0;
				for(std::vector<_HisAlg_Cluster>::iterator clusterIterator	=	stCluster.begin();	clusterIterator != stCluster.end();	clusterIterator++){
					if(clusterIterator->iscore > idefectscore){
						idefectscore	=	clusterIterator->iscore;
						clusterIndex	=	clusterIterator;
					}
				}

				itemshareData.drawLock.lockForWrite();
				int ilastcount	=	itemshareData.itemdrawList.size();
				itemshareData.itemdrawList.resize(ilastcount + 1);
				theIterator	=	itemshareData.itemdrawList.begin() +ilastcount;
				theIterator->usitem							=	whitepanelitem_pixel;
				theIterator->uctype							=	HisDrawType_Block;
				theIterator->stcolor							=	stdefectcluster;
				theIterator->strinfo.stblock				=	clusterIndex->stRange;
				if(ucDataFormat < HisYUV8_422_YUYV){
					theIterator->strinfo.stblock.left			=	(theIterator->strinfo.stblock.left <<1);
					theIterator->strinfo.stblock.top			=	(theIterator->strinfo.stblock.top <<1);
					theIterator->strinfo.stblock.right			=	(theIterator->strinfo.stblock.right <<1);
					theIterator->strinfo.stblock.bottom		=	(theIterator->strinfo.stblock.bottom <<1);
				}
				itemshareData.drawLock.unlock();
			}
		}
		else if(stCluster.size() > 0)
		{
			std::vector<_HisAlg_Cluster>::iterator clusterIndex;
			for(std::vector<_HisAlg_Cluster>::iterator clusterIterator	=	stCluster.begin();	clusterIterator != stCluster.end();	clusterIterator++){
				if(clusterIterator->iscore > iClusterMaxScore){
					iClusterMaxScore	=	clusterIterator->iscore;
					clusterIndex				=	clusterIterator;
				}
			}

			if(clusterIndex->iscore > itemshareData.wpDefectPixelParameter->stAlgHA.defectpixel_iclustermaxscore){
				iresult					=	HisCCMError_Result;
				stLogItem.itemvalue	=	"NG";

				itemshareData.drawLock.lockForWrite();
				int ilastcount	=	itemshareData.itemdrawList.size();
				itemshareData.itemdrawList.resize(ilastcount + 1);
				theIterator	=	itemshareData.itemdrawList.begin() +ilastcount;
				theIterator->usitem							=	whitepanelitem_pixel;
				theIterator->uctype							=	HisDrawType_Block;
				theIterator->stcolor							=	stdefectcluster;
				theIterator->strinfo.stblock				=	clusterIndex->stRange;
				if(ucDataFormat < HisYUV8_422_YUYV){
					theIterator->strinfo.stblock.left			=	(theIterator->strinfo.stblock.left <<1);
					theIterator->strinfo.stblock.top			=	(theIterator->strinfo.stblock.top <<1);
					theIterator->strinfo.stblock.right			=	(theIterator->strinfo.stblock.right <<1);
					theIterator->strinfo.stblock.bottom		=	(theIterator->strinfo.stblock.bottom <<1);
				}
				itemshareData.drawLock.unlock();
			}
		}

		classstLogItem.SubRef();
		classLog->push_back(stLogItem);
		++(stLogItem.itemtype);
		stLogItem.itemkey		=	"Defect_Pixel Number";
		stLogItem.itemvalue	=	idefectpixel;
		classLog->push_back(stLogItem);
		++(stLogItem.itemtype);
		stLogItem.itemkey		=	"Wound_Pixel Number";
		stLogItem.itemvalue	=	iwoundpixel;
		classLog->push_back(stLogItem);
		++(stLogItem.itemtype);
		stLogItem.itemkey		=	"Dead_Pixel Number";
		stLogItem.itemvalue	=	ideadpixel;
		classLog->push_back(stLogItem);
		++(stLogItem.itemtype);
		stLogItem.itemkey		=	"Defect_Cluster Number";
		stLogItem.itemvalue	=	iclustercount;
		classLog->push_back(stLogItem);
		++(stLogItem.itemtype);
		stLogItem.itemkey		=	"Defect_Score Sum";
		stLogItem.itemvalue	=	itotalscore;
		classLog->push_back(stLogItem);
		++(stLogItem.itemtype);
		stLogItem.itemkey		=	"Defect_Cluster_Max_Score";
		stLogItem.itemvalue	=	iClusterMaxScore;
		classLog->push_back(stLogItem);
	}
	else if(itemshareData.wpDefectPixelParameter->defectpixelAlg == _HisAlg_SWITCH_B)
	{
		int iCenterDefectTotal, iCenterWoundTotal, iCenterDeadTotal, iEdgeDefectTotal, iEdgeWoundTotal, iEdgeDeadTotal;
		int iCenterDefectClusterMax=0, iCenterWoundClusterMax=0,iCenterDeadClusterMax=0;
		int iEdgeDefectClusterMax=0, iEdgeWoundClusterMax=0,iEdgeDeadClusterMax=0;
		RECT stMaxCluster;
		std::vector<_HisAlg_DefectPixelHB_Cluster> vectorClsuter;
		unsigned char* pucBaylorR = 0, *pucBaylorB = 0, *pucBaylorGr = 0, *pucBaylorGb = 0;
		int iWidthT = (itemshareData.previewParameter->iWidth >>1), iHeightT = (itemshareData.previewParameter->iHeight >>1);
		bool bPerChannel = itemshareData.wpDefectPixelParameter->stAlgHB.defectpixelhb_bPerChannel;
		if(ucDataFormat >= HisYUV8_422_YUYV && ucDataFormat <= HisYUV8_420P)
		{
			unsigned char* pucYUV	=	(unsigned char*)HisAlignedMalloc(itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight *2);
			if(!pucYUV) return HisFX3Error_MallocBuffer;

			//取得raw图像数据
			if(iresult	=	GetFreshframe(pucYUV, itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight*2, _FrameType_Raw, true)){
				HisReleaseMalloc(pucYUV);
				return iresult;
			}

			classAlgorithm.extactYfromYUV422U8(pucYUV, pucYUV, itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight, itemshareData.previewParameter->ucDataFormat);

			pucBaylorR	=	pucYUV;
			iWidthT		=	itemshareData.previewParameter->iWidth;
			iHeightT		=	itemshareData.previewParameter->iHeight;
			bPerChannel	=	true;
		}
		else if(ucDataFormat == HisRGB_RGB24)
		{
			unsigned char* pucRGB24	=	(unsigned char*)HisAlignedMalloc(itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight *3);
			QHisFX3MallocAlignedManage classpucRGB24(pucRGB24);
			if(!pucRGB24) return HisFX3Error_MallocBuffer;

			if(iresult	=	GetFreshframe(pucRGB24, itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight *3, _FrameType_RGB24, true))
				return iresult;

			pucBaylorR		=	(unsigned char*)HisAlignedMalloc(itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight);
			pucBaylorB		=	(unsigned char*)HisAlignedMalloc(itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight);
			pucBaylorGr	=	(unsigned char*)HisAlignedMalloc(itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight);
			if(!pucBaylorR || !pucBaylorB || !pucBaylorGr) {
				HisReleaseMalloc(pucBaylorR);
				HisReleaseMalloc(pucBaylorB);
				HisReleaseMalloc(pucBaylorGr);
				return HisFX3Error_MallocBuffer;
			}

			ROPLOW::extractrgb24(pucRGB24, pucBaylorR, pucBaylorGr, pucBaylorB, itemshareData.previewParameter->iWidth, itemshareData.previewParameter->iHeight);

			iWidthT			=	itemshareData.previewParameter->iWidth;
			iHeightT			=	itemshareData.previewParameter->iHeight;
			bPerChannel	=	true;
		}
		else
		{
			unsigned char* pucBaylor	=	(unsigned char*)HisAlignedMalloc(itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight);
			if(!pucBaylor) return HisFX3Error_MallocBuffer;
			QHisFX3MallocAlignedManage classpucBaylor(pucBaylor);

			//取得raw图像数据
			if(iresult	=	GetFreshframe(pucBaylor, itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight, _FrameType_Raw, true))
				return iresult;

			pucBaylorR		=	(unsigned char*)HisAlignedMalloc(itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight /4);
			pucBaylorB		=	(unsigned char*)HisAlignedMalloc(itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight /4);
			pucBaylorGr	=	(unsigned char*)HisAlignedMalloc(itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight /4);
			pucBaylorGb	=	(unsigned char*)HisAlignedMalloc(itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight /4);
			if(!pucBaylorR || !pucBaylorB || !pucBaylorGr || !pucBaylorGb) {
				HisReleaseMalloc(pucBaylorR);
				HisReleaseMalloc(pucBaylorB);
				HisReleaseMalloc(pucBaylorGr);
				HisReleaseMalloc(pucBaylorGb);
				return HisFX3Error_MallocBuffer;
			}

			if( itemshareData.wpDefectPixelParameter->bSaveDefectPixelCalImage)
			{	
				QString strSerialNumber;
				QDir classDir;
				classLog->getserialnumber(strSerialNumber);
				QString strIniPath	=	QDir::currentPath() % "/WhitePanel_DefectPixelImage";
				classDir.mkpath(strIniPath);
				ROPLOW::saveRaw10(strIniPath, strSerialNumber % "_DefectPixel"%(QDateTime::currentDateTime()).toString("yyyyMMdd_hhmmss"), itemshareData.previewParameter->ucDataFormat, \
					itemshareData.previewParameter->iWidth, itemshareData.previewParameter->iHeight, (void*)(pucBaylor));
			}

			classAlgorithm.patchbaylor(pucBaylor, itemshareData.previewParameter->iWidth, itemshareData.previewParameter->iHeight, pucBaylorB, pucBaylorR, pucBaylorGr, pucBaylorGb, ucDataFormat);

			if(hisglobalparameter.bDebugMode)
			{
				unsigned char* pucSaveImage	=	(unsigned char*)HisAlignedMalloc(itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight*3);
				QHisFX3MallocAlignedManage classpucSaveImage(pucSaveImage);

				if(pucSaveImage && ucDataFormat < HisYUV8_422_YUYV)
				{
					for(unsigned int ty=0;	ty<5;	++ty){
						QString strSaveFileName, strSaveInfo;
						unsigned int uiSaveWidth, uiSaveHeight;
						unsigned char *pucSaveSrc, *pucSaveDes	=	pucSaveImage;
						switch (ty){
						case 0:
							uiSaveWidth		=	itemshareData.previewParameter->iWidth;
							uiSaveHeight		=	itemshareData.previewParameter->iHeight;
							pucSaveSrc		=	pucBaylor;
							strSaveFileName=	".\\DefectPixelDebug_Baylor.bmp";
							strSaveInfo			=	QTextCodec::codecForName( "GBK")->toUnicode("坏点测试原始RAW图保存在DefectPixelDebug_Baylor.bmp");
							break;
						case 1:
							uiSaveWidth		=	(itemshareData.previewParameter->iWidth >>1);
							uiSaveHeight		=	(itemshareData.previewParameter->iHeight >>1);
							pucSaveSrc		=	pucBaylorR;
							strSaveFileName=	".\\DefectPixelDebug_R.bmp";
							strSaveInfo			=	QTextCodec::codecForName( "GBK")->toUnicode("坏点测试原始RAW_R图保存在DefectPixelDebug_R.bmp");
							break;
						case 2:
							uiSaveWidth		=	(itemshareData.previewParameter->iWidth >>1);
							uiSaveHeight		=	(itemshareData.previewParameter->iHeight >>1);
							pucSaveSrc		=	pucBaylorGr;
							strSaveFileName=	".\\DefectPixelDebug_Gr.bmp";
							strSaveInfo			=	QTextCodec::codecForName( "GBK")->toUnicode("坏点测试原始RAW_Gr图保存在DefectPixelDebug_Gr.bmp");
							break;
						case 3:
							uiSaveWidth		=	(itemshareData.previewParameter->iWidth >>1);
							uiSaveHeight		=	(itemshareData.previewParameter->iHeight >>1);
							pucSaveSrc		=	pucBaylorGb;
							strSaveFileName=	".\\DefectPixelDebug_Gb.bmp";
							strSaveInfo			=	QTextCodec::codecForName( "GBK")->toUnicode("坏点测试原始RAW_Gb图保存在DefectPixelDebug_Gb.bmp");
							break;
						default:
							uiSaveWidth		=	(itemshareData.previewParameter->iWidth >>1);
							uiSaveHeight		=	(itemshareData.previewParameter->iHeight >>1);
							pucSaveSrc		=	pucBaylorB;
							strSaveFileName=	".\\DefectPixelDebug_B.bmp";
							strSaveInfo			=	QTextCodec::codecForName( "GBK")->toUnicode("坏点测试原始RAW_B图保存在DefectPixelDebug_B.bmp");
							break;
						}

						unsigned int uiSaveSize			=	uiSaveWidth *uiSaveHeight;
						for(unsigned int tx=0;	tx<uiSaveSize;	++tx){
							*pucSaveDes = *(pucSaveDes+1) = *(pucSaveDes+2)	=	*pucSaveSrc;
							++pucSaveSrc;
							pucSaveDes	+=	3;
						}
						QImage image2(pucSaveImage, uiSaveWidth, uiSaveHeight, uiSaveWidth *3, QImage::Format_RGB888);
						image2.save(strSaveFileName, 0, 100);
						emit information(strSaveInfo);
					}
				}
			}
		}

		QHisFX3MallocAlignedManage classpucBaylorR(pucBaylorR);
		QHisFX3MallocAlignedManage classpucBaylorB(pucBaylorB);
		QHisFX3MallocAlignedManage classpucBaylorGr(pucBaylorGr);
		QHisFX3MallocAlignedManage classpucBaylorGb(pucBaylorGb);

		iresult	=	classAlgorithm.HisCCMWhitePanel_DefectPixelHB(pucBaylorR, pucBaylorB, pucBaylorGr,pucBaylorGb,iWidthT, \
			iHeightT, itemshareData.wpDefectPixelParameter->stAlgHB.flDefectMin,  itemshareData.wpDefectPixelParameter->stAlgHB.flDefectMax, \
			itemshareData.wpDefectPixelParameter->stAlgHB.flWoundMin,  itemshareData.wpDefectPixelParameter->stAlgHB.flWoundMax, \
			itemshareData.wpDefectPixelParameter->stAlgHB.flDeadMin,  itemshareData.wpDefectPixelParameter->stAlgHB.flDeadMax, \
			itemshareData.wpDefectPixelParameter->stAlgHB.defectpixelhb_flCenterRange, itemshareData.wpDefectPixelParameter->stAlgHB.defectpixelhb_uiBlockSize, \
			ucDataFormat, bPerChannel, iCenterDefectTotal, iCenterWoundTotal, iCenterDeadTotal, iEdgeDefectTotal, iEdgeWoundTotal, iEdgeDeadTotal, \
			stMaxCluster,vectorClsuter,hisglobalparameter.bDebugMode);
		if(iresult)	return iresult;


		emit information(QTextCodec::codecForName( "GBK")->toUnicode("中心总坏点个数：") % QString::number(iCenterDefectTotal));
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("中心总伤点个数：") % QString::number(iCenterWoundTotal));
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("中心总死点个数：") % QString::number(iCenterDeadTotal));
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("周边总坏点个数：") % QString::number(iEdgeDefectTotal));
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("周边总伤点个数：") % QString::number(iEdgeWoundTotal));
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("周边总死点个数：") % QString::number(iEdgeDeadTotal));

		for(int x=0;	x<vectorClsuter.size();	++x)
		{
			if(vectorClsuter.at(x).bCenter){
				switch (vectorClsuter.at(x).ucType){
				case 3:	iCenterDeadClusterMax	=	max(iCenterDeadClusterMax, vectorClsuter.at(x).uiPixelCount);break;
				case 2: iCenterWoundClusterMax	=	max(iCenterWoundClusterMax, vectorClsuter.at(x).uiPixelCount);break;
				default: iCenterDefectClusterMax	=	max(iCenterDefectClusterMax, vectorClsuter.at(x).uiPixelCount);break;
				}
			}
			else{
				switch (vectorClsuter.at(x).ucType){
				case 3: iEdgeDeadClusterMax	=	max(iEdgeDeadClusterMax, vectorClsuter.at(x).uiPixelCount);break;
				case 2: iEdgeWoundClusterMax	=	max(iEdgeWoundClusterMax, vectorClsuter.at(x).uiPixelCount);break;
				default: iEdgeDefectClusterMax	=	max(iEdgeDefectClusterMax, vectorClsuter.at(x).uiPixelCount);break;
				}
			}
		}

		if(iCenterDefectTotal>itemshareData.wpDefectPixelParameter->stAlgHB.defectpixelhb_uiCenterDefectSingle || \
			iCenterWoundTotal>itemshareData.wpDefectPixelParameter->stAlgHB.defectpixelhb_uiCenterWoundSingle || \
			iCenterDeadTotal>itemshareData.wpDefectPixelParameter->stAlgHB.defectpixelhb_uiCenterDeadSingle || \
			iEdgeDefectTotal>itemshareData.wpDefectPixelParameter->stAlgHB.defectpixelhb_uiEdgeDefectSingle || \
			iEdgeWoundTotal>itemshareData.wpDefectPixelParameter->stAlgHB.defectpixelhb_uiEdgeWoundSingle || \
			iEdgeDeadTotal>itemshareData.wpDefectPixelParameter->stAlgHB.defectpixelhb_uiEdgeDeadSingle)
		{
			iresult					=	HisCCMError_Result;
			stLogItem.itemvalue	=	"NG";

			if(vectorClsuter.size() > 0){
				itemshareData.drawLock.lockForWrite();
				int ilastcount	=	itemshareData.itemdrawList.size();
				itemshareData.itemdrawList.resize(ilastcount + 1);
				theIterator	=	itemshareData.itemdrawList.begin() +ilastcount;
				theIterator->usitem							=	whitepanelitem_pixel;
				theIterator->uctype							=	HisDrawType_Block;
				theIterator->stcolor							=	stdefectcluster;
				theIterator->strinfo.stblock				=	stMaxCluster;
				ROPLOW::expand2minrect(theIterator->strinfo.stblock, itemshareData.previewParameter->iWidth, itemshareData.previewParameter->iHeight, \
					itemshareData.previewParameter->iWidth *0.1f, itemshareData.previewParameter->iHeight *0.1f);
				itemshareData.drawLock.unlock();
			}
		}
		else if(vectorClsuter.size() > 0)
		{
			if(iCenterDefectClusterMax > itemshareData.wpDefectPixelParameter->stAlgHB.defectpixelhb_uiCenterDefectClusterMax || \
				iCenterWoundClusterMax > itemshareData.wpDefectPixelParameter->stAlgHB.defectpixelhb_uiCenterWoundClusterMax || \
				iCenterDeadClusterMax > itemshareData.wpDefectPixelParameter->stAlgHB.defectpixelhb_uiCenterDeadClusterMax || \
				iEdgeDefectClusterMax > itemshareData.wpDefectPixelParameter->stAlgHB.defectpixelhb_uiEdgeDefectClusterMax || \
				iEdgeWoundClusterMax > itemshareData.wpDefectPixelParameter->stAlgHB.defectpixelhb_uiEdgeWoundClusterMax || \
				iEdgeDeadClusterMax > itemshareData.wpDefectPixelParameter->stAlgHB.defectpixelhb_uiEdgeDeadClusterMax){
					iresult					=	HisCCMError_Result;
					stLogItem.itemvalue	=	"NG";

					itemshareData.drawLock.lockForWrite();
					int ilastcount	=	itemshareData.itemdrawList.size();
					itemshareData.itemdrawList.resize(ilastcount + 1);
					theIterator	=	itemshareData.itemdrawList.begin() +ilastcount;
					theIterator->usitem							=	whitepanelitem_pixel;
					theIterator->uctype							=	HisDrawType_Block;
					theIterator->stcolor							=	stdefectcluster;
					theIterator->strinfo.stblock				=	stMaxCluster;
					ROPLOW::expand2minrect(theIterator->strinfo.stblock, itemshareData.previewParameter->iWidth, itemshareData.previewParameter->iHeight, \
						itemshareData.previewParameter->iWidth *0.1f, itemshareData.previewParameter->iHeight *0.1f);
					itemshareData.drawLock.unlock();
			}
		}

		emit information(QTextCodec::codecForName( "GBK")->toUnicode("中心最大坏点簇像素个数：") % QString::number(iCenterDefectClusterMax));
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("中心最大伤点簇像素个数：") % QString::number(iCenterWoundClusterMax));
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("中心最大死点簇像素个数：") % QString::number(iCenterDeadClusterMax));
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("周边最大坏点簇像素个数：") % QString::number(iEdgeDefectClusterMax));
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("周边最大伤点簇像素个数：") % QString::number(iEdgeWoundClusterMax));
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("周边最大死点簇像素个数：") % QString::number(iEdgeDeadClusterMax));

		classstLogItem.SubRef();
		classLog->push_back(stLogItem);
		++(stLogItem.itemtype);
		stLogItem.itemkey		=	"Center_Defect_Pixel_Number";
		stLogItem.itemvalue	=	iCenterDefectTotal;
		classLog->push_back(stLogItem);
		++(stLogItem.itemtype);
		stLogItem.itemkey		=	"Center_Wound_Pixel_Number";
		stLogItem.itemvalue	=	iCenterWoundTotal;
		classLog->push_back(stLogItem);
		++(stLogItem.itemtype);
		stLogItem.itemkey		=	"Center_Dead_Pixel_Number";
		stLogItem.itemvalue	=	iCenterDeadTotal;
		classLog->push_back(stLogItem);
		++(stLogItem.itemtype);
		stLogItem.itemkey		=	"Center_DefectCluster_Max";
		stLogItem.itemvalue	=	iCenterDefectClusterMax;
		classLog->push_back(stLogItem);
		++(stLogItem.itemtype);
		stLogItem.itemkey		=	"Center_WoundCluster_Max";
		stLogItem.itemvalue	=	iCenterWoundClusterMax;
		classLog->push_back(stLogItem);
		++(stLogItem.itemtype);
		stLogItem.itemkey		=	"Center_DeadCluster_Max";
		stLogItem.itemvalue	=	iCenterDeadClusterMax;
		classLog->push_back(stLogItem);
		++(stLogItem.itemtype);
		stLogItem.itemkey		=	"Edge_Defect_Pixel_Number";
		stLogItem.itemvalue	=	iEdgeDefectTotal;
		classLog->push_back(stLogItem);
		++(stLogItem.itemtype);
		stLogItem.itemkey		=	"Edge_Wound_Pixel_Number";
		stLogItem.itemvalue	=	iEdgeWoundTotal;
		classLog->push_back(stLogItem);
		++(stLogItem.itemtype);
		stLogItem.itemkey		=	"Edge_Dead_Pixel_Number";
		stLogItem.itemvalue	=	iEdgeDeadTotal;
		classLog->push_back(stLogItem);
		++(stLogItem.itemtype);
		stLogItem.itemkey		=	"Edge_DefectCluster_Max";
		stLogItem.itemvalue	=	iEdgeDefectClusterMax;
		classLog->push_back(stLogItem);
		++(stLogItem.itemtype);
		stLogItem.itemkey		=	"Edge_WoundCluster_Max";
		stLogItem.itemvalue	=	iEdgeWoundClusterMax;
		classLog->push_back(stLogItem);
		++(stLogItem.itemtype);
		stLogItem.itemkey		=	"Edge_DeadCluster_Max";
		stLogItem.itemvalue	=	iEdgeDeadClusterMax;
		classLog->push_back(stLogItem);

		if(hisglobalparameter.bDebugMode)
		{
			emit information(QTextCodec::codecForName( "GBK")->toUnicode("坏点位置信息保存在DefectPixelDebug.bmp"));
			RECT stCenter;
			int x	=	static_cast<int>(itemshareData.previewParameter->iWidth *itemshareData.wpDefectPixelParameter->stAlgHB.defectpixelhb_flCenterRange);
			int y	=	static_cast<int>(itemshareData.previewParameter->iHeight *itemshareData.wpDefectPixelParameter->stAlgHB.defectpixelhb_flCenterRange);
			stCenter.left				=	((itemshareData.previewParameter->iWidth - x) >>1);
			stCenter.right			=	((itemshareData.previewParameter->iWidth + x) >>1);
			stCenter.top			=	((itemshareData.previewParameter->iHeight - y) >>1);
			stCenter.bottom		=	((itemshareData.previewParameter->iHeight + y) >>1);
			emit information(QTextCodec::codecForName( "GBK")->toUnicode("坏点中心区域位置:(ROI:") % \
				QString::number(stCenter.left) % "," % QString::number(stCenter.top) % "," % \
				QString::number(stCenter.right) % "," % QString::number(stCenter.bottom) % ")");
		}
	}

	return iresult;
}

int itemprocess::getwhitePanelShadingParameter(bool bupdate, bool bcheck)
{
	QMutexLocker locker(&hisglobalparameter.mutexDatabase);

	itemshareData.itemparameterLock.lockForRead();
	if(!bupdate && itemshareData.wpShadingParameter)	{	itemshareData.itemparameterLock.unlock();	return 0;	}
	itemshareData.itemparameterLock.unlock();

	itemshareData.itemparameterLock.lockForWrite();
	if(!itemshareData.wpShadingParameter)	itemshareData.wpShadingParameter		=	new _wpShadingParameter;
	if(!itemshareData.wpShadingParameter)	{	itemshareData.itemparameterLock.unlock();	return HisFX3Error_MallocBuffer;	}

	bool bItemExist = false;
	{
		QSqlDatabase customdb = QSqlDatabase::addDatabase("QSQLITE", "querycustom");
		customdb.setDatabaseName(QDir::currentPath() % "/HisFX3Custom");
		if (!customdb.open()){
			itemshareData.itemparameterLock.unlock();
			return HisCCMError_Database;
		}

		QStringList strname, strvalue;
		QString strData, strData2;
		QSqlQuery query(customdb);
		query.prepare("SELECT itemsuffix2,key,value,reserve FROM " % itemshareData.currentTableName % \
			" WHERE classfy='algorithm' AND item='whitepanel' AND itemsuffix1='total' ORDER BY id ASC" );
		query.exec();

		//
		//
		//(opticalcenteralg:a)(defectpixelalg:a)(defectlinealg:a)
		//(belmishalg:a)(coloralg:a)(shadingalg:a)(vignettingalg:a)
		while (query.next()){
			bItemExist = true;
			for(int y=0;	y<5;	++y){
				strData	=	query.value(y).toString();
				ROPLOW::patchconfigstring(strData, strname, strvalue);
				for(int x=0;	x<strname.size();	++x){
					if(strname.at(x) == "shadingalg"){
						if(strvalue.at(x) == "a")	itemshareData.wpShadingParameter->shadingAlg	=	_HisAlg_SWITCH_A;
						else if(strvalue.at(x) == "b")	itemshareData.wpShadingParameter->shadingAlg	=	_HisAlg_SWITCH_B;
						else if(strvalue.at(x) == "c")	itemshareData.wpShadingParameter->shadingAlg	=	_HisAlg_SWITCH_C;
						else if(strvalue.at(x) == "d")	itemshareData.wpShadingParameter->shadingAlg	=	_HisAlg_SWITCH_D;
						else if(strvalue.at(x) == "e")	itemshareData.wpShadingParameter->shadingAlg	=	_HisAlg_SWITCH_E;
						else if(strvalue.at(x) == "f")	itemshareData.wpShadingParameter->shadingAlg	=	_HisAlg_SWITCH_F;
					}
				}
			}
		}

		query.prepare("SELECT itemsuffix2,key,value,reserve FROM " % itemshareData.currentTableName % \
			" WHERE classfy='algorithm' AND item='whitepanel' AND itemsuffix1='shandingha' ORDER BY id ASC" );
		query.exec();
		//(channel:y)(roiw:0.2)(roih:0.2)
		//(specmin:0.5)(specmax:0.8)(specdev:0.05)
		while (query.next()){
			bItemExist = true;
			for(int y=0;	y<4;	++y){
				strData	=	query.value(y).toString();
				ROPLOW::patchconfigstring(strData, strname, strvalue);
				for(int x=0;	x<strname.size();	++x){
					if(strname.at(x) == "roiw")	 itemshareData.wpShadingParameter->stShadingConfigHA.flRatioW = strvalue.at(x).toFloat();
					else if(strname.at(x) == "roih")	 itemshareData.wpShadingParameter->stShadingConfigHA.flRatioH = strvalue.at(x).toFloat();
					else if(strname.at(x) == "specmin")	 itemshareData.wpShadingParameter->stShadingConfigHA.flShadingSpecMin = strvalue.at(x).toFloat();
					else if(strname.at(x) == "specmax")	 itemshareData.wpShadingParameter->stShadingConfigHA.flShadingSpecMax = strvalue.at(x).toFloat();
					else if(strname.at(x) == "specdev")	 itemshareData.wpShadingParameter->stShadingConfigHA.flShadingSpecDev = strvalue.at(x).toFloat();
					else if(strname.at(x) == "channel")	{
						if(strvalue.at(x) == "r")	itemshareData.wpShadingParameter->stShadingConfigHA.imgChannel	=	_HisCCMAlg_ImageBuffer_Channel_R;
						else if(strvalue.at(x) == "g")	itemshareData.wpShadingParameter->stShadingConfigHA.imgChannel	=	_HisCCMAlg_ImageBuffer_Channel_Gr;
						else if(strvalue.at(x) == "b")	itemshareData.wpShadingParameter->stShadingConfigHA.imgChannel	=	_HisCCMAlg_ImageBuffer_Channel_B;
						else	itemshareData.wpShadingParameter->stShadingConfigHA.imgChannel	=	_HisCCMAlg_ImageBuffer_Channel_Y;
					}
				}
			}
		}

		query.prepare("SELECT itemsuffix2,key,value,reserve FROM " % itemshareData.currentTableName % \
			" WHERE classfy='algorithm' AND item='whitepanel' AND itemsuffix1='shandinghb' ORDER BY id ASC" );
		query.exec();
		//(rgmin:0.0)(rgmax:4.0)(bgmin:0.0)(bgmax:4.0)
		//(specmin:50.0)(specmax:80.0)(specdev:5.0)
		//(ppmin:0.0)(ppmax:4.0)(bgoffset:0.0)(rgoffset:0.0)(ppoffset:0.0)(yyoffset:0.0)
		while (query.next()){
			bItemExist = true;
			for(int y=0;	y<4;	++y){
				strData	=	query.value(y).toString();
				ROPLOW::patchconfigstring(strData, strname, strvalue);
				for(int x=0;	x<strname.size();	++x){
					if(strname.at(x) == "rgmin")	 itemshareData.wpShadingParameter->stShadingConfigHB.flSpecRGMin = strvalue.at(x).toFloat();
					else if(strname.at(x) == "rgmax")	 itemshareData.wpShadingParameter->stShadingConfigHB.flSpecRGMax = strvalue.at(x).toFloat();
					else if(strname.at(x) == "bgmin")	 itemshareData.wpShadingParameter->stShadingConfigHB.flSpecBGMin = strvalue.at(x).toFloat();
					else if(strname.at(x) == "bgmax")	 itemshareData.wpShadingParameter->stShadingConfigHB.flSpecBGMax = strvalue.at(x).toFloat();
					else if(strname.at(x) == "specmin")	 itemshareData.wpShadingParameter->stShadingConfigHB.flShadingSpecMin = strvalue.at(x).toFloat();
					else if(strname.at(x) == "specmax")	 itemshareData.wpShadingParameter->stShadingConfigHB.flShadingSpecMax = strvalue.at(x).toFloat();
					else if(strname.at(x) == "specdev")	 itemshareData.wpShadingParameter->stShadingConfigHB.flShadingSpecDev = strvalue.at(x).toFloat();
					else if(strname.at(x) == "ppmin")	 itemshareData.wpShadingParameter->stShadingConfigHB.flSpecPPMin = strvalue.at(x).toFloat();
					else if(strname.at(x) == "ppmax")	 itemshareData.wpShadingParameter->stShadingConfigHB.flSpecPPMax = strvalue.at(x).toFloat();
					else if(strname.at(x) == "bgoffset")	 itemshareData.wpShadingParameter->stShadingConfigHB.flBGOffset = strvalue.at(x).toFloat();
					else if(strname.at(x) == "rgoffset")	 itemshareData.wpShadingParameter->stShadingConfigHB.flRGOffset = strvalue.at(x).toFloat();
					else if(strname.at(x) == "ppoffset")	 itemshareData.wpShadingParameter->stShadingConfigHB.flPPOffset = strvalue.at(x).toFloat();
					else if(strname.at(x) == "yyoffset")	 itemshareData.wpShadingParameter->stShadingConfigHB.flYYOffset = strvalue.at(x).toFloat();
				}
			}
		}

		query.prepare("SELECT itemsuffix2,key,value,reserve FROM " % itemshareData.currentTableName % \
			" WHERE classfy='algorithm' AND item='whitepanel' AND itemsuffix1='shandinghc' ORDER BY id ASC" );
		query.exec();
		//(rawinfo:)(lightsource:)
		//(tunegain:)
		//(yymin:)(yymax:)(bgmin:)(bgmax:)(rgmin:)(rgmax:)
		//(ppmin:0.0)(ppmax:4.0)(cornermin:)(cornermax:)(vignetmin:)(vignetmax:)
		while (query.next())
		{
			bItemExist = true;
			for(int y=0;	y<4;	++y){
				strData	=	query.value(y).toString();
				ROPLOW::patchconfigstring(strData, strname, strvalue);
				for(int x=0;	x<strname.size();	++x)
				{
					if(strname.at(x) == "rawinfo")	 itemshareData.wpShadingParameter->stShadingConfigHC.strRawInfo = strvalue.at(x);
					else if(strname.at(x) == "lightsource")	 itemshareData.wpShadingParameter->stShadingConfigHC.strLightSource = strvalue.at(x);
					else if(strname.at(x) == "tunegain")	 itemshareData.wpShadingParameter->stShadingConfigHC.strTuneGain = strvalue.at(x);
					else if(strname.at(x) == "yymin")	 itemshareData.wpShadingParameter->stShadingConfigHC.flYMin = strvalue.at(x).toFloat();
					else if(strname.at(x) == "yymax")	 itemshareData.wpShadingParameter->stShadingConfigHC.flYMax = strvalue.at(x).toFloat();
					else if(strname.at(x) == "yyoffset")	 itemshareData.wpShadingParameter->stShadingConfigHC.flYOffset = strvalue.at(x).toFloat();
					else if(strname.at(x) == "bgmin")	 itemshareData.wpShadingParameter->stShadingConfigHC.flBGMin = strvalue.at(x).toFloat();
					else if(strname.at(x) == "bgmax")	 itemshareData.wpShadingParameter->stShadingConfigHC.flBGMax = strvalue.at(x).toFloat();
					else if(strname.at(x) == "bgoffset")	 itemshareData.wpShadingParameter->stShadingConfigHC.flBGOffset = strvalue.at(x).toFloat();
					else if(strname.at(x) == "rgmin")	 itemshareData.wpShadingParameter->stShadingConfigHC.flRGMin = strvalue.at(x).toFloat();
					else if(strname.at(x) == "rgmax")	 itemshareData.wpShadingParameter->stShadingConfigHC.flRGMax = strvalue.at(x).toFloat();
					else if(strname.at(x) == "rgoffset")	 itemshareData.wpShadingParameter->stShadingConfigHC.flRGOffset = strvalue.at(x).toFloat();
					else if(strname.at(x) == "ppmin")	 itemshareData.wpShadingParameter->stShadingConfigHC.flPPMin = strvalue.at(x).toFloat();
					else if(strname.at(x) == "ppmax")	 itemshareData.wpShadingParameter->stShadingConfigHC.flPPMax = strvalue.at(x).toFloat();
					else if(strname.at(x) == "ppoffset")	 itemshareData.wpShadingParameter->stShadingConfigHC.flPPOffset= strvalue.at(x).toFloat();
					else if(strname.at(x) == "cornermin")	 itemshareData.wpShadingParameter->stShadingConfigHC.flCornerMin = strvalue.at(x).toFloat();
					else if(strname.at(x) == "cornermax")	 itemshareData.wpShadingParameter->stShadingConfigHC.flCornerMax = strvalue.at(x).toFloat();
					else if(strname.at(x) == "corneroffset")	 itemshareData.wpShadingParameter->stShadingConfigHC.flCornerOffset = strvalue.at(x).toFloat();
					else if(strname.at(x) == "vignetmin")	 itemshareData.wpShadingParameter->stShadingConfigHC.flVignetMin = strvalue.at(x).toFloat();
					else if(strname.at(x) == "vignetmax")	 itemshareData.wpShadingParameter->stShadingConfigHC.flVignetMax = strvalue.at(x).toFloat();
					else if(strname.at(x) == "vignetoffset")	 itemshareData.wpShadingParameter->stShadingConfigHC.flVignetOffset = strvalue.at(x).toFloat();
				}
			}
		}

		query.prepare("SELECT itemsuffix2,key,value,reserve FROM " % itemshareData.currentTableName % \
			" WHERE classfy='algorithm' AND item='whitepanel' AND itemsuffix1='shandinghd' ORDER BY id ASC" );
		query.exec();
		//(blockw:17)(blockh:15)
		//(ppymin:0.3)(ppymax:0.6)(pprgmin:0.3)(pprgmax:0.6)(ppbgmin:0.3)(ppbgmax:0.6)
		while (query.next())
		{
			bItemExist = true;
			for(int y=0;	y<4;	++y)
			{
				strData	=	query.value(y).toString();
				ROPLOW::patchconfigstring(strData, strname, strvalue);
				for(int x=0;	x<strname.size();	++x)
				{
					if(strname.at(x) == "blockw")	 itemshareData.wpShadingParameter->stShadingConfigHD.usBlockW = strvalue.at(x).toUInt() & 0xFFFF;
					else if(strname.at(x) == "blockh")	 itemshareData.wpShadingParameter->stShadingConfigHD.usBlockH = strvalue.at(x).toUInt() & 0xFFFF;
					else if(strname.at(x) == "ppymin")	 itemshareData.wpShadingParameter->stShadingConfigHD.flPP_YMin = strvalue.at(x).toFloat();
					else if(strname.at(x) == "ppymax")	 itemshareData.wpShadingParameter->stShadingConfigHD.flPP_YMax = strvalue.at(x).toFloat();
					else if(strname.at(x) == "pprgmin")	 itemshareData.wpShadingParameter->stShadingConfigHD.flPP_RGMin = strvalue.at(x).toFloat();
					else if(strname.at(x) == "pprgmax")	 itemshareData.wpShadingParameter->stShadingConfigHD.flPP_RGMax = strvalue.at(x).toFloat();
					else if(strname.at(x) == "ppbgmin")	 itemshareData.wpShadingParameter->stShadingConfigHD.flPP_BGMin = strvalue.at(x).toFloat();
					else if(strname.at(x) == "ppbgmax")	 itemshareData.wpShadingParameter->stShadingConfigHD.flPP_BGMax = strvalue.at(x).toFloat();
				}
			}
		}

		query.prepare("SELECT itemsuffix2,key,value,reserve FROM " % itemshareData.currentTableName % \
			" WHERE classfy='algorithm' AND item='whitepanel' AND itemsuffix1='shandinghe' ORDER BY id ASC" );
		query.exec();
		//(blockw:17)(blockh:15)
		//(ppymin:0.3)(ppymax:0.6)(pprgmin:0.3)(pprgmax:0.6)(ppbgmin:0.3)(ppbgmax:0.6)
		while (query.next())
		{
			bItemExist = true;
			for(int y=0;	y<4;	++y)
			{
				strData	=	query.value(y).toString();
				ROPLOW::patchconfigstring(strData, strname, strvalue);
				for(int x=0;	x<strname.size();	++x)
				{
					if(strname.at(x) == "qs_roisize")	 itemshareData.wpShadingParameter->stShadingConfigHE.qs_fRoiSize = strvalue.at(x).toFloat();
					else if(strname.at(x) == "qs_blc")	 itemshareData.wpShadingParameter->stShadingConfigHE.qs_iBlackLevel = strvalue.at(x).toUInt();
					else if(strname.at(x) == "qs_diff")	 itemshareData.wpShadingParameter->stShadingConfigHE.qs_fYDiff = strvalue.at(x).toFloat();

					else if(strname.at(x) == "qs_yshading_lt_min")	 itemshareData.wpShadingParameter->stShadingConfigHE.qs_ShadingY1_min = strvalue.at(x).toFloat();
					else if(strname.at(x) == "qs_yshading_lt_max")	 itemshareData.wpShadingParameter->stShadingConfigHE.qs_ShadingY1_max = strvalue.at(x).toFloat();
					else if(strname.at(x) == "qs_yshading_rt_min")	 itemshareData.wpShadingParameter->stShadingConfigHE.qs_ShadingY3_min = strvalue.at(x).toFloat();
					else if(strname.at(x) == "qs_yshading_rt_max")	 itemshareData.wpShadingParameter->stShadingConfigHE.qs_ShadingY3_max = strvalue.at(x).toFloat();
					else if(strname.at(x) == "qs_yshading_lb_min")	 itemshareData.wpShadingParameter->stShadingConfigHE.qs_ShadingY7_min = strvalue.at(x).toFloat();
					else if(strname.at(x) == "qs_yshading_lb_max")	 itemshareData.wpShadingParameter->stShadingConfigHE.qs_ShadingY7_max = strvalue.at(x).toFloat();
					else if(strname.at(x) == "qs_yshading_rb_min")	 itemshareData.wpShadingParameter->stShadingConfigHE.qs_ShadingY9_min = strvalue.at(x).toFloat();
					else if(strname.at(x) == "qs_yshading_rb_max")	 itemshareData.wpShadingParameter->stShadingConfigHE.qs_ShadingY9_max = strvalue.at(x).toFloat();
					else if(strname.at(x) == "qs_yshading_t_min")	 itemshareData.wpShadingParameter->stShadingConfigHE.qs_ShadingY2_min = strvalue.at(x).toFloat();
					else if(strname.at(x) == "qs_yshading_t_max")	 itemshareData.wpShadingParameter->stShadingConfigHE.qs_ShadingY2_max = strvalue.at(x).toFloat();
					else if(strname.at(x) == "qs_yshading_l_min")	 itemshareData.wpShadingParameter->stShadingConfigHE.qs_ShadingY4_min = strvalue.at(x).toFloat();
					else if(strname.at(x) == "qs_yshading_l_max")	 itemshareData.wpShadingParameter->stShadingConfigHE.qs_ShadingY4_max = strvalue.at(x).toFloat();
					else if(strname.at(x) == "qs_yshading_r_min")	 itemshareData.wpShadingParameter->stShadingConfigHE.qs_ShadingY6_min = strvalue.at(x).toFloat();
					else if(strname.at(x) == "qs_yshading_r_max")	 itemshareData.wpShadingParameter->stShadingConfigHE.qs_ShadingY6_max = strvalue.at(x).toFloat();
					else if(strname.at(x) == "qs_yshading_b_min")	 itemshareData.wpShadingParameter->stShadingConfigHE.qs_ShadingY8_min = strvalue.at(x).toFloat();
					else if(strname.at(x) == "qs_yshading_b_max")	 itemshareData.wpShadingParameter->stShadingConfigHE.qs_ShadingY8_max = strvalue.at(x).toFloat();

					else if(strname.at(x) == "qs_rshading_lt_min")	 itemshareData.wpShadingParameter->stShadingConfigHE.qs_ShadingR1_min = strvalue.at(x).toFloat();
					else if(strname.at(x) == "qs_rshading_lt_max")	 itemshareData.wpShadingParameter->stShadingConfigHE.qs_ShadingR1_max = strvalue.at(x).toFloat();
					else if(strname.at(x) == "qs_rshading_rt_min")	 itemshareData.wpShadingParameter->stShadingConfigHE.qs_ShadingR3_min = strvalue.at(x).toFloat();
					else if(strname.at(x) == "qs_rshading_rt_max")	 itemshareData.wpShadingParameter->stShadingConfigHE.qs_ShadingR3_max = strvalue.at(x).toFloat();
					else if(strname.at(x) == "qs_rshading_lb_min")	 itemshareData.wpShadingParameter->stShadingConfigHE.qs_ShadingR7_min = strvalue.at(x).toFloat();
					else if(strname.at(x) == "qs_rshading_lb_max")	 itemshareData.wpShadingParameter->stShadingConfigHE.qs_ShadingR7_max = strvalue.at(x).toFloat();
					else if(strname.at(x) == "qs_rshading_rb_min")	 itemshareData.wpShadingParameter->stShadingConfigHE.qs_ShadingR9_min = strvalue.at(x).toFloat();
					else if(strname.at(x) == "qs_rshading_rb_max")	 itemshareData.wpShadingParameter->stShadingConfigHE.qs_ShadingR9_max = strvalue.at(x).toFloat();
					else if(strname.at(x) == "qs_rshading_t_min")	 itemshareData.wpShadingParameter->stShadingConfigHE.qs_ShadingR2_min = strvalue.at(x).toFloat();
					else if(strname.at(x) == "qs_rshading_t_max")	 itemshareData.wpShadingParameter->stShadingConfigHE.qs_ShadingR2_max = strvalue.at(x).toFloat();
					else if(strname.at(x) == "qs_rshading_l_min")	 itemshareData.wpShadingParameter->stShadingConfigHE.qs_ShadingR4_min = strvalue.at(x).toFloat();
					else if(strname.at(x) == "qs_rshading_l_max")	 itemshareData.wpShadingParameter->stShadingConfigHE.qs_ShadingR4_max = strvalue.at(x).toFloat();
					else if(strname.at(x) == "qs_rshading_r_min")	 itemshareData.wpShadingParameter->stShadingConfigHE.qs_ShadingR6_min = strvalue.at(x).toFloat();
					else if(strname.at(x) == "qs_rshading_r_max")	 itemshareData.wpShadingParameter->stShadingConfigHE.qs_ShadingR6_max = strvalue.at(x).toFloat();
					else if(strname.at(x) == "qs_rshading_b_min")	 itemshareData.wpShadingParameter->stShadingConfigHE.qs_ShadingR8_min = strvalue.at(x).toFloat();
					else if(strname.at(x) == "qs_rshading_b_max")	 itemshareData.wpShadingParameter->stShadingConfigHE.qs_ShadingR8_max = strvalue.at(x).toFloat();

					else if(strname.at(x) == "qs_bshading_lt_min")	 itemshareData.wpShadingParameter->stShadingConfigHE.qs_ShadingB1_min = strvalue.at(x).toFloat();
					else if(strname.at(x) == "qs_bshading_lt_max")	 itemshareData.wpShadingParameter->stShadingConfigHE.qs_ShadingB1_max = strvalue.at(x).toFloat();
					else if(strname.at(x) == "qs_bshading_rt_min")	 itemshareData.wpShadingParameter->stShadingConfigHE.qs_ShadingB3_min = strvalue.at(x).toFloat();
					else if(strname.at(x) == "qs_bshading_rt_max")	 itemshareData.wpShadingParameter->stShadingConfigHE.qs_ShadingB3_max = strvalue.at(x).toFloat();
					else if(strname.at(x) == "qs_bshading_lb_min")	 itemshareData.wpShadingParameter->stShadingConfigHE.qs_ShadingB7_min = strvalue.at(x).toFloat();
					else if(strname.at(x) == "qs_bshading_lb_max")	 itemshareData.wpShadingParameter->stShadingConfigHE.qs_ShadingB7_max = strvalue.at(x).toFloat();
					else if(strname.at(x) == "qs_bshading_rb_min")	 itemshareData.wpShadingParameter->stShadingConfigHE.qs_ShadingB9_min = strvalue.at(x).toFloat();
					else if(strname.at(x) == "qs_bshading_rb_max")	 itemshareData.wpShadingParameter->stShadingConfigHE.qs_ShadingB9_max = strvalue.at(x).toFloat();
					else if(strname.at(x) == "qs_bshading_t_min")	 itemshareData.wpShadingParameter->stShadingConfigHE.qs_ShadingB2_min = strvalue.at(x).toFloat();
					else if(strname.at(x) == "qs_bshading_t_max")	 itemshareData.wpShadingParameter->stShadingConfigHE.qs_ShadingB2_max = strvalue.at(x).toFloat();
					else if(strname.at(x) == "qs_bshading_l_min")	 itemshareData.wpShadingParameter->stShadingConfigHE.qs_ShadingB4_min = strvalue.at(x).toFloat();
					else if(strname.at(x) == "qs_bshading_l_max")	 itemshareData.wpShadingParameter->stShadingConfigHE.qs_ShadingB4_max = strvalue.at(x).toFloat();
					else if(strname.at(x) == "qs_bshading_r_min")	 itemshareData.wpShadingParameter->stShadingConfigHE.qs_ShadingB6_min = strvalue.at(x).toFloat();
					else if(strname.at(x) == "qs_bshading_r_max")	 itemshareData.wpShadingParameter->stShadingConfigHE.qs_ShadingB6_max = strvalue.at(x).toFloat();
					else if(strname.at(x) == "qs_bshading_b_min")	 itemshareData.wpShadingParameter->stShadingConfigHE.qs_ShadingB8_min = strvalue.at(x).toFloat();
					else if(strname.at(x) == "qs_bshading_b_max")	 itemshareData.wpShadingParameter->stShadingConfigHE.qs_ShadingB8_max = strvalue.at(x).toFloat();
				}
			}
		}

		query.prepare("SELECT itemsuffix2,key,value,reserve FROM " % itemshareData.currentTableName % \
			" WHERE classfy='algorithm' AND item='whitepanel' AND itemsuffix1='shandinghf' ORDER BY id ASC" );
		query.exec();
		while (query.next())
		{
			bItemExist = true;
			for(int y=0;	y<4;	++y)
			{
				strData	=	query.value(y).toString();
				ROPLOW::patchconfigstring(strData, strname, strvalue);
				for(int x=0;	x<strname.size();	++x)
				{
					if(strname.at(x) == "roiwnumber")	 itemshareData.wpShadingParameter->stShadingConfigHF.iROIWNumber_AlgF = strvalue.at(x).toUInt() & 0xFFFF;
					else if(strname.at(x) == "roihnumber")	 itemshareData.wpShadingParameter->stShadingConfigHF.iROIHNumber_AlgF = strvalue.at(x).toUInt() & 0xFFFF;
					else if(strname.at(x) == "mindivmax")	 itemshareData.wpShadingParameter->stShadingConfigHF.fMinMaxRatioSpec_AlgF = strvalue.at(x).toFloat();
				}
			}
		}

		customdb.close();
	}

	QSqlDatabase::removeDatabase("querycustom");

	if(!bItemExist)
	{
		HisReleaseNewO(itemshareData.wpShadingParameter);
		itemshareData.itemparameterLock.unlock();
		return HisFX3Error_Parameter;
	}

	if(!bcheck) {itemshareData.itemparameterLock.unlock(); return 0; }

	itemshareData.itemparameterLock.unlock();
	return 0;
}

int itemprocess::whitePanelShading()
{
	emit information(tr("Test Item: SHADING"));

	std::vector<_itemDraw>::iterator theIterator;
	itemshareData.clearDrawList();

#ifdef _DEBUG
	fnMTF_Q fnMTF=(fnMTF_Q)QLibrary::resolve("cvImageToold.dll","fnMTF");
	getMarkDistance_RGB24 funCalMarkDist=(getMarkDistance_RGB24)QLibrary::resolve("fqqImageToolD.dll","getMarkDistance_RGB24");
	polyfit funPolyfit=(polyfit)QLibrary::resolve("fqqImageToolD.dll","polyfit");
	opticalCenter funOC=(opticalCenter)QLibrary::resolve("fqqImageToolD.dll","opticalCenter");
#else
	fnMTF_Q fnMTF=(fnMTF_Q)QLibrary::resolve("cvImageTool.dll","fnMTF");
	getMarkDistance_RGB24 funCalMarkDist=(getMarkDistance_RGB24)QLibrary::resolve("fqqImageTool.dll","getMarkDistance_RGB24");
	polyfit funPolyfit=(polyfit)QLibrary::resolve("fqqImageTool.dll","polyfit");
	opticalCenter funOC=(opticalCenter)QLibrary::resolve("fqqImageTool.dll","opticalCenter");
#endif

	//判断图像是否点亮中
	if(!threadshareData.GetHisPreviewflag())	return HisCCMError_NotPreivew;

	//取得配置参数和规格
	int iresult	=	getwhitePanelShadingParameter(false);
	if(iresult)	return iresult;

	QHReadWriteLockManage classitemparameterLock(&(itemshareData.itemparameterLock));
	stLogItem.itemtype		=	classLog->getmaxtypeindex(_HISLOG_CLASSIFY_SHADING);
	stLogItem.itemkey		=	"shading_result";
	QHDefaultLogManage classstLogItem(classLog, &stLogItem, "NG");

	_HisFX3_BaylorMode ucDataFormat;
	ROPLOW::BaylorXForamt2Baloy8(itemshareData.previewParameter->ucDataFormat, ucDataFormat);

	if(itemshareData.wpShadingParameter->shadingAlg == _HisAlg_SWITCH_A)
	{
		emit information(tr("Algorithm: A"));
		unsigned char* pucRGB24	=	(unsigned char*)HisAlignedMalloc(itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight *3);
		QHisFX3MallocAlignedManage classpucRGB24(pucRGB24);
		if(!pucRGB24) return HisFX3Error_MallocBuffer;

		if(iresult	=	GetFreshframe(pucRGB24, itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight *3, _FrameType_RGB24, true))
			return iresult;

		_HisAlg_Shading_HA_Data stShadingData;
		if(iresult = classAlgorithm.HisCCMWhitePanel_ShadingHA(pucRGB24, itemshareData.previewParameter->iWidth, \
			itemshareData.previewParameter->iHeight, itemshareData.wpShadingParameter->stShadingConfigHA, stShadingData, hisglobalparameter.bDebugMode)){
				emit information(QString::fromWCharArray(classAlgorithm.GetLastError()));
				return iresult;
		}

		if(!stShadingData.bResult)	iresult	=	HisCCMError_Result;

		emit information(QTextCodec::codecForName( "GBK")->toUnicode("左上角shanding: ") % QString::number(stShadingData.flLT));
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("右上角shanding: ") % QString::number(stShadingData.flRT));
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("左下角shanding: ") % QString::number(stShadingData.flLB));
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("右下角shanding: ") % QString::number(stShadingData.flRB));
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("四角shanding差异: ") % QString::number(stShadingData.flDev));

		classstLogItem.SubRef();
		ROPLOW::saveShadingHALog(stShadingData, *classLog);
		ROPLOW::addDrawShadingHA(itemshareData.wpShadingParameter->stShadingConfigHA, stShadingData, itemshareData.itemdrawList);
	}
	else if(itemshareData.wpShadingParameter->shadingAlg == _HisAlg_SWITCH_B)
	{
		emit information(tr("Algorithm: B"));
		unsigned char* pucRGB24	=	(unsigned char*)HisAlignedMalloc(itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight *3);
		QHisFX3MallocAlignedManage classpucRGB24(pucRGB24);
		if(!pucRGB24) return HisFX3Error_MallocBuffer;

		if(iresult	=	GetFreshframe(pucRGB24, itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight *3, _FrameType_RGB24, true))
			return iresult;

		_HisAlg_Shading_HB_Data stShadingData,stShadingDataOffset;
		if(iresult = classAlgorithm.HisCCMWhitePanel_ShadingHB(pucRGB24, itemshareData.previewParameter->iWidth, \
			itemshareData.previewParameter->iHeight, stShadingData, hisglobalparameter.bDebugMode)){
				emit information(QString::fromWCharArray(classAlgorithm.GetLastError()));
				return iresult;
		}

		stShadingDataOffset				=	stShadingData;
		stShadingDataOffset.Y			+=	itemshareData.wpShadingParameter->stShadingConfigHB.flYYOffset;
		stShadingDataOffset.RG		+=	itemshareData.wpShadingParameter->stShadingConfigHB.flRGOffset;
		stShadingDataOffset.BG		+=	itemshareData.wpShadingParameter->stShadingConfigHB.flBGOffset;
		stShadingDataOffset.PP		+=	itemshareData.wpShadingParameter->stShadingConfigHB.flPPOffset;

		if(stShadingDataOffset.Y_0 > itemshareData.wpShadingParameter->stShadingConfigHB.flShadingSpecMax || stShadingDataOffset.Y_0 < itemshareData.wpShadingParameter->stShadingConfigHB.flShadingSpecMin || \
			stShadingDataOffset.Y_6 > itemshareData.wpShadingParameter->stShadingConfigHB.flShadingSpecMax || stShadingDataOffset.Y_6 < itemshareData.wpShadingParameter->stShadingConfigHB.flShadingSpecMin || \
			stShadingDataOffset.Y_42 > itemshareData.wpShadingParameter->stShadingConfigHB.flShadingSpecMax || stShadingDataOffset.Y_42 < itemshareData.wpShadingParameter->stShadingConfigHB.flShadingSpecMin || \
			stShadingDataOffset.Y_48 > itemshareData.wpShadingParameter->stShadingConfigHB.flShadingSpecMax || stShadingDataOffset.Y_48 < itemshareData.wpShadingParameter->stShadingConfigHB.flShadingSpecMin || \
			stShadingDataOffset.Y > itemshareData.wpShadingParameter->stShadingConfigHB.flShadingSpecDev || \
			stShadingDataOffset.RG > itemshareData.wpShadingParameter->stShadingConfigHB.flSpecRGMax || stShadingDataOffset.RG < itemshareData.wpShadingParameter->stShadingConfigHB.flSpecRGMin || \
			stShadingDataOffset.BG > itemshareData.wpShadingParameter->stShadingConfigHB.flSpecBGMax || stShadingDataOffset.BG < itemshareData.wpShadingParameter->stShadingConfigHB.flSpecBGMin || \
			stShadingDataOffset.PP > itemshareData.wpShadingParameter->stShadingConfigHB.flSpecPPMax || stShadingDataOffset.PP < itemshareData.wpShadingParameter->stShadingConfigHB.flSpecPPMin)
			stShadingDataOffset.bResult	=	false;
		else
			stShadingDataOffset.bResult	=	true;

		if(!stShadingDataOffset.bResult)	iresult	=	HisCCMError_Result;
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("左上角shanding: ") % QString::number(stShadingData.Y_0));
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("右上角shanding: ") % QString::number(stShadingData.Y_6));
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("左下角shanding: ") % QString::number(stShadingData.Y_42));
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("右下角shanding: ") % QString::number(stShadingData.Y_48));
		emit information("YY   Original: " % QString::number(stShadingData.Y, 'f', 3) % "  Offset: " % QString::number(itemshareData.wpShadingParameter->stShadingConfigHB.flYYOffset, 'f', 3) % \
			"  Final: " % QString::number(stShadingDataOffset.Y, 'f', 3));
		emit information("RG   Original: " % QString::number(stShadingData.RG, 'f', 3) % "  Offset: " % QString::number(itemshareData.wpShadingParameter->stShadingConfigHB.flRGOffset, 'f', 3) % \
			"  Final: " % QString::number(stShadingDataOffset.RG, 'f', 3));
		emit information("BG   Original: " % QString::number(stShadingData.BG, 'f', 3) % "  Offset: " % QString::number(itemshareData.wpShadingParameter->stShadingConfigHB.flBGOffset, 'f', 3) % \
			"  Final: " % QString::number(stShadingDataOffset.BG, 'f', 3));
		emit information("PP   Original: " % QString::number(stShadingData.PP, 'f', 3) % "  Offset: " % QString::number(itemshareData.wpShadingParameter->stShadingConfigHB.flPPOffset, 'f', 3) % \
			"  Final: " % QString::number(stShadingDataOffset.PP, 'f', 3));

		classstLogItem.SubRef();
		ROPLOW::saveShadingHBLog(stShadingData, stShadingDataOffset, itemshareData.wpShadingParameter->stShadingConfigHB.flYYOffset, \
			itemshareData.wpShadingParameter->stShadingConfigHB.flRGOffset, itemshareData.wpShadingParameter->stShadingConfigHB.flBGOffset, \
			itemshareData.wpShadingParameter->stShadingConfigHB.flPPOffset, *classLog);
		ROPLOW::addDrawShadingHB(itemshareData.wpShadingParameter->stShadingConfigHB, stShadingData, itemshareData.itemdrawList);
	}
	else if(itemshareData.wpShadingParameter->shadingAlg == _HisAlg_SWITCH_C)
	{
		emit information(tr("Algorithm: C"));
		QString strDllPath = QDir::currentPath() % "/SRITDLL/BIGMESH_Dll";
		typedef int (*RRT_RLST_rlst_run)(char *,char *,char *,unsigned short,double *,double *,double *,double *,double *,double *,double *,double *,double *,double *,double *,double *,double *,double *,char *);
		typedef int (*RRT_BMD_big_mesh)(char *,char *,char *,char *);
		typedef int (*RRT_BMD_big_mesh_log)(int,char *);
		typedef int (*RRT_BMD_coordinate_gen)(int,int,unsigned short,unsigned short,unsigned short,unsigned short *,unsigned short *);
		typedef int (*RRT_BMD_mesh_gen)(int,int,unsigned short *,unsigned short *,unsigned short *,unsigned short *);

#ifdef _WIN64
		RRT_RLST_rlst_run				RLST_rlst_run					= (RRT_RLST_rlst_run)(QLibrary::resolve(strDllPath, "?RLST_rlst_run@@YAHPEAD00GPEAN11111111111110@Z"));
		RRT_BMD_big_mesh				BMD_big_mesh				= (RRT_BMD_big_mesh)(QLibrary::resolve(strDllPath, "?BMD_big_mesh@@YAHPEAD000@Z"));
		RRT_BMD_big_mesh_log		BMD_big_mesh_log		= (RRT_BMD_big_mesh_log)(QLibrary::resolve(strDllPath, "?BMD_big_mesh_log@@YAHHPEAD@Z"));
		RRT_BMD_coordinate_gen	BMD_coordinate_gen		= (RRT_BMD_coordinate_gen)(QLibrary::resolve(strDllPath, "?BMD_coordinate_gen@@YAHHHGGGPEAG0@Z"));
		RRT_BMD_mesh_gen			BMD_mesh_gen				= (RRT_BMD_mesh_gen)(QLibrary::resolve(strDllPath, "?BMD_mesh_gen@@YAHHHPEAG000@Z"));
#else
		RRT_RLST_rlst_run				RLST_rlst_run					= (RRT_RLST_rlst_run)(QLibrary::resolve(strDllPath, "?RLST_rlst_run@@YAHPAD00GPAN11111111111110@Z"));
		RRT_BMD_big_mesh				BMD_big_mesh				= (RRT_BMD_big_mesh)(QLibrary::resolve(strDllPath, "?BMD_big_mesh@@YAHPAD000@Z"));
		RRT_BMD_big_mesh_log		BMD_big_mesh_log		= (RRT_BMD_big_mesh_log)(QLibrary::resolve(strDllPath, "?BMD_big_mesh_log@@YAHHPA_W@Z"));
		RRT_BMD_coordinate_gen	BMD_coordinate_gen		= (RRT_BMD_coordinate_gen)(QLibrary::resolve(strDllPath, "?BMD_coordinate_gen@@YAHHHGGGPAG0@Z"));
		RRT_BMD_mesh_gen			BMD_mesh_gen				= (RRT_BMD_mesh_gen)(QLibrary::resolve(strDllPath, "?BMD_mesh_gen@@YAHHHPAG000@Z"));

#endif

		if(!RLST_rlst_run || !BMD_big_mesh || !BMD_big_mesh_log || !BMD_coordinate_gen || !BMD_mesh_gen){
			emit information(strDllPath % " load RSBT_rsbt_run_mem fail");
			return HisCCMError_LoadDLLFuc;
		}

		unsigned short* pusBaylor	=	(unsigned short*)HisAlignedMalloc(itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight *2);
		if(!pusBaylor) return HisFX3Error_MallocBuffer;
		QHisFX3MallocAlignedManage classpusBaylor(pusBaylor);

		//取得raw图像数据
		if(iresult	=	GetFreshframe((unsigned char*)pusBaylor, itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight *2, _FrameType_Raw10, true))
			return iresult;

		QString strRawPath = QDir::currentPath() % "/SRITDLL/RLST10.raw";

		QFile classFile(strRawPath);
		iresult	=	0;
		if(classFile.open(QIODevice::WriteOnly | QIODevice::Truncate))
		{
			if(classFile.write((char*)(pusBaylor), itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight *2) == -1)	iresult	=	HisCCMError_WriteFile;
			classFile.close();
		}
		else iresult	=	HisCCMError_WriteFile;

		if(iresult) { emit information(strRawPath % " write fail"); return iresult; }

		QString strRawInfo = QDir::currentPath() % "/SRITDLL/" % itemshareData.wpShadingParameter->stShadingConfigHC.strRawInfo;
		if(!QFile::exists(strRawInfo)){
			emit information(strRawInfo % " is not exist");
			return HisCCMError_FilePath;
		}

		QString strLightSource = QDir::currentPath() % "/SRITDLL/" % itemshareData.wpShadingParameter->stShadingConfigHC.strLightSource;
		if(!QFile::exists(strLightSource)){
			emit information(strLightSource % " is not exist");
			return HisCCMError_FilePath;
		}

		QString strTuneGain = QDir::currentPath() % "/SRITDLL/" % itemshareData.wpShadingParameter->stShadingConfigHC.strTuneGain;
		if(!QFile::exists(strTuneGain)){
			emit information(strTuneGain % " is not exist");
			return HisCCMError_FilePath;
		}

		// BIGMESH
		QString strBigMesh = QDir::currentPath() % "/SRITDLL/BigMesh.bmd";
		int			CalResult;
		iresult = BMD_big_mesh(strRawPath.toAscii().data(), strRawInfo.toAscii().data(), strLightSource.toAscii().data(), strBigMesh.toAscii().data());
		if (iresult)
		{
			emit information("BMD_big_mesh return: " % QString::number(iresult));
			return HisCCMError_OtpFucExec;
		}

		CalResult = 1;			// This value is calibration result from HOST SYSTEM ; 1 = success
		iresult = BMD_big_mesh_log(CalResult, strBigMesh.toAscii().data());
		if (iresult)
		{
			emit information("BMD_big_mesh_log return: " % QString::number(iresult));
			return HisCCMError_OtpFucExec;
		}

		double		_Y, R_G, B_G, P_P, min_Corner, min_Vig;
		double		LT_Corner, RT_Corner, LB_Corner, RB_Corner;
		double 		LT_Vignet, RT_Vignet, LB_Vignet, RB_Vignet;
		iresult	=	RLST_rlst_run(strRawPath.toAscii().data(), strRawInfo.toAscii().data(), strTuneGain.toAscii().data(), 0x0F, &_Y, &R_G, &B_G, &P_P, &min_Corner, &min_Vig,
			&LT_Corner, &RT_Corner, &LB_Corner, &RB_Corner, &LT_Vignet, &RT_Vignet, &LB_Vignet, &RB_Vignet, strBigMesh.toAscii().data());
		if (iresult)
		{
			emit information("RLST_rlst_run return: " % QString::number(iresult));
			return HisCCMError_OtpFucExec;
		}

		_Y	+=	itemshareData.wpShadingParameter->stShadingConfigHC.flYOffset;
		R_G	+=	itemshareData.wpShadingParameter->stShadingConfigHC.flRGOffset;
		B_G	+=	itemshareData.wpShadingParameter->stShadingConfigHC.flBGOffset;
		P_P	+=	itemshareData.wpShadingParameter->stShadingConfigHC.flPPOffset;
		min_Corner	+= itemshareData.wpShadingParameter->stShadingConfigHC.flCornerOffset;
		min_Vig		+= itemshareData.wpShadingParameter->stShadingConfigHC.flVignetOffset;
		LT_Vignet	+= itemshareData.wpShadingParameter->stShadingConfigHC.flVignetOffset;
		RT_Vignet	+=	itemshareData.wpShadingParameter->stShadingConfigHC.flVignetOffset;
		LB_Vignet	+=	itemshareData.wpShadingParameter->stShadingConfigHC.flVignetOffset;
		RB_Vignet	+=	itemshareData.wpShadingParameter->stShadingConfigHC.flVignetOffset;
		emit information("Shading(C) Test Result:");
		emit information("YDev: " % QString::number(_Y));
		emit information("R_G: " % QString::number(R_G));
		emit information("B_G: " % QString::number(B_G));
		emit information("P_P: " % QString::number(P_P));
		emit information("YMin: " % QString::number(min_Corner));
		emit information("LT_Corner: " % QString::number(LT_Corner));
		emit information("RT_Corner: " % QString::number(RT_Corner));
		emit information("LB_Corner: " % QString::number(LB_Corner));
		emit information("RB_Corner: " % QString::number(RB_Corner));
		emit information("min_Vig: " % QString::number(min_Vig));
		emit information("LT_Vignet: " % QString::number(LT_Vignet));
		emit information("RT_Vignet: " % QString::number(RT_Vignet));
		emit information("LB_Vignet: " % QString::number(LB_Vignet));
		emit information("RB_Vignet: " % QString::number(RB_Vignet));

		int					img_Width;						// CIS Image Width
		int					img_Height;						// CIS Image Height
		unsigned short		MeshWindow;						// Size of Big Mesh Window
		unsigned short		width_Mesh;						// Number of Big Mesh Width
		unsigned short		height_Mesh;					// Number of Big Mesh Height
		unsigned short		SizeofMemory;					// Big Mesh Data Size of each channel

		img_Width	= threadshareData.uiWidth;
		img_Height	= threadshareData.uiHeight;

		iresult = BMD_mesh_gen(img_Width, img_Height, &MeshWindow, 
			&width_Mesh, &height_Mesh, &SizeofMemory);
		if (iresult)
		{
			emit information("BMD_mesh_gen return: " % QString::number(iresult));
			return HisCCMError_OtpFucExec;
		}

		unsigned short* x_coordinate_buf = (unsigned short*)malloc(width_Mesh* height_Mesh*sizeof(unsigned short) + 1024); 
		unsigned short* y_coordinate_buf = (unsigned short*)malloc(width_Mesh* height_Mesh*sizeof(unsigned short) + 1024); 
		if(!x_coordinate_buf || !y_coordinate_buf)
		{
			if(x_coordinate_buf) { free(x_coordinate_buf); x_coordinate_buf = 0; }
			if(y_coordinate_buf) { free(y_coordinate_buf); y_coordinate_buf = 0; }
			return HisFX3Error_MallocBuffer;
		}

		emit information("MeshWindow: " % QString::number(MeshWindow));
		emit information("width_Mesh: " % QString::number(width_Mesh));
		emit information("height_Mesh: " % QString::number(height_Mesh));

		iresult = BMD_coordinate_gen(img_Width, img_Height, MeshWindow, 
			width_Mesh, height_Mesh, x_coordinate_buf, y_coordinate_buf);
		if (iresult)
		{
			free(x_coordinate_buf);	x_coordinate_buf = NULL;
			free(y_coordinate_buf);	y_coordinate_buf = NULL;
			emit information("BMD_coordinate_gen return: " % QString::number(iresult));
			return HisCCMError_OtpFucExec;
		}

		if(x_coordinate_buf) { free(x_coordinate_buf); x_coordinate_buf = 0; }
		if(y_coordinate_buf) { free(y_coordinate_buf); y_coordinate_buf = 0; }

		iresult = 0;
		if(_Y < itemshareData.wpShadingParameter->stShadingConfigHC.flYMin || _Y > itemshareData.wpShadingParameter->stShadingConfigHC.flYMax) iresult = HisCCMError_Result;
		if(R_G < itemshareData.wpShadingParameter->stShadingConfigHC.flRGMin || R_G > itemshareData.wpShadingParameter->stShadingConfigHC.flRGMax) iresult = HisCCMError_Result;
		if(B_G < itemshareData.wpShadingParameter->stShadingConfigHC.flBGMin || B_G > itemshareData.wpShadingParameter->stShadingConfigHC.flBGMax) iresult = HisCCMError_Result;
		if(P_P < itemshareData.wpShadingParameter->stShadingConfigHC.flPPMin || P_P > itemshareData.wpShadingParameter->stShadingConfigHC.flPPMax) iresult = HisCCMError_Result;
		// 		if(LT_Corner < itemshareData.wpShadingParameter->stShadingConfigHC.flCornerMin || LT_Corner > itemshareData.wpShadingParameter->stShadingConfigHC.flCornerMax) iresult = HisCCMError_Result;
		// 		if(RT_Corner < itemshareData.wpShadingParameter->stShadingConfigHC.flCornerMin || RT_Corner > itemshareData.wpShadingParameter->stShadingConfigHC.flCornerMax) iresult = HisCCMError_Result;
		// 		if(LB_Corner < itemshareData.wpShadingParameter->stShadingConfigHC.flCornerMin || LB_Corner > itemshareData.wpShadingParameter->stShadingConfigHC.flCornerMax) iresult = HisCCMError_Result;
		// 		if(RB_Corner < itemshareData.wpShadingParameter->stShadingConfigHC.flCornerMin || RB_Corner > itemshareData.wpShadingParameter->stShadingConfigHC.flCornerMax) iresult = HisCCMError_Result;
		if(RB_Vignet < itemshareData.wpShadingParameter->stShadingConfigHC.flVignetMin || RB_Vignet > itemshareData.wpShadingParameter->stShadingConfigHC.flVignetMax) iresult = HisCCMError_Result;
		if(RT_Vignet < itemshareData.wpShadingParameter->stShadingConfigHC.flVignetMin || RT_Vignet > itemshareData.wpShadingParameter->stShadingConfigHC.flVignetMax) iresult = HisCCMError_Result;
		if(LB_Vignet < itemshareData.wpShadingParameter->stShadingConfigHC.flVignetMin || LB_Vignet > itemshareData.wpShadingParameter->stShadingConfigHC.flVignetMax) iresult = HisCCMError_Result;
		if(LT_Vignet < itemshareData.wpShadingParameter->stShadingConfigHC.flVignetMin || LT_Vignet > itemshareData.wpShadingParameter->stShadingConfigHC.flVignetMax) iresult = HisCCMError_Result;

		if(iresult) stLogItem.itemvalue	=	"NG";
		classstLogItem.SubRef();
		classLog->push_back(stLogItem);

		++(stLogItem.itemtype); stLogItem.itemkey = "Shading_YDev"; stLogItem.itemvalue = _Y; classLog->push_back(stLogItem);
		++(stLogItem.itemtype); stLogItem.itemkey = "Shading_RG"; stLogItem.itemvalue = R_G; classLog->push_back(stLogItem);
		++(stLogItem.itemtype); stLogItem.itemkey = "Shading_BG"; stLogItem.itemvalue = B_G; classLog->push_back(stLogItem);
		++(stLogItem.itemtype); stLogItem.itemkey = "Shading_PP"; stLogItem.itemvalue = P_P; classLog->push_back(stLogItem);
		++(stLogItem.itemtype); stLogItem.itemkey = "Shading_YMin"; stLogItem.itemvalue = min_Corner; classLog->push_back(stLogItem);
		++(stLogItem.itemtype); stLogItem.itemkey = "Shading_LT_Corner"; stLogItem.itemvalue = LT_Corner; classLog->push_back(stLogItem);
		++(stLogItem.itemtype); stLogItem.itemkey = "Shading_RT_Corner"; stLogItem.itemvalue = RT_Corner; classLog->push_back(stLogItem);
		++(stLogItem.itemtype); stLogItem.itemkey = "Shading_LB_Corner"; stLogItem.itemvalue = LB_Corner; classLog->push_back(stLogItem);
		++(stLogItem.itemtype); stLogItem.itemkey = "Shading_RB_Corner"; stLogItem.itemvalue = RB_Corner; classLog->push_back(stLogItem);
		++(stLogItem.itemtype); stLogItem.itemkey = "Shading_min_Vig"; stLogItem.itemvalue = min_Vig; classLog->push_back(stLogItem);
		++(stLogItem.itemtype); stLogItem.itemkey = "Shading_LT_Vignet"; stLogItem.itemvalue = LT_Vignet; classLog->push_back(stLogItem);
		++(stLogItem.itemtype); stLogItem.itemkey = "Shading_RT_Vignet"; stLogItem.itemvalue = RT_Vignet; classLog->push_back(stLogItem);
		++(stLogItem.itemtype); stLogItem.itemkey = "Shading_LB_Vignet"; stLogItem.itemvalue = LB_Vignet; classLog->push_back(stLogItem);
		++(stLogItem.itemtype); stLogItem.itemkey = "Shading_RB_Vignet"; stLogItem.itemvalue = RB_Vignet; classLog->push_back(stLogItem);
	}
	else if(itemshareData.wpShadingParameter->shadingAlg == _HisAlg_SWITCH_D)
	{
		emit information(tr("Algorithm: D"));
		unsigned char* pucRGB24	=	(unsigned char*)HisAlignedMalloc(itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight *3);
		if(!pucRGB24) return HisFX3Error_MallocBuffer;
		QHisFX3MallocAlignedManage classpucRGB24(pucRGB24);

		if(iresult = threadshareData.GetFreshframe(pucRGB24, itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight *3, _FrameType_RGB24, true))
			return iresult;

		_HisShadingHD_Result stRel;
		if(iresult = classRolongoTest.ShadingHD(pucRGB24, itemshareData.previewParameter->iWidth, itemshareData.previewParameter->iHeight, \
			itemshareData.wpShadingParameter->stShadingConfigHD.usBlockW, itemshareData.wpShadingParameter->stShadingConfigHD.usBlockH, stRel))
		{
			emit information(QString::fromAscii(classRolongoTest.GetLastError()));
			return iresult;
		}

		emit information("PP_Y: " % QString::number(stRel.flPP_Y, 'f', 4));
		emit information("PP_RG: " % QString::number(stRel.flPP_RG, 'f', 4));
		emit information("PP_BG: " % QString::number(stRel.flPP_BG, 'f', 4));

		itemshareData.drawLock.lockForWrite();
		itemshareData.itemdrawList.resize(stRel.vecItem.size() *4 + 2);
		theIterator	=	itemshareData.itemdrawList.begin();
		theIterator->usitem	=	whitepanelitem_shading;
		theIterator->uctype	=	HisDrawType_Line;
		theIterator->stcolor	=	QColor::fromRgb(255, 255, 0);
		theIterator->strinfo.stblock.left	=	stRel.iCenterX - 50;
		theIterator->strinfo.stblock.right	=	stRel.iCenterX + 50;
		theIterator->strinfo.stblock.top = theIterator->strinfo.stblock.bottom	=	stRel.iCenterY;
		theIterator++;

		theIterator->usitem	=	whitepanelitem_shading;
		theIterator->uctype	=	HisDrawType_Line;
		theIterator->stcolor	=	QColor::fromRgb(255, 255, 0);
		theIterator->strinfo.stblock.top		=	stRel.iCenterY - 50;
		theIterator->strinfo.stblock.bottom	=	stRel.iCenterY + 50;
		theIterator->strinfo.stblock.left = theIterator->strinfo.stblock.right	=	stRel.iCenterX;
		theIterator++;

		for(size_t w=0;	w<stRel.vecItem.size();	++w)
		{
			theIterator->usitem	=	whitepanelitem_shading;
			theIterator->uctype	=	HisDrawType_Block;
			theIterator->stcolor	=	QColor::fromRgb(255, 255, 0);
			theIterator->strinfo.stblock	=	stRel.vecItem[w].stROI;
			theIterator++;

			theIterator->usitem	=	whitepanelitem_shading;
			theIterator->uctype	=	HisDrawType_Text;
			theIterator->stcolor	=	QColor::fromRgb(0xCD, 0x85, 0);
			theIterator->idata[0]	=	stRel.vecItem[w].stROI.left;
			theIterator->idata[1]	=	stRel.vecItem[w].stROI.top + (stRel.vecItem[w].stROI.bottom - stRel.vecItem[w].stROI.top) /3;
			sprintf(theIterator->strinfo.strtext, "Y:%.3f", stRel.vecItem[w].flY);
			theIterator++;

			theIterator->usitem	=	whitepanelitem_shading;
			theIterator->uctype	=	HisDrawType_Text;
			theIterator->stcolor	=	QColor::fromRgb(0xCD, 0x85, 0);
			theIterator->idata[0]	=	stRel.vecItem[w].stROI.left;
			theIterator->idata[1]	=	stRel.vecItem[w].stROI.top + (stRel.vecItem[w].stROI.bottom - stRel.vecItem[w].stROI.top) *2 /3;
			sprintf(theIterator->strinfo.strtext, "RG:%.3f", stRel.vecItem[w].flRG);
			theIterator++;

			theIterator->usitem	=	whitepanelitem_shading;
			theIterator->uctype	=	HisDrawType_Text;
			theIterator->stcolor	=	QColor::fromRgb(0xCD, 0x85, 0);
			theIterator->idata[0]	=	stRel.vecItem[w].stROI.left;
			theIterator->idata[1]	=	stRel.vecItem[w].stROI.bottom;
			sprintf(theIterator->strinfo.strtext, "BG:%.3f", stRel.vecItem[w].flBG);
			theIterator++;
		}

		itemshareData.drawLock.unlock();
	}else if(itemshareData.wpShadingParameter->shadingAlg == _HisAlg_SWITCH_E){
		_ShadingImageInfo imageInfo;
		imageInfo.dAWBROI_HRatio=itemshareData.wpShadingParameter->stShadingConfigHE.qs_fRoiSize;
		imageInfo.dAWBROI_WRatio=itemshareData.wpShadingParameter->stShadingConfigHE.qs_fRoiSize;
		imageInfo.dCShadingROI_WRatio=itemshareData.wpShadingParameter->stShadingConfigHE.qs_fRoiSize;
		imageInfo.dCShadingROI_HRatio=itemshareData.wpShadingParameter->stShadingConfigHE.qs_fRoiSize;
		imageInfo.dYShadingROI_HRatio=itemshareData.wpShadingParameter->stShadingConfigHE.qs_fRoiSize;
		imageInfo.dYShadingROI_WRatio=itemshareData.wpShadingParameter->stShadingConfigHE.qs_fRoiSize;
		imageInfo.bDrawMode=false;
		imageInfo.uiBlackLeve=itemshareData.wpShadingParameter->stShadingConfigHE.qs_iBlackLevel<<2;
		imageInfo.uiCShadingMode=1;
		imageInfo.uiImageType=0;
		imageInfo.uiWidth=itemshareData.previewParameter->iWidth;
		imageInfo.uiHeight=itemshareData.previewParameter->iHeight;

		unsigned short *pusBaylor=(unsigned short*)malloc(itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight * 2);
		if(iresult	=	GetFreshframe((unsigned char*)pusBaylor, itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight *2, _FrameType_Raw10, true))
			return iresult;

		// 0:R 1:GR 2:GB 3:B
		switch (itemshareData.previewParameter->ucDataFormat)
		{
		case HisBaylor8_BGGR:
		case HisBaylor10_BGGR:
		case HisBaylor12_BGGR:
			imageInfo.uiFirstPixel=3;
			break;
		case HisBaylor8_RGGB:
		case HisBaylor10_RGGB:
		case HisBaylor12_RGGB:
			imageInfo.uiFirstPixel=0;
			break;
		case HisBaylor8_GBRG:
		case HisBaylor10_GBRG:
		case HisBaylor12_GBRG:
			imageInfo.uiFirstPixel=2;
			break;
		case HisBaylor8_GRBG:
		case HisBaylor10_GRBG:
		case HisBaylor12_GRBG:
			imageInfo.uiFirstPixel=1;
			break;
		}
		imageInfo.pImage=pusBaylor;


		_OutInfo outInfo;
#ifdef _DEBUG
		fnShadingE fnShadinge=(fnShadingE)QLibrary::resolve("cvImageToold.dll","fnShading");
#else
		fnShadingE fnShadinge=(fnShadingE)QLibrary::resolve("cvImageTool.dll","fnShading");
#endif
		if(!fnShadinge){
			emit information(QString::fromLocal8Bit("cvImageTool.dll 加载失败!"));
			free(pusBaylor);
			return -1;
		}

		iresult=fnShadinge(imageInfo,outInfo);
		if(iresult){
			emit information(QString::fromLocal8Bit("Shading错误，请检查图像亮度是否过亮。"));
			free(pusBaylor);
			return -1;
		}

		//************** 判断是否符合规格 **************
		bool yresult[8];
		bool rresult[8];
		bool bresult[8];

		double *pyshading=&outInfo.YShadingInfo.dShadingLT;
		double *prshading=&outInfo.RShadingInfo.dShadingLT;
		double *pbshading=&outInfo.BShadingInfo.dShadingLT;

		float *pyshadingMin=&itemshareData.wpShadingParameter->stShadingConfigHE.qs_ShadingY1_min;
		float *pyshadingMax=&itemshareData.wpShadingParameter->stShadingConfigHE.qs_ShadingY1_max;
		float *prshadingMin=&itemshareData.wpShadingParameter->stShadingConfigHE.qs_ShadingR1_min;
		float *prshadingMax=&itemshareData.wpShadingParameter->stShadingConfigHE.qs_ShadingR1_max;
		float *pbshadingMin=&itemshareData.wpShadingParameter->stShadingConfigHE.qs_ShadingB1_min;
		float *pbshadingMax=&itemshareData.wpShadingParameter->stShadingConfigHE.qs_ShadingB1_max;
		for (int i=0;i<8;i++)
		{
			if(pyshading[i]<pyshadingMin[i]||pyshading[i]>pyshadingMax[i]){
				yresult[i]=false;
			}else{
				yresult[i]=true;
			}
			if(prshading[i]<prshadingMin[i]||prshading[i]>prshadingMax[i]){
				rresult[i]=false;
			}else{
				rresult[i]=true;
			}
			if(pbshading[i]<pbshadingMin[i]||pbshading[i]>pbshadingMax[i]){
				bresult[i]=false;
			}else{
				bresult[i]=true;
			}
		}


		//************** Draw Shading Roi ************


		itemshareData.drawLock.lockForWrite();
		_HisAlg_Shading_HD_Config config=itemshareData.wpShadingParameter->stShadingConfigHE;
		int RoiWidth=imageInfo.uiWidth*imageInfo.dYShadingROI_WRatio;
		int RoiHeight=imageInfo.uiHeight*imageInfo.dYShadingROI_HRatio;

		itemshareData.itemdrawList.resize(9*4);
		theIterator	=	itemshareData.itemdrawList.begin();
		QRect rect[8];

		int offsetX=(imageInfo.uiWidth-RoiWidth*3)/2+RoiWidth;
		int offsetY=(imageInfo.uiHeight-RoiHeight*3)/2+RoiHeight;

		int index=0;
		for (int r=0;r<3;r++)
		{
			for (int c=0;c<3;c++)
			{
				if(r*3+c==4){// Center ROI

				}else{
					QRect tempRect(offsetX*c,offsetY*r,RoiWidth,RoiHeight);
					rect[index++]=tempRect;
				}

			}
		}

		for (int i=0;i<8;i++)
		{
			
			theIterator->usitem	=	whitepanelitem_shading;
			theIterator->uctype	=	HisDrawType_Block;
			theIterator->strinfo.stblock.left	=	rect[i].left();
			theIterator->strinfo.stblock.right	=	rect[i].right();
			theIterator->strinfo.stblock.top = rect[i].top();
			theIterator->strinfo.stblock.bottom	=	rect[i].bottom();
			if((!yresult[i])||(!rresult[i])||(!bresult[i])){
				theIterator->stcolor	=	QColor::fromRgb(255, 0, 0);
			}else{
				theIterator->stcolor	=	QColor::fromRgb(0, 255, 0);
			}

			theIterator++;

			//*****************  Display Y Shading ******************
			theIterator->usitem	=	whitepanelitem_shading;
			theIterator->uctype	=	HisDrawType_Text;
			theIterator->strinfo.stblock.left	=	rect[i].left();
			theIterator->strinfo.stblock.right	=	rect[i].right();
			theIterator->strinfo.stblock.top = rect[i].top();
			theIterator->strinfo.stblock.bottom	=	rect[i].bottom();

			theIterator->idata[0]=rect[i].left();
			theIterator->idata[1]=rect[i].bottom()-100;

			sprintf(theIterator->strinfo.strtext, "Y:%.3f",pyshading[i]);
			if((!yresult[i])){
				theIterator->stcolor	=	QColor::fromRgb(255, 0, 0);
			}else{
				theIterator->stcolor	=	QColor::fromRgb(0, 255, 0);
			}

			theIterator++;

			//*****************  Display R Shading ******************
			theIterator->usitem	=	whitepanelitem_shading;
			theIterator->uctype	=	HisDrawType_Text;
			theIterator->strinfo.stblock.left	=	rect[i].left();
			theIterator->strinfo.stblock.right	=	rect[i].right();
			theIterator->strinfo.stblock.top = rect[i].top();
			theIterator->strinfo.stblock.bottom	=	rect[i].bottom();

			theIterator->idata[0]=rect[i].left();
			theIterator->idata[1]=rect[i].bottom()-50;

			sprintf(theIterator->strinfo.strtext, "R/G:%.3f",prshading[i]);
			if((!rresult[i])){
				theIterator->stcolor	=	QColor::fromRgb(255, 0, 0);
			}else{
				theIterator->stcolor	=	QColor::fromRgb(0, 255, 0);
			}

			theIterator++;

			//*****************  Display B Shading ******************
			theIterator->usitem	=	whitepanelitem_shading;
			theIterator->uctype	=	HisDrawType_Text;
			theIterator->strinfo.stblock.left	=	rect[i].left();
			theIterator->strinfo.stblock.right	=	rect[i].right();
			theIterator->strinfo.stblock.top = rect[i].top();
			theIterator->strinfo.stblock.bottom	=	rect[i].bottom();

			theIterator->idata[0]=rect[i].left();
			theIterator->idata[1]=rect[i].bottom();

			sprintf(theIterator->strinfo.strtext, "B/G:%.3f",pbshading[i]);
			if((!bresult[i])){
				theIterator->stcolor	=	QColor::fromRgb(255, 0, 0);
			}else{
				theIterator->stcolor	=	QColor::fromRgb(0, 255, 0);
			}

			theIterator++;

		}



		//****** Y Shading Diff***************
		double nMax=0,nMin=0xFF;
		double yShadingTemp[4]={outInfo.YShadingInfo.dShadingLT,outInfo.YShadingInfo.dShadingRT,\
			outInfo.YShadingInfo.dShadingLB,outInfo.YShadingInfo.dShadingRB};

		for(int i=0;i<4;i++)
		{
			if(yShadingTemp[i]>nMax)nMax=yShadingTemp[i];
			if(yShadingTemp[i]<nMin)nMin=yShadingTemp[i];
		}

		emit information(QString::fromLocal8Bit("Y Shading Diff(Max-Min)%1").arg(nMax-nMin));
		if(nMax-nMin>itemshareData.wpShadingParameter->stShadingConfigHE.qs_fYDiff){
			iresult=-1;
			emit information(QString::fromLocal8Bit("Y Shading Diff(Max-Min)%1 超出规格").arg(nMax-nMin));
		}

		//********************
		for (int i=0;i<8;i++)
		{
			if(!yresult[i])
				iresult=-1;
			if(!rresult[i])
				iresult=-1;
			if(!bresult[i])
				iresult=-1;
		}


		//*******  Draw Center Roi ******************
		theIterator->usitem	=	whitepanelitem_shading;
		theIterator->uctype	=	HisDrawType_Block;
		theIterator->strinfo.stblock.left	=	(imageInfo.uiWidth-RoiWidth)/2;
		theIterator->strinfo.stblock.right	=	theIterator->strinfo.stblock.left+RoiWidth;
		theIterator->strinfo.stblock.top = (imageInfo.uiHeight-RoiHeight)/2;
		theIterator->strinfo.stblock.bottom	=theIterator->strinfo.stblock.top+RoiHeight	;
		if(iresult){
			theIterator->stcolor	=	QColor::fromRgb(255, 0, 0);
		}else{
			theIterator->stcolor	=	QColor::fromRgb(0, 255, 0);
		}

		theIterator++;

		itemshareData.drawLock.unlock();
	}else if(itemshareData.wpShadingParameter->shadingAlg == _HisAlg_SWITCH_F){
		emit information(tr("Algorithm: F"));
#ifdef _DEBUG
		fnShadingF fnShadingf=(fnShadingF)QLibrary::resolve("cvImageToold.dll","fnShadingF");
#else
		fnShadingF fnShadingf=(fnShadingF)QLibrary::resolve("cvImageTool.dll","fnShadingF");
#endif
		unsigned char *pucBuffer=(unsigned char*)malloc(itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight * 3);
		if(iresult	=	GetFreshframe(pucBuffer, itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight *3, _FrameType_RGB24, true))
			return iresult;

		int iRoiwNumber=itemshareData.wpShadingParameter->stShadingConfigHF.iROIWNumber_AlgF;
		int iRoihNumber=itemshareData.wpShadingParameter->stShadingConfigHF.iROIHNumber_AlgF;

		long outLen=0;
		double *outBuffer=(double*)malloc(iRoiwNumber*iRoihNumber*sizeof(double));
		fnShadingf(pucBuffer,itemshareData.previewParameter->iWidth,itemshareData.previewParameter->iHeight,24,\
			iRoiwNumber,iRoihNumber,outBuffer,&outLen);
		free(pucBuffer);

		//求 Min  Max
		int min=0xFF,max=0,minIndex=0,maxIndex=0;
		for (int i=0;i<outLen;i++)
		{
			if(outBuffer[i]<min){
				min=outBuffer[i];
				minIndex=i;
			}
			if(outBuffer[i]>max){
				max=outBuffer[i];
				maxIndex=i;
			}
		}
		emit information(QString("RI(Y Channel) Min:%1  Max:%2  Min/Max:%3").arg(min).arg(max).arg((float)min/max));
		//************  判断规格 *******************
		if((float)min/max<itemshareData.wpShadingParameter->stShadingConfigHF.fMinMaxRatioSpec_AlgF)
			iresult=-1;

		//***************  画框 ***************************
		itemshareData.drawLock.lockForWrite();
		itemshareData.itemdrawList.resize(iRoihNumber*iRoiwNumber*2);
		theIterator	=	itemshareData.itemdrawList.begin();

		int iROIW=(int)((double)itemshareData.previewParameter->iWidth/iRoiwNumber+0.5f);
		int iROIH=(int)((double)itemshareData.previewParameter->iHeight/iRoihNumber+0.5f);

		int index=0;
		for (int h=0;h<iRoihNumber;h++)
		{
			for (int w=0;w<iRoiwNumber;w++)
			{
				int x = w*iROIW;
				int y = h*iROIH;
				int roiW_temp = iROIW;
				int roiH_temp = iROIH;
				if (w == iRoiwNumber - 1) {
					roiW_temp = itemshareData.previewParameter->iWidth - x;
				}
				if (h == iRoihNumber - 1) {
					roiH_temp = itemshareData.previewParameter->iHeight - y;
				}

				QColor color;
				color=QColor::fromRgb(255, 255, 0);
				if(index==minIndex){
					color=QColor::fromRgb(255, 0, 0);
				}
				if(index==maxIndex){
					color=QColor::fromRgb(0, 0, 255);
				}
					

				theIterator->usitem	=	whitepanelitem_shading;
				theIterator->uctype	=	HisDrawType_Block;
				theIterator->strinfo.stblock.left	=	x;
				theIterator->strinfo.stblock.top = y;
				theIterator->strinfo.stblock.right	=	theIterator->strinfo.stblock.left+roiW_temp;
				theIterator->strinfo.stblock.bottom	=	theIterator->strinfo.stblock.top+roiH_temp;
				theIterator->stcolor	=	color;
				theIterator++;

				theIterator->usitem	=	whitepanelitem_shading;
				theIterator->uctype	=	HisDrawType_Text;
				theIterator->idata[0]=x;
				theIterator->idata[1]=y+((double)roiH_temp/2);
				sprintf(theIterator->strinfo.strtext,"%.1f",outBuffer[index++]);
				theIterator->stcolor	=	color;
				theIterator++;
			}
		}

		// Save Log **********************
		_HisLog_Item logitem;
		logitem.itemtype		=	classLog->getmaxtypeindex(_HISLOG_CLASSIFY_SHADING);
		logitem.itemkey		=	"shadingF_MinDivMax";
		logitem.itemvalue	=	(float)min/max;
		classLog->push_back(logitem);

		_HisLog_Item logitem2;
		logitem2.itemtype		=	classLog->getmaxtypeindex(_HISLOG_CLASSIFY_SHADING);
		logitem2.itemkey		=	"shadingF_Min";
		logitem2.itemvalue	=	min;
		classLog->push_back(logitem2);

		_HisLog_Item logitem3;
		logitem3.itemtype		=	classLog->getmaxtypeindex(_HISLOG_CLASSIFY_SHADING);
		logitem3.itemkey		=	"shadingF_Max";
		logitem3.itemvalue	=	max;
		classLog->push_back(logitem3);

		_HisLog_Item logitem1;
		logitem1.itemtype		=	classLog->getmaxtypeindex(_HISLOG_CLASSIFY_SHADING);
		logitem1.itemkey		=	"shading_result";
		logitem1.itemvalue	=	(iresult)?("NG"):("OK");
		classLog->push_back(logitem1);
		

		itemshareData.drawLock.unlock();
	}

	return iresult;
}

int itemprocess::getwhitePanelVignettingParameter(bool bupdate, bool bcheck)
{
	QMutexLocker locker(&hisglobalparameter.mutexDatabase);

	itemshareData.itemparameterLock.lockForRead();
	if(!bupdate && itemshareData.wpVignetingParameter)	{	itemshareData.itemparameterLock.unlock();	return 0;	}
	itemshareData.itemparameterLock.unlock();

	itemshareData.itemparameterLock.lockForWrite();
	if(!itemshareData.wpVignetingParameter)	itemshareData.wpVignetingParameter		=	new _wpVignetingParameter;
	if(!itemshareData.wpVignetingParameter)	{	itemshareData.itemparameterLock.unlock();	return HisFX3Error_MallocBuffer;	}

	bool bItemExist = false;
	{
		QSqlDatabase customdb = QSqlDatabase::addDatabase("QSQLITE", "querycustom");
		customdb.setDatabaseName(QDir::currentPath() % "/HisFX3Custom");
		if (!customdb.open()){
			itemshareData.itemparameterLock.unlock();
			return HisCCMError_Database;
		}

		QStringList strname, strvalue;
		QString strData, strData2;
		QSqlQuery query(customdb);
		query.prepare("SELECT itemsuffix2,key,value,reserve FROM " % itemshareData.currentTableName % \
			" WHERE classfy='algorithm' AND item='whitepanel' AND itemsuffix1='total' ORDER BY id ASC" );
		query.exec();

		//
		//
		//(opticalcenteralg:a)(defectpixelalg:a)(defectlinealg:a)
		//(belmishalg:a)(coloralg:a)(shadingalg:a)(vignettingalg:a)
		while (query.next()){
			bItemExist = true;
			for(int y=0;	y<4;	++y){
				strData	=	query.value(y).toString();
				ROPLOW::patchconfigstring(strData, strname, strvalue);
				for(int x=0;	x<strname.size();	++x){
					if(strname.at(x) == "vignettingalg"){
						if(strvalue.at(x) == "a")	itemshareData.wpVignetingParameter->vignettingAlg	=	_HisAlg_SWITCH_A;
					}
				}
			}
		}

		query.prepare("SELECT itemsuffix2,key,value,reserve FROM " % itemshareData.currentTableName % \
			" WHERE classfy='algorithm' AND item='whitepanel' AND itemsuffix1='vignettingha' ORDER BY id ASC" );
		query.exec();
		//(roi1w:32)(roi1h:32)
		//(specr2min:0.9)(specr2max:1.1)
		//(specr3min:0.9)(specr3max:1.1)
		while (query.next()){
			bItemExist = true;
			for(int y=0;	y<4;	++y){
				strData	=	query.value(y).toString();
				ROPLOW::patchconfigstring(strData, strname, strvalue);
				for(int x=0;	x<strname.size();	++x){
					if(strname.at(x) == "roi1w")	 itemshareData.wpVignetingParameter->stVignettingConfigHA.uiROIW = strvalue.at(x).toUInt();
					else if(strname.at(x) == "roi1h")	 itemshareData.wpVignetingParameter->stVignettingConfigHA.uiROIH = strvalue.at(x).toUInt();
					else if(strname.at(x) == "specr2min")	 itemshareData.wpVignetingParameter->stVignettingConfigHA.flSpecR2Min = strvalue.at(x).toFloat();
					else if(strname.at(x) == "specr2max")	 itemshareData.wpVignetingParameter->stVignettingConfigHA.flSpecR2Max = strvalue.at(x).toFloat();
					else if(strname.at(x) == "specr3min")	 itemshareData.wpVignetingParameter->stVignettingConfigHA.flSpecR3Min = strvalue.at(x).toFloat();
					else if(strname.at(x) == "specr3max")	 itemshareData.wpVignetingParameter->stVignettingConfigHA.flSpecR3Max = strvalue.at(x).toFloat();
				}
			}
		}

		customdb.close();
	}

	QSqlDatabase::removeDatabase("querycustom");

	if(!bItemExist)
	{
		HisReleaseNewO(itemshareData.wpVignetingParameter);
		itemshareData.itemparameterLock.unlock();
		return HisFX3Error_Parameter;
	}

	if(!bcheck) {itemshareData.itemparameterLock.unlock(); return 0; }

	itemshareData.itemparameterLock.unlock();
	return 0;
}

int itemprocess::whitePanelVignetting()
{
	std::vector<_itemDraw>::iterator theIterator;
	itemshareData.clearDrawList();

	//判断图像是否点亮中
	if(!threadshareData.GetHisPreviewflag())	return HisCCMError_NotPreivew;

	//取得配置参数和规格
	int iresult	=	getwhitePanelVignettingParameter(false);
	if(iresult)	return iresult;

	QHReadWriteLockManage classitemparameterLock(&(itemshareData.itemparameterLock));
	stLogItem.itemtype		=	classLog->getmaxtypeindex(_HISLOG_CLASSIFY_VIGNETTING);
	stLogItem.itemkey		=	"vignetting_result";
	QHDefaultLogManage classstLogItem(classLog, &stLogItem, "NG");

	_HisFX3_BaylorMode ucDataFormat;
	ROPLOW::BaylorXForamt2Baloy8(itemshareData.previewParameter->ucDataFormat, ucDataFormat);

	if(itemshareData.wpVignetingParameter->vignettingAlg == _HisAlg_SWITCH_A)
	{
		unsigned char* pucRGB24	=	(unsigned char*)HisAlignedMalloc(itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight *3);
		QHisFX3MallocAlignedManage classpucRGB24(pucRGB24);
		if(!pucRGB24) return HisFX3Error_MallocBuffer;

		if(iresult	=	GetFreshframe(pucRGB24, itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight *3, _FrameType_RGB24, true))
			return iresult;

		_HisAlg_Vignetting_HA_Data stVignettingData;
		if(iresult = classAlgorithm.HisCCMWhitePanel_VignettingHA(pucRGB24, itemshareData.previewParameter->iWidth, \
			itemshareData.previewParameter->iHeight, itemshareData.wpVignetingParameter->stVignettingConfigHA, stVignettingData, hisglobalparameter.bDebugMode)){
				emit information(QString::fromWCharArray(classAlgorithm.GetLastError()));
				return iresult;
		}

		if(!stVignettingData.bResult)	iresult	=	HisCCMError_Result;
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("Vignetting(Y)左上角R1 /R2: ") % QString::number(stVignettingData.flLTR2));
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("Vignetting(Y)左上角R1 /R3: ") % QString::number(stVignettingData.flLTR3));
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("Vignetting(Y)右上角R1 /R2: ") % QString::number(stVignettingData.flRTR2));
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("Vignetting(Y)右上角R1 /R3: ") % QString::number(stVignettingData.flRTR3));
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("Vignetting(Y)左下角R1 /R2: ") % QString::number(stVignettingData.flLBR2));
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("Vignetting(Y)左下角R1 /R3: ") % QString::number(stVignettingData.flLBR3));
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("Vignetting(Y)右下角R1 /R2: ") % QString::number(stVignettingData.flRBR2));
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("Vignetting(Y)右下角R1 /R3: ") % QString::number(stVignettingData.flRBR3));

		emit information(QTextCodec::codecForName( "GBK")->toUnicode("Vignetting(R)左上角R1 /R2: ") % QString::number(stVignettingData.flLTR2_R));
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("Vignetting(R)左上角R1 /R3: ") % QString::number(stVignettingData.flLTR3_R));
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("Vignetting(R)右上角R1 /R2: ") % QString::number(stVignettingData.flRTR2_R));
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("Vignetting(R)右上角R1 /R3: ") % QString::number(stVignettingData.flRTR3_R));
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("Vignetting(R)左下角R1 /R2: ") % QString::number(stVignettingData.flLBR2_R));
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("Vignetting(R)左下角R1 /R3: ") % QString::number(stVignettingData.flLBR3_R));
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("Vignetting(R)右下角R1 /R2: ") % QString::number(stVignettingData.flRBR2_R));
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("Vignetting(R)右下角R1 /R3: ") % QString::number(stVignettingData.flRBR3_R));

		emit information(QTextCodec::codecForName( "GBK")->toUnicode("Vignetting(G)左上角R1 /R2: ") % QString::number(stVignettingData.flLTR2_G));
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("Vignetting(G)左上角R1 /R3: ") % QString::number(stVignettingData.flLTR3_G));
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("Vignetting(G)右上角R1 /R2: ") % QString::number(stVignettingData.flRTR2_G));
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("Vignetting(G)右上角R1 /R3: ") % QString::number(stVignettingData.flRTR3_G));
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("Vignetting(G)左下角R1 /R2: ") % QString::number(stVignettingData.flLBR2_G));
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("Vignetting(G)左下角R1 /R3: ") % QString::number(stVignettingData.flLBR3_G));
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("Vignetting(G)右下角R1 /R2: ") % QString::number(stVignettingData.flRBR2_G));
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("Vignetting(G)右下角R1 /R3: ") % QString::number(stVignettingData.flRBR3_G));

		emit information(QTextCodec::codecForName( "GBK")->toUnicode("Vignetting(B)左上角R1 /R2: ") % QString::number(stVignettingData.flLTR2_B));
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("Vignetting(B)左上角R1 /R3: ") % QString::number(stVignettingData.flLTR3_B));
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("Vignetting(B)右上角R1 /R2: ") % QString::number(stVignettingData.flRTR2_B));
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("Vignetting(B)右上角R1 /R3: ") % QString::number(stVignettingData.flRTR3_B));
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("Vignetting(B)左下角R1 /R2: ") % QString::number(stVignettingData.flLBR2_B));
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("Vignetting(B)左下角R1 /R3: ") % QString::number(stVignettingData.flLBR3_B));
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("Vignetting(B)右下角R1 /R2: ") % QString::number(stVignettingData.flRBR2_B));
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("Vignetting(B)右下角R1 /R3: ") % QString::number(stVignettingData.flRBR3_B));

		classstLogItem.SubRef();
		ROPLOW::saveVignettingHALog(stVignettingData, *classLog);
	}

	return iresult;
}

int itemprocess::getBlemishParameter(bool bupdate, bool bcheck)
{
	QMutexLocker locker(&hisglobalparameter.mutexDatabase);

	itemshareData.itemparameterLock.lockForRead();
	if(!bupdate && itemshareData.blemishParameter)	{	itemshareData.itemparameterLock.unlock();	return 0;	}
	itemshareData.itemparameterLock.unlock();

	itemshareData.itemparameterLock.lockForWrite();
	if(!itemshareData.blemishParameter)	itemshareData.blemishParameter		=	new _blemishParameter;
	if(!itemshareData.blemishParameter)	{	itemshareData.itemparameterLock.unlock();	return HisFX3Error_MallocBuffer;	}

	bool bItemExist = false;
	{
		QSqlDatabase customdb = QSqlDatabase::addDatabase("QSQLITE", "querycustom");
		customdb.setDatabaseName(QDir::currentPath() % "/HisFX3Custom");
		if (!customdb.open()){
			itemshareData.itemparameterLock.unlock();
			return HisCCMError_Database;
		}

		QStringList strname, strvalue;
		QString strData, strData2;
		QSqlQuery query(customdb);
		query.prepare("SELECT itemsuffix2,key,value,reserve FROM " % itemshareData.currentTableName % \
			" WHERE classfy='algorithm' AND item='whitepanel' AND itemsuffix1='total' ORDER BY id ASC" );
		query.exec();

		//
		//
		//(opticalcenteralg:a)(defectpixelalg:a)(defectlinealg:a)
		//(belmishalg:a)(coloralg:a)(shadingalg:a)(vignettingalg:a)
		while (query.next())
		{
			bItemExist = true;
			for(int y=0;	y<4;	++y)
			{
				strData	=	query.value(y).toString();
				ROPLOW::patchconfigstring(strData, strname, strvalue);

				for(int x=0;	x<strname.size();	++x)
				{
					if(strname.at(x) == "belmishalg"){
						if(strvalue.at(x) == "a")		itemshareData.blemishParameter->blemishAlg	=	_HisAlg_SWITCH_A;
						else if(strvalue.at(x) == "b")	itemshareData.blemishParameter->blemishAlg	=	_HisAlg_SWITCH_B;
						else if(strvalue.at(x) == "c")	itemshareData.blemishParameter->blemishAlg	=	_HisAlg_SWITCH_C;
						else if(strvalue.at(x) == "d")	itemshareData.blemishParameter->blemishAlg	=	_HisAlg_SWITCH_D;
					}
				}
			}
		}

		query.prepare("SELECT itemsuffix2,key,value,reserve FROM " % itemshareData.currentTableName % \
			" WHERE classfy='algorithm' AND item='whitepanel' AND itemsuffix1='blemish' ORDER BY id ASC" );
		query.exec();

		//(range:0.9)(filter:12,24)
		//(amplitude:70)(dev:43)(cornerspec:0.15)
		while (query.next())
		{
			bItemExist = true;
			for(int y=0;	y<4;	++y)
			{
				strData	=	query.value(y).toString();
				ROPLOW::patchconfigstring(strData, strname, strvalue);

				for(int x=0;	x<strname.size();	++x)
				{
					if(strname.at(x) == "range")					itemshareData.blemishParameter->stBlemishHA.blemish_flrange	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "cornerspec")	itemshareData.blemishParameter->stBlemishHA.blemish_corner	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "amplitude")		itemshareData.blemishParameter->stBlemishHA.blemish_iamplitude	=	strvalue.at(x).toInt();
					else if(strname.at(x) == "dev")				itemshareData.blemishParameter->stBlemishHA.blemish_idev	=	strvalue.at(x).toInt();
					else if(strname.at(x) == "filter")
					{
						strData	=	strvalue.at(x);
						int iindex	=	strData.indexOf(",");
						strData2	=	strData.left(iindex);
						strData	=	strData.right(strData.size() - iindex -1);
						if(iindex > 0 && !strData.isEmpty() && !strData2.isEmpty()){
							itemshareData.blemishParameter->stBlemishHA.blemish_ihighpass	=	strData2.toInt();
							itemshareData.blemishParameter->stBlemishHA.blemish_ilowpass	=	strData.toInt();
						}
					}
				}
			}
		}

		query.prepare("SELECT itemsuffix2,key,value,reserve FROM " % itemshareData.currentTableName % \
			" WHERE classfy='algorithm' AND item='whitepanel' AND itemsuffix1='blemishhb' ORDER BY id ASC" );
		query.exec();
		//(z1r1:0.1)(z1r2:0.1)
		//(z2r1:0.1)(z2r2:0.1)
		//(z3r1:0.1)(z3r2:0.1)
		//(zone1range:0.2)(zone3x:300)(zone3y:300)(removedefect:false)
		while (query.next())
		{
			bItemExist = true;
			for(int y=0;	y<4;	++y)
			{
				strData	=	query.value(y).toString();
				ROPLOW::patchconfigstring(strData, strname, strvalue);

				for(int x=0;	x<strname.size();	++x)
				{
					if(strname.at(x) == "zone1range")				itemshareData.blemishParameter->stBlemishHB.blemishhb_Zone1Range	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "frame")				itemshareData.blemishParameter->stBlemishHB.frames	=	strvalue.at(x).toUInt() & 0xFF;					
					else if(strname.at(x) == "zone3x")				itemshareData.blemishParameter->stBlemishHB.blemishhb_Zone3X	=	strvalue.at(x).toUInt();
					else if(strname.at(x) == "zone3y")				itemshareData.blemishParameter->stBlemishHB.blemishhb_Zone3Y	=	strvalue.at(x).toUInt();
					else if(strname.at(x) == "removedefect")	itemshareData.blemishParameter->stBlemishHB.blemishhb_RemoveDefectPixel	=	(strvalue.at(x) == "true");
					else if(strname.at(x) == "z1r1")					itemshareData.blemishParameter->stBlemishHB.blemishhb_Zone1Spec[0]	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "z1r2")					itemshareData.blemishParameter->stBlemishHB.blemishhb_Zone1Spec[1]	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "z1r3")					itemshareData.blemishParameter->stBlemishHB.blemishhb_Zone1Spec[2]	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "z1r4")					itemshareData.blemishParameter->stBlemishHB.blemishhb_Zone1Spec[3]	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "z1r5")					itemshareData.blemishParameter->stBlemishHB.blemishhb_Zone1Spec[4]	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "z1r6")					itemshareData.blemishParameter->stBlemishHB.blemishhb_Zone1Spec[5]	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "z1r7")					itemshareData.blemishParameter->stBlemishHB.blemishhb_Zone1Spec[6]	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "z1r8")					itemshareData.blemishParameter->stBlemishHB.blemishhb_Zone1Spec[7]	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "z1r9")					itemshareData.blemishParameter->stBlemishHB.blemishhb_Zone1Spec[8]	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "z1r10")				itemshareData.blemishParameter->stBlemishHB.blemishhb_Zone1Spec[9]	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "z1r11")					itemshareData.blemishParameter->stBlemishHB.blemishhb_Zone1Spec[10]	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "z1r12")				itemshareData.blemishParameter->stBlemishHB.blemishhb_Zone1Spec[11]	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "z1r13")				itemshareData.blemishParameter->stBlemishHB.blemishhb_Zone1Spec[12]	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "z1r14")				itemshareData.blemishParameter->stBlemishHB.blemishhb_Zone1Spec[13]	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "z1r15")				itemshareData.blemishParameter->stBlemishHB.blemishhb_Zone1Spec[14]	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "z2r1")					itemshareData.blemishParameter->stBlemishHB.blemishhb_Zone2Spec[0]	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "z2r2")					itemshareData.blemishParameter->stBlemishHB.blemishhb_Zone2Spec[1]	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "z2r3")					itemshareData.blemishParameter->stBlemishHB.blemishhb_Zone2Spec[2]	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "z2r4")					itemshareData.blemishParameter->stBlemishHB.blemishhb_Zone2Spec[3]	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "z2r5")					itemshareData.blemishParameter->stBlemishHB.blemishhb_Zone2Spec[4]	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "z2r6")					itemshareData.blemishParameter->stBlemishHB.blemishhb_Zone2Spec[5]	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "z2r7")					itemshareData.blemishParameter->stBlemishHB.blemishhb_Zone2Spec[6]	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "z2r8")					itemshareData.blemishParameter->stBlemishHB.blemishhb_Zone2Spec[7]	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "z2r9")					itemshareData.blemishParameter->stBlemishHB.blemishhb_Zone2Spec[8]	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "z2r10")				itemshareData.blemishParameter->stBlemishHB.blemishhb_Zone2Spec[9]	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "z2r11")					itemshareData.blemishParameter->stBlemishHB.blemishhb_Zone2Spec[10]	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "z2r12")				itemshareData.blemishParameter->stBlemishHB.blemishhb_Zone2Spec[11]	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "z2r13")				itemshareData.blemishParameter->stBlemishHB.blemishhb_Zone2Spec[12]	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "z2r14")				itemshareData.blemishParameter->stBlemishHB.blemishhb_Zone2Spec[13]	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "z2r15")				itemshareData.blemishParameter->stBlemishHB.blemishhb_Zone2Spec[14]	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "z3r1")					itemshareData.blemishParameter->stBlemishHB.blemishhb_Zone3Spec[0]	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "z3r2")					itemshareData.blemishParameter->stBlemishHB.blemishhb_Zone3Spec[1]	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "z3r3")					itemshareData.blemishParameter->stBlemishHB.blemishhb_Zone3Spec[2]	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "z3r4")					itemshareData.blemishParameter->stBlemishHB.blemishhb_Zone3Spec[3]	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "z3r5")					itemshareData.blemishParameter->stBlemishHB.blemishhb_Zone3Spec[4]	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "z3r6")					itemshareData.blemishParameter->stBlemishHB.blemishhb_Zone3Spec[5]	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "z3r7")					itemshareData.blemishParameter->stBlemishHB.blemishhb_Zone3Spec[6]	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "z3r8")					itemshareData.blemishParameter->stBlemishHB.blemishhb_Zone3Spec[7]	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "z3r9")					itemshareData.blemishParameter->stBlemishHB.blemishhb_Zone3Spec[8]	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "z3r10")				itemshareData.blemishParameter->stBlemishHB.blemishhb_Zone3Spec[9]	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "z3r11")					itemshareData.blemishParameter->stBlemishHB.blemishhb_Zone3Spec[10]	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "z3r12")				itemshareData.blemishParameter->stBlemishHB.blemishhb_Zone3Spec[11]	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "z3r13")				itemshareData.blemishParameter->stBlemishHB.blemishhb_Zone3Spec[12]	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "z3r14")				itemshareData.blemishParameter->stBlemishHB.blemishhb_Zone3Spec[13]	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "z3r15")				itemshareData.blemishParameter->stBlemishHB.blemishhb_Zone3Spec[14]	=	strvalue.at(x).toFloat();
				}
			}
		}

		query.prepare("SELECT itemsuffix2,key,value,reserve FROM " % itemshareData.currentTableName % \
			" WHERE classfy='algorithm' AND item='whitepanel' AND itemsuffix1='blemishhc' ORDER BY id ASC" );
		query.exec();
		//(minarea:0.1)(maxarea:0.1)(edgezone:0.05)(tuning:2.0)(lsc:false)(wb:false)
		//(z1b:0.009)(z2b:0.009)(z3b:0.009)(z4b:0.009)(z5b:0.009)(z6b:0.009)(z7b:0.009)(z8b:0.009)(z9b:0.009)(z10b:0.009)(zdgeb:0.009)
		while (query.next())
		{
			bItemExist = true;
			for(int y=0;	y<4;	++y)
			{
				strData	=	query.value(y).toString();
				ROPLOW::patchconfigstring(strData, strname, strvalue);

				for(int x=0;	x<strname.size();	++x)
				{
					if(strname.at(x) == "minarea") itemshareData.blemishParameter->stBlemishHC.flAreaMin	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "frame") itemshareData.blemishParameter->stBlemishHC.frames	=	strvalue.at(x).toUInt() & 0xFF;					
					else if(strname.at(x) == "maxarea") itemshareData.blemishParameter->stBlemishHC.flAreaMax	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "edgezone") itemshareData.blemishParameter->stBlemishHC.flEdgeZone	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "cornerzone") itemshareData.blemishParameter->stBlemishHC.flCornerZone	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "tuning") itemshareData.blemishParameter->stBlemishHC.flTuning	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "z1b") itemshareData.blemishParameter->stBlemishHC.stSpec[0].flLux	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "z2b") itemshareData.blemishParameter->stBlemishHC.stSpec[1].flLux	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "z3b") itemshareData.blemishParameter->stBlemishHC.stSpec[2].flLux	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "z4b") itemshareData.blemishParameter->stBlemishHC.stSpec[3].flLux	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "z5b") itemshareData.blemishParameter->stBlemishHC.stSpec[4].flLux	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "z6b") itemshareData.blemishParameter->stBlemishHC.stSpec[5].flLux	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "z7b") itemshareData.blemishParameter->stBlemishHC.stSpec[6].flLux	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "z8b") itemshareData.blemishParameter->stBlemishHC.stSpec[7].flLux	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "z9b") itemshareData.blemishParameter->stBlemishHC.stSpec[8].flLux	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "z10b") itemshareData.blemishParameter->stBlemishHC.stSpec[9].flLux	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "zdgeb") itemshareData.blemishParameter->stBlemishHC.stSpec[10].flLux	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "cornerb") itemshareData.blemishParameter->stBlemishHC.stSpec[11].flLux	=	strvalue.at(x).toFloat();
				}
			}
		}

		query.prepare("SELECT itemsuffix2,key,value,reserve FROM " % itemshareData.currentTableName % \
			" WHERE classfy='algorithm' AND item='whitepanel' AND itemsuffix1='blemishhd' ORDER BY id ASC" );
		query.exec();
		//(rawinfo:)
		//(optbin:)
		//(maxedgediff:0.0)
		while (query.next())
		{
			bItemExist = true;
			for(int y=0;	y<4;	++y)
			{
				strData	=	query.value(y).toString();
				ROPLOW::patchconfigstring(strData, strname, strvalue);

				for(int x=0;	x<strname.size();	++x)
				{
					if(strname.at(x) == "rawinfo") itemshareData.blemishParameter->stBlemishHD.strRawInfo	=	strvalue.at(x);
					else if(strname.at(x) == "optbin") itemshareData.blemishParameter->stBlemishHD.strOptionBin	=	strvalue.at(x);
					else if(strname.at(x) == "maxedgediff") itemshareData.blemishParameter->stBlemishHD.dflMaxEdgeDiff	=	strvalue.at(x).toDouble();
				}
			}
		}

		customdb.close();
	}

	QSqlDatabase::removeDatabase("querycustom");

	if(!bItemExist)
	{
		HisReleaseNewO(itemshareData.blemishParameter);
		itemshareData.itemparameterLock.unlock();
		return HisFX3Error_Parameter;
	}

	if(!bcheck) {itemshareData.itemparameterLock.unlock(); return 0; }

	itemshareData.itemparameterLock.unlock();
	return 0;
}

int itemprocess::blemish()
{
	//判断图像是否点亮中
	if(!threadshareData.GetHisPreviewflag())	return HisCCMError_NotPreivew;

	std::vector<_itemDraw>::iterator theIterator;
	itemshareData.clearDrawList();

	//取得配置参数和规格
	int iresult	=	getBlemishParameter(false);
	if(iresult)	return iresult;

	QColor stblemishcolor		=	QColor::fromRgb(255, 0, 0);
	QHReadWriteLockManage classitemparameterLock(&(itemshareData.itemparameterLock));

	_HisAlg_Debug stdebug;
	stdebug.uipt_x	=	static_cast<unsigned int>(hisglobalparameter.mouse_ptx *static_cast<double>(itemshareData.previewParameter->iWidth));
	stdebug.uipt_y	=	static_cast<unsigned int>(hisglobalparameter.mouse_pty *static_cast<double>(itemshareData.previewParameter->iHeight));

	stLogItem.itemtype		=	classLog->getmaxtypeindex(_HISLOG_CLASSIFY_BLEMISH);
	stLogItem.itemkey		=	"Blemish Result";
	stLogItem.itemvalue	=	"OK";
	QHDefaultLogManage classstLogItem(classLog, &stLogItem, "NG");

	std::vector<RECT> stblemish;
	if(itemshareData.blemishParameter->blemishAlg == _HisAlg_SWITCH_A)
	{
		unsigned char* pucRGB24	=	(unsigned char*)HisAlignedMalloc(itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight *3);
		if(!pucRGB24) return HisFX3Error_MallocBuffer;
		QHisFX3MallocAlignedManage classpucRGB24(pucRGB24);

		if(iresult	=	GetFreshframe(pucRGB24, itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight *3, _FrameType_RGB24, true))
			return iresult;

		iresult	=	classAlgorithm.HisCCMWhitePanel_BlemishHA(pucRGB24, itemshareData.previewParameter->iWidth, \
			itemshareData.previewParameter->iHeight,stblemish, stdebug, \
			itemshareData.blemishParameter->stBlemishHA.blemish_flrange, itemshareData.blemishParameter->stBlemishHA.blemish_ihighpass,\
			itemshareData.blemishParameter->stBlemishHA.blemish_ilowpass, itemshareData.blemishParameter->stBlemishHA.blemish_iamplitude, \
			itemshareData.blemishParameter->stBlemishHA.blemish_idev, itemshareData.blemishParameter->stBlemishHA.blemish_corner);
		if(iresult)	return iresult;
	}
	else if(itemshareData.blemishParameter->blemishAlg == _HisAlg_SWITCH_B)
	{
		_HisAlg_BlemishHA_DebugInfo stZone1Debug[15], stZone2Debug[15], stZone3Debug[15];
		unsigned char* pucBlemishT = NULL;
		if(itemshareData.previewParameter->ucDataFormat >= HisYUV8_422_YUYV && itemshareData.previewParameter->ucDataFormat <= HisYUV8_420P)
		{
			unsigned char* pucYUV	=	(unsigned char*)HisAlignedMalloc(itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight *2);
			QHisFX3MallocAlignedManage classpucYUV(pucYUV);
			unsigned int* bufSum = (unsigned int*)HisAlignedMalloc(itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight *2 *sizeof(unsigned int));
			QHisFX3MallocAlignedManage classbufSum(bufSum);
			if(!pucYUV || !bufSum) return HisFX3Error_MallocBuffer;
			memset(bufSum, 0, itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight *2 *sizeof(unsigned int));
			unsigned int loop = itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight*2;

			for (unsigned int x=0; x<itemshareData.blemishParameter->stBlemishHB.frames; ++x)
			{
				//取得raw图像数据
				if(iresult	=	GetFreshframe(pucYUV, itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight*2, _FrameType_Raw, !x))
					return iresult;
				unsigned int* ps = bufSum;
				unsigned char* py = pucYUV;
				for (unsigned int i=0; i<loop; ++i)
				{
					*ps	+=	*py;
					++ps; ++py;
				}
			}

			unsigned int* ps = bufSum;
			unsigned char* py = pucYUV;
			for (unsigned int i=0; i<loop; ++i)
			{
				*py = *ps / itemshareData.blemishParameter->stBlemishHB.frames;
				++py;  ++ps;
			}

			classAlgorithm.extactYfromYUV422U8(pucYUV, pucYUV, itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight, itemshareData.previewParameter->ucDataFormat);

			pucBlemishT	=	(unsigned char*)HisAlignedMalloc(((itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight) >>2));
			if(!pucBlemishT)  return HisFX3Error_MallocBuffer;
			ROPLOW::FastResize2(pucYUV, pucBlemishT, itemshareData.previewParameter->iWidth, itemshareData.previewParameter->iHeight);
		}
		else if(itemshareData.previewParameter->ucDataFormat == HisRGB_RGB24)
		{
			unsigned char* pucRGB24	=	(unsigned char*)HisAlignedMalloc(itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight *3);			
			QHisFX3MallocAlignedManage classpucRGB24(pucRGB24);
			unsigned int* bufSum = (unsigned int*)HisAlignedMalloc(itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight *3 *sizeof(unsigned int));
			QHisFX3MallocAlignedManage classbufSum(bufSum);
			if(!pucRGB24 || !bufSum) return HisFX3Error_MallocBuffer;
			memset(bufSum, 0, itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight *3 *sizeof(unsigned int));
			unsigned int loop = itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight*3;

			for (unsigned int x=0; x<itemshareData.blemishParameter->stBlemishHB.frames; ++x)
			{
				if(iresult	=	GetFreshframe(pucRGB24, itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight *3, _FrameType_RGB24, !x))
					return iresult;
				unsigned int* ps = bufSum;
				unsigned char* py = pucRGB24;
				for (unsigned int i=0; i<loop; ++i)
				{
					*ps	+=	*py;
					++ps; ++py;
				}
			}

			unsigned int* ps = bufSum;
			unsigned char* py = pucRGB24;
			for (unsigned int i=0; i<loop; ++i)
			{
				*py = *ps / itemshareData.blemishParameter->stBlemishHB.frames;
				++py;  ++ps;
			}

			unsigned int uiPixel = itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight;
			unsigned char* pucDes = pucRGB24, *pucSrc = pucRGB24 +1;
			for(unsigned int x=0; x<uiPixel; ++x){
				*pucDes++	=	*pucSrc;
				pucSrc			+=	3;
			}

			pucBlemishT	=	(unsigned char*)HisAlignedMalloc(((itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight) >>2));
			if(!pucBlemishT)  return HisFX3Error_MallocBuffer;
			ROPLOW::FastResize2(pucRGB24, pucBlemishT, itemshareData.previewParameter->iWidth, itemshareData.previewParameter->iHeight);
		}
		else
		{
			unsigned char* pucBaylor	=	(unsigned char*)HisAlignedMalloc(itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight);
			QHisFX3MallocAlignedManage classpucBaylor(pucBaylor);
			unsigned int* bufSum = (unsigned int*)HisAlignedMalloc(itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight *sizeof(unsigned int));
			QHisFX3MallocAlignedManage classbufSum(bufSum);
			if(!pucBaylor || !bufSum) return HisFX3Error_MallocBuffer;
			memset(bufSum, 0, itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight *sizeof(unsigned int));
			unsigned int loop = itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight;

			for (unsigned int x=0; x<itemshareData.blemishParameter->stBlemishHB.frames; ++x)
			{
				//取得raw图像数据
				if(iresult	=	GetFreshframe(pucBaylor, itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight, _FrameType_Raw, !x))
					return iresult;
				unsigned int* ps = bufSum;
				unsigned char* py = pucBaylor;
				for (unsigned int i=0; i<loop; ++i)
				{
					*ps	+=	*py;
					++ps; ++py;
				}
			}

			unsigned int* ps = bufSum;
			unsigned char* py = pucBaylor;
			for (unsigned int i=0; i<loop; ++i)
			{
				*py = *ps / itemshareData.blemishParameter->stBlemishHB.frames;
				++py;  ++ps;
			}

			pucBlemishT	=	(unsigned char*)HisAlignedMalloc(((itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight) >>2));
			if(!pucBlemishT)  return HisFX3Error_MallocBuffer;
			unsigned char* pucLine, *pucData, *pucDes = pucBlemishT;

			switch (itemshareData.previewParameter->ucDataFormat)
			{
			case HisBaylor8_BGGR:
			case HisBaylor10_BGGR:
			case HisBaylor12_BGGR:
				pucLine	=	pucBaylor + itemshareData.previewParameter->iWidth;
				break;
			case HisBaylor8_RGGB:
			case HisBaylor10_RGGB:
			case HisBaylor12_RGGB:
				pucLine	=	pucBaylor +1;
				break;
			case HisBaylor8_GBRG:
			case HisBaylor10_GBRG:
			case HisBaylor12_GBRG:
				pucLine	=	pucBaylor + itemshareData.previewParameter->iWidth +1;
				break;
			case HisBaylor8_GRBG:
			case HisBaylor10_GRBG:
			case HisBaylor12_GRBG:
				pucLine	=	pucBaylor;
				break;
			default:
				emit information("Data Format: " % QString::number(itemshareData.previewParameter->ucDataFormat));
				return HisFX3Error_Parameter;
				break;
			}

			unsigned int uiLineByte	=	itemshareData.previewParameter->iWidth *2;
			for(unsigned int y=0;	y<itemshareData.previewParameter->iHeight;	y+=2)
			{
				pucData	=	pucLine;
				pucLine	+=	uiLineByte;
				for(unsigned int x=0;	x<itemshareData.previewParameter->iWidth;	x+=2)
				{
					*pucDes++	=	*pucData;
					pucData		+=	2;
				}
			}
		}

		float blemishhb_Zone1Spec[15], blemishhb_Zone3Spec[15], blemishhb_Zone2Spec[15];
		memcpy(blemishhb_Zone1Spec, itemshareData.blemishParameter->stBlemishHB.blemishhb_Zone1Spec, 15 *sizeof(float));
		memcpy(blemishhb_Zone2Spec, itemshareData.blemishParameter->stBlemishHB.blemishhb_Zone2Spec, 15 *sizeof(float));
		memcpy(blemishhb_Zone3Spec, itemshareData.blemishParameter->stBlemishHB.blemishhb_Zone3Spec, 15 *sizeof(float));
		for(unsigned int i=0; i<15; ++i) { blemishhb_Zone2Spec[i] = 999999.0f; }

		iresult = classAlgorithm.HisCCMWhitePanel_BlemishHB(pucBlemishT, (itemshareData.previewParameter->iWidth>>1), \
			(itemshareData.previewParameter->iHeight>>1), itemshareData.blemishParameter->stBlemishHB.blemishhb_Zone1Range, \
			(itemshareData.blemishParameter->stBlemishHB.blemishhb_Zone3X>>1), (itemshareData.blemishParameter->stBlemishHB.blemishhb_Zone3Y>>1), \
			blemishhb_Zone1Spec, blemishhb_Zone3Spec, \
			blemishhb_Zone2Spec, stblemish, itemshareData.blemishParameter->stBlemishHB.blemishhb_RemoveDefectPixel, \
			hisglobalparameter.bDebugMode,stZone1Debug, stZone2Debug, stZone3Debug);
		HisReleaseMalloc(pucBlemishT);
		if(iresult)	return iresult;

		if(hisglobalparameter.bDebugMode)
		{
			QString strTempText;
			RECT stCenter;
			int x	=	static_cast<int>(itemshareData.previewParameter->iWidth *itemshareData.blemishParameter->stBlemishHB.blemishhb_Zone1Range);
			int y	=	static_cast<int>(itemshareData.previewParameter->iHeight *itemshareData.blemishParameter->stBlemishHB.blemishhb_Zone1Range);
			stCenter.left				=	((itemshareData.previewParameter->iWidth - x) >>1);
			stCenter.right			=	((itemshareData.previewParameter->iWidth + x) >>1);
			stCenter.top			=	((itemshareData.previewParameter->iHeight - y) >>1);
			stCenter.bottom		=	((itemshareData.previewParameter->iHeight + y) >>1);
			emit information(QTextCodec::codecForName( "GBK")->toUnicode("污点中心测试区域位置:(ROI:") % \
				QString::number(stCenter.left) % "," % QString::number(stCenter.top) % "," % \
				QString::number(stCenter.right) % "," % QString::number(stCenter.bottom) % ")");
			for(unsigned int x=0;	x<15;	++x){
				strTempText		=	QString::number((x+1)*8) % "x" % QString::number((x+1)*8);
				emit information(QTextCodec::codecForName( "GBK")->toUnicode("污点中心区域") % \
					strTempText % QTextCodec::codecForName( "GBK")->toUnicode("调试信息：") % " (ROI:" % \
					QString::number(stZone1Debug[x].stroi.left) % "," % QString::number(stZone1Debug[x].stroi.top) % \
					"," % QString::number(stZone1Debug[x].stroi.right) % "," %QString::number(stZone1Debug[x].stroi.bottom) % \
					") " % QTextCodec::codecForName( "GBK")->toUnicode("值：") % QString::number(stZone1Debug[x].flvalue));
			}
			for(unsigned int x=0;	x<15;	++x){
				strTempText		=	QString::number((x+1)*8) % "x" % QString::number((x+1)*8);
				emit information(QTextCodec::codecForName( "GBK")->toUnicode("污点其余区域") % \
					strTempText % QTextCodec::codecForName( "GBK")->toUnicode("调试信息：") % " (ROI:" % \
					QString::number(stZone2Debug[x].stroi.left) % "," % QString::number(stZone2Debug[x].stroi.top) % \
					"," % QString::number(stZone2Debug[x].stroi.right) % "," %QString::number(stZone2Debug[x].stroi.bottom) % \
					") " % QTextCodec::codecForName( "GBK")->toUnicode("值：") % QString::number(stZone2Debug[x].flvalue));
			}
			stCenter.left			=	stCenter.top	=	0;
			stCenter.right		=	itemshareData.blemishParameter->stBlemishHB.blemishhb_Zone3X;
			stCenter.bottom	=	itemshareData.blemishParameter->stBlemishHB.blemishhb_Zone3Y;
			emit information(QTextCodec::codecForName( "GBK")->toUnicode("污点左上角测试区域位置:(ROI:") % \
				QString::number(stCenter.left) % "," % QString::number(stCenter.top) % "," % \
				QString::number(stCenter.right) % "," % QString::number(stCenter.bottom) % ")");				
			stCenter.left			=	itemshareData.previewParameter->iWidth - itemshareData.blemishParameter->stBlemishHB.blemishhb_Zone3X;
			stCenter.right		=	itemshareData.previewParameter->iWidth;
			stCenter.top		=	0;
			stCenter.bottom	=	itemshareData.blemishParameter->stBlemishHB.blemishhb_Zone3Y;
			emit information(QTextCodec::codecForName( "GBK")->toUnicode("污点右上角测试区域位置:(ROI:") % \
				QString::number(stCenter.left) % "," % QString::number(stCenter.top) % "," % \
				QString::number(stCenter.right) % "," % QString::number(stCenter.bottom) % ")");	
			stCenter.left			=	0;
			stCenter.right		=	itemshareData.blemishParameter->stBlemishHB.blemishhb_Zone3X;
			stCenter.top		=	itemshareData.previewParameter->iHeight - itemshareData.blemishParameter->stBlemishHB.blemishhb_Zone3Y;
			stCenter.bottom	=	itemshareData.previewParameter->iHeight;
			emit information(QTextCodec::codecForName( "GBK")->toUnicode("污点左下角测试区域位置:(ROI:") % \
				QString::number(stCenter.left) % "," % QString::number(stCenter.top) % "," % \
				QString::number(stCenter.right) % "," % QString::number(stCenter.bottom) % ")");	
			stCenter.left			=	itemshareData.previewParameter->iWidth - itemshareData.blemishParameter->stBlemishHB.blemishhb_Zone3X;
			stCenter.right		=	itemshareData.previewParameter->iWidth;
			stCenter.top		=	itemshareData.previewParameter->iHeight - itemshareData.blemishParameter->stBlemishHB.blemishhb_Zone3Y;
			stCenter.bottom	=	itemshareData.previewParameter->iHeight;
			emit information(QTextCodec::codecForName( "GBK")->toUnicode("污点右下角测试区域位置:(ROI:") % \
				QString::number(stCenter.left) % "," % QString::number(stCenter.top) % "," % \
				QString::number(stCenter.right) % "," % QString::number(stCenter.bottom) % ")");	
			for(unsigned int x=0;	x<15;	++x){
				strTempText		=	QString::number((x+1)*8) % "x" % QString::number((x+1)*8);
				emit information(QTextCodec::codecForName( "GBK")->toUnicode("污点四角区域") % \
					strTempText % QTextCodec::codecForName( "GBK")->toUnicode("调试信息：") % " (ROI:" % \
					QString::number(stZone3Debug[x].stroi.left) % "," % QString::number(stZone3Debug[x].stroi.top) % \
					"," % QString::number(stZone3Debug[x].stroi.right) % "," %QString::number(stZone3Debug[x].stroi.bottom) % \
					") " % QTextCodec::codecForName( "GBK")->toUnicode("值：") % QString::number(stZone3Debug[x].flvalue));
			}
		}
	}
	else if(itemshareData.blemishParameter->blemishAlg == _HisAlg_SWITCH_C)
	{
		unsigned char* pucRGB24 = (unsigned char*)HisAlignedMalloc(itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight *3);
		QHisFX3MallocAlignedManage classpucRGB24(pucRGB24);
		unsigned char* pucR	=	(unsigned char*)HisAlignedMalloc(itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight);
		QHisFX3MallocAlignedManage classpucR(pucR);
		unsigned char* pucG	=	(unsigned char*)HisAlignedMalloc(itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight);
		QHisFX3MallocAlignedManage classpucG(pucG);
		unsigned char* pucB	=	(unsigned char*)HisAlignedMalloc(itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight);
		QHisFX3MallocAlignedManage classpucB(pucB);
		unsigned int* bufSum = (unsigned int*)HisAlignedMalloc(itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight *3 *sizeof(unsigned int));
		QHisFX3MallocAlignedManage classbufSum(bufSum);
		if(!(pucRGB24 && pucR && pucG && pucB && bufSum))  return HisFX3Error_MallocBuffer;
		memset(bufSum, 0, itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight *3 *sizeof(unsigned int));
		unsigned int loop = itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight*3;

		for (unsigned int x=0; x<itemshareData.blemishParameter->stBlemishHB.frames; ++x)
		{
			if(iresult = GetFreshframe(pucRGB24, itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight *3, _FrameType_RGB24, !x))
				return iresult;
			unsigned int* ps = bufSum;
			unsigned char* py = pucRGB24;
			for (unsigned int i=0; i<loop; ++i)
			{
				*ps	+=	*py;
				++ps; ++py;
			}
		}

		unsigned int* ps = bufSum;
		unsigned char* py = pucRGB24;
		for (unsigned int i=0; i<loop; ++i)
		{
			*py = *ps / itemshareData.blemishParameter->stBlemishHB.frames;
			++py;  ++ps;
		}

		ROPLOW::extractrgb24(pucRGB24, pucR, pucG, pucB, itemshareData.previewParameter->iWidth, itemshareData.previewParameter->iHeight);
		std::vector<_HisCCMAlg_BlemishHC_Blemish> vecBlemish;
		if(iresult = classAlgorithm.HisCCMWhitePanel_BlemishHC(pucR, pucG, pucB, itemshareData.previewParameter->iWidth, \
			itemshareData.previewParameter->iHeight, itemshareData.blemishParameter->stBlemishHC.stSpec, vecBlemish, \
			itemshareData.blemishParameter->stBlemishHC.flEdgeZone, itemshareData.blemishParameter->stBlemishHC.flCornerZone,itemshareData.blemishParameter->stBlemishHC.flAreaMin, \
			itemshareData.blemishParameter->stBlemishHC.flAreaMax, false, itemshareData.blemishParameter->stBlemishHC.flTuning, \
			false, true))
			return iresult;

		if(vecBlemish.size())
		{
			stLogItem.itemvalue	=	"NG";
			iresult	=	HisCCMError_Result;
			itemshareData.drawLock.lockForWrite();
			int ilastcount	=	itemshareData.itemdrawList.size();
			itemshareData.itemdrawList.resize(ilastcount + vecBlemish.size());
			std::vector<_itemDraw>::iterator drawIterator	=	itemshareData.itemdrawList.begin() +ilastcount;
			for(std::vector<_HisCCMAlg_BlemishHC_Blemish>::iterator theiterator = vecBlemish.begin(); theiterator != vecBlemish.end(); theiterator++){
				drawIterator->usitem				=	whitepanelitem_blemish;
				drawIterator->uctype				=	HisDrawType_Block;
				drawIterator->stcolor				=	stblemishcolor;
				drawIterator->strinfo.stblock	=	theiterator->stROI;
				if(hisglobalparameter.bDebugMode){
					QString strZone	=	tr("Edge");
					if(theiterator->uiSpecIndex < 10) strZone = QString::number(theiterator->uiSpecIndex + 1);
					emit information(tr("Blemish: ") % ROPLOW::rect2qstring(theiterator->stROI) % tr("   Brightness: ") % \
						QString::number(theiterator->flLux, 'f', 6) % tr("   Color: ") % QString::number(theiterator->flColor, 'f', 6) % \
						tr("   Zone: ") % strZone);
				}
				drawIterator++;
			}
			itemshareData.drawLock.unlock();
		}
	}
	else if(itemshareData.blemishParameter->blemishAlg == _HisAlg_SWITCH_D)
	{
		QString strDllPath = QDir::currentPath() % "/SRITDLL/BIGMESH_Dll";
		typedef int (*RRT_RSBT_rsbt_run_mem)(unsigned short *,char *,char *,unsigned short,void *,double *);
#ifdef _WIN64
		RRT_RSBT_rsbt_run_mem  RSBT_rsbt_run_mem = (RRT_RSBT_rsbt_run_mem)(QLibrary::resolve(strDllPath, "?RSBT_rsbt_run_mem@@YAHPEAGPEAD1GPEAXPEAN@Z"));
#else
		RRT_RSBT_rsbt_run_mem  RSBT_rsbt_run_mem = (RRT_RSBT_rsbt_run_mem)(QLibrary::resolve(strDllPath, "?RSBT_rsbt_run_mem@@YAHPAGPAD1GPAXPAN@Z"));
#endif
		if(!RSBT_rsbt_run_mem){
			emit information(strDllPath % " load RSBT_rsbt_run_mem fail");
			return HisCCMError_LoadDLLFuc;
		}

		unsigned short* pusBaylor	=	(unsigned short*)HisAlignedMalloc(itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight *2);
		if(!pusBaylor) return HisFX3Error_MallocBuffer;
		QHisFX3MallocAlignedManage classpusBaylor(pusBaylor);

		//取得raw图像数据
		if(iresult	=	GetFreshframe((unsigned char*)pusBaylor, itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight *2, _FrameType_Raw10, true))
			return iresult;

		QString strRawInfo = QDir::currentPath() % "/SRITDLL/" % itemshareData.blemishParameter->stBlemishHD.strRawInfo;
		if(!QFile::exists(strRawInfo)){
			emit information(strRawInfo % " is not exist");
			return HisCCMError_FilePath;
		}

		QString strOptPath = QDir::currentPath() % "/SRITDLL/" % itemshareData.blemishParameter->stBlemishHD.strOptionBin;
		if(!QFile::exists(strOptPath)){
			emit information(strOptPath % " is not exist");
			return HisCCMError_FilePath;
		}

		const unsigned short RSBT_DATACODE = 0xAB;
		typedef struct __rsbt_detect_data_type 
		{ 
			unsigned short i_category; 
			unsigned short i_size; 
			unsigned short i_st_X; 
			unsigned short i_st_Y; 
			unsigned short i_ed_X; 
			unsigned short i_ed_Y; 
		} rsbt_detect_data_type;

		const unsigned int NUM_OF_DETECT	=	100;
		rsbt_detect_data_type Detect[NUM_OF_DETECT]; 
		double Edge_MaxDiff; 
		for(unsigned int _i = 0; _i < NUM_OF_DETECT; _i++) 
		{ 
			Detect[_i].i_category = RSBT_DATACODE; // 1 : Stain , 2 : Blemish 
			Detect[_i].i_size = RSBT_DATACODE; 
			Detect[_i].i_st_X = RSBT_DATACODE;
			Detect[_i].i_st_Y = RSBT_DATACODE; 
			Detect[_i].i_ed_X = RSBT_DATACODE; 
			Detect[_i].i_ed_Y = RSBT_DATACODE; 
		}

		int Err = RSBT_rsbt_run_mem(pusBaylor, strRawInfo.toAscii().data(), strOptPath.toAscii().data(),NUM_OF_DETECT, (void*)&Detect, &Edge_MaxDiff);
		if(Err != 0)
		{
			emit information("RSBT_rsbt_run_mem return:" % QString::number(Err));
			return HisCCMError_OtpFucExec;
		}

		unsigned int uiDrawCount	=	0;

		char strText[128];
		for(unsigned int x=0;	x<NUM_OF_DETECT; ++x)
		{
			if(Detect[x].i_category == RSBT_DATACODE)  break; 
			++uiDrawCount;
			sprintf(strText, "%d %d %d %d %d %d \r\n" , Detect[x].i_category, Detect[x].i_size , Detect[x].i_st_X, Detect[x].i_st_Y, Detect[x].i_ed_X, Detect[x].i_ed_Y);
			emit information(QString::fromAscii(strText));
		}

		emit information("Max Edge Diff: " % QString::number(Edge_MaxDiff));
		if(Edge_MaxDiff > itemshareData.blemishParameter->stBlemishHD.dflMaxEdgeDiff || uiDrawCount){
			iresult	=	HisCCMError_Result;
			stLogItem.itemvalue	=	"NG";
		}

		classstLogItem.SubRef();
		classLog->push_back(stLogItem);
		++(stLogItem.itemtype); stLogItem.itemkey = "Max_Edge_Diff"; stLogItem.itemvalue = Edge_MaxDiff; classLog->push_back(stLogItem);
		++(stLogItem.itemtype); stLogItem.itemkey = "Blemish_Detected"; stLogItem.itemvalue = uiDrawCount; classLog->push_back(stLogItem);


		if(uiDrawCount)
		{
			uiDrawCount = min(uiDrawCount, 20);
			itemshareData.drawLock.lockForWrite();
			int ilastcount	=	itemshareData.itemdrawList.size();
			itemshareData.itemdrawList.resize(ilastcount + uiDrawCount);
			theIterator	=	itemshareData.itemdrawList.begin() +ilastcount;
			for(int i=0;	i<uiDrawCount;	++i)
			{
				theIterator->usitem	=	whitepanelitem_blemish;
				theIterator->uctype	=	HisDrawType_Block;
				theIterator->stcolor	=	stblemishcolor;
				theIterator->strinfo.stblock.left		=	Detect[i].i_st_X;
				theIterator->strinfo.stblock.right		=	Detect[i].i_ed_X;
				theIterator->strinfo.stblock.top		=	Detect[i].i_st_Y;
				theIterator->strinfo.stblock.bottom	=	Detect[i].i_ed_Y;
				// 				emit information(QTextCodec::codecForName( "GBK")->toUnicode("污点") % QString::number(i+1, 10) % ":    " % \
				// 					QTextCodec::codecForName( "GBK")->toUnicode("左上(") % QString::number(theIterator->strinfo.stblock.left, 10) % \
				// 					"," % QString::number(theIterator->strinfo.stblock.top, 10) % QTextCodec::codecForName( "GBK")->toUnicode(")    右下(") % \
				// 					QString::number(theIterator->strinfo.stblock.right, 10) % "," % QString::number(theIterator->strinfo.stblock.bottom, 10) % ")");
				theIterator++;
			}
			itemshareData.drawLock.unlock();
		}
	}

	if(stblemish.size() && itemshareData.blemishParameter->blemishAlg != _HisAlg_SWITCH_C)
	{
		iresult	=	HisCCMError_Result;
		itemshareData.drawLock.lockForWrite();
		int ilastcount	=	itemshareData.itemdrawList.size();
		itemshareData.itemdrawList.resize(ilastcount + stblemish.size());
		theIterator	=	itemshareData.itemdrawList.begin() +ilastcount;
		for(int i=0;	i<stblemish.size();	++i){
			theIterator->usitem	=	whitepanelitem_blemish;
			theIterator->uctype	=	HisDrawType_Block;
			theIterator->stcolor	=	stblemishcolor;
			theIterator->strinfo.stblock	=	stblemish.at(i);
			emit information(QTextCodec::codecForName( "GBK")->toUnicode("污点") % QString::number(i+1, 10) % ":    " % \
				QTextCodec::codecForName( "GBK")->toUnicode("左上(") % QString::number(theIterator->strinfo.stblock.left, 10) % \
				"," % QString::number(theIterator->strinfo.stblock.top, 10) % QTextCodec::codecForName( "GBK")->toUnicode(")    右下(") % \
				QString::number(theIterator->strinfo.stblock.right, 10) % "," % QString::number(theIterator->strinfo.stblock.bottom, 10) % ")");
			theIterator++;
		}
		itemshareData.drawLock.unlock();

		stLogItem.itemvalue	=	"NG";
	}

	if(itemshareData.blemishParameter->blemishAlg != _HisAlg_SWITCH_D)
	{
		classstLogItem.SubRef();
		classLog->push_back(stLogItem);
	}

	//output debug info
	if(stdebug.stlist.size() > 0)
	{
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("点(") % QString::number(stdebug.uipt_x, 10) % \
			"," % QString::number(stdebug.uipt_y, 10) % QTextCodec::codecForName( "GBK")->toUnicode(")调试信息："));
		for(int i=0;	i<stdebug.stlist.size(); ++i){
			switch (stdebug.stlist.at(i).ustype){
			case HisAlg_WhitePanel_Blemish_Corner:
				break;
			case HisAlg_WhitePanel_Blemish_Amplitude:
				emit information(QTextCodec::codecForName( "GBK")->toUnicode("      污点测试-振幅：") % \
					QString::number(static_cast<double>(stdebug.stlist.at(i).dflvalue), 'f', 6));
				break;
			case HisAlg_WhitePanel_Blemish_Dev:
				emit information(QTextCodec::codecForName( "GBK")->toUnicode("      污点测试-方差：") % \
					QString::number(static_cast<double>(stdebug.stlist.at(i).dflvalue), 'f', 6));
				break;
			case HisAlg_WhitePanel_Color_Uniform:
				emit information(QTextCodec::codecForName( "GBK")->toUnicode("      颜色均匀测试-差异：") % \
					QString::number(static_cast<double>(stdebug.stlist.at(i).dflvalue), 'f', 6));
				break;
			default:
				break;
			}
		}
		stdebug.stlist.clear();
	}

	return iresult;
}

int itemprocess::blemishb()
{
	//判断图像是否点亮中
	if(!threadshareData.GetHisPreviewflag())	return HisCCMError_NotPreivew;

	std::vector<_itemDraw>::iterator theIterator;
	itemshareData.clearDrawList();

	//取得配置参数和规格
	int iresult	=	getBlemishParameter(false);
	if(iresult)	return iresult;

	QColor stblemishcolor		=	QColor::fromRgb(255, 0, 0);
	QHReadWriteLockManage classitemparameterLock(&(itemshareData.itemparameterLock));

	_HisAlg_Debug stdebug;
	stdebug.uipt_x	=	static_cast<unsigned int>(hisglobalparameter.mouse_ptx *static_cast<double>(itemshareData.previewParameter->iWidth));
	stdebug.uipt_y	=	static_cast<unsigned int>(hisglobalparameter.mouse_pty *static_cast<double>(itemshareData.previewParameter->iHeight));

	stLogItem.itemtype		=	classLog->getmaxtypeindex(_HISLOG_CLASSIFY_BLEMISH);
	stLogItem.itemkey		=	"Blemish Result";
	stLogItem.itemvalue	=	"OK";
	QHDefaultLogManage classstLogItem(classLog, &stLogItem, "NG");

	std::vector<RECT> stblemish;
	if(itemshareData.blemishParameter->blemishAlg == _HisAlg_SWITCH_A)
	{
		unsigned char* pucRGB24	=	(unsigned char*)HisAlignedMalloc(itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight *3);
		if(!pucRGB24) return HisFX3Error_MallocBuffer;
		QHisFX3MallocAlignedManage classpucRGB24(pucRGB24);

		if(iresult	=	GetFreshframe(pucRGB24, itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight *3, _FrameType_RGB24, true))
			return iresult;

		iresult	=	classAlgorithm.HisCCMWhitePanel_BlemishHA(pucRGB24, itemshareData.previewParameter->iWidth, \
			itemshareData.previewParameter->iHeight,stblemish, stdebug, \
			itemshareData.blemishParameter->stBlemishHA.blemish_flrange, itemshareData.blemishParameter->stBlemishHA.blemish_ihighpass,\
			itemshareData.blemishParameter->stBlemishHA.blemish_ilowpass, itemshareData.blemishParameter->stBlemishHA.blemish_iamplitude, \
			itemshareData.blemishParameter->stBlemishHA.blemish_idev, itemshareData.blemishParameter->stBlemishHA.blemish_corner);
		if(iresult)	return iresult;
	}
	else if(itemshareData.blemishParameter->blemishAlg == _HisAlg_SWITCH_B)
	{
		_HisAlg_BlemishHA_DebugInfo stZone1Debug[15], stZone2Debug[15], stZone3Debug[15];
		unsigned char* pucBlemishT = NULL;
		if(itemshareData.previewParameter->ucDataFormat >= HisYUV8_422_YUYV && itemshareData.previewParameter->ucDataFormat <= HisYUV8_420P)
		{
			unsigned char* pucYUV	=	(unsigned char*)HisAlignedMalloc(itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight *2);
			QHisFX3MallocAlignedManage classpucYUV(pucYUV);
			unsigned int* bufSum = (unsigned int*)HisAlignedMalloc(itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight *2 *sizeof(unsigned int));
			QHisFX3MallocAlignedManage classbufSum(bufSum);
			if(!pucYUV || !bufSum) return HisFX3Error_MallocBuffer;
			memset(bufSum, 0, itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight *2 *sizeof(unsigned int));
			unsigned int loop = itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight*2;

			for (unsigned int x=0; x<itemshareData.blemishParameter->stBlemishHB.frames; ++x)
			{
				//取得raw图像数据
				if(iresult	=	GetFreshframe(pucYUV, itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight*2, _FrameType_Raw, !x))
					return iresult;
				unsigned int* ps = bufSum;
				unsigned char* py = pucYUV;
				for (unsigned int i=0; i<loop; ++i)
				{
					*ps	+=	*py;
					++ps; ++py;
				}
			}

			unsigned int* ps = bufSum;
			unsigned char* py = pucYUV;
			for (unsigned int i=0; i<loop; ++i)
			{
				*py = *ps / itemshareData.blemishParameter->stBlemishHB.frames;
				++py;  ++ps;
			}

			classAlgorithm.extactYfromYUV422U8(pucYUV, pucYUV, itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight, itemshareData.previewParameter->ucDataFormat);

			pucBlemishT	=	(unsigned char*)HisAlignedMalloc(((itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight) >>2));
			if(!pucBlemishT)  return HisFX3Error_MallocBuffer;
			ROPLOW::FastResize2(pucYUV, pucBlemishT, itemshareData.previewParameter->iWidth, itemshareData.previewParameter->iHeight);
		}
		else if(itemshareData.previewParameter->ucDataFormat == HisRGB_RGB24)
		{
			unsigned char* pucRGB24	=	(unsigned char*)HisAlignedMalloc(itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight *3);			
			QHisFX3MallocAlignedManage classpucRGB24(pucRGB24);
			unsigned int* bufSum = (unsigned int*)HisAlignedMalloc(itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight *3 *sizeof(unsigned int));
			QHisFX3MallocAlignedManage classbufSum(bufSum);
			if(!pucRGB24 || !bufSum) return HisFX3Error_MallocBuffer;
			memset(bufSum, 0, itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight *3 *sizeof(unsigned int));
			unsigned int loop = itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight*3;

			for (unsigned int x=0; x<itemshareData.blemishParameter->stBlemishHB.frames; ++x)
			{
				if(iresult	=	GetFreshframe(pucRGB24, itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight *3, _FrameType_RGB24, !x))
					return iresult;
				unsigned int* ps = bufSum;
				unsigned char* py = pucRGB24;
				for (unsigned int i=0; i<loop; ++i)
				{
					*ps	+=	*py;
					++ps; ++py;
				}
			}

			unsigned int* ps = bufSum;
			unsigned char* py = pucRGB24;
			for (unsigned int i=0; i<loop; ++i)
			{
				*py = *ps / itemshareData.blemishParameter->stBlemishHB.frames;
				++py;  ++ps;
			}

			unsigned int uiPixel = itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight;
			unsigned char* pucDes = pucRGB24, *pucSrc = pucRGB24 +1;
			for(unsigned int x=0; x<uiPixel; ++x){
				*pucDes++	=	*pucSrc;
				pucSrc			+=	3;
			}

			pucBlemishT	=	(unsigned char*)HisAlignedMalloc(((itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight) >>2));
			if(!pucBlemishT)  return HisFX3Error_MallocBuffer;
			ROPLOW::FastResize2(pucRGB24, pucBlemishT, itemshareData.previewParameter->iWidth, itemshareData.previewParameter->iHeight);
		}
		else
		{
			unsigned char* pucBaylor	=	(unsigned char*)HisAlignedMalloc(itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight);
			QHisFX3MallocAlignedManage classpucBaylor(pucBaylor);
			unsigned int* bufSum = (unsigned int*)HisAlignedMalloc(itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight *sizeof(unsigned int));
			QHisFX3MallocAlignedManage classbufSum(bufSum);
			if(!pucBaylor || !bufSum) return HisFX3Error_MallocBuffer;
			memset(bufSum, 0, itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight *sizeof(unsigned int));
			unsigned int loop = itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight;

			for (unsigned int x=0; x<itemshareData.blemishParameter->stBlemishHB.frames; ++x)
			{
				//取得raw图像数据
				if(iresult	=	GetFreshframe(pucBaylor, itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight, _FrameType_Raw, !x))
					return iresult;
				unsigned int* ps = bufSum;
				unsigned char* py = pucBaylor;
				for (unsigned int i=0; i<loop; ++i)
				{
					*ps	+=	*py;
					++ps; ++py;
				}
			}

			unsigned int* ps = bufSum;
			unsigned char* py = pucBaylor;
			for (unsigned int i=0; i<loop; ++i)
			{
				*py = *ps / itemshareData.blemishParameter->stBlemishHB.frames;
				++py;  ++ps;
			}

			pucBlemishT	=	(unsigned char*)HisAlignedMalloc(((itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight) >>2));
			if(!pucBlemishT)  return HisFX3Error_MallocBuffer;
			unsigned char* pucLine, *pucData, *pucDes = pucBlemishT;

			switch (itemshareData.previewParameter->ucDataFormat)
			{
			case HisBaylor8_BGGR:
			case HisBaylor10_BGGR:
			case HisBaylor12_BGGR:
				pucLine	=	pucBaylor + itemshareData.previewParameter->iWidth;
				break;
			case HisBaylor8_RGGB:
			case HisBaylor10_RGGB:
			case HisBaylor12_RGGB:
				pucLine	=	pucBaylor +1;
				break;
			case HisBaylor8_GBRG:
			case HisBaylor10_GBRG:
			case HisBaylor12_GBRG:
				pucLine	=	pucBaylor + itemshareData.previewParameter->iWidth +1;
				break;
			case HisBaylor8_GRBG:
			case HisBaylor10_GRBG:
			case HisBaylor12_GRBG:
				pucLine	=	pucBaylor;
				break;
			default:
				emit information("Data Format: " % QString::number(itemshareData.previewParameter->ucDataFormat));
				return HisFX3Error_Parameter;
				break;
			}

			unsigned int uiLineByte	=	itemshareData.previewParameter->iWidth *2;
			for(unsigned int y=0;	y<itemshareData.previewParameter->iHeight;	y+=2)
			{
				pucData	=	pucLine;
				pucLine	+=	uiLineByte;
				for(unsigned int x=0;	x<itemshareData.previewParameter->iWidth;	x+=2)
				{
					*pucDes++	=	*pucData;
					pucData		+=	2;
				}
			}
		}

		float blemishhb_Zone1Spec[15], blemishhb_Zone3Spec[15], blemishhb_Zone2Spec[15];
		memcpy(blemishhb_Zone1Spec, itemshareData.blemishParameter->stBlemishHB.blemishhb_Zone1Spec, 15 *sizeof(float));
		memcpy(blemishhb_Zone2Spec, itemshareData.blemishParameter->stBlemishHB.blemishhb_Zone2Spec, 15 *sizeof(float));
		memcpy(blemishhb_Zone3Spec, itemshareData.blemishParameter->stBlemishHB.blemishhb_Zone3Spec, 15 *sizeof(float));
		for(unsigned int i=0; i<15; ++i) { blemishhb_Zone1Spec[i] = 999999.0f; blemishhb_Zone3Spec[i] = 999999.0f; }

		iresult = classAlgorithm.HisCCMWhitePanel_BlemishHB(pucBlemishT, (itemshareData.previewParameter->iWidth>>1), \
			(itemshareData.previewParameter->iHeight>>1), itemshareData.blemishParameter->stBlemishHB.blemishhb_Zone1Range, \
			(itemshareData.blemishParameter->stBlemishHB.blemishhb_Zone3X>>1), (itemshareData.blemishParameter->stBlemishHB.blemishhb_Zone3Y>>1), \
			blemishhb_Zone1Spec, blemishhb_Zone3Spec, \
			blemishhb_Zone2Spec, stblemish, itemshareData.blemishParameter->stBlemishHB.blemishhb_RemoveDefectPixel, \
			hisglobalparameter.bDebugMode,stZone1Debug, stZone2Debug, stZone3Debug);
		HisReleaseMalloc(pucBlemishT);
		if(iresult)	return iresult;

		if(hisglobalparameter.bDebugMode)
		{
			QString strTempText;
			RECT stCenter;
			int x	=	static_cast<int>(itemshareData.previewParameter->iWidth *itemshareData.blemishParameter->stBlemishHB.blemishhb_Zone1Range);
			int y	=	static_cast<int>(itemshareData.previewParameter->iHeight *itemshareData.blemishParameter->stBlemishHB.blemishhb_Zone1Range);
			stCenter.left				=	((itemshareData.previewParameter->iWidth - x) >>1);
			stCenter.right			=	((itemshareData.previewParameter->iWidth + x) >>1);
			stCenter.top			=	((itemshareData.previewParameter->iHeight - y) >>1);
			stCenter.bottom		=	((itemshareData.previewParameter->iHeight + y) >>1);
			emit information(QTextCodec::codecForName( "GBK")->toUnicode("污点中心测试区域位置:(ROI:") % \
				QString::number(stCenter.left) % "," % QString::number(stCenter.top) % "," % \
				QString::number(stCenter.right) % "," % QString::number(stCenter.bottom) % ")");
			for(unsigned int x=0;	x<15;	++x){
				strTempText		=	QString::number((x+1)*8) % "x" % QString::number((x+1)*8);
				emit information(QTextCodec::codecForName( "GBK")->toUnicode("污点中心区域") % \
					strTempText % QTextCodec::codecForName( "GBK")->toUnicode("调试信息：") % " (ROI:" % \
					QString::number(stZone1Debug[x].stroi.left) % "," % QString::number(stZone1Debug[x].stroi.top) % \
					"," % QString::number(stZone1Debug[x].stroi.right) % "," %QString::number(stZone1Debug[x].stroi.bottom) % \
					") " % QTextCodec::codecForName( "GBK")->toUnicode("值：") % QString::number(stZone1Debug[x].flvalue));
			}
			for(unsigned int x=0;	x<15;	++x){
				strTempText		=	QString::number((x+1)*8) % "x" % QString::number((x+1)*8);
				emit information(QTextCodec::codecForName( "GBK")->toUnicode("污点其余区域") % \
					strTempText % QTextCodec::codecForName( "GBK")->toUnicode("调试信息：") % " (ROI:" % \
					QString::number(stZone2Debug[x].stroi.left) % "," % QString::number(stZone2Debug[x].stroi.top) % \
					"," % QString::number(stZone2Debug[x].stroi.right) % "," %QString::number(stZone2Debug[x].stroi.bottom) % \
					") " % QTextCodec::codecForName( "GBK")->toUnicode("值：") % QString::number(stZone2Debug[x].flvalue));
			}
			stCenter.left			=	stCenter.top	=	0;
			stCenter.right		=	itemshareData.blemishParameter->stBlemishHB.blemishhb_Zone3X;
			stCenter.bottom	=	itemshareData.blemishParameter->stBlemishHB.blemishhb_Zone3Y;
			emit information(QTextCodec::codecForName( "GBK")->toUnicode("污点左上角测试区域位置:(ROI:") % \
				QString::number(stCenter.left) % "," % QString::number(stCenter.top) % "," % \
				QString::number(stCenter.right) % "," % QString::number(stCenter.bottom) % ")");				
			stCenter.left			=	itemshareData.previewParameter->iWidth - itemshareData.blemishParameter->stBlemishHB.blemishhb_Zone3X;
			stCenter.right		=	itemshareData.previewParameter->iWidth;
			stCenter.top		=	0;
			stCenter.bottom	=	itemshareData.blemishParameter->stBlemishHB.blemishhb_Zone3Y;
			emit information(QTextCodec::codecForName( "GBK")->toUnicode("污点右上角测试区域位置:(ROI:") % \
				QString::number(stCenter.left) % "," % QString::number(stCenter.top) % "," % \
				QString::number(stCenter.right) % "," % QString::number(stCenter.bottom) % ")");	
			stCenter.left			=	0;
			stCenter.right		=	itemshareData.blemishParameter->stBlemishHB.blemishhb_Zone3X;
			stCenter.top		=	itemshareData.previewParameter->iHeight - itemshareData.blemishParameter->stBlemishHB.blemishhb_Zone3Y;
			stCenter.bottom	=	itemshareData.previewParameter->iHeight;
			emit information(QTextCodec::codecForName( "GBK")->toUnicode("污点左下角测试区域位置:(ROI:") % \
				QString::number(stCenter.left) % "," % QString::number(stCenter.top) % "," % \
				QString::number(stCenter.right) % "," % QString::number(stCenter.bottom) % ")");	
			stCenter.left			=	itemshareData.previewParameter->iWidth - itemshareData.blemishParameter->stBlemishHB.blemishhb_Zone3X;
			stCenter.right		=	itemshareData.previewParameter->iWidth;
			stCenter.top		=	itemshareData.previewParameter->iHeight - itemshareData.blemishParameter->stBlemishHB.blemishhb_Zone3Y;
			stCenter.bottom	=	itemshareData.previewParameter->iHeight;
			emit information(QTextCodec::codecForName( "GBK")->toUnicode("污点右下角测试区域位置:(ROI:") % \
				QString::number(stCenter.left) % "," % QString::number(stCenter.top) % "," % \
				QString::number(stCenter.right) % "," % QString::number(stCenter.bottom) % ")");	
			for(unsigned int x=0;	x<15;	++x){
				strTempText		=	QString::number((x+1)*8) % "x" % QString::number((x+1)*8);
				emit information(QTextCodec::codecForName( "GBK")->toUnicode("污点四角区域") % \
					strTempText % QTextCodec::codecForName( "GBK")->toUnicode("调试信息：") % " (ROI:" % \
					QString::number(stZone3Debug[x].stroi.left) % "," % QString::number(stZone3Debug[x].stroi.top) % \
					"," % QString::number(stZone3Debug[x].stroi.right) % "," %QString::number(stZone3Debug[x].stroi.bottom) % \
					") " % QTextCodec::codecForName( "GBK")->toUnicode("值：") % QString::number(stZone3Debug[x].flvalue));
			}
		}
	}
	else if(itemshareData.blemishParameter->blemishAlg == _HisAlg_SWITCH_C)
	{
		unsigned char* pucRGB24 = (unsigned char*)HisAlignedMalloc(itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight *3);
		QHisFX3MallocAlignedManage classpucRGB24(pucRGB24);
		unsigned char* pucR	=	(unsigned char*)HisAlignedMalloc(itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight);
		QHisFX3MallocAlignedManage classpucR(pucR);
		unsigned char* pucG	=	(unsigned char*)HisAlignedMalloc(itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight);
		QHisFX3MallocAlignedManage classpucG(pucG);
		unsigned char* pucB	=	(unsigned char*)HisAlignedMalloc(itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight);
		QHisFX3MallocAlignedManage classpucB(pucB);
		unsigned int* bufSum = (unsigned int*)HisAlignedMalloc(itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight *3 *sizeof(unsigned int));
		QHisFX3MallocAlignedManage classbufSum(bufSum);
		if(!(pucRGB24 && pucR && pucG && pucB && bufSum))  return HisFX3Error_MallocBuffer;
		memset(bufSum, 0, itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight *3 *sizeof(unsigned int));
		unsigned int loop = itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight*3;

		for (unsigned int x=0; x<itemshareData.blemishParameter->stBlemishHB.frames; ++x)
		{
			if(iresult = GetFreshframe(pucRGB24, itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight *3, _FrameType_RGB24, !x))
				return iresult;
			unsigned int* ps = bufSum;
			unsigned char* py = pucRGB24;
			for (unsigned int i=0; i<loop; ++i)
			{
				*ps	+=	*py;
				++ps; ++py;
			}
		}

		unsigned int* ps = bufSum;
		unsigned char* py = pucRGB24;
		for (unsigned int i=0; i<loop; ++i)
		{
			*py = *ps / itemshareData.blemishParameter->stBlemishHB.frames;
			++py;  ++ps;
		}

		ROPLOW::extractrgb24(pucRGB24, pucR, pucG, pucB, itemshareData.previewParameter->iWidth, itemshareData.previewParameter->iHeight);
		std::vector<_HisCCMAlg_BlemishHC_Blemish> vecBlemish;
		if(iresult = classAlgorithm.HisCCMWhitePanel_BlemishHC(pucR, pucG, pucB, itemshareData.previewParameter->iWidth, \
			itemshareData.previewParameter->iHeight, itemshareData.blemishParameter->stBlemishHC.stSpec, vecBlemish, \
			itemshareData.blemishParameter->stBlemishHC.flEdgeZone, itemshareData.blemishParameter->stBlemishHC.flCornerZone,itemshareData.blemishParameter->stBlemishHC.flAreaMin, \
			itemshareData.blemishParameter->stBlemishHC.flAreaMax, false, itemshareData.blemishParameter->stBlemishHC.flTuning, \
			false, true))
			return iresult;

		if(vecBlemish.size())
		{
			stLogItem.itemvalue	=	"NG";
			iresult	=	HisCCMError_Result;
			itemshareData.drawLock.lockForWrite();
			int ilastcount	=	itemshareData.itemdrawList.size();
			itemshareData.itemdrawList.resize(ilastcount + vecBlemish.size());
			std::vector<_itemDraw>::iterator drawIterator	=	itemshareData.itemdrawList.begin() +ilastcount;
			for(std::vector<_HisCCMAlg_BlemishHC_Blemish>::iterator theiterator = vecBlemish.begin(); theiterator != vecBlemish.end(); theiterator++){
				drawIterator->usitem				=	whitepanelitem_blemish;
				drawIterator->uctype				=	HisDrawType_Block;
				drawIterator->stcolor				=	stblemishcolor;
				drawIterator->strinfo.stblock	=	theiterator->stROI;
				if(hisglobalparameter.bDebugMode){
					QString strZone	=	tr("Edge");
					if(theiterator->uiSpecIndex < 10) strZone = QString::number(theiterator->uiSpecIndex + 1);
					emit information(tr("Blemish: ") % ROPLOW::rect2qstring(theiterator->stROI) % tr("   Brightness: ") % \
						QString::number(theiterator->flLux, 'f', 6) % tr("   Color: ") % QString::number(theiterator->flColor, 'f', 6) % \
						tr("   Zone: ") % strZone);
				}
				drawIterator++;
			}
			itemshareData.drawLock.unlock();
		}
	}
	else if(itemshareData.blemishParameter->blemishAlg == _HisAlg_SWITCH_D)
	{
		QString strDllPath = QDir::currentPath() % "/SRITDLL/BIGMESH_Dll";
		typedef int (*RRT_RSBT_rsbt_run_mem)(unsigned short *,char *,char *,unsigned short,void *,double *);
#ifdef _WIN64
		RRT_RSBT_rsbt_run_mem  RSBT_rsbt_run_mem = (RRT_RSBT_rsbt_run_mem)(QLibrary::resolve(strDllPath, "?RSBT_rsbt_run_mem@@YAHPEAGPEAD1GPEAXPEAN@Z"));
#else
		RRT_RSBT_rsbt_run_mem  RSBT_rsbt_run_mem = (RRT_RSBT_rsbt_run_mem)(QLibrary::resolve(strDllPath, "?RSBT_rsbt_run_mem@@YAHPAGPAD1GPAXPAN@Z"));
#endif
		if(!RSBT_rsbt_run_mem){
			emit information(strDllPath % " load RSBT_rsbt_run_mem fail");
			return HisCCMError_LoadDLLFuc;
		}

		unsigned short* pusBaylor	=	(unsigned short*)HisAlignedMalloc(itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight *2);
		if(!pusBaylor) return HisFX3Error_MallocBuffer;
		QHisFX3MallocAlignedManage classpusBaylor(pusBaylor);

		//取得raw图像数据
		if(iresult	=	GetFreshframe((unsigned char*)pusBaylor, itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight *2, _FrameType_Raw10, true))
			return iresult;

		QString strRawInfo = QDir::currentPath() % "/SRITDLL/" % itemshareData.blemishParameter->stBlemishHD.strRawInfo;
		if(!QFile::exists(strRawInfo)){
			emit information(strRawInfo % " is not exist");
			return HisCCMError_FilePath;
		}

		QString strOptPath = QDir::currentPath() % "/SRITDLL/" % itemshareData.blemishParameter->stBlemishHD.strOptionBin;
		if(!QFile::exists(strOptPath)){
			emit information(strOptPath % " is not exist");
			return HisCCMError_FilePath;
		}

		const unsigned short RSBT_DATACODE = 0xAB;
		typedef struct __rsbt_detect_data_type 
		{ 
			unsigned short i_category; 
			unsigned short i_size; 
			unsigned short i_st_X; 
			unsigned short i_st_Y; 
			unsigned short i_ed_X; 
			unsigned short i_ed_Y; 
		} rsbt_detect_data_type;

		const unsigned int NUM_OF_DETECT	=	100;
		rsbt_detect_data_type Detect[NUM_OF_DETECT]; 
		double Edge_MaxDiff; 
		for(unsigned int _i = 0; _i < NUM_OF_DETECT; _i++) 
		{ 
			Detect[_i].i_category = RSBT_DATACODE; // 1 : Stain , 2 : Blemish 
			Detect[_i].i_size = RSBT_DATACODE; 
			Detect[_i].i_st_X = RSBT_DATACODE;
			Detect[_i].i_st_Y = RSBT_DATACODE; 
			Detect[_i].i_ed_X = RSBT_DATACODE; 
			Detect[_i].i_ed_Y = RSBT_DATACODE; 
		}

		int Err = RSBT_rsbt_run_mem(pusBaylor, strRawInfo.toAscii().data(), strOptPath.toAscii().data(),NUM_OF_DETECT, (void*)&Detect, &Edge_MaxDiff);
		if(Err != 0)
		{
			emit information("RSBT_rsbt_run_mem return:" % QString::number(Err));
			return HisCCMError_OtpFucExec;
		}

		unsigned int uiDrawCount	=	0;

		char strText[128];
		for(unsigned int x=0;	x<NUM_OF_DETECT; ++x)
		{
			if(Detect[x].i_category == RSBT_DATACODE)  break; 
			++uiDrawCount;
			sprintf(strText, "%d %d %d %d %d %d \r\n" , Detect[x].i_category, Detect[x].i_size , Detect[x].i_st_X, Detect[x].i_st_Y, Detect[x].i_ed_X, Detect[x].i_ed_Y);
			emit information(QString::fromAscii(strText));
		}

		emit information("Max Edge Diff: " % QString::number(Edge_MaxDiff));
		if(Edge_MaxDiff > itemshareData.blemishParameter->stBlemishHD.dflMaxEdgeDiff || uiDrawCount){
			iresult	=	HisCCMError_Result;
			stLogItem.itemvalue	=	"NG";
		}

		classstLogItem.SubRef();
		classLog->push_back(stLogItem);
		++(stLogItem.itemtype); stLogItem.itemkey = "Max_Edge_Diff"; stLogItem.itemvalue = Edge_MaxDiff; classLog->push_back(stLogItem);
		++(stLogItem.itemtype); stLogItem.itemkey = "Blemish_Detected"; stLogItem.itemvalue = uiDrawCount; classLog->push_back(stLogItem);


		if(uiDrawCount)
		{
			uiDrawCount = min(uiDrawCount, 20);
			itemshareData.drawLock.lockForWrite();
			int ilastcount	=	itemshareData.itemdrawList.size();
			itemshareData.itemdrawList.resize(ilastcount + uiDrawCount);
			theIterator	=	itemshareData.itemdrawList.begin() +ilastcount;
			for(int i=0;	i<uiDrawCount;	++i)
			{
				theIterator->usitem	=	whitepanelitem_blemish;
				theIterator->uctype	=	HisDrawType_Block;
				theIterator->stcolor	=	stblemishcolor;
				theIterator->strinfo.stblock.left		=	Detect[i].i_st_X;
				theIterator->strinfo.stblock.right		=	Detect[i].i_ed_X;
				theIterator->strinfo.stblock.top		=	Detect[i].i_st_Y;
				theIterator->strinfo.stblock.bottom	=	Detect[i].i_ed_Y;
				// 				emit information(QTextCodec::codecForName( "GBK")->toUnicode("污点") % QString::number(i+1, 10) % ":    " % \
				// 					QTextCodec::codecForName( "GBK")->toUnicode("左上(") % QString::number(theIterator->strinfo.stblock.left, 10) % \
				// 					"," % QString::number(theIterator->strinfo.stblock.top, 10) % QTextCodec::codecForName( "GBK")->toUnicode(")    右下(") % \
				// 					QString::number(theIterator->strinfo.stblock.right, 10) % "," % QString::number(theIterator->strinfo.stblock.bottom, 10) % ")");
				theIterator++;
			}
			itemshareData.drawLock.unlock();
		}
	}

	if(stblemish.size() && itemshareData.blemishParameter->blemishAlg != _HisAlg_SWITCH_C)
	{
		iresult	=	HisCCMError_Result;
		itemshareData.drawLock.lockForWrite();
		int ilastcount	=	itemshareData.itemdrawList.size();
		itemshareData.itemdrawList.resize(ilastcount + stblemish.size());
		theIterator	=	itemshareData.itemdrawList.begin() +ilastcount;
		for(int i=0;	i<stblemish.size();	++i){
			theIterator->usitem	=	whitepanelitem_blemish;
			theIterator->uctype	=	HisDrawType_Block;
			theIterator->stcolor	=	stblemishcolor;
			theIterator->strinfo.stblock	=	stblemish.at(i);
			emit information(QTextCodec::codecForName( "GBK")->toUnicode("污点") % QString::number(i+1, 10) % ":    " % \
				QTextCodec::codecForName( "GBK")->toUnicode("左上(") % QString::number(theIterator->strinfo.stblock.left, 10) % \
				"," % QString::number(theIterator->strinfo.stblock.top, 10) % QTextCodec::codecForName( "GBK")->toUnicode(")    右下(") % \
				QString::number(theIterator->strinfo.stblock.right, 10) % "," % QString::number(theIterator->strinfo.stblock.bottom, 10) % ")");
			theIterator++;
		}
		itemshareData.drawLock.unlock();

		stLogItem.itemvalue	=	"NG";
	}

	if(itemshareData.blemishParameter->blemishAlg != _HisAlg_SWITCH_D)
	{
		classstLogItem.SubRef();
		classLog->push_back(stLogItem);
	}

	//output debug info
	if(stdebug.stlist.size() > 0)
	{
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("点(") % QString::number(stdebug.uipt_x, 10) % \
			"," % QString::number(stdebug.uipt_y, 10) % QTextCodec::codecForName( "GBK")->toUnicode(")调试信息："));
		for(int i=0;	i<stdebug.stlist.size(); ++i){
			switch (stdebug.stlist.at(i).ustype){
			case HisAlg_WhitePanel_Blemish_Corner:
				break;
			case HisAlg_WhitePanel_Blemish_Amplitude:
				emit information(QTextCodec::codecForName( "GBK")->toUnicode("      污点测试-振幅：") % \
					QString::number(static_cast<double>(stdebug.stlist.at(i).dflvalue), 'f', 6));
				break;
			case HisAlg_WhitePanel_Blemish_Dev:
				emit information(QTextCodec::codecForName( "GBK")->toUnicode("      污点测试-方差：") % \
					QString::number(static_cast<double>(stdebug.stlist.at(i).dflvalue), 'f', 6));
				break;
			case HisAlg_WhitePanel_Color_Uniform:
				emit information(QTextCodec::codecForName( "GBK")->toUnicode("      颜色均匀测试-差异：") % \
					QString::number(static_cast<double>(stdebug.stlist.at(i).dflvalue), 'f', 6));
				break;
			default:
				break;
			}
		}
		stdebug.stlist.clear();
	}

	return iresult;
}



#if 0

int itemprocess::whitepanel_BlemishHC()
{
	unsigned char* pucRGB24 = (unsigned char*)_aligned_malloc(itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight *3, _HisCacheLine_Aligned);
	unsigned char* pucR	=	(unsigned char*)_aligned_malloc(itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight, _HisCacheLine_Aligned);
	unsigned char* pucG	=	(unsigned char*)_aligned_malloc(itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight, _HisCacheLine_Aligned);
	unsigned char* pucB	=	(unsigned char*)_aligned_malloc(itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight, _HisCacheLine_Aligned);
	int iresult;
	if(!(pucRGB24 && pucR && pucG && pucB)) 
		_CODE_BLEMISH_HC_EXIT1(HisFX3Error_MallocBuffer) 

		_HisFX3_BaylorMode ucDataFormat;
	ROPLOW::BaylorXForamt2Baloy8(itemshareData.previewParameter->ucDataFormat, ucDataFormat);

	if(iresult = GetFreshframe(pucRGB24, itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight *3, _FrameType_RGB24, true))
		_CODE_BLEMISH_HC_EXIT1(iresult)	

		ROPLOW::extractrgb24(pucRGB24, pucR, pucG, pucB, itemshareData.previewParameter->iWidth, itemshareData.previewParameter->iHeight);
	std::vector<_HisCCMAlg_BlemishHC_Blemish> vecBlemish;
	if(iresult = classAlgorithm.HisCCMWhitePanel_BlemishHC(pucR, pucG, pucB, itemshareData.previewParameter->iWidth, \
		itemshareData.previewParameter->iHeight, itemshareData.blemishParameter->stBlemishHC.stSpec, vecBlemish, \
		itemshareData.blemishParameter->stBlemishHC.flEdgeZone, itemshareData.blemishParameter->stBlemishHC.flCornerZone,itemshareData.whitepanelParameter->stBlemishHC.flAreaMin, \
		itemshareData.blemishParameter->stBlemishHC.flAreaMax, false, itemshareData.blemishParameter->stBlemishHC.flTuning, \
		itemshareData.blemishParameter->stBlemishHC.bWB, false))
		_CODE_BLEMISH_HC_EXIT1(iresult)	

		if(vecBlemish.size()){
			iresult	=	HisCCMError_Result;
			QColor stblemishcolor		=	QColor::fromRgb(255, 0, 0);
			itemshareData.drawLock.lockForWrite();
			int ilastcount	=	itemshareData.itemdrawList.size();
			itemshareData.itemdrawList.resize(ilastcount + vecBlemish.size());
			std::vector<_itemDraw>::iterator drawIterator	=	itemshareData.itemdrawList.begin() +ilastcount;
			for(std::vector<_HisCCMAlg_BlemishHC_Blemish>::iterator theiterator = vecBlemish.begin(); theiterator != vecBlemish.end(); theiterator++){
				drawIterator->usitem				=	whitepanelitem_blemish;
				drawIterator->uctype				=	HisDrawType_Block;
				drawIterator->stcolor				=	stblemishcolor;
				drawIterator->strinfo.stblock	=	theiterator->stROI;
				if(hisglobalparameter.bDebugMode){
					QString strZone	=	tr("Edge");
					if(theiterator->uiSpecIndex < 10) strZone = QString::number(theiterator->uiSpecIndex + 1);
					emit information(tr("Blemish: ") % ROPLOW::rect2qstring(theiterator->stROI) % tr("   Brightness: ") % \
						QString::number(theiterator->flLux, 'f', 6) % tr("   Color: ") % QString::number(theiterator->flColor, 'f', 6) % \
						tr("   Zone: ") % strZone);
				}
				drawIterator++;
			}
			itemshareData.drawLock.unlock();
		}

		_CODE_BLEMISH_HC_EXIT1(iresult)
}

#endif

int itemprocess::getblackfieldParameter(bool bupdate, bool bcheck)
{
	QMutexLocker locker(&hisglobalparameter.mutexDatabase);

	itemshareData.itemparameterLock.lockForRead();
	if(!bupdate && itemshareData.blackfieldParameter){
		itemshareData.itemparameterLock.unlock();
		return 0;
	}

	itemshareData.itemparameterLock.unlock();
	itemshareData.itemparameterLock.lockForWrite();
	if(!itemshareData.blackfieldParameter)	itemshareData.blackfieldParameter		=	new _blackfiledParameter;

	bool bItemExist = false;
	{
		QSqlDatabase customdb = QSqlDatabase::addDatabase("QSQLITE", "querycustom");
		customdb.setDatabaseName(QDir::currentPath() % "/HisFX3Custom");
		if (!customdb.open()){
			itemshareData.itemparameterLock.unlock();
			return HisCCMError_Database;
		}

		QStringList strname, strvalue;
		QString strData, strData2;
		QSqlQuery query(customdb);
		query.prepare("SELECT itemsuffix2,key,value,reserve FROM " % itemshareData.currentTableName % \
			" WHERE classfy='algorithm' AND item='blackfield' AND itemsuffix1='total' ORDER BY id ASC" );
		query.exec();

		//(alg:a)(digitalgain:1)(analoggain:1)(framesleep:500)
		while (query.next()){
			bItemExist = true;
			for(int y=0;	y<4;	++y){
				strData	=	query.value(y).toString();
				ROPLOW::patchconfigstring(strData, strname, strvalue);
				for(int x=0;	x<strname.size();	++x){
					if(strname.at(x) == "alg"){
						if(strvalue.at(x) == "a")	itemshareData.blackfieldParameter->ui8BlackFiledAlg	=	_HisAlg_SWITCH_A;
						else if(strvalue.at(x) == "b")	itemshareData.blackfieldParameter->ui8BlackFiledAlg	=	_HisAlg_SWITCH_B;
					}
				}
			}
		}

		if(itemshareData.blackfieldParameter->ui8BlackFiledAlg == _HisAlg_SWITCH_A)
		{
			query.prepare("SELECT itemsuffix2,key,value,reserve FROM " % itemshareData.currentTableName % \
				" WHERE classfy='algorithm' AND item='blackfield' AND itemsuffix1='alga' ORDER BY id ASC" );
			query.exec();

			//(lightdefine:30)(clusterdefine:6)(centerratio:50)
			//(centerlightspec:70)(arounglightspce:43)
			//(centerclusterspec:10)(aroundclusterspec:10)(maxclusterspec:10)
			while (query.next())
			{
				bItemExist = true;
				for(int y=0;	y<4;	++y)
				{
					strData	=	query.value(y).toString();
					ROPLOW::patchconfigstring(strData, strname, strvalue);
					for(int x=0;	x<strname.size();	++x)
					{
						if(strname.at(x) == "centerratio")
							itemshareData.blackfieldParameter->stAlgA.ui8CenterRatio	=	static_cast<unsigned __int8>(strvalue.at(x).toUInt());
						else if(strname.at(x) == "lightdefine")
							itemshareData.blackfieldParameter->stAlgA.ui8LightPixelDef	=	static_cast<unsigned __int8>(strvalue.at(x).toUInt());
						else if(strname.at(x) == "clusterdefine")
							itemshareData.blackfieldParameter->stAlgA.uiClusterDef			=	strvalue.at(x).toUInt();
						else if(strname.at(x) == "centerlightspec")
							itemshareData.blackfieldParameter->stAlgA.uiSpecCenterPixel	=	strvalue.at(x).toUInt();
						else if(strname.at(x) == "arounglightspce")
							itemshareData.blackfieldParameter->stAlgA.uiSpecAroundPixel	=	strvalue.at(x).toUInt();
						else if(strname.at(x) == "centerclusterspec")
							itemshareData.blackfieldParameter->stAlgA.uiSpecCenterCluster	=	strvalue.at(x).toUInt();
						else if(strname.at(x) == "aroundclusterspec")
							itemshareData.blackfieldParameter->stAlgA.uiSpecAroundCluster	=	strvalue.at(x).toUInt();
						else if(strname.at(x) == "maxclusterspec")
							itemshareData.blackfieldParameter->stAlgA.uiSpecMaxCluster		=	strvalue.at(x).toUInt();
					}
				}
			}
		}
		else if(itemshareData.blackfieldParameter->ui8BlackFiledAlg == _HisAlg_SWITCH_B)
		{
			query.prepare("SELECT itemsuffix2,key,value,reserve FROM " % itemshareData.currentTableName % \
				" WHERE classfy='algorithm' AND item='blackfield' AND itemsuffix1='algb' ORDER BY id ASC" );
			query.exec();

			//(blacklevel:0)
			//(rgmin:)(rgmax:)(bgmin:)(bgmax:)(ppmin:)(ppmax:)
			while (query.next())
			{
				bItemExist = true;
				for(int y=0;	y<4;	++y)
				{
					strData	=	query.value(y).toString();
					ROPLOW::patchconfigstring(strData, strname, strvalue);
					for(int x=0;	x<strname.size();	++x)
					{
						if(strname.at(x) == "blacklevel")	itemshareData.blackfieldParameter->stAlgB.ucBlackLevel	=	strvalue.at(x).toUInt() & 0xFF;
						else if(strname.at(x) == "rgmin")	itemshareData.blackfieldParameter->stAlgB.flRGMin	=	strvalue.at(x).toFloat();
						else if(strname.at(x) == "rgmax")	itemshareData.blackfieldParameter->stAlgB.flRGMax	=	strvalue.at(x).toFloat();
						else if(strname.at(x) == "bgmin")	itemshareData.blackfieldParameter->stAlgB.flBGMin	=	strvalue.at(x).toFloat();
						else if(strname.at(x) == "bgmax")	itemshareData.blackfieldParameter->stAlgB.flBGMax	=	strvalue.at(x).toFloat();
						else if(strname.at(x) == "ppmin")	itemshareData.blackfieldParameter->stAlgB.flPPMin	=	strvalue.at(x).toFloat();
						else if(strname.at(x) == "ppmax")	itemshareData.blackfieldParameter->stAlgB.flPPMax	=	strvalue.at(x).toFloat();
					}
				}
			}
		}

		customdb.close();
	}

	QSqlDatabase::removeDatabase("querycustom");

	if(!bItemExist)
	{
		HisReleaseNewO(itemshareData.blackfieldParameter)
			itemshareData.itemparameterLock.unlock();
		return HisFX3Error_Parameter;
	}

	if(!bcheck) {itemshareData.itemparameterLock.unlock(); return 0; }

	int iresult	=	0;
	if(itemshareData.blackfieldParameter->ui8BlackFiledAlg == 0xFF){
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("黑场参数错误：未选定算法"));
		iresult	=	HisFX3Error_Parameter;
	}

	if(iresult)  { HisReleaseNewO(itemshareData.blackfieldParameter) }
	itemshareData.itemparameterLock.unlock();
	return iresult;
}

int itemprocess::blackfield()
{
	std::vector<_itemDraw>::iterator theIterator;
	itemshareData.clearDrawList();

	//判断图像是否点亮中
	if(!threadshareData.GetHisPreviewflag())	return HisCCMError_NotPreivew;

	//取得配置参数和规格
	int iresult	=	getblackfieldParameter(false);
	if(iresult)	return iresult;

	QHReadWriteLockManage classitemparameterLock(&(itemshareData.itemparameterLock));
	stLogItem.itemtype		=	classLog->getmaxtypeindex(_HISLOG_CLASSIFY_BLACKFIELD);
	stLogItem.itemkey		=	"BlackField_Result";
	stLogItem.itemvalue	=	"OK";
	QHDefaultLogManage classstLogItem(classLog, &stLogItem, "NG");

	if(itemshareData.blackfieldParameter->ui8BlackFiledAlg == _HisAlg_SWITCH_A)
	{
		unsigned char ucFrameType	=	_FrameType_Raw;
		unsigned int uiBufferSize	=	itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight;
		if(itemshareData.previewParameter->ucDataFormat == HisRGB_RGB24)		{
			ucFrameType	=	_FrameType_RGB24;
			uiBufferSize	*=	3;
		}
		else if(itemshareData.previewParameter->ucDataFormat >= HisYUV8_422_YUYV && itemshareData.previewParameter->ucDataFormat <= HisYUV8_422_VYUY) {
			uiBufferSize *= 2;
		}

		unsigned char* pucRaw	=	(unsigned char*)HisAlignedMalloc(uiBufferSize);
		if(!pucRaw)	return HisFX3Error_MallocBuffer;
		QHisFX3MallocAlignedManage classpucRaw(pucRaw);

		if(iresult	=	GetFreshframe(pucRaw, uiBufferSize, ucFrameType, true)) return iresult;

		unsigned int uiCenterPixel, uiAroundPixel, uiCenterCluster, uiAroundCluster, uiMaxArea;
		RECT stRang;
		int iWidthT	=	itemshareData.previewParameter->iWidth, iHeightT = itemshareData.previewParameter->iHeight;
		unsigned char* pucRawT	=	pucRaw;
		unsigned char* pucBufY		=	NULL;
		if(itemshareData.previewParameter->ucDataFormat == HisRGB_RGB24)	iWidthT	*=	3;
		else if(itemshareData.previewParameter->ucDataFormat >= HisYUV8_422_YUYV && itemshareData.previewParameter->ucDataFormat <= HisYUV8_422_VYUY){
			pucBufY	=	(unsigned char*)_aligned_malloc(itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight, _HisCacheLine_Aligned);
			if(!pucBufY){ HisReleaseMalloc(pucRaw); return HisFX3Error_MallocBuffer; }
			classAlgorithm.extactYfromYUV422U8(pucRaw, pucBufY, itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight, itemshareData.previewParameter->ucDataFormat);
			pucRawT	=	pucBufY;
		}

		iresult	=	classAlgorithm.HisCCMBlackFieldHA(pucRawT, itemshareData.previewParameter->ucDataFormat, iWidthT, iHeightT, \
			itemshareData.blackfieldParameter->stAlgA.uiClusterDef, itemshareData.blackfieldParameter->stAlgA.ui8LightPixelDef, \
			static_cast<unsigned int>(itemshareData.blackfieldParameter->stAlgA.ui8CenterRatio), uiCenterPixel, \
			uiAroundPixel, uiCenterCluster, uiAroundCluster, uiMaxArea, stRang);
		HisReleaseMalloc(pucBufY);
		if(iresult)	return iresult;

		if(itemshareData.previewParameter->ucDataFormat == HisRGB_RGB24){
			stRang.left	/=	3;
			stRang.right	/=	3;
		}

		emit information(QTextCodec::codecForName( "GBK")->toUnicode("中心区域亮点个数：") % QString::number(uiCenterPixel));
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("周边区域亮点个数：") % QString::number(uiAroundPixel));
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("中心区域聚簇个数：") % QString::number(uiCenterCluster));
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("周围区域聚簇个数：") % QString::number(uiAroundCluster));
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("最大聚簇面积：") % QString::number(uiMaxArea));

		if(uiCenterPixel > itemshareData.blackfieldParameter->stAlgA.uiSpecCenterPixel || \
			uiAroundPixel > itemshareData.blackfieldParameter->stAlgA.uiSpecAroundPixel || \
			uiCenterCluster > itemshareData.blackfieldParameter->stAlgA.uiSpecCenterCluster || \
			uiAroundCluster > itemshareData.blackfieldParameter->stAlgA.uiSpecAroundCluster || \
			uiMaxArea > itemshareData.blackfieldParameter->stAlgA.uiSpecMaxCluster){
				iresult	=	HisCCMError_Result;
		}

		if(iresult)	stLogItem.itemvalue	=	"NG";
		classstLogItem.SubRef();
		classLog->push_back(stLogItem);
		++(stLogItem.itemtype);
		stLogItem.itemkey		=	"BlackField_LightPixel_Center";
		stLogItem.itemvalue	=	uiCenterPixel;
		classLog->push_back(stLogItem);
		++(stLogItem.itemtype);
		stLogItem.itemkey		=	"BlackField_LightPixel_Around";
		stLogItem.itemvalue	=	uiAroundPixel;
		classLog->push_back(stLogItem);
		++(stLogItem.itemtype);
		stLogItem.itemkey		=	"BlackField_LightCluster_Center";
		stLogItem.itemvalue	=	uiCenterCluster;
		classLog->push_back(stLogItem);
		++(stLogItem.itemtype);
		stLogItem.itemkey		=	"BlackField_LightCluster_Around";
		stLogItem.itemvalue	=	uiAroundCluster;
		classLog->push_back(stLogItem);
		++(stLogItem.itemtype);
		stLogItem.itemkey		=	"BlackField_LightCluster_MaxArea";
		stLogItem.itemvalue	=	uiMaxArea;
		classLog->push_back(stLogItem);

		int iCenterWidth			=	itemshareData.previewParameter->iWidth * \
			static_cast<int>(itemshareData.blackfieldParameter->stAlgA.ui8CenterRatio) /100;
		int iCenterHeight		=	itemshareData.previewParameter->iHeight * \
			static_cast<int>(itemshareData.blackfieldParameter->stAlgA.ui8CenterRatio) /100;

		itemshareData.drawLock.lockForWrite();
		itemshareData.itemdrawList.resize(((iresult)?(2):(1)));
		theIterator	=	itemshareData.itemdrawList.begin();
		theIterator->uctype							=	HisDrawType_Block;
		theIterator->strinfo.stblock.left		=	((itemshareData.previewParameter->iWidth - iCenterWidth) >>1);
		theIterator->strinfo.stblock.right		=	((itemshareData.previewParameter->iWidth + iCenterWidth) >>1);
		theIterator->strinfo.stblock.top		=	((itemshareData.previewParameter->iHeight - iCenterHeight) >>1);
		theIterator->strinfo.stblock.bottom	=	((itemshareData.previewParameter->iHeight + iCenterHeight) >>1);
		ROPLOW::expand2minrect(theIterator->strinfo.stblock, itemshareData.previewParameter->iWidth,  itemshareData.previewParameter->iHeight, \
			itemshareData.previewParameter->iWidth *0.1f,  itemshareData.previewParameter->iHeight *0.1f);
		theIterator->usitem							=	blackfielditem;
		theIterator->stcolor							=	QColor::fromRgb(255,255,0);
		if(iresult){
			theIterator++;
			theIterator->uctype					=	HisDrawType_Block;
			theIterator->strinfo.stblock		=	stRang;
			theIterator->usitem					=	blackfielditem;
			theIterator->stcolor					=	QColor::fromRgb(255,0,0);
		}
		itemshareData.drawLock.unlock();
	}
	else if(itemshareData.blackfieldParameter->ui8BlackFiledAlg == _HisAlg_SWITCH_B)
	{
		typedef enum __RLL_ERROR_TYPE 
		{ 
			RLL_ERR_NONE = 0,
			RLL_LINE_ERROR = 400, 
			RLL_ALGORITHM_SEQUENCE, 
			RLL_OBJECT_ERR, 
			RLL_LINE_FIT_ERR, 
			RLL_GRD_CALC_ERR, 
			RLL_CALL_IMG_OBJ_ERR, 
			RLL_CALL_IMG_FILE_READ_ERR
		} RLL_ERR;

		QString strDllPath = QDir::currentPath() % "/SRITDLL/RLLT_Dll";
		typedef enum __RLL_ERROR_TYPE (*RRT_RLLT_run)(unsigned short *,unsigned int,unsigned int,unsigned int,unsigned int,double &,double &,double &);
#ifdef _WIN64
		RRT_RLLT_run  RLLT_run = (RRT_RLLT_run)(QLibrary::resolve(strDllPath, "?RLLT_run@@YA?AW4__RLL_ERROR_TYPE@@PEAGIIIIAEAN11@Z"));
#else
		RRT_RLLT_run  RLLT_run = (RRT_RLLT_run)(QLibrary::resolve(strDllPath, "?RLLT_run@@YA?AW4__RLL_ERROR_TYPE@@PAGIIIIAAN11@Z"));
#endif
		if(!RLLT_run){
			emit information(strDllPath % " load RLLT_run fail");
			return HisCCMError_LoadDLLFuc;
		}

		unsigned short* pusBaylor	=	(unsigned short*)HisAlignedMalloc(itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight *2);
		if(!pusBaylor) return HisFX3Error_MallocBuffer;
		QHisFX3MallocAlignedManage classpusBaylor(pusBaylor);

		//取得raw图像数据
		if(iresult	=	GetFreshframe((unsigned char*)pusBaylor, itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight *2, _FrameType_Raw10, true))
			return iresult;

		unsigned int ch_order;
		switch (itemshareData.previewParameter->ucDataFormat)
		{
		case HisBaylor8_BGGR:
		case HisBaylor10_BGGR:
		case HisBaylor12_BGGR:
			ch_order	=	2;
			break;
		case HisBaylor8_RGGB:
		case HisBaylor10_RGGB:
		case HisBaylor12_RGGB:
			ch_order	=	1;
			break;
		case HisBaylor8_GRBG:
		case HisBaylor10_GRBG:
		case HisBaylor12_GRBG:
			ch_order	=	0;
			break;
		case HisBaylor8_GBRG:
		case HisBaylor10_GBRG:
		case HisBaylor12_GBRG:
		default:
			ch_order	=	3;
			break;
		}

		double	rg = 0.0, bg = 0.0, pp = 0.0;
		iresult	=	0;
		RLL_ERR rllt_err = RLLT_run(pusBaylor, itemshareData.previewParameter->iWidth, itemshareData.previewParameter->iHeight,ch_order,itemshareData.blackfieldParameter->stAlgB.ucBlackLevel, rg, bg, pp);
		if(rllt_err != RLL_ERR_NONE)
		{
			iresult = HisCCMError_Result;
			emit information("RLLT_run return(error): " % QString::number(rllt_err));
		}
		else
		{
			emit information("Dark RG: " % QString::number(rg));
			emit information("Dark BG: " % QString::number(bg));
			emit information("Dark PP: " % QString::number(pp));
			if(rg < itemshareData.blackfieldParameter->stAlgB.flRGMin || rg > itemshareData.blackfieldParameter->stAlgB.flRGMax || \
				bg < itemshareData.blackfieldParameter->stAlgB.flBGMin || bg > itemshareData.blackfieldParameter->stAlgB.flBGMax || \
				pp < itemshareData.blackfieldParameter->stAlgB.flPPMin || pp > itemshareData.blackfieldParameter->stAlgB.flPPMax)
				iresult = HisCCMError_Result;
		}

		if(iresult) stLogItem.itemvalue = "NG";
		classstLogItem.SubRef();
		classLog->push_back(stLogItem);
		++(stLogItem.itemtype); stLogItem.itemkey = "Dark_RG"; stLogItem.itemvalue = rg; classLog->push_back(stLogItem);
		++(stLogItem.itemtype); stLogItem.itemkey = "Dark_BG"; stLogItem.itemvalue = bg; classLog->push_back(stLogItem);
		++(stLogItem.itemtype); stLogItem.itemkey = "Dark_PP"; stLogItem.itemvalue = pp; classLog->push_back(stLogItem);
	}

	return iresult;
}

int itemprocess::setexposureTimeExe(unsigned int uiexposure)
{
	int iresult	=		getccmhardwareParameter(false);
	if(iresult)
		return iresult;

	//判断图像是否点亮中
	if(!threadshareData.GetHisPreviewflag())
		return HisCCMError_NotPreivew;

	itemshareData.itemparameterLock.lockForRead();

	iresult	=	 setExposureTime((itemshareData.ccmhardwareParameter->sensortype.toAscii()).data(), \
		itemshareData.previewParameter->ucSlave, uiexposure, \
		globalFunPointer.ReadHisFX3IIC, globalFunPointer.WriteHisFX3IIC, globalFunPointer.SetHisFX3IICSpeed, globalFunPointer.PullHisFX3RESET, globalFunPointer.PullHisFX3PWND, \
		globalFunPointer.PageWriteHisFX3IIC, globalFunPointer.PageReadHisFX3IIC, globalFunPointer.HisFX3PageWriteSPI, globalFunPointer.HisFX3PageReadSPI);
	itemshareData.itemparameterLock.unlock();
	return iresult;
}

int itemprocess::setGain(float gain)
{
	int iresult	=		getccmhardwareParameter(false);
	if(iresult)
		return iresult;

	//判断图像是否点亮中
	if(!threadshareData.GetHisPreviewflag())
		return HisCCMError_NotPreivew;

	itemshareData.itemparameterLock.lockForRead();

	iresult	=	 setGlobalGain((itemshareData.ccmhardwareParameter->sensortype.toAscii()).data(), \
		itemshareData.previewParameter->ucSlave, gain, \
		globalFunPointer.ReadHisFX3IIC, globalFunPointer.WriteHisFX3IIC, globalFunPointer.SetHisFX3IICSpeed, globalFunPointer.PullHisFX3RESET, globalFunPointer.PullHisFX3PWND, \
		globalFunPointer.PageWriteHisFX3IIC, globalFunPointer.PageReadHisFX3IIC, globalFunPointer.HisFX3PageWriteSPI, globalFunPointer.HisFX3PageReadSPI);

	itemshareData.itemparameterLock.unlock();
	return iresult;
}

int itemprocess::setMotorExe(int imotor, int iType)
{
	int iresult	=		getccmhardwareParameter(false);
	if(iresult)	return iresult;
	bool bOTP	=	false;
	if(iType == 0 || iType == 1 || iType == 2){
		if(iresult = getafburnParameter(false)) return iresult;
		bOTP	=	true;
	}

	itemshareData.itemparameterLock.lockForRead();

	if(bOTP)
	{
		_HisCCMAFBurn_Config stParameter;
		stParameter.ucSlave			=	itemshareData.previewParameter->ucSlave;
		stParameter.iwidth				=	itemshareData.previewParameter->iWidth;
		stParameter.iheight				=	itemshareData.previewParameter->iHeight;
		stParameter.uiDataFormat	=	itemshareData.previewParameter->ucDataFormat;
		stParameter.uiFrameSleep=	itemshareData.afburnParameter->uiFrameDelay;
		stParameter.iNearMotor		=	0x00FFFFFF;
		stParameter.iMiddleMotor	=	0x00FFFFFF;
		stParameter.iInfinitMotor		=	0x00FFFFFF;
		stParameter.uiMachineID	=	0xFFFFFFFF;
		stParameter.bDebug			=	hisglobalparameter.bDebugMode;
		stParameter.strDriverIC		=	(itemshareData.ccmhardwareParameter->motortype.toAscii()).data();
		stParameter.strproject		=	(itemshareData.ccmhardwareParameter->projectname.toAscii()).data();
		stParameter.strsensor		=	(itemshareData.ccmhardwareParameter->sensortype.toAscii()).data();
		stParameter.strFunctionChoose		=	(itemshareData.afburnParameter->strFunctionChoose.toAscii()).data();
		stParameter.ucEESlave		=	itemshareData.ccmhardwareParameter->ucEESlave;
		stParameter.bNear		=	false;
		stParameter.bMiddle	=	false;
		stParameter.bInfinite	=	false;

		QString strSerialNumber;
		classLog->getserialnumber(strSerialNumber);
		stParameter.strSerialNumber	=	strSerialNumber.toAscii().data();

		if(iType	==	0)	stParameter.bNear		=	true;
		else if(iType	==	1)	stParameter.bMiddle		=	true;
		else 	stParameter.bInfinite		=	true;

#if (defined _WIN64) && (defined _DEBUG)
		QString strLibPath	=	QDir::currentPath() % "/HisCCMOTP64D";
#elif (defined _WIN64) && !(defined _DEBUG)
		QString strLibPath	=	QDir::currentPath() % "/HisCCMOTP64";
#elif (defined _WIN32) && (defined _DEBUG)
		QString strLibPath	=	QDir::currentPath() % "/HisCCMOTP32D";
#else
		QString strLibPath	=	QDir::currentPath() % "/HisCCMOTP32";
#endif

		RolongoOTPAPIVersion getRolongoOTPAPIVersion = (RolongoOTPAPIVersion)(QLibrary::resolve(strLibPath, "getRolongoOTPAPIVersion"));
		Rolongocheckafmotor checkafmotor = (Rolongocheckafmotor)(QLibrary::resolve(strLibPath, "checkafmotor"));

		if(!(getRolongoOTPAPIVersion && checkafmotor)){
			emit information(tr("Resolve HisCCMOTP DLL Function Fail"));
			itemshareData.itemparameterLock.unlock();
			return HisCCMError_LoadDLLFuc;
		}

		emit enableinfotimer(1);
		iresult	=	checkafmotor(*globalFunPointer.vectorHisCCMOTPInfoW, &stParameter, globalFunPointer.ReadHisFX3IIC, globalFunPointer.WriteHisFX3IIC, globalFunPointer.SetHisFX3IICSpeed, \
			globalFunPointer.SetHisFX3Voltage, globalFunPointer.GetHisFX3Voltage, SetHisFX3VFuseVolt, GetHisFX3VFuseVolt, GetFreshframe, \
			SetHisFX3GPIO, GetHisFX3GPIO, globalFunPointer.PullHisFX3RESET, globalFunPointer.PullHisFX3PWND, globalFunPointer.BatchReadHisFX3IICNoLimit, globalFunPointer.BatchWriteHisFX3IICNoLimit, \
			globalFunPointer.HisFX3LogPush_back, globalFunPointer.PageWriteHisFX3IIC, globalFunPointer.PageReadHisFX3IIC, \
			globalFunPointer.HisFX3PageWriteSPI, globalFunPointer.HisFX3PageReadSPI);
		emit enableinfotimer(0);

		if(iresult){
			emit information(QTextCodec::codecForName( "GBK")->toUnicode("获取AF烧录马达值失败"));
			itemshareData.itemparameterLock.unlock();
			return iresult;
		}

		if(iType	==	0)	{
			imotor	=	stParameter.iNearMotor - itemshareData.afburnParameter->iNearMotorOffset;
			emit information(QTextCodec::codecForName( "GBK")->toUnicode("烧录马达值：") % QString::number(stParameter.iNearMotor) % \
				QTextCodec::codecForName( "GBK")->toUnicode("减去OFFSET: ") % QString::number(itemshareData.afburnParameter->iNearMotorOffset));
		}
		else if(iType	==	0){	
			imotor		=	stParameter.iMiddleMotor - itemshareData.afburnParameter->iMiddleMotorOffset;
			emit information(QTextCodec::codecForName( "GBK")->toUnicode("烧录马达值：") % QString::number(stParameter.iMiddleMotor) % \
				QTextCodec::codecForName( "GBK")->toUnicode("减去OFFSET: ") % QString::number(itemshareData.afburnParameter->iMiddleMotorOffset));
		}
		else {	
			imotor		=	stParameter.iInfinitMotor - itemshareData.afburnParameter->iFarMotorOffset;
			emit information(QTextCodec::codecForName( "GBK")->toUnicode("烧录马达值：") % QString::number(stParameter.iInfinitMotor) % \
				QTextCodec::codecForName( "GBK")->toUnicode("减去OFFSET: ") % QString::number(itemshareData.afburnParameter->iFarMotorOffset));
		}
	}

	iresult	=	 setMotor((itemshareData.ccmhardwareParameter->motortype.toAscii()).data(), \
		itemshareData.previewParameter->ucSlave, \
		(itemshareData.ccmhardwareParameter->projectname.toAscii()).data(), imotor, \
		globalFunPointer.ReadHisFX3IIC, globalFunPointer.WriteHisFX3IIC, globalFunPointer.SetHisFX3IICSpeed, globalFunPointer.PullHisFX3RESET, globalFunPointer.PullHisFX3PWND, \
		globalFunPointer.PageWriteHisFX3IIC, globalFunPointer.PageReadHisFX3IIC, globalFunPointer.HisFX3PageWriteSPI, globalFunPointer.HisFX3PageReadSPI);

	if(iresult)
		emit information(tr("set motor value fail: ") % QString::number(imotor));
	else
		emit information(tr("set motor value success: ") % QString::number(imotor));

	itemshareData.itemparameterLock.unlock();
	return iresult;
}

int itemprocess::getCustomIICGParameter(bool bupdate, unsigned int uiGroup, bool bcheck)
{
	QString strItemName;
	_HisCCMCustomIICParatemer* pstTheParamter;
	if(uiGroup == 1){
		strItemName	=	"customiicg1";
		itemshareData.itemparameterLock.lockForRead();
		if(!bupdate && itemshareData.customIICG1Parameter) { itemshareData.itemparameterLock.unlock(); return 0; }

		itemshareData.itemparameterLock.unlock();
		itemshareData.itemparameterLock.lockForWrite();
		if(!itemshareData.customIICG1Parameter)	itemshareData.customIICG1Parameter		=	new _HisCCMCustomIICParatemer;
		if(!itemshareData.customIICG1Parameter) {	itemshareData.itemparameterLock.unlock(); return HisFX3Error_MallocBuffer; }
		pstTheParamter	=	itemshareData.customIICG1Parameter;
	}
	else if(uiGroup == 2){
		strItemName	=	"customiicg2";
		itemshareData.itemparameterLock.lockForRead();
		if(!bupdate && itemshareData.customIICG2Parameter) { itemshareData.itemparameterLock.unlock(); return 0; }

		itemshareData.itemparameterLock.unlock();
		itemshareData.itemparameterLock.lockForWrite();
		if(!itemshareData.customIICG2Parameter)	itemshareData.customIICG2Parameter		=	new _HisCCMCustomIICParatemer;
		if(!itemshareData.customIICG2Parameter) {	itemshareData.itemparameterLock.unlock(); return HisFX3Error_MallocBuffer; }
		pstTheParamter	=	itemshareData.customIICG2Parameter;
	}
	else if(uiGroup == 3){
		strItemName	=	"customiicg3";
		itemshareData.itemparameterLock.lockForRead();
		if(!bupdate && itemshareData.customIICG3Parameter) { itemshareData.itemparameterLock.unlock(); return 0; }

		itemshareData.itemparameterLock.unlock();
		itemshareData.itemparameterLock.lockForWrite();
		if(!itemshareData.customIICG3Parameter)	itemshareData.customIICG3Parameter		=	new _HisCCMCustomIICParatemer;
		if(!itemshareData.customIICG3Parameter) {	itemshareData.itemparameterLock.unlock(); return HisFX3Error_MallocBuffer; }
		pstTheParamter	=	itemshareData.customIICG3Parameter;
	}
	else{
		strItemName	=	"customiicg4";
		itemshareData.itemparameterLock.lockForRead();
		if(!bupdate && itemshareData.customIICG4Parameter) { itemshareData.itemparameterLock.unlock(); return 0; }

		itemshareData.itemparameterLock.unlock();
		itemshareData.itemparameterLock.lockForWrite();
		if(!itemshareData.customIICG4Parameter)	itemshareData.customIICG4Parameter		=	new _HisCCMCustomIICParatemer;
		if(!itemshareData.customIICG4Parameter) {	itemshareData.itemparameterLock.unlock(); return HisFX3Error_MallocBuffer; }
		pstTheParamter	=	itemshareData.customIICG4Parameter;
	}

	QMutexLocker locker(&hisglobalparameter.mutexDatabase);

	bool bparsesuccess	=	true, bItemExist = false;

	//读取，解析config
	for(int  w=0;	w<1;	++w){ //此处是有意义的,不要删除
		QSqlDatabase customdb = QSqlDatabase::addDatabase("QSQLITE", "querycustom");
		customdb.setDatabaseName(QDir::currentPath() % "/HisFX3Custom");
		if (!customdb.open()){
			bparsesuccess	=	false;
			break;
		}

		QString strData, strdata2;
		QStringList stringlist;
		QSqlQuery query(customdb);
		bool bok;
		query.prepare("SELECT value FROM " % itemshareData.currentTableName % \
			" WHERE classfy='platform' AND item='" % strItemName % "' AND itemsuffix1='custom_i2c' ORDER BY id ASC" );
		query.exec();

		while (query.next()){
			++(pstTheParamter->usCount);
		}

		pstTheParamter->pusType			=	new unsigned short[pstTheParamter->usCount];
		pstTheParamter->puiData			=	new unsigned int[pstTheParamter->usCount];
		pstTheParamter->puiAddr			=	new unsigned int[pstTheParamter->usCount];
		pstTheParamter->pucSlave		=	new unsigned char[pstTheParamter->usCount];
		if(!pstTheParamter->pusType	 || !pstTheParamter->puiData || !pstTheParamter->puiAddr || !pstTheParamter->pucSlave){
			bparsesuccess	=	false;
			break;
		}

		query.prepare("SELECT value FROM " % itemshareData.currentTableName % \
			" WHERE classfy='platform' AND item='" % strItemName % "' AND itemsuffix1='custom_i2c' ORDER BY id ASC" );
		query.exec();
		unsigned short usIndex	=	0;
		while (query.next()){
			bItemExist = true;
			strData	=	query.value(0).toString();
			strData	=	strData.toLower();
			strData	=	strData.remove("0x");
			strData	=	strData.remove(" ");
			stringlist	=	strData.split(",", QString::SkipEmptyParts);
			if (stringlist.size() == 4){
				pstTheParamter->pucSlave[usIndex]		=	static_cast<unsigned char>(stringlist.at(0).toUShort(&bok, 16));
				pstTheParamter->puiAddr[usIndex]		=	stringlist.at(1).toUInt(&bok, 16);
				pstTheParamter->puiData[usIndex]		=	stringlist.at(2).toULongLong(&bok, 16);
				pstTheParamter->pusType[usIndex]		=	stringlist.at(3).toUShort(&bok, 16);
				++usIndex;
			}
		}

		pstTheParamter->usCount	=	usIndex;

		customdb.close();
	}

	QSqlDatabase::removeDatabase("querycustom");

	if(!bparsesuccess || !bItemExist){
		if(uiGroup == 1) {HisReleaseNewO(itemshareData.customIICG1Parameter);}
		else if(uiGroup == 2) {HisReleaseNewO(itemshareData.customIICG2Parameter);}
		else if(uiGroup == 3) {HisReleaseNewO(itemshareData.customIICG3Parameter);}
		else {HisReleaseNewO(itemshareData.customIICG4Parameter);}
		itemshareData.itemparameterLock.unlock();
		return HisFX3Error_Parameter;
	}

	if(!bcheck) {itemshareData.itemparameterLock.unlock(); return 0; }

	itemshareData.itemparameterLock.unlock();
	return 0;
}

int itemprocess::setCustomIICG(unsigned int uiGroup)
{
	int iresult;
	if(iresult = getCustomIICGParameter(false, uiGroup)) return iresult;

	_HisCCMCustomIICParatemer* pstParameter;
	if(uiGroup == 1){ pstParameter = itemshareData.customIICG1Parameter; }
	else if(uiGroup == 2){ pstParameter = itemshareData.customIICG2Parameter; }
	else if(uiGroup == 3){ pstParameter = itemshareData.customIICG3Parameter; }
	else{ pstParameter = itemshareData.customIICG4Parameter; }

	if(!pstParameter->usCount) return 0;

	if(hisglobalparameter.bDebugMode){
		emit information("write custom register command:");
		for(unsigned int x=0;	x<pstParameter->usCount;	++x){
			emit information("0x" % QString::number(pstParameter->pucSlave[x], 16) % ",0x" % QString::number(pstParameter->puiAddr[x], 16) % \
				",0x" % QString::number(pstParameter->puiData[x], 16) % ",0x" % QString::number(pstParameter->pusType[x], 16) % "\n");
		}
	}

	for(unsigned short x=0;	x<pstParameter->usCount;	++x)
	{
		if(iresult = classPlatform.HisFX3WriteIIC(pstParameter->pucSlave[x], pstParameter->puiAddr[x], pstParameter->puiData[x], pstParameter->pusType[x], true))
			return iresult;
	}

	return iresult;
	// 	return classPlatform.HisFX3BatchWriteIICNoLimit(pstParameter->usCount, pstParameter->pucSlave, pstParameter->puiAddr, pstParameter->puiData, pstParameter->pusType, 100);
}

int itemprocess::getotpburnParameter(bool bupdate, bool bcheck)
{
	itemshareData.itemparameterLock.lockForRead();
	if(!bupdate && itemshareData.otpburnParameter){
		itemshareData.itemparameterLock.unlock();
		return 0;
	}

	QMutexLocker locker(&hisglobalparameter.mutexDatabase);

	itemshareData.itemparameterLock.unlock();
	itemshareData.itemparameterLock.lockForWrite();
	if(!itemshareData.otpburnParameter)
		itemshareData.otpburnParameter		=	new _otpburnParameter;
	if(!itemshareData.otpburnParameter){
		itemshareData.itemparameterLock.unlock();
		return HisFX3Error_MallocBuffer;
	}

	itemshareData.otpburnParameter->uiIndex	=	0;

	bool bparsesuccess	=	true, bItemExist = false;

	//读取，解析config
	for(int  w=0;	w<1;	++w){ //此处是有意义的,不要删除
		QSqlDatabase customdb = QSqlDatabase::addDatabase("QSQLITE", "querycustom");
		customdb.setDatabaseName(QDir::currentPath() % "/HisFX3Custom");
		if (!customdb.open()){
			bparsesuccess	=	false;
			break;
		}

		QString strData, strdata2;
		QStringList strname, strvalue;
		bool bok;
		QSqlQuery query(customdb);
		query.prepare("SELECT itemsuffix2,key,value,reserve FROM " % itemshareData.currentTableName % \
			" WHERE classfy='sensor' AND item='otpburn' ORDER BY id ASC" );
		query.exec();

		//(burn:true)(onlycheckdata:true)(sleep:1000)(ob:0)(luxmin:118)(luxmax:138)(lsc_shadinguniform:0.3)(blocksize:5)(curfun:OV8858_INTEL_SENSOR_RULE1)
		//(mid:0x01)(lensid:0x01)(vcmid:0x01)(driverid:0x01)(centerrange:0.2)(lightcomp_b:1.0)((lightcomp_r:1.0))
		//(lsc_shadingmin:0.1)(lsc_shadingmax:0.2)(lsc_luxsymm:0.05)(lsc_centerr2grmin:0.5)(lsc_centerr2grmax:1.5)---
		//---(lsc_centerb2grmin:0.5)(lsc_centerb2grmax:1.5)(lsc_b2gr2centermax:0.5)(lsc_r2gr2centermax:1.5)
		//paint text

		while (query.next()){
			bItemExist = true;
			for(int y=0;	y<3;	++y){
				strData	=	query.value(y).toString();
				ROPLOW::patchconfigstring(strData, strname, strvalue);
				for(int x=0;	x<strname.size();	++x){
					if(strname.at(x) == "burn")	itemshareData.otpburnParameter->bburn	=	(strvalue.at(x) == "true");
					else if(strname.at(x) == "burnOpticalCenter")	itemshareData.otpburnParameter->bBurnOpticalCenter	=	(strvalue.at(x) == "true");
					else if(strname.at(x) == "onlycheckdata")	itemshareData.otpburnParameter->bOnlyCheckData	=	(strvalue.at(x) == "true");
					else if(strname.at(x) == "curfun")
						itemshareData.otpburnParameter->strFunctionChoose	=	strvalue.at(x).toUpper();
					else if(strname.at(x) == "sleep")
						itemshareData.otpburnParameter->uiFrameSleep	=	strvalue.at(x).toUInt();
					else if(strname.at(x) == "ob")
						itemshareData.otpburnParameter->uiDark	=	strvalue.at(x).toUInt();
					else if(strname.at(x) == "luxmin")
						itemshareData.otpburnParameter->uiLuxMin	=	strvalue.at(x).toUInt();
					else if(strname.at(x) == "luxmax")
						itemshareData.otpburnParameter->uiLuxMax	=	strvalue.at(x).toUInt();
					else if(strname.at(x) == "blocksize")
						itemshareData.otpburnParameter->uiBlockSize	=	strvalue.at(x).toUInt();
					else if(strname.at(x) == "centerrange")
						itemshareData.otpburnParameter->flRangeRatio	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "lightcomp_b")
						itemshareData.otpburnParameter->dflLightCoeB	=	strvalue.at(x).toDouble();
					else if(strname.at(x) == "lightcomp_r")
						itemshareData.otpburnParameter->dflLightCoeR	=	strvalue.at(x).toDouble();
					else if(strname.at(x) == "lsc_shadingmin")
						itemshareData.otpburnParameter->flLSC_LuxShadingMin	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "lsc_shadingmax")
						itemshareData.otpburnParameter->flLSC_LuxShadingMax	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "lsc_shadinguniform")
						itemshareData.otpburnParameter->flLSC_LuxShadingUniform	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "lsc_luxsymm")
						itemshareData.otpburnParameter->flLSC_LuxSymmMax	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "lsc_centerr2grmin")
						itemshareData.otpburnParameter->flLSC_CenterR2GrMin	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "lsc_centerr2grmax")
						itemshareData.otpburnParameter->flLSC_CenterR2GrMax	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "lsc_centerb2grmin")
						itemshareData.otpburnParameter->flLSC_CenterB2GrMin	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "lsc_centerb2grmax")
						itemshareData.otpburnParameter->flLSC_CenterB2GrMax	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "lsc_r2gr2centermax")
						itemshareData.otpburnParameter->flLSC_WB2CenterMax_R2Gr	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "lsc_b2gr2centermax")
						itemshareData.otpburnParameter->flLSC_WB2CenterMax_B2Gr	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "mid"){
						strData	=	strvalue.at(x);
						itemshareData.otpburnParameter->uiMID	=	(strData.remove("0x")).toUInt(&bok, 16);
					}
					else if(strname.at(x) == "lensid"){
						strData	=	strvalue.at(x);
						itemshareData.otpburnParameter->uiLENSID	=	(strData.remove("0x")).toUInt(&bok, 16);
					}
					else if(strname.at(x) == "vcmid"){
						strData	=	strvalue.at(x);
						itemshareData.otpburnParameter->uiVCMID	=	(strData.remove("0x")).toUInt(&bok, 16);
					}
					else if(strname.at(x) == "driverid"){
						strData	=	strvalue.at(x);
						itemshareData.otpburnParameter->uiDRIVERICID	=	(strData.remove("0x")).toUInt(&bok, 16);
					}
					else if(strname.at(x) == "ocxdeviationmax")
						itemshareData.otpburnParameter->iOCXDeviationMax	=	strvalue.at(x).toInt();
					else if(strname.at(x) == "ocydeviationmax")
						itemshareData.otpburnParameter->iOCYDeviationMax	=	strvalue.at(x).toInt();
				}
			}
			itemshareData.otpburnParameter->pairConfig	=	query.value(3).toString();
		}

		customdb.close();
	}

	QSqlDatabase::removeDatabase("querycustom");

	if(!bparsesuccess || !bItemExist){
		HisReleaseNewO(itemshareData.otpburnParameter);
		itemshareData.itemparameterLock.unlock();
		return HisFX3Error_Parameter;
	}

	if(!bcheck) {itemshareData.itemparameterLock.unlock(); return 0; }

	itemshareData.itemparameterLock.unlock();

	return 0;
}

int itemprocess::otpburn()
{
	//判断图像是否点亮中
	if(!threadshareData.GetHisPreviewflag())
		return HisCCMError_NotPreivew;

	//取得配置参数和规格
	int iresult	=	getotpburnParameter(false);
	if(iresult)
		return iresult;
	iresult	=	getccmhardwareParameter(false);
	if(iresult)
		return iresult;

	QDir classDir;
	QString strData	=	QDir::currentPath() % "/otptemplate/" % itemshareData.ccmhardwareParameter->sensortype;
	classDir.mkpath(strData);

	itemshareData.itemparameterLock.lockForRead();

	_HisCCMOTP_Config stParameter;
	stParameter.puiIndex	=	&(itemshareData.otpburnParameter->uiIndex);
	stParameter.iheight		=	itemshareData.previewParameter->iHeight;
	stParameter.iwidth		=	itemshareData.previewParameter->iWidth;
	stParameter.uiDataFormat	=	itemshareData.previewParameter->ucDataFormat;
	stParameter.bburn		=	itemshareData.otpburnParameter->bburn;
	stParameter.bOnlyCheckBurnData		=	itemshareData.otpburnParameter->bOnlyCheckData;
	stParameter.uiFrameSleep	=	itemshareData.otpburnParameter->uiFrameSleep;
	stParameter.uiMID	=	itemshareData.otpburnParameter->uiMID;
	stParameter.uiLENSID	=	itemshareData.otpburnParameter->uiLENSID;
	stParameter.uiVCMID	=	itemshareData.otpburnParameter->uiVCMID;
	stParameter.uiDRIVERICID	=	itemshareData.otpburnParameter->uiDRIVERICID;
	stParameter.flRangeRatio	=	itemshareData.otpburnParameter->flRangeRatio;
	stParameter.uiLuxMin	=	itemshareData.otpburnParameter->uiLuxMin;
	stParameter.uiLuxMax	=	itemshareData.otpburnParameter->uiLuxMax;
	stParameter.uiDark	=	itemshareData.otpburnParameter->uiDark;
	stParameter.flLSC_LuxShadingMin	=	itemshareData.otpburnParameter->flLSC_LuxShadingMin;
	stParameter.flLSC_LuxShadingMax	=	itemshareData.otpburnParameter->flLSC_LuxShadingMax;
	stParameter.flLSC_LuxSymmMax	=	itemshareData.otpburnParameter->flLSC_LuxSymmMax;
	stParameter.flLSC_CenterR2GrMin	=	itemshareData.otpburnParameter->flLSC_CenterR2GrMin;
	stParameter.flLSC_CenterR2GrMax	=	itemshareData.otpburnParameter->flLSC_CenterR2GrMax;
	stParameter.flLSC_CenterB2GrMin	=	itemshareData.otpburnParameter->flLSC_CenterB2GrMin;
	stParameter.flLSC_CenterB2GrMax	=	itemshareData.otpburnParameter->flLSC_CenterB2GrMax;
	stParameter.flLSC_WB2CenterMax_R2Gr	=	itemshareData.otpburnParameter->flLSC_WB2CenterMax_R2Gr;
	stParameter.flLSC_WB2CenterMax_B2Gr	=	itemshareData.otpburnParameter->flLSC_WB2CenterMax_B2Gr;
	stParameter.flLSC_LuxShadingUniform	=	itemshareData.otpburnParameter->flLSC_LuxShadingUniform;
	stParameter.uiBlockSize	=	itemshareData.otpburnParameter->uiBlockSize;
	stParameter.dflLightCoeR	=	itemshareData.otpburnParameter->dflLightCoeR;
	stParameter.dflLightCoeB	=	itemshareData.otpburnParameter->dflLightCoeB;
	stParameter.strproject	=	(itemshareData.ccmhardwareParameter->projectname.toAscii()).data();
	stParameter.strsensor	=	(itemshareData.ccmhardwareParameter->sensortype.toAscii()).data();
	stParameter.strFunctionChoose	=	(itemshareData.otpburnParameter->strFunctionChoose.toAscii()).data();
	stParameter.ucSlave		=	itemshareData.previewParameter->ucSlave;
	stParameter.ucEESlave	=	itemshareData.ccmhardwareParameter->ucEESlave;
	stParameter.bDebug		=	hisglobalparameter.bDebugMode;
	stParameter.bBurnOpticalCenter=itemshareData.otpburnParameter->bBurnOpticalCenter;

	QString strSerialNumber;
	classLog->getserialnumber(strSerialNumber);
	stParameter.strSerialNumber	=	strSerialNumber.toAscii().data();

#if (defined _WIN64) && (defined _DEBUG)
	QString strLibPath	=	QDir::currentPath() % "/HisCCMOTP64D";
#elif (defined _WIN64) && !(defined _DEBUG)
	QString strLibPath	=	QDir::currentPath() % "/HisCCMOTP64";
#elif (defined _WIN32) && (defined _DEBUG)
	QString strLibPath	=	QDir::currentPath() % "/HisCCMOTP32D";
#else
	QString strLibPath	=	QDir::currentPath() % "/HisCCMOTP32";
#endif

	RolongoOTPAPIVersion getRolongoOTPAPIVersion = (RolongoOTPAPIVersion)(QLibrary::resolve(strLibPath, "getRolongoOTPAPIVersion"));
	Rolongowriteotp writeotp = (Rolongowriteotp)(QLibrary::resolve(strLibPath, "writeotp"));

	emit information("getRolongoOTPAPIVersion: "  % QString::number((unsigned int)getRolongoOTPAPIVersion, 16));
	emit information("writeotp: "  % QString::number((unsigned int)writeotp, 16));

	if(!(getRolongoOTPAPIVersion && writeotp)){
		emit information(tr("Resolve HisCCMOTP DLL Function Fail"));
		itemshareData.itemparameterLock.unlock();
		return HisCCMError_LoadDLLFuc;
	}

	strData	=	itemshareData.otpburnParameter->pairConfig.remove("(");
	QStringList stringlist	=	strData.split(")");
	QStringList stringlist2;
	stParameter.vectorPair.clear();
	stParameter.vectorPair.reserve(stringlist.size());
	int y = 0;
	for(int x=0; x<stringlist.size();	++x){
		stringlist2	=	stringlist.at(x).split(":");
		if(stringlist2.size() == 2){
			stParameter.vectorPair.resize(y+1);
			stParameter.vectorPair.at(y).strkey	=	stringlist2.at(0).trimmed().toAscii().data();
			stParameter.vectorPair.at(y).strvalue	=	stringlist2.at(1).trimmed().toAscii().data();
			++y;
		}
	}

#if 1
	//*********************  2017/12/11  *****************
	QSqlDatabase dbLotSN = QSqlDatabase::addDatabase("QSQLITE", "dbLotSN");
	dbLotSN.setDatabaseName("JSL_OtpCount");
	if (!dbLotSN.open()){
		itemshareData.itemparameterLock.unlock();
		return HisCCMError_Database;
	}

	QSqlQuery query(dbLotSN);
	query.prepare("select * from [CurrentBurnLotSN] where 1");
	query.exec();
	query.next();
	QString strLotSN=query.value(0).toString();
	query.prepare(QString("select * from [")+strLotSN+"] where ChipID='"+ QString::fromStdString(stParameter.strSerialNumber) +"'");
	query.exec();
	if(query.next()){
		emit information(QString::fromLocal8Bit("模组已有烧录记录:SN=")+QString::fromStdString(stParameter.strSerialNumber));
		itemshareData.itemparameterLock.unlock();
		return HisCCMError_OtpWrite;
	}

	emit information(QString::fromLocal8Bit("SN=")+QString::fromStdString(stParameter.strSerialNumber));
#endif


	//********************************
	if(itemshareData.otpburnParameter->bBurnOpticalCenter)
	{
		unsigned char* pucRGBBuffer = NULL;
		unsigned int uiImgSize=itemshareData.previewParameter->iWidth*itemshareData.previewParameter->iHeight*3;
		unsigned char ucFrameType		=	_FrameType_RGB24;

		pucRGBBuffer		=	(unsigned char*)_aligned_malloc(uiImgSize, _HisCacheLine_Aligned);
		if(!pucRGBBuffer)
		{
			HisReleaseMalloc(pucRGBBuffer);
			itemshareData.itemparameterLock.unlock();
			return HisFX3Error_MallocBuffer;
		}

		iresult	=	GetFreshframe(pucRGBBuffer, uiImgSize, ucFrameType, true);
		if(iresult){
			HisReleaseMalloc(pucRGBBuffer);
			itemshareData.itemparameterLock.unlock();
			return iresult;
		}
		int  iOCX=0,iOCY=0;
		iresult =	classRolongoTest.cvRolongoHD6017Otpcenter(pucRGBBuffer,itemshareData.previewParameter->iWidth,itemshareData.previewParameter->iHeight,
			0.0001f,iOCX,iOCY);
		HisReleaseMalloc(pucRGBBuffer);
		stParameter.iOpitcalcenterX=iOCX;
		stParameter.iOpitcalcenterY=iOCY;
		int  iOCShiftX=iOCX-itemshareData.previewParameter->iWidth/2;
		int  iOCShiftY=iOCY-itemshareData.previewParameter->iHeight/2;
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("OCX Shift：") % QString::number(iOCShiftX));
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("OCY Shift：") % QString::number(iOCShiftY));


		if(abs(iOCShiftX)>itemshareData.otpburnParameter->iOCXDeviationMax ||abs(iOCShiftY)>itemshareData.otpburnParameter->iOCYDeviationMax)
		{
			iresult=HisCCMError_OpticalCenterTest;
			emit information(QTextCodec::codecForName( "GBK")->toUnicode("Opitcal center X/Y测试超出规格") );
		}
	}

	emit enableinfotimer(1);



	iresult	=	writeotp(*globalFunPointer.vectorHisCCMOTPInfoW, &stParameter, globalFunPointer.ReadHisFX3IIC, globalFunPointer.WriteHisFX3IIC, globalFunPointer.SetHisFX3IICSpeed, \
		globalFunPointer.SetHisFX3Voltage, globalFunPointer.GetHisFX3Voltage, SetHisFX3VFuseVolt, GetHisFX3VFuseVolt, GetFreshframe, \
		globalFunPointer.BatchWriteHisFX3IIC, globalFunPointer.BatchReadHisFX3IIC, SetHisFX3GPIO, GetHisFX3GPIO, globalFunPointer.PullHisFX3RESET, globalFunPointer.PullHisFX3PWND, \
		globalFunPointer.BatchReadHisFX3IICNoLimit, globalFunPointer.BatchWriteHisFX3IICNoLimit, globalFunPointer.HisFX3LogPush_back, \
		globalFunPointer.PageWriteHisFX3IIC, globalFunPointer.PageReadHisFX3IIC, globalFunPointer.HisFX3PageWriteSPI, globalFunPointer.HisFX3PageReadSPI);
	emit enableinfotimer(0);

	//unsigned int uiTempAddr[3]={0x0074,0x0075,0x0076};
	//unsigned int uiTempVal[3]={0};
	//unsigned short usTypeArr[3]={0x1608,0x1608,0x1608};
	/*DWORD stratTime=GetTickCount();
	//BatchWriteHisFX3IICNoLimitC1(3,&stParameter.ucSlave,uiTempAddr,uiTempVal,usTypeArr,10);
	WriteHisFX3IICC1(stParameter.ucSlave,0x74,0x05,0x1608,true);
	//BatchWriteHisFX3IICNoLimitC1(1,&stParameter.ucSlave,uiTempAddr,uiTempVal,usTypeArr,10);
	DWORD TotalTime=GetTickCount()-stratTime;*/

#if 0 //2017/12/27 
	//*********************  2017/12/11  *****************
	QSqlDatabase dbLotSN = QSqlDatabase::addDatabase("QSQLITE", "dbLotSN");
	dbLotSN.setDatabaseName("HisFX3Template");
	if (!dbLotSN.open()){
		itemshareData.itemparameterLock.unlock();
		return HisCCMError_Database;
	}

	QSqlQuery query(dbLotSN);
	query.prepare("select SN from burndata where SN=:sn");
	query.bindValue(":sn",stParameter.strSerialNumber.c_str());
	query.exec();
	if(query.next()){
		query.prepare("update burndata set DateTime=:datetime,result=:result where SN=:sn");
		query.bindValue(":datetime",QDateTime::currentDateTime());
		query.bindValue(":result",iresult==0);
		query.bindValue(":sn",stParameter.strSerialNumber.c_str());
		if(!query.exec()){
			emit information("sqlSave Error:"+query.lastError().text());
		}
	}else{
		query.prepare("insert into burndata values(:sn,:datetime,:result)");
		query.bindValue(":datetime",QDateTime::currentDateTime());
		query.bindValue(":result",iresult==0);
		query.bindValue(":sn",stParameter.strSerialNumber.c_str());
		query.exec();
	}

#endif

#if 1
	//******************** 2017/12/11 ***********************

	if(iresult==0){ 
		global_unit_rg=stParameter.iOpitcalcenterX;
		global_unit_bg=stParameter.iOpitcalcenterY;
		global_unit_g=stParameter.uiMachineID;
		global_burn_group=stParameter.uiHardwareVersion;
	}

	emit sigBurnCount();
#endif
	//******************************** 

	stLogItem.itemtype		=	classLog->getmaxtypeindex(_HISLOG_CLASSIFY_OTPBURN);
	stLogItem.itemkey		=	"OTPBurn Result";
	stLogItem.itemvalue	=	(iresult)?("NG"):("OK");
	classLog->push_back(stLogItem);

	if(stParameter.flLuxResult >= 0.0f)
		_CODE_LOG_PUSHBACK("OTPBurn_Brightness_G", stParameter.flLuxResult);
	if(stParameter.flLSC_LuxShadingUniformResult_Gr >= 0.0f)
		_CODE_LOG_PUSHBACK("OTPBurn_CornerUniform_Gr", stParameter.flLSC_LuxShadingUniformResult_Gr);
	if(stParameter.flLSC_LuxShadingResult_GrLT >= 0.0f)
		_CODE_LOG_PUSHBACK("OTPBurn_Shading_Gr_LT", stParameter.flLSC_LuxShadingResult_GrLT);
	if(stParameter.flLSC_LuxShadingResult_GrRT >= 0.0f)
		_CODE_LOG_PUSHBACK("OTPBurn_Shading_Gr_RT", stParameter.flLSC_LuxShadingResult_GrRT);
	if(stParameter.flLSC_LuxShadingResult_GrLB >= 0.0f)
		_CODE_LOG_PUSHBACK("OTPBurn_Shading_Gr_LB", stParameter.flLSC_LuxShadingResult_GrLB);
	if(stParameter.flLSC_LuxShadingResult_GrRB >= 0.0f)
		_CODE_LOG_PUSHBACK("OTPBurn_Shading_Gr_RB", stParameter.flLSC_LuxShadingResult_GrRB);
	if(stParameter.flLSC_LuxSymmMaxResult_Gr >= 0.0f)
		_CODE_LOG_PUSHBACK("OTPBurn_SymmMax_Gr", stParameter.flLSC_LuxSymmMaxResult_Gr);
	if(stParameter.flLSC_LuxSymmMaxResult_Gb >= 0.0f)
		_CODE_LOG_PUSHBACK("OTPBurn_SymmMax_Gb", stParameter.flLSC_LuxSymmMaxResult_Gb);
	if(stParameter.flLSC_LuxSymmMaxResult_R >= 0.0f)
		_CODE_LOG_PUSHBACK("OTPBurn_SymmMax_R", stParameter.flLSC_LuxSymmMaxResult_R);
	if(stParameter.flLSC_LuxSymmMaxResult_B >= 0.0f)
		_CODE_LOG_PUSHBACK("OTPBurn_SymmMax_B", stParameter.flLSC_LuxSymmMaxResult_B);
	if(stParameter.flLSC_CenterR2GrResult >= 0.0f)
		_CODE_LOG_PUSHBACK("OTPBurn_ColorCenter_R2Gr", stParameter.flLSC_CenterR2GrResult);
	if(stParameter.flLSC_CenterB2GrResult >= 0.0f)
		_CODE_LOG_PUSHBACK("OTPBurn_ColorCenter_B2Gr", stParameter.flLSC_CenterB2GrResult);
	if(stParameter.flLSC_CenterGb2GrResult >= 0.0f)
		_CODE_LOG_PUSHBACK("OTPBurn_ColorCenter_Gb2Gr", stParameter.flLSC_CenterGb2GrResult);
	if(stParameter.flLSC_WB2CenterMaxResult_R2Gr >= 0.0f)
		_CODE_LOG_PUSHBACK("OTPBurn_ColorUniformMax_R2Gr", stParameter.flLSC_WB2CenterMaxResult_R2Gr);
	if(stParameter.flLSC_WB2CenterMaxResult_B2Gr >= 0.0f)
		_CODE_LOG_PUSHBACK("OTPBurn_ColorUniformMax_B2Gr", stParameter.flLSC_WB2CenterMaxResult_B2Gr);

	if(iresult){
		itemshareData.itemparameterLock.unlock();
		return iresult;
	}

	itemshareData.itemparameterLock.unlock();
	return 0;
}

int itemprocess::otpcheck()
{
#ifdef _HisFX3_Platform_Jigboard
	return jigboard_OTPCheck_Rule1(&classPlatform);
#endif

	//判断图像是否点亮中
	if(!threadshareData.GetHisPreviewflag())	return HisCCMError_NotPreivew;

	//取得配置参数和规格
	int iresult	=	getotpburnParameter(false);
	if(iresult)
		return iresult;
	iresult	=	getccmhardwareParameter(false);
	if(iresult)
		return iresult;

	QDir classDir;
	QString strData	=	QDir::currentPath() % "/otptemplate/" % itemshareData.ccmhardwareParameter->sensortype;
	classDir.mkpath(strData);

	itemshareData.itemparameterLock.lockForRead();

	_HisCCMOTP_Config stParameter;
	stParameter.puiIndex	=	&(itemshareData.otpburnParameter->uiIndex);
	stParameter.iheight		=	itemshareData.previewParameter->iHeight;
	stParameter.iwidth		=	itemshareData.previewParameter->iWidth;
	stParameter.uiDataFormat	=	itemshareData.previewParameter->ucDataFormat;
	stParameter.bburn		=	itemshareData.otpburnParameter->bburn;
	stParameter.bOnlyCheckBurnData		=	itemshareData.otpburnParameter->bOnlyCheckData;
	stParameter.uiFrameSleep	=	itemshareData.otpburnParameter->uiFrameSleep;
	stParameter.uiMID	=	itemshareData.otpburnParameter->uiMID;
	stParameter.uiLENSID	=	itemshareData.otpburnParameter->uiLENSID;
	stParameter.uiVCMID	=	itemshareData.otpburnParameter->uiVCMID;
	stParameter.uiDRIVERICID	=	itemshareData.otpburnParameter->uiDRIVERICID;
	stParameter.flRangeRatio	=	itemshareData.otpburnParameter->flRangeRatio;
	stParameter.uiLuxMin	=	itemshareData.otpburnParameter->uiLuxMin;
	stParameter.uiLuxMax	=	itemshareData.otpburnParameter->uiLuxMax;
	stParameter.uiDark	=	itemshareData.otpburnParameter->uiDark;
	stParameter.flLSC_LuxShadingMin	=	itemshareData.otpburnParameter->flLSC_LuxShadingMin;
	stParameter.flLSC_LuxShadingMax	=	itemshareData.otpburnParameter->flLSC_LuxShadingMax;
	stParameter.flLSC_LuxSymmMax	=	itemshareData.otpburnParameter->flLSC_LuxSymmMax;
	stParameter.flLSC_CenterR2GrMin	=	itemshareData.otpburnParameter->flLSC_CenterR2GrMin;
	stParameter.flLSC_CenterR2GrMax	=	itemshareData.otpburnParameter->flLSC_CenterR2GrMax;
	stParameter.flLSC_CenterB2GrMin	=	itemshareData.otpburnParameter->flLSC_CenterB2GrMin;
	stParameter.flLSC_CenterB2GrMax	=	itemshareData.otpburnParameter->flLSC_CenterB2GrMax;
	stParameter.flLSC_WB2CenterMax_R2Gr	=	itemshareData.otpburnParameter->flLSC_WB2CenterMax_R2Gr;
	stParameter.flLSC_WB2CenterMax_B2Gr	=	itemshareData.otpburnParameter->flLSC_WB2CenterMax_B2Gr;
	stParameter.flLSC_LuxShadingUniform	=	itemshareData.otpburnParameter->flLSC_LuxShadingUniform;
	stParameter.uiBlockSize	=	itemshareData.otpburnParameter->uiBlockSize;
	stParameter.dflLightCoeR	=	itemshareData.otpburnParameter->dflLightCoeR;
	stParameter.dflLightCoeB	=	itemshareData.otpburnParameter->dflLightCoeB;
	stParameter.strproject	=	(itemshareData.ccmhardwareParameter->projectname.toAscii()).data();
	stParameter.strsensor	=	(itemshareData.ccmhardwareParameter->sensortype.toAscii()).data();
	stParameter.strFunctionChoose	=	(itemshareData.otpburnParameter->strFunctionChoose.toAscii()).data();
	stParameter.ucSlave		=	itemshareData.previewParameter->ucSlave;
	stParameter.ucEESlave	=	itemshareData.ccmhardwareParameter->ucEESlave;
	stParameter.bDebug		=	hisglobalparameter.bDebugMode;

	QString strSerialNumber;
	classLog->getserialnumber(strSerialNumber);
	stParameter.strSerialNumber	=	strSerialNumber.toAscii().data();

	strData	=	itemshareData.otpburnParameter->pairConfig.remove("(");
	QStringList stringlist	=	strData.split(")");
	QStringList stringlist2;
	stParameter.vectorPair.clear();
	stParameter.vectorPair.reserve(stringlist.size());
	int y = 0;
	for(int x=0; x<stringlist.size();	++x){
		stringlist2	=	stringlist.at(x).split(":");
		if(stringlist2.size() == 2){
			stParameter.vectorPair.resize(y+1);
			stParameter.vectorPair.at(y).strkey	=	stringlist2.at(0).trimmed().toAscii().data();
			stParameter.vectorPair.at(y).strvalue	=	stringlist2.at(1).trimmed().toAscii().data();
			++y;
		}
	}

#if (defined _WIN64) && (defined _DEBUG)
	QString strLibPath	=	QDir::currentPath() % "/HisCCMOTP64D";
#elif (defined _WIN64) && !(defined _DEBUG)
	QString strLibPath	=	QDir::currentPath() % "/HisCCMOTP64";
#elif (defined _WIN32) && (defined _DEBUG)
	QString strLibPath	=	QDir::currentPath() % "/HisCCMOTP32D";
#else
	QString strLibPath	=	QDir::currentPath() % "/HisCCMOTP32";
#endif

	RolongoOTPAPIVersion getRolongoOTPAPIVersion = (RolongoOTPAPIVersion)(QLibrary::resolve(strLibPath, "getRolongoOTPAPIVersion"));
	Rolongocheckotp checkotp = (Rolongocheckotp)(QLibrary::resolve(strLibPath, "checkotp"));

	if(!(getRolongoOTPAPIVersion && checkotp)){
		emit information(tr("Resolve HisCCMOTP DLL Function Fail"));
		itemshareData.itemparameterLock.unlock();
		return HisCCMError_LoadDLLFuc;
	}

	emit enableinfotimer(1);
	iresult	=	checkotp(*globalFunPointer.vectorHisCCMOTPInfoW, &stParameter, globalFunPointer.ReadHisFX3IIC, globalFunPointer.WriteHisFX3IIC, globalFunPointer.SetHisFX3IICSpeed, \
		globalFunPointer.SetHisFX3Voltage, globalFunPointer.GetHisFX3Voltage, SetHisFX3VFuseVolt, GetHisFX3VFuseVolt, GetFreshframe, \
		globalFunPointer.BatchWriteHisFX3IIC, globalFunPointer.BatchReadHisFX3IIC, SetHisFX3GPIO, GetHisFX3GPIO, globalFunPointer.PullHisFX3RESET, globalFunPointer.PullHisFX3PWND, \
		globalFunPointer.BatchReadHisFX3IICNoLimit, globalFunPointer.BatchWriteHisFX3IICNoLimit, globalFunPointer.HisFX3LogPush_back, \
		globalFunPointer.PageWriteHisFX3IIC, globalFunPointer.PageReadHisFX3IIC, globalFunPointer.HisFX3PageWriteSPI, globalFunPointer.HisFX3PageReadSPI);
	emit enableinfotimer(0);

#if 1 //2017/12/27 
	//*********************  2017/12/11  *****************
	QSqlDatabase dbLotSN = QSqlDatabase::addDatabase("QSQLITE", "dbLotSN");
	dbLotSN.setDatabaseName("HisFX3Template");
	if (!dbLotSN.open()){
		itemshareData.itemparameterLock.unlock();
		return HisCCMError_Database;
	}

	QSqlQuery query(dbLotSN);
	query.prepare("select SN from checkdata where SN=:sn");
	query.bindValue(":sn",stParameter.strSerialNumber.c_str());
	query.exec();
	if(query.next()){
		query.prepare("update checkdata set DateTime=:datetime,result=:result where SN=:sn");
		query.bindValue(":datetime",QDateTime::currentDateTime());
		query.bindValue(":result",iresult==0);
		query.bindValue(":sn",stParameter.strSerialNumber.c_str());
		if(!query.exec()){
			emit information("sqlSave Error:"+query.lastError().text());
		}
	}else{
		query.prepare("insert into checkdata values(:sn,:datetime,:result)");
		query.bindValue(":datetime",QDateTime::currentDateTime());
		query.bindValue(":result",iresult==0);
		query.bindValue(":sn",stParameter.strSerialNumber.c_str());
		query.exec();
	}

#endif

	stLogItem.itemtype		=	classLog->getmaxtypeindex(_HISLOG_CLASSIFY_OTPCHECK);
	stLogItem.itemkey		=	"OTPBurnCheck Result";
	stLogItem.itemvalue	=	(iresult)?("NG"):("OK");
	classLog->push_back(stLogItem);

	if(stParameter.flLuxResult >= 0.0f)
		_CODE_LOG_PUSHBACK("OTPCheck_Brightness_G", stParameter.flLuxResult);
	if(stParameter.flLSC_LuxShadingUniformResult_Gr >= 0.0f)
		_CODE_LOG_PUSHBACK("OTPCheck_CornerUniform_Gr", stParameter.flLSC_LuxShadingUniformResult_Gr);
	if(stParameter.flLSC_LuxShadingResult_GrLT >= 0.0f)
		_CODE_LOG_PUSHBACK("OTPCheck_Shading_Gr_LT", stParameter.flLSC_LuxShadingResult_GrLT);
	if(stParameter.flLSC_LuxShadingResult_GrRT >= 0.0f)
		_CODE_LOG_PUSHBACK("OTPCheck_Shading_Gr_RT", stParameter.flLSC_LuxShadingResult_GrRT);
	if(stParameter.flLSC_LuxShadingResult_GrLB >= 0.0f)
		_CODE_LOG_PUSHBACK("OTPCheck_Shading_Gr_LB", stParameter.flLSC_LuxShadingResult_GrLB);
	if(stParameter.flLSC_LuxShadingResult_GrRB >= 0.0f)
		_CODE_LOG_PUSHBACK("OTPCheck_Shading_Gr_RB", stParameter.flLSC_LuxShadingResult_GrRB);
	if(stParameter.flLSC_LuxSymmMaxResult_Gr >= 0.0f)
		_CODE_LOG_PUSHBACK("OTPCheck_SymmMax_Gr", stParameter.flLSC_LuxSymmMaxResult_Gr);
	if(stParameter.flLSC_LuxSymmMaxResult_Gb >= 0.0f)
		_CODE_LOG_PUSHBACK("OTPCheck_SymmMax_Gb", stParameter.flLSC_LuxSymmMaxResult_Gb);
	if(stParameter.flLSC_LuxSymmMaxResult_R >= 0.0f)
		_CODE_LOG_PUSHBACK("OTPCheck_SymmMax_R", stParameter.flLSC_LuxSymmMaxResult_R);
	if(stParameter.flLSC_LuxSymmMaxResult_B >= 0.0f)
		_CODE_LOG_PUSHBACK("OTPCheck_SymmMax_B", stParameter.flLSC_LuxSymmMaxResult_B);
	if(stParameter.flLSC_CenterR2GrResult >= 0.0f)
		_CODE_LOG_PUSHBACK("OTPCheck_ColorCenter_R2Gr", stParameter.flLSC_CenterR2GrResult);
	if(stParameter.flLSC_CenterB2GrResult >= 0.0f)
		_CODE_LOG_PUSHBACK("OTPCheck_ColorCenter_B2Gr", stParameter.flLSC_CenterB2GrResult);
	if(stParameter.flLSC_CenterGb2GrResult >= 0.0f)
		_CODE_LOG_PUSHBACK("OTPCheck_ColorCenter_Gb2Gr", stParameter.flLSC_CenterGb2GrResult);
	if(stParameter.flLSC_WB2CenterMaxResult_R2Gr >= 0.0f)
		_CODE_LOG_PUSHBACK("OTPCheck_ColorUniformMax_R2Gr", stParameter.flLSC_WB2CenterMaxResult_R2Gr);
	if(stParameter.flLSC_WB2CenterMaxResult_B2Gr >= 0.0f)
		_CODE_LOG_PUSHBACK("OTPCheck_ColorUniformMax_B2Gr", stParameter.flLSC_WB2CenterMaxResult_B2Gr);


	if(iresult){
		itemshareData.itemparameterLock.unlock();
		return iresult;
	}

	itemshareData.itemparameterLock.unlock();
	return 0;
}

int itemprocess::getlsCheckParameter(bool bupdate, bool bcheck)
{
	QMutexLocker locker(&hisglobalparameter.mutexDatabase);

	itemshareData.itemparameterLock.lockForRead();
	if(!bupdate && itemshareData.lightsourcecheckParameter)	{	itemshareData.itemparameterLock.unlock();	return 0;	}
	itemshareData.itemparameterLock.unlock();

	QHReadWriteLockManage classitemparameterLock(&(itemshareData.itemparameterLock), true);

	if(!itemshareData.lightsourcecheckParameter)	itemshareData.lightsourcecheckParameter		=	new _lightsourcecheckParameter;
	if(!itemshareData.lightsourcecheckParameter)	{	return HisFX3Error_MallocBuffer;	}

	bool bItemExist = false;
	{
		QSqlDatabase customdb = QSqlDatabase::addDatabase("QSQLITE", "querycustom");
		customdb.setDatabaseName(QDir::currentPath() % "/HisFX3Custom");
		if (!customdb.open()){
			itemshareData.itemparameterLock.unlock();
			return HisCCMError_Database;
		}

		QStringList strname, strvalue;
		QString strData, strData2;
		QSqlQuery query(customdb);
		query.prepare("SELECT itemsuffix2,key,value,reserve FROM " % itemshareData.currentTableName % \
			" WHERE classfy='algorithm' AND item='lightsourcecheck' AND itemsuffix1='total' ORDER BY id ASC" );
		query.exec();

		//(alg:0)
		while (query.next())
		{
			bItemExist = true;
			for(int y=0;	y<4;	++y)
			{
				strData	=	query.value(y).toString();
				ROPLOW::patchconfigstring(strData, strname, strvalue);
				for(int x=0;	x<strname.size();	++x){
					if(strname.at(x) == "alg")	 itemshareData.lightsourcecheckParameter->ucAlg	=	strvalue.at(x).toUInt() & 0xFF;					
				}
			}
		}

		query.prepare("SELECT itemsuffix2,key,value,reserve FROM " % itemshareData.currentTableName % \
			" WHERE classfy='algorithm' AND item='lightsourcecheck' AND itemsuffix1='alga' ORDER BY id ASC" );
		query.exec();

		//(roiw:0.2)(roih:0.2)
		//(rgmin:0.3)(rgmax:0.6)(bgmin:0.3)(bgmax:0.6)(gmin:180.0)(gmax:190.0)
		while (query.next())
		{
			bItemExist = true;
			for(int y=0;	y<4;	++y)
			{
				strData	=	query.value(y).toString();
				ROPLOW::patchconfigstring(strData, strname, strvalue);
				for(int x=0;	x<strname.size();	++x)
				{
					if(strname.at(x) == "roiw")				itemshareData.lightsourcecheckParameter->stAlgA.flROIW =	strvalue.at(x).toFloat();
					else if(strname.at(x) == "roih")		itemshareData.lightsourcecheckParameter->stAlgA.flROIH =	strvalue.at(x).toFloat();
					else if(strname.at(x) == "rgmin")	itemshareData.lightsourcecheckParameter->stAlgA.flRGMin =	strvalue.at(x).toFloat();
					else if(strname.at(x) == "rgmax")	itemshareData.lightsourcecheckParameter->stAlgA.flRGMax =	strvalue.at(x).toFloat();
					else if(strname.at(x) == "bgmin")	itemshareData.lightsourcecheckParameter->stAlgA.flBGMin =	strvalue.at(x).toFloat();
					else if(strname.at(x) == "bgmax")	itemshareData.lightsourcecheckParameter->stAlgA.flBGMax =	strvalue.at(x).toFloat();
					else if(strname.at(x) == "gmin")		itemshareData.lightsourcecheckParameter->stAlgA.flGMin		=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "gmax")		itemshareData.lightsourcecheckParameter->stAlgA.flGMax		=	strvalue.at(x).toFloat();
				}
			}
		}

		query.prepare("SELECT itemsuffix2,key,value,reserve FROM " % itemshareData.currentTableName % \
			" WHERE classfy='algorithm' AND item='lightsourcecheck' AND itemsuffix1='algb' ORDER BY id ASC" );
		query.exec();

		//(rawinfo:)
		//(rgmin:0.3)(rgmax:0.6)(bgmin:0.3)(bgmax:0.6)(ppmin:180.0)(ppmax:190.0)
		while (query.next())
		{
			bItemExist = true;
			for(int y=0;	y<4;	++y)
			{
				strData	=	query.value(y).toString();
				ROPLOW::patchconfigstring(strData, strname, strvalue);
				for(int x=0;	x<strname.size();	++x)
				{
					if(strname.at(x) == "rawinfo")				itemshareData.lightsourcecheckParameter->stAlgB.strRawInfo	=	strvalue.at(x);
					else if(strname.at(x) == "rgmin")		itemshareData.lightsourcecheckParameter->stAlgB.flRGMin		=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "rgmax")		itemshareData.lightsourcecheckParameter->stAlgB.flRGMax		=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "bgmin")		itemshareData.lightsourcecheckParameter->stAlgB.flBGMin		=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "bgmax")		itemshareData.lightsourcecheckParameter->stAlgB.flBGMax		=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "ppmin")		itemshareData.lightsourcecheckParameter->stAlgB.flPPMin		=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "ppmax")		itemshareData.lightsourcecheckParameter->stAlgB.flPPMax		=	strvalue.at(x).toFloat();
				}
			}
		}

		customdb.close();
	}

	QSqlDatabase::removeDatabase("querycustom");

	if(!bItemExist)
	{
		HisReleaseNewO(itemshareData.lightsourcecheckParameter);
		return HisFX3Error_Parameter;
	}

	return 0;
}

int itemprocess::LightSourceCheck()
{
	itemshareData.clearDrawList();

	//判断图像是否点亮中
	if(!threadshareData.GetHisPreviewflag())	return HisCCMError_NotPreivew;

	//取得配置参数和规格
	int iresult	=	getotpburnParameter(false);
	if(iresult)	return iresult;
	iresult	=	getlsCheckParameter(false);
	if(iresult)	return iresult;


	QHReadWriteLockManage classitemparameterLock(&(itemshareData.itemparameterLock));
	stLogItem.itemtype		=	classLog->getmaxtypeindex(_HISLOG_CLASSIFY_LSCHECK);
	stLogItem.itemkey		=	"LSCheck_Result";
	stLogItem.itemvalue	=	"OK";
	QHDefaultLogManage classstLogItem(classLog, &stLogItem, "NG");

	if(itemshareData.lightsourcecheckParameter->ucAlg == _HisAlg_SWITCH_A)
	{
		unsigned char* pucRGB24 = (unsigned char*)HisAlignedMalloc(itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight *3);
		if(!pucRGB24) return HisFX3Error_MallocBuffer;
		QHisFX3MallocAlignedManage classpucRGB24(pucRGB24);

		if(iresult = threadshareData.GetFreshframe(pucRGB24, itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight *3, _FrameType_RGB24, true))
			return iresult;

		RECT stblock;
		stblock.right		= itemshareData.previewParameter->iWidth *itemshareData.lightsourcecheckParameter->stAlgA.flROIW;
		stblock.bottom = itemshareData.previewParameter->iHeight *itemshareData.lightsourcecheckParameter->stAlgA.flROIH;
		stblock.left = (itemshareData.previewParameter->iWidth - stblock.right) /2;
		stblock.top = (itemshareData.previewParameter->iHeight - stblock.bottom) /2;
		stblock.right		=	stblock.left + stblock.right;
		stblock.bottom	=	stblock.top + stblock.bottom;

		unsigned char* pucLine = pucRGB24 + stblock.top *itemshareData.previewParameter->iWidth *3 + stblock.left *3;
		unsigned __int64 ui64R = 0, ui64G= 0, ui64B = 0, ui64Count = 0;
		for(int y=stblock.top;	y<stblock.bottom;	++y)
		{
			unsigned char* pucData	=	pucLine;
			pucLine	+=	(itemshareData.previewParameter->iWidth *3);
			for(int x=stblock.left; x<stblock.right; ++x)
			{
				ui64R	+=	*pucData-itemshareData.otpburnParameter->uiDark;
				ui64G	+=	*(pucData+1)-itemshareData.otpburnParameter->uiDark;
				ui64B	+=	*(pucData+2)-itemshareData.otpburnParameter->uiDark;
				pucData	+=	3;
				++ui64Count;
			}
		}

		double dflRG = 0.0, dflBG = 0.0, dflG = (double)(ui64G) / ui64Count;

		if(ui64G)
		{
			dflRG	=	(double)(ui64R)/ ui64G;
			dflBG	=	(double)(ui64B)/ ui64G;
		}

		emit information("RG: " % QString::number(dflRG, 'f', 4));
		emit information("BG: " % QString::number(dflBG, 'f', 4));
		emit information("G: " % QString::number(dflG, 'f', 4));

		itemshareData.drawLock.lockForWrite();
		itemshareData.itemdrawList.resize(4);
		unsigned int uiDrawIndex = 0;
		itemshareData.itemdrawList[uiDrawIndex].usitem	=	lightsourcecheckitem;
		itemshareData.itemdrawList[uiDrawIndex].uctype	=	HisDrawType_Block;
		itemshareData.itemdrawList[uiDrawIndex].stcolor	=	QColor::fromRgb(255, 255, 0);
		itemshareData.itemdrawList[uiDrawIndex].strinfo.stblock	=	stblock;
		++uiDrawIndex;

		itemshareData.itemdrawList[uiDrawIndex].usitem	=	lightsourcecheckitem;
		itemshareData.itemdrawList[uiDrawIndex].uctype	=	HisDrawType_Text;
		itemshareData.itemdrawList[uiDrawIndex].idata[0]	=	stblock.left;
		itemshareData.itemdrawList[uiDrawIndex].idata[1]	=	stblock.top;
		sprintf_s(itemshareData.itemdrawList[uiDrawIndex].strinfo.strtext,	15, "R/G:%.3f", dflRG);
		itemshareData.itemdrawList[uiDrawIndex].stcolor	=	QColor::fromRgb(0, 255, 0);
		if(dflRG > itemshareData.lightsourcecheckParameter->stAlgA.flRGMax || dflRG < itemshareData.lightsourcecheckParameter->stAlgA.flRGMin)
			itemshareData.itemdrawList[uiDrawIndex].stcolor	=	QColor::fromRgb(255, 0, 0);
		++uiDrawIndex;

		itemshareData.itemdrawList[uiDrawIndex].usitem	=	lightsourcecheckitem;
		itemshareData.itemdrawList[uiDrawIndex].uctype	=	HisDrawType_Text;
		itemshareData.itemdrawList[uiDrawIndex].idata[0]	=	stblock.left;
		itemshareData.itemdrawList[uiDrawIndex].idata[1]	=	stblock.bottom;
		sprintf_s(itemshareData.itemdrawList[uiDrawIndex].strinfo.strtext,	15, "B/G:%.3f", dflBG);
		itemshareData.itemdrawList[uiDrawIndex].stcolor	=	QColor::fromRgb(0, 255, 0);
		if(dflBG > itemshareData.lightsourcecheckParameter->stAlgA.flBGMax || dflBG < itemshareData.lightsourcecheckParameter->stAlgA.flBGMin)
			itemshareData.itemdrawList[uiDrawIndex].stcolor	=	QColor::fromRgb(255, 0, 0);
		++uiDrawIndex;

		itemshareData.itemdrawList[uiDrawIndex].usitem	=	lightsourcecheckitem;
		itemshareData.itemdrawList[uiDrawIndex].uctype	=	HisDrawType_Text;
		itemshareData.itemdrawList[uiDrawIndex].idata[0]	=	stblock.left;
		itemshareData.itemdrawList[uiDrawIndex].idata[1]	=	(stblock.top + stblock.bottom) /2;
		sprintf_s(itemshareData.itemdrawList[uiDrawIndex].strinfo.strtext,	15, "G:%.3f", dflG);
		itemshareData.itemdrawList[uiDrawIndex].stcolor	=	QColor::fromRgb(0, 255, 0);
		if(dflG > itemshareData.lightsourcecheckParameter->stAlgA.flGMax || dflG < itemshareData.lightsourcecheckParameter->stAlgA.flGMin)
			itemshareData.itemdrawList[uiDrawIndex].stcolor	=	QColor::fromRgb(255, 0, 0);
		itemshareData.drawLock.unlock();

		iresult	=	0;
		if(dflRG > itemshareData.lightsourcecheckParameter->stAlgA.flRGMax || dflRG < itemshareData.lightsourcecheckParameter->stAlgA.flRGMin || \
			dflBG > itemshareData.lightsourcecheckParameter->stAlgA.flBGMax || dflBG < itemshareData.lightsourcecheckParameter->stAlgA.flBGMin || \
			dflG > itemshareData.lightsourcecheckParameter->stAlgA.flGMax || dflG < itemshareData.lightsourcecheckParameter->stAlgA.flGMin)
			iresult	=	HisCCMError_Result;

		if(iresult) stLogItem.itemvalue = "NG";
		classstLogItem.SubRef();
		classLog->push_back(stLogItem);

		++(stLogItem.itemtype); stLogItem.itemkey = "LSCheck_RG"; stLogItem.itemvalue = dflRG; classLog->push_back(stLogItem);
		++(stLogItem.itemtype); stLogItem.itemkey = "LSCheck_BG"; stLogItem.itemvalue = dflBG; classLog->push_back(stLogItem);
		++(stLogItem.itemtype); stLogItem.itemkey = "LSCheck_G"; stLogItem.itemvalue = dflG; classLog->push_back(stLogItem);
	}
	else if(itemshareData.lightsourcecheckParameter->ucAlg == _HisAlg_SWITCH_B)
	{
		QString strDllPath = QDir::currentPath() % "/SRITDLL/BIGMESH_Dll";
		typedef int (*RRT_RLSV_make_binary)(char *,char *,char *);
		typedef int (*RRT_RLSV_run)(char *,char *,char *,double &,double &,double &);
#ifdef _WIN64
		RRT_RLSV_make_binary  RLSV_make_binary = (RRT_RLSV_make_binary)(QLibrary::resolve(strDllPath, "?RLSV_make_binary@@YAHPEAD00@Z"));
		RRT_RLSV_run  RLSV_run = (RRT_RLSV_run)(QLibrary::resolve(strDllPath, "?RLSV_run@@YAHPEAD00AEAN11@Z"));
#else
		RRT_RLSV_make_binary  RLSV_make_binary = (RRT_RLSV_make_binary)(QLibrary::resolve(strDllPath, "?RLSV_make_binary@@YAHPAD00@Z"));
		RRT_RLSV_run  RLSV_run = (RRT_RLSV_run)(QLibrary::resolve(strDllPath, "?RLSV_run@@YAHPAD00AAN11@Z"));
#endif
		if(!RLSV_make_binary || !RLSV_run){
			emit information(strDllPath % " load RLSV_run fail");
			return HisCCMError_LoadDLLFuc;
		}

		unsigned short* pusBaylor	=	(unsigned short*)HisAlignedMalloc(itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight *2);
		if(!pusBaylor) return HisFX3Error_MallocBuffer;
		QHisFX3MallocAlignedManage classpusBaylor(pusBaylor);

		//取得raw图像数据
		if(iresult	=	GetFreshframe((unsigned char*)pusBaylor, itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight *2, _FrameType_Raw10, true))
			return iresult;

		QString strRawInfo = QDir::currentPath() % "/SRITDLL/" % itemshareData.lightsourcecheckParameter->stAlgB.strRawInfo;
		if(!QFile::exists(strRawInfo)){
			emit information(strRawInfo % " is not exist");
			return HisCCMError_FilePath;
		}

		QString strRawPath = QDir::currentPath() % "/SRITDLL/RLSV.raw";

		QFile classFile(strRawPath);
		iresult	=	0;
		if(classFile.open(QIODevice::WriteOnly | QIODevice::Truncate))
		{
			if(classFile.write((char*)(pusBaylor), itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight *2) == -1)	iresult	=	HisCCMError_WriteFile;
			classFile.close();
		}
		else iresult	=	HisCCMError_WriteFile;

		if(iresult) { emit information(strRawPath % " write fail"); return iresult; }

		QString strRLSVBinOut = QDir::currentPath() % "/SRITDLL/RLSV_LS.bin";
		if(QFile::exists(strRLSVBinOut))
			QFile::remove(strRLSVBinOut);

		iresult = RLSV_make_binary(strRawPath.toAscii().data(), strRLSVBinOut.toAscii().data(), strRawInfo.toAscii().data());
		if(iresult)
		{
			emit information("RLSV_make_binary return(error): " % QString::number(iresult));
			return HisCCMError_OtpFucExec;
		}

		if(!QFile::exists(strRLSVBinOut))
		{
			emit information(strRLSVBinOut % " is not exist");
			return HisCCMError_OtpFucExec;
		}

		double rg, bg, pp;
		iresult	=	RLSV_run(strRawPath.toAscii().data(), strRLSVBinOut.toAscii().data(), strRawInfo.toAscii().data(), rg, bg, pp);
		if(iresult)
		{
			emit information("RLSV_run return(error): " % QString::number(iresult));
			return HisCCMError_OtpFucExec;
		}

		emit information("RG: " % QString::number(rg, 'f', 4));
		emit information("BG: " % QString::number(bg, 'f', 4));
		emit information("PP: " % QString::number(pp, 'f', 4));

		iresult	=	0;
		if(rg > itemshareData.lightsourcecheckParameter->stAlgB.flRGMax || rg < itemshareData.lightsourcecheckParameter->stAlgB.flRGMin || \
			bg > itemshareData.lightsourcecheckParameter->stAlgB.flBGMax || bg < itemshareData.lightsourcecheckParameter->stAlgB.flBGMin || \
			pp > itemshareData.lightsourcecheckParameter->stAlgB.flPPMax || pp < itemshareData.lightsourcecheckParameter->stAlgB.flPPMin)
			iresult	=	HisCCMError_Result;

		if(iresult) stLogItem.itemvalue = "NG";
		classstLogItem.SubRef();
		classLog->push_back(stLogItem);

		++(stLogItem.itemtype); stLogItem.itemkey = "LSCheck_RG"; stLogItem.itemvalue = rg; classLog->push_back(stLogItem);
		++(stLogItem.itemtype); stLogItem.itemkey = "LSCheck_BG"; stLogItem.itemvalue = bg; classLog->push_back(stLogItem);
		++(stLogItem.itemtype); stLogItem.itemkey = "LSCheck_PP"; stLogItem.itemvalue = pp; classLog->push_back(stLogItem);
	}

	return iresult;
}

int itemprocess::getsavelogParameter(bool bupdate, bool bcheck)
{
	itemshareData.itemparameterLock.lockForRead();
	if(!bupdate && itemshareData.savelogParameter){
		itemshareData.itemparameterLock.unlock();
		return 0;
	}

	QMutexLocker locker(&hisglobalparameter.mutexDatabase);

	itemshareData.itemparameterLock.unlock();
	itemshareData.itemparameterLock.lockForWrite();
	if(!itemshareData.savelogParameter)
		itemshareData.savelogParameter		=	new _savelogParameter;
	if(!itemshareData.savelogParameter){
		itemshareData.itemparameterLock.unlock();
		return HisFX3Error_MallocBuffer;
	}

	itemshareData.savelogParameter->ucSerialNumberSource	=	_His_SerialNumber_Text;
	itemshareData.savelogParameter->strSerialNumberFormat.clear();
	itemshareData.savelogParameter->strCHIPIDIIC.clear();
	bool bparsesuccess	=	true, bItemExist = false;

	//读取，解析config
	for(int  w=0;	w<1;	++w){ //此处是有意义的,不要删除
		QSqlDatabase customdb = QSqlDatabase::addDatabase("QSQLITE", "querycustom");
		customdb.setDatabaseName(QDir::currentPath() % "/HisFX3Custom");
		if (!customdb.open()){
			bparsesuccess	=	false;
			break;
		}

		QString strData, strdata2;
		QStringList strname, strvalue;
		QSqlQuery query(customdb);
		query.prepare("SELECT itemsuffix2,key,value,reserve FROM " % itemshareData.currentTableName % \
			" WHERE classfy='other' AND item='savelog' ORDER BY id ASC" );
		query.exec();

		//(snsource:text)(snformat:*)

		while (query.next()){
			bItemExist = true;
			for(int y=0;	y<4;	++y){
				strData	=	query.value(y).toString();
				ROPLOW::patchconfigstring(strData, strname, strvalue);
				for(int x=0;	x<strname.size();	++x)
				{
					if(strname.at(x) == "snsource"){
						if(strvalue.at(x) == "vision")
							itemshareData.savelogParameter->ucSerialNumberSource	=	_His_SerialNumber_Vision;
						else if(strvalue.at(x) == "otp")
							itemshareData.savelogParameter->ucSerialNumberSource	=	_His_SerialNumber_OTP;
						else if(strvalue.at(x) == "chip")
							itemshareData.savelogParameter->ucSerialNumberSource	=	_His_SerialNumber_Chip;
						else
							itemshareData.savelogParameter->ucSerialNumberSource	=	_His_SerialNumber_Text;
					}
					else if(strname.at(x) == "snformat")	
						itemshareData.savelogParameter->strSerialNumberFormat	=	strvalue.at(x);
				}
			}
		}

		if(itemshareData.savelogParameter->ucSerialNumberSource	==	_His_SerialNumber_Chip){
			query.prepare("SELECT itemsuffix2 FROM " % itemshareData.currentTableName % \
				" WHERE classfy='other' AND item='chipid'  AND itemsuffix1='total'" );
			query.exec();
			while (query.next()){
				bItemExist = true;
				ROPLOW::patchconfigstring(query.value(0).toString(), strname, strvalue);
				for(int x=0;	x<strname.size();	++x){
					if(strname.at(x) == "sensor") itemshareData.savelogParameter->strChipIDSensorType = strvalue.at(x);
				}
			}

			query.prepare("SELECT value FROM " % itemshareData.currentTableName % \
				" WHERE classfy='other' AND item='chipid'  AND itemsuffix1='iic' ORDER BY id ASC" );
			query.exec();
			strvalue.clear();
			while (query.next()){
				bItemExist = true;
				strvalue.append(query.value(0).toString());
			}
			itemshareData.savelogParameter->strCHIPIDIIC = strvalue.join("\n");
		}

		customdb.close();
	}

	QSqlDatabase::removeDatabase("querycustom");

	if(!bparsesuccess/* || !bItemExist*/)
	{
		HisReleaseNewO(itemshareData.savelogParameter)
			itemshareData.itemparameterLock.unlock();
		return HisFX3Error_Parameter;
	}

	if(!bcheck) {itemshareData.itemparameterLock.unlock(); return 0; }

	itemshareData.savelogParameter->strSerialNumberFormat	=	itemshareData.savelogParameter->strSerialNumberFormat.toUpper();
	itemshareData.itemparameterLock.unlock();
	return 0;
}

int itemprocess::getSerialNumber()
{
	int iresult	=	getsavelogParameter(false);
	if(iresult)
		return iresult;
	iresult	=	getccmhardwareParameter(false);
	if(iresult)
		return iresult;

	QString strSerialNumber;
	if(itemshareData.savelogParameter->ucSerialNumberSource == _His_SerialNumber_Vision)
	{
		serialNumberLineEdit.clear();


	}
	else if(itemshareData.savelogParameter->ucSerialNumberSource == _His_SerialNumber_OTP){

	}
	else if(itemshareData.savelogParameter->ucSerialNumberSource == _His_SerialNumber_Chip)
	{
		if(itemshareData.savelogParameter->strCHIPIDIIC.isEmpty())
			return HisFX3Error_Parameter;
		if(bBoxChannel1 && !classPlatform.HisFX3isstart())	return HisFX3Error_IsNotPreview;
		else if(!bBoxChannel1 && !classPlatform.HisFX3isstart_S2())	return HisFX3Error_IsNotPreview;

		QStringList strValueList, strList	=	itemshareData.savelogParameter->strCHIPIDIIC.split("\n");
		QString strData;
		unsigned char ucSlave	=	itemshareData.previewParameter->ucSlave;
		unsigned int uiReg, uiData, uiIndex, uiCount=0;
		unsigned int uiReadData[50];
		unsigned short usReadType[50];
		unsigned __int64 ui64Data;
		unsigned short usType;
		for(unsigned int x=0;	x<strList.size();	++x){
			strValueList	=	strList.at(x).split(",");
			if(strValueList.size() != 5)
				return HisFX3Error_Parameter;
			strData	=	strValueList.at(0);
			strData	=	strData.remove("0x");
			uiReg		=	strData.toUInt(0, 16);
			strData	=	strValueList.at(1);
			strData	=	strData.remove("0x");
			uiData		=	strData.toUInt(0, 16);
			strData	=	strValueList.at(2);
			strData	=	strData.remove("0x");
			usType		=	strData.toUShort(0, 16);
			strData	=	strValueList.at(4);
			uiIndex		=	strData.toUInt(0, 10);
			if(strValueList.at(3) == "write"){
				iresult	=	globalFunPointer.WriteHisFX3IIC(ucSlave, uiReg, uiData, usType, true);
				if(iresult)
					return iresult;
			}
			else if(strValueList.at(3) == "sleep"){
				::Sleep(uiData);
			}
			else if(strValueList.at(3) == "read"){
				iresult	=	globalFunPointer.ReadHisFX3IIC(ucSlave, uiReg, &ui64Data, usType);
				if(iresult)
					return iresult;
				uiReadData[uiIndex-1]		=	ui64Data;
				usReadType[uiIndex-1]	=	usType;
				++uiCount;
			}
		}

		if(!uiCount)
			return HisFX3Error_Parameter;
		for(unsigned int x=0;	x<uiCount;	++x){
			if(usReadType[x] == 0x0808 || usReadType[x] == 0x1608){
				strData	=	QString::number(uiReadData[x], 16);
				if(strData.size() == 1)
					strData.prepend("0");
				strSerialNumber	=	strSerialNumber % strData;
			}
			else if(usReadType[x] == 0x0816 || usReadType[x] == 0x1616){
				uiData		=	((uiReadData[x] >>8) & 0xFF);
				strData	=	QString::number(uiData, 16);
				if(strData.size() == 1)
					strData.prepend("0");
				strSerialNumber	=	strSerialNumber % strData;

				uiData		=	(uiReadData[x] & 0xFF);
				strData	=	QString::number(uiData, 16);
				if(strData.size() == 1)
					strData.prepend("0");
				strSerialNumber	=	strSerialNumber % strData;
			}
			else if(usReadType[x] == 0x1632){
				uiData		=	((uiReadData[x] >>24) & 0xFF);
				strData	=	QString::number(uiData, 16);
				if(strData.size() == 1)
					strData.prepend("0");
				strSerialNumber	=	strSerialNumber % strData;

				uiData		=	((uiReadData[x] >>16) & 0xFF);
				strData	=	QString::number(uiData, 16);
				if(strData.size() == 1)
					strData.prepend("0");
				strSerialNumber	=	strSerialNumber % strData;

				uiData		=	((uiReadData[x] >>8) & 0xFF);
				strData	=	QString::number(uiData, 16);
				if(strData.size() == 1)
					strData.prepend("0");
				strSerialNumber	=	strSerialNumber % strData;

				uiData		=	(uiReadData[x] & 0xFF);
				strData	=	QString::number(uiData, 16);
				if(strData.size() == 1)
					strData.prepend("0");
				strSerialNumber	=	strSerialNumber % strData;
			}
			else
				return HisFX3Error_Parameter;
		}
		emit information(strSerialNumber);

		stLogItem.itemtype		=	_HISLOG_CLASSIFY_SN;
		stLogItem.itemkey		=	"serial number";
		stLogItem.itemvalue	=	strSerialNumber.toUpper();
		classLog->push_back(stLogItem);
	}
	else{
#if 0
		QNetworkAccessManager classHttp(this);
		QNetworkReply * pReply = classHttp.get(QNetworkRequest(QUrl("http://10.0.0.1/camdora.cgi?service=system&device=status")));
		QEventLoop loop;
		connect(pReply, SIGNAL(finished()), &loop, SLOT(quit()));
		loop.exec();
		emit information("error:" % QString::number(pReply->error()));
		QByteArray tdata = pReply->readAll();
		QString sdata(tdata);
		emit information(sdata);
		Json::Reader Reader;
		Json::Value person;
		if (Reader.parse(sdata.toStdString(), person)){
			Json::Value arrayObj = person["data"];
			threadshareData.strSerialNumber = QString::fromStdString(arrayObj["sn"].asString());
		}
		if(threadshareData.strSerialNumber.isEmpty()) threadshareData.strSerialNumber = "1";
#endif
		stLogItem.itemtype		=	_HISLOG_CLASSIFY_SN;
		stLogItem.itemkey		=	"serial number";
		stLogItem.itemvalue	=	threadshareData.strSerialNumber.toUpper();
		classLog->push_back(stLogItem);
	}

	bool bSerialNumberFormat	=	false;
	if(itemshareData.savelogParameter->strSerialNumberFormat.isEmpty() || \
		itemshareData.savelogParameter->strSerialNumberFormat == "*")
		bSerialNumberFormat	=	true;
	if(!bSerialNumberFormat && itemshareData.savelogParameter->strSerialNumberFormat.size() == strSerialNumber.size()){
		bSerialNumberFormat	=	true;
		for(int x=0;	x<strSerialNumber.size();	++x){
			if(itemshareData.savelogParameter->strSerialNumberFormat.at(x) != '*' && \
				itemshareData.savelogParameter->strSerialNumberFormat.at(x) != strSerialNumber.at(x)){
					bSerialNumberFormat	=	false;
					break;
			}
		}
	}

	if(bSerialNumberFormat){
		stLogItem.itemtype		=	_HISLOG_CLASSIFY_DATE;
		stLogItem.itemkey		=	"DATE";
		stLogItem.itemvalue	=	QDate::currentDate().toString("yy-MM-dd");
		classLog->push_back(stLogItem);
		stLogItem.itemtype		=	_HISLOG_CLASSIFY_TIME;
		stLogItem.itemkey		=	"TIME";
		stLogItem.itemvalue	=	QTime::currentTime().toString("hh:mm:ss");
		classLog->push_back(stLogItem);
	}

	return (bSerialNumberFormat)?(0):(_HisSaveLogError_SNMatch);
}

int itemprocess::burnSerialNumber()
{
	return 0;
}

int itemprocess::getafburnParameter(bool bupdate, bool bcheck )
{
	itemshareData.itemparameterLock.lockForRead();
	if(!bupdate && itemshareData.afburnParameter){
		itemshareData.itemparameterLock.unlock();
		return 0;
	}

	QMutexLocker locker(&hisglobalparameter.mutexDatabase);

	itemshareData.itemparameterLock.unlock();
	itemshareData.itemparameterLock.lockForWrite();
	if(!itemshareData.afburnParameter)	itemshareData.afburnParameter		=	new _afburnParameter;
	if(!itemshareData.afburnParameter){
		itemshareData.itemparameterLock.unlock();
		return HisFX3Error_MallocBuffer;
	}

	bool bparsesuccess	=	true, bItemExist = false;

	//读取，解析config
	for(int  w=0;	w<1;	++w){ //此处是有意义的,不要删除
		QSqlDatabase customdb = QSqlDatabase::addDatabase("QSQLITE", "querycustom");
		customdb.setDatabaseName(QDir::currentPath() % "/HisFX3Custom");
		if (!customdb.open()){
			bparsesuccess	=	false;
			break;
		}

		QString strData, strdata2;
		QStringList strname, strvalue;
		QSqlQuery query(customdb);
		query.prepare("SELECT itemsuffix2,key,value,reserve FROM " % itemshareData.currentTableName % \
			" WHERE classfy='algorithm' AND item='afburn' ORDER BY id ASC" );
		query.exec();

		//(framedelay:500)(machine:0)(curfun:rule)
		//(nearaf:on)(nearoffset:0)(nearmin:0)(nearmax:1023)
		//(middleaf:on)(middleoffset:0)(middlemin:0)(middlemax:1023)
		//(infiniteaf:on)(faroffset:0)(farmin:0)(farmax:1023)
		while (query.next()){
			bItemExist = true;
			for(int y=0;	y<4;	++y){
				strData	=	query.value(y).toString();
				ROPLOW::patchconfigstring(strData, strname, strvalue);
				for(int x=0;	x<strname.size();	++x){
					if(strname.at(x) == "nearaf")	itemshareData.afburnParameter->bNear	=	(strvalue.at(x) == "on");
					else if(strname.at(x) == "curfun")	itemshareData.afburnParameter->strFunctionChoose	=	strvalue.at(x).toUpper();
					else if(strname.at(x) == "middleaf") itemshareData.afburnParameter->bMiddle =	(strvalue.at(x) == "on");
					else if(strname.at(x) == "infiniteaf") itemshareData.afburnParameter->bInfinite =	(strvalue.at(x) == "on");
					else if(strname.at(x) == "machine") itemshareData.afburnParameter->uiMachineCode	=	strvalue.at(x).toInt();
					else if(strname.at(x) == "framedelay") itemshareData.afburnParameter->uiFrameDelay =	strvalue.at(x).toInt();
					else if(strname.at(x) == "nearoffset") itemshareData.afburnParameter->iNearMotorOffset =	strvalue.at(x).toInt();
					else if(strname.at(x) == "nearmin") itemshareData.afburnParameter->iNearMotorMin =	strvalue.at(x).toInt();
					else if(strname.at(x) == "nearmax") itemshareData.afburnParameter->iNearMotorMax =	strvalue.at(x).toInt();
					else if(strname.at(x) == "middleoffset") itemshareData.afburnParameter->iMiddleMotorOffset =	strvalue.at(x).toInt();
					else if(strname.at(x) == "middlemin") itemshareData.afburnParameter->iMiddleMotorMin =	strvalue.at(x).toInt();
					else if(strname.at(x) == "middlemax") itemshareData.afburnParameter->iMiddleMotorMax =	strvalue.at(x).toInt();
					else if(strname.at(x) == "faroffset") itemshareData.afburnParameter->iFarMotorOffset =	strvalue.at(x).toInt();
					else if(strname.at(x) == "farmin") itemshareData.afburnParameter->iFarMotorMin =	strvalue.at(x).toInt();
					else if(strname.at(x) == "farmax") itemshareData.afburnParameter->iFarMotorMax =	strvalue.at(x).toInt();
				}
			}
		}

		customdb.close();
	}

	QSqlDatabase::removeDatabase("querycustom");

	if(!bparsesuccess || !bItemExist)
	{
		HisReleaseNewO(itemshareData.afburnParameter);
		itemshareData.itemparameterLock.unlock();
		return HisFX3Error_Parameter;
	}

	if(!bcheck) {itemshareData.itemparameterLock.unlock(); return 0; }

	if(!(itemshareData.afburnParameter->bNear || itemshareData.afburnParameter->bMiddle || \
		itemshareData.afburnParameter->bInfinite)){
			HisReleaseNewO(itemshareData.afburnParameter);
			itemshareData.itemparameterLock.unlock();
			return HisFX3Error_Parameter;
	}

	itemshareData.itemparameterLock.unlock();
	return 0;
}

int itemprocess::afBurn()
{
#ifdef _HisFX3_Platform_Jigboard
	return Jig_afBurn();
#endif

	//判断图像是否点亮中
	if(!threadshareData.GetHisPreviewflag())	return HisCCMError_NotPreivew;

	//取得配置参数和规格
	int iresult	=	getafburnParameter(false);
	if(iresult)	return iresult;
	if(iresult	=	getccmhardwareParameter(false))	return iresult;

	itemshareData.itemparameterLock.lockForRead();

	_HisCCMAFBurn_Config stParameter;
	stParameter.ucSlave			=	itemshareData.previewParameter->ucSlave;
	stParameter.iwidth				=	itemshareData.previewParameter->iWidth;
	stParameter.iheight				=	itemshareData.previewParameter->iHeight;
	stParameter.uiDataFormat	=	itemshareData.previewParameter->ucDataFormat;
	stParameter.bNear				=	itemshareData.afburnParameter->bNear;
	stParameter.bMiddle			=	itemshareData.afburnParameter->bMiddle;
	stParameter.bInfinite			=	itemshareData.afburnParameter->bInfinite;
	stParameter.uiMachineID	=	itemshareData.afburnParameter->uiMachineCode;
	stParameter.uiFrameSleep=	itemshareData.afburnParameter->uiFrameDelay;
	stParameter.bDebug			=	hisglobalparameter.bDebugMode;
	stParameter.strDriverIC		=	(itemshareData.ccmhardwareParameter->motortype.toAscii()).data();
	stParameter.strproject		=	(itemshareData.ccmhardwareParameter->projectname.toAscii()).data();
	stParameter.strsensor		=	(itemshareData.ccmhardwareParameter->sensortype.toAscii()).data();
	stParameter.strFunctionChoose		=	(itemshareData.afburnParameter->strFunctionChoose.toAscii()).data();
	stParameter.ucEESlave		=	itemshareData.ccmhardwareParameter->ucEESlave;
	stParameter.iNearMotor		=	(iNearPeakMotorDec==0x00FFFFFF)?(0x00FFFFFF):(iNearPeakMotorDec + itemshareData.afburnParameter->iNearMotorOffset);
	stParameter.iMiddleMotor	=	(iMiddlePeakMotorDec==0x00FFFFFF)?(0x00FFFFFF):(iMiddlePeakMotorDec + itemshareData.afburnParameter->iMiddleMotorOffset);
	stParameter.iInfinitMotor		= (iFarPeakMotorDec==0x00FFFFFF)?(0x00FFFFFF):(iFarPeakMotorDec + itemshareData.afburnParameter->iFarMotorOffset);
	stParameter.Reserve1.ivalue[0]		=	(iMotorStartDec==0x00FFFFFF)?(0x00FFFFFF):(iMotorStartDec + itemshareData.afburnParameter->iFarMotorOffset);


	//*********** Test *****************

	//**********************************
	if(stParameter.bNear)
	{
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("近焦马达最优点：") % QString::number(iNearPeakMotorDec) % \
			"		OFFSET: " % QString::number(itemshareData.afburnParameter->iNearMotorOffset) % \
			QTextCodec::codecForName( "GBK")->toUnicode("		烧录值：") % QString::number(stParameter.iNearMotor));
		if(stParameter.iNearMotor > itemshareData.afburnParameter->iNearMotorMax || stParameter.iNearMotor < itemshareData.afburnParameter->iNearMotorMin){
			emit information(QTextCodec::codecForName( "GBK")->toUnicode("近焦马达烧录值超出范围"));
			itemshareData.itemparameterLock.unlock();
			return HisCCMError_Result;
		}
	}
	if(stParameter.bMiddle)
	{
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("中焦马达最优点：") % QString::number(iMiddlePeakMotorDec) % \
			"		OFFSET: " % QString::number(itemshareData.afburnParameter->iMiddleMotorOffset) % \
			QTextCodec::codecForName( "GBK")->toUnicode("		烧录值：") % QString::number(stParameter.iMiddleMotor));
		if(stParameter.iMiddleMotor > itemshareData.afburnParameter->iMiddleMotorMax || stParameter.iMiddleMotor < itemshareData.afburnParameter->iMiddleMotorMin){
			emit information(QTextCodec::codecForName( "GBK")->toUnicode("中焦马达烧录值超出范围"));
			itemshareData.itemparameterLock.unlock();
			return HisCCMError_Result;
		}
	}
	if(stParameter.bInfinite)
	{
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("远焦马达最优点：") % QString::number(iFarPeakMotorDec) % \
			"		OFFSET: " % QString::number(itemshareData.afburnParameter->iFarMotorOffset) % \
			QTextCodec::codecForName( "GBK")->toUnicode("		烧录值：") % QString::number(stParameter.iInfinitMotor));
		if(stParameter.iInfinitMotor > itemshareData.afburnParameter->iFarMotorMax || stParameter.iInfinitMotor < itemshareData.afburnParameter->iFarMotorMin){
			emit information(QTextCodec::codecForName( "GBK")->toUnicode("远焦马达烧录值超出范围"));
			itemshareData.itemparameterLock.unlock();
			return HisCCMError_Result;
		}
	}

	QString strSerialNumber;
	classLog->getserialnumber(strSerialNumber);
	stParameter.strSerialNumber	=	strSerialNumber.toAscii().data();

#if (defined _WIN64) && (defined _DEBUG)
	QString strLibPath	=	QDir::currentPath() % "/HisCCMOTP64D";
#elif (defined _WIN64) && !(defined _DEBUG)
	QString strLibPath	=	QDir::currentPath() % "/HisCCMOTP64";
#elif (defined _WIN32) && (defined _DEBUG)
	QString strLibPath	=	QDir::currentPath() % "/HisCCMOTP32D";
#else
	QString strLibPath	=	QDir::currentPath() % "/HisCCMOTP32";
#endif

	RolongoOTPAPIVersion getRolongoOTPAPIVersion = (RolongoOTPAPIVersion)(QLibrary::resolve(strLibPath, "getRolongoOTPAPIVersion"));
	Rolongowriteafmotor writeafmotor = (Rolongowriteafmotor)(QLibrary::resolve(strLibPath, "writeafmotor"));

	if(!(getRolongoOTPAPIVersion && writeafmotor)){
		emit information(tr("Resolve HisCCMOTP DLL Function Fail"));
		itemshareData.itemparameterLock.unlock();
		return HisCCMError_LoadDLLFuc;
	}

	emit enableinfotimer(1);
	iresult	=	writeafmotor(*globalFunPointer.vectorHisCCMOTPInfoW, &stParameter, globalFunPointer.ReadHisFX3IIC, globalFunPointer.WriteHisFX3IIC, globalFunPointer.SetHisFX3IICSpeed, \
		globalFunPointer.SetHisFX3Voltage, globalFunPointer.GetHisFX3Voltage, SetHisFX3VFuseVolt, GetHisFX3VFuseVolt, GetFreshframe, \
		SetHisFX3GPIO, GetHisFX3GPIO, globalFunPointer.PullHisFX3RESET, globalFunPointer.PullHisFX3PWND, globalFunPointer.BatchReadHisFX3IICNoLimit, globalFunPointer.BatchWriteHisFX3IICNoLimit, \
		globalFunPointer.HisFX3LogPush_back, globalFunPointer.PageWriteHisFX3IIC, globalFunPointer.PageReadHisFX3IIC, \
		globalFunPointer.HisFX3PageWriteSPI, globalFunPointer.HisFX3PageReadSPI);
	emit enableinfotimer(0);

	itemshareData.itemparameterLock.unlock();

	stLogItem.itemtype	=	classLog->getmaxtypeindex(_HISLOG_CLASSIFY_AFBURN);
	stLogItem.itemkey	=	"AF_BURN_Result";
	stLogItem.itemvalue=	(iresult)?("NG"):("OK");
	classLog->push_back(stLogItem);
	if(stParameter.bNear){
		++(stLogItem.itemtype);
		stLogItem.itemkey	=	"AF_BURN_Near_Motor";
		stLogItem.itemvalue=	stParameter.iNearMotor;
		classLog->push_back(stLogItem);
	}
	if(stParameter.bMiddle){
		++(stLogItem.itemtype);
		stLogItem.itemkey	=	"AF_BURN_Middle_Motor";
		stLogItem.itemvalue=	stParameter.iMiddleMotor;
		classLog->push_back(stLogItem);
	}
	if(stParameter.bInfinite){
		++(stLogItem.itemtype);
		stLogItem.itemkey	=	"AF_BURN_Infinite_Motor";
		stLogItem.itemvalue=	stParameter.iInfinitMotor;
		classLog->push_back(stLogItem);
	}

	return iresult;
}

int itemprocess::afBurnCheck() //0:near 1:middle 2:infinite
{
	_CODE_CLEAR_IMAGEDRAW

		int iresult;
#ifdef _HisFX3_Platform_Jigboard
	if(iresult = Jig_afBurnCheck(0)) return iresult;
	return Jig_afBurnCheck(2);
	// 	return Jig_afBurnCheck(ucType);
#endif

	//判断图像是否点亮中
	if(!threadshareData.GetHisPreviewflag())	return HisCCMError_NotPreivew;

	//取得配置参数和规格
	if(iresult	=	getafburnParameter(false))	return iresult;
	if(iresult	=	getccmhardwareParameter(false))	return iresult;

	itemshareData.itemparameterLock.lockForRead();
	_HisCCMAFBurn_Config stParameter;
	stParameter.ucSlave			=	itemshareData.previewParameter->ucSlave;
	stParameter.iwidth				=	itemshareData.previewParameter->iWidth;
	stParameter.iheight				=	itemshareData.previewParameter->iHeight;
	stParameter.uiDataFormat	=	itemshareData.previewParameter->ucDataFormat;
	stParameter.uiFrameSleep=	itemshareData.afburnParameter->uiFrameDelay;
	stParameter.iNearMotor		=	(iNearPeakMotorDec==0x00FFFFFF)?(0x00FFFFFF):(iNearPeakMotorDec + itemshareData.afburnParameter->iNearMotorOffset);
	stParameter.iMiddleMotor	=	(iMiddlePeakMotorDec==0x00FFFFFF)?(0x00FFFFFF):(iMiddlePeakMotorDec + itemshareData.afburnParameter->iMiddleMotorOffset);
	stParameter.iInfinitMotor		=	(iFarPeakMotorDec==0x00FFFFFF)?(0x00FFFFFF):(iFarPeakMotorDec + itemshareData.afburnParameter->iFarMotorOffset);
	stParameter.uiMachineID	=	0xFFFFFFFF;
	stParameter.bDebug			=	hisglobalparameter.bDebugMode;
	stParameter.strDriverIC		=	(itemshareData.ccmhardwareParameter->motortype.toAscii()).data();
	stParameter.strproject		=	(itemshareData.ccmhardwareParameter->projectname.toAscii()).data();
	stParameter.strsensor		=	(itemshareData.ccmhardwareParameter->sensortype.toAscii()).data();
	stParameter.strFunctionChoose		=	(itemshareData.afburnParameter->strFunctionChoose.toAscii()).data();
	stParameter.ucEESlave		=	itemshareData.ccmhardwareParameter->ucEESlave;

	QString strSerialNumber;
	classLog->getserialnumber(strSerialNumber);
	stParameter.strSerialNumber	=	strSerialNumber.toAscii().data();

	stParameter.bNear		=	itemshareData.afburnParameter->bNear;
	stParameter.bMiddle	=	itemshareData.afburnParameter->bMiddle;
	stParameter.bInfinite	=	itemshareData.afburnParameter->bInfinite;

#if (defined _WIN64) && (defined _DEBUG)
	QString strLibPath	=	QDir::currentPath() % "/HisCCMOTP64D";
#elif (defined _WIN64) && !(defined _DEBUG)
	QString strLibPath	=	QDir::currentPath() % "/HisCCMOTP64";
#elif (defined _WIN32) && (defined _DEBUG)
	QString strLibPath	=	QDir::currentPath() % "/HisCCMOTP32D";
#else
	QString strLibPath	=	QDir::currentPath() % "/HisCCMOTP32";
#endif

	RolongoOTPAPIVersion getRolongoOTPAPIVersion = (RolongoOTPAPIVersion)(QLibrary::resolve(strLibPath, "getRolongoOTPAPIVersion"));
	Rolongocheckafmotor checkafmotor = (Rolongocheckafmotor)(QLibrary::resolve(strLibPath, "checkafmotor"));

	if(!(getRolongoOTPAPIVersion && checkafmotor)){
		emit information(tr("Resolve HisCCMOTP DLL Function Fail"));
		itemshareData.itemparameterLock.unlock();
		return HisCCMError_LoadDLLFuc;
	}

	emit enableinfotimer(1);
	iresult	=	checkafmotor(*globalFunPointer.vectorHisCCMOTPInfoW, &stParameter, globalFunPointer.ReadHisFX3IIC, globalFunPointer.WriteHisFX3IIC, globalFunPointer.SetHisFX3IICSpeed, \
		globalFunPointer.SetHisFX3Voltage, globalFunPointer.GetHisFX3Voltage, SetHisFX3VFuseVolt, GetHisFX3VFuseVolt, GetFreshframe, \
		SetHisFX3GPIO, GetHisFX3GPIO, globalFunPointer.PullHisFX3RESET, globalFunPointer.PullHisFX3PWND, globalFunPointer.BatchReadHisFX3IICNoLimit, globalFunPointer.BatchWriteHisFX3IICNoLimit, \
		globalFunPointer.HisFX3LogPush_back, globalFunPointer.PageWriteHisFX3IIC, globalFunPointer.PageReadHisFX3IIC, \
		globalFunPointer.HisFX3PageWriteSPI, globalFunPointer.HisFX3PageReadSPI);
	emit enableinfotimer(0);

	if(iresult)
	{
		itemshareData.itemparameterLock.unlock();
		stLogItem.itemtype	=	classLog->getmaxtypeindex(_HISLOG_CLASSIFY_AFBURNCHECK);
		stLogItem.itemkey	=	"AFBURNCheck_Result";
		stLogItem.itemvalue=	"NG";
		classLog->push_back(stLogItem);
		return iresult;
	}



	//***************** by feng 2018/01/30 Add **************
	if(hisglobalparameter.bDebugMode){
		QDir classDir;
		QString saveDir=QDir::currentPath()%"/savelog";
		classDir.mkdir(saveDir);

		QFile file(saveDir%"/AF Code.csv");
		if(!file.exists()){
			file.open(QIODevice::ReadWrite|QIODevice::Append|QIODevice::Text);
			file.write("Chip ID,Far,Marco\n");
		}else{
			file.open(QIODevice::ReadWrite|QIODevice::Append|QIODevice::Text);
		}

		QTextStream out(&file);
		out<<"#"<<strSerialNumber<<","<<stParameter.iInfinitMotor<<","<<stParameter.iNearMotor<<"\n";

		file.close();
	}

	//*******************************************************


	iresult	=	0;
	if(stParameter.bNear){
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("近焦马达烧录值：") % QString::number(stParameter.iNearMotor));
		if(stParameter.iNearMotor > itemshareData.afburnParameter->iNearMotorMax || stParameter.iNearMotor < itemshareData.afburnParameter->iNearMotorMin){
			emit information(QTextCodec::codecForName( "GBK")->toUnicode("近焦马达烧录值超出范围"));
			iresult	=	HisCCMError_Result;
		}
	}
	if(stParameter.bMiddle){
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("中焦马达烧录值：") % QString::number(stParameter.iMiddleMotor));
		if(stParameter.iMiddleMotor > itemshareData.afburnParameter->iMiddleMotorMax || stParameter.iMiddleMotor < itemshareData.afburnParameter->iMiddleMotorMin){
			emit information(QTextCodec::codecForName( "GBK")->toUnicode("中焦马达烧录值超出范围"));
			iresult	=	HisCCMError_Result;
		}
	}
	if(stParameter.bInfinite){
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("远焦马达烧录值：") % QString::number(stParameter.iInfinitMotor));
		if(stParameter.iInfinitMotor > itemshareData.afburnParameter->iFarMotorMax || stParameter.iInfinitMotor < itemshareData.afburnParameter->iFarMotorMin){
			emit information(QTextCodec::codecForName( "GBK")->toUnicode("远焦马达烧录值超出范围"));
			iresult	=	HisCCMError_Result;
		}
	}

	stLogItem.itemtype	=	classLog->getmaxtypeindex(_HISLOG_CLASSIFY_AFBURNCHECK);
	stLogItem.itemkey	=	"AFBURNCheck_Result";
	stLogItem.itemvalue=	(iresult)?("NG"):("OK");
	classLog->push_back(stLogItem);

	itemshareData.itemparameterLock.unlock();

	return iresult;
}
int itemprocess::senttcpmessage(_QH_TcpIpCommu_Itemnew clientiteminfo)
{
	return 0;
}

int itemprocess::serialport(QString QStrinfo, unsigned char ucEbaud,unsigned char ucEpar,unsigned char ucEstop,unsigned char ucCOMIndex)
{
	CSerial serial;
	CSerial::EParity iEpar;
	CSerial::EBaudrate iEbaud;
	CSerial::EStopBits iEstop;
	char strCOMIndex[10];
	switch(ucEpar)
	{
	case 0:
		iEpar	=	CSerial::EParOdd;
		break;
	case 1:
		iEpar	=	CSerial::EParEven;
		break;
	case 2:
		iEpar	=	CSerial::EParNone;
		break;
	default:
		iEpar	=	CSerial::EParNone;
		break;
	}
	switch(ucEstop)
	{
	case 0:
		iEstop	=	CSerial::EStop1;
		break;
	case 1:
		iEstop	=	CSerial::EStop1_5;
		break;
	case 2:
		iEstop	=	CSerial::EStop2;
		break;
	default:
		iEstop	=	CSerial::EStop1;
		break;
	}
	switch(ucEbaud)
	{
	case 0:
		iEbaud	=CSerial::EBaud2400;
		break;
	case 1:
		iEbaud	=CSerial::EBaud4800;
		break;
	case 2:
		iEbaud	=CSerial::EBaud9600;
		break;
	case 3:
		iEbaud	=CSerial::EBaud14400;
		break;
	case 4:
		iEbaud	=CSerial::EBaud19200;
		break;
	case 5:
		iEbaud	=CSerial::EBaud38400;
		break;
	case 6:
		iEbaud	=CSerial::EBaud56000;
		break;
	case 7:
		iEbaud	=CSerial::EBaud57600;
		break;
	case 8:
		iEbaud	=CSerial::EBaud115200;
		break;
	case 9:
		iEbaud	=CSerial::EBaud128000;
		break;
	case 10:
		iEbaud	=CSerial::EBaud256000;
		break;
	default:
		iEbaud	=CSerial::EBaud2400;
		break;
	}
	sprintf(strCOMIndex, "COM%d", ucCOMIndex);
	// Attempt to open the serial port (COM1)
	LONG lLastError = serial.Open(strCOMIndex,	0,	0,	false);
	if (lLastError != ERROR_SUCCESS)
		return HisRs232Error_Open;

	// Setup the serial port (9600,8N1, which is the default setting)

	lLastError = serial.Setup(iEbaud,CSerial::EData8,iEpar,iEstop);
	if (lLastError != ERROR_SUCCESS)
	{
		serial.Close();
		return HisRs232Error_BasicSteup;
	}

	// Setup handshaking
	lLastError = serial.SetupHandshaking(CSerial::EHandshakeOff);
	if (lLastError != ERROR_SUCCESS)
	{
		serial.Close();
		return HisRs232Error_SetHandShake;
	}

	// Register only for the receive event
	lLastError = serial.SetMask(CSerial::EEventBreak |
		CSerial::EEventCTS   |
		CSerial::EEventDSR   |
		CSerial::EEventError |
		CSerial::EEventRing  |
		CSerial::EEventRLSD  |
		CSerial::EEventRecv);
	if (lLastError != ERROR_SUCCESS)
	{
		serial.Close();
		return HisRs232Error_SetEvent;
	}

	// Use 'non-blocking' reads, because we don't know how many bytes
	// will be received. This is normally the most convenient mode
	// (and also the default mode for reading data).
	lLastError = serial.SetupReadTimeouts(CSerial::EReadTimeoutNonblocking);
	if (lLastError != ERROR_SUCCESS){
		serial.Close();
		return HisRs232Error_SetTimeOut;
	}

	emit information("Serial Port Write: " % QStrinfo);

	// The serial port is now ready and we can send/receive data. If
	// the following call blocks, then the other side doesn't support
	// hardware handshaking.
	lLastError = serial.Write(QStrinfo.toAscii().data(), QStrinfo.size());
	if (lLastError != ERROR_SUCCESS)
	{
		serial.Close();
		return HisRs232Error_Write;
	}

	serial.Close();
	return 0;
}

int itemprocess::saveimage(unsigned char ucimagesrc, unsigned char ucimageformat, bool bOriginal, bool bSaveFail, unsigned short usDelay)
{
	int iresult	=	getccmhardwareParameter(false);
	if(iresult)	return iresult;

	itemshareData.itemparameterLock.lockForRead();
	QString strDir	=	QDir::currentPath() % "/saveimage/" % itemshareData.ccmhardwareParameter->projectname % \
		"/" % QDate::currentDate().toString("yyyy-MM-dd");
	QDir classDir;
	classDir.mkpath(strDir);
	QString strName;
	iresult	=	classLog->getserialnumber(strName);
	if(strName.isEmpty() || strName.at(0) == '*') 
		strName	=	"[" % QDateTime::currentDateTime().toString("yyyy-MM-dd hh-mm-ss") % "]";
	itemshareData.itemparameterLock.unlock();

	if(bSaveFail && (GetTotalResult() == 0)) return 0;

	if(usDelay) Sleep(usDelay);

	threadshareData.bSavingImage	=	true;
	emit execsaveimage(strDir, strName, ucimageformat, ucimagesrc);

	bool bLoop = true;
	while(bLoop)
	{
		Sleep(20);
		threadshareData.flaglock.lockForRead();
		bLoop	=	threadshareData.bSavingImage;
		threadshareData.flaglock.unlock();
	}

	return 0;
}

int itemprocess::lschatemplate(bool breplace, unsigned char ucType, unsigned int uiShading)
{
	//判断图像是否点亮中
	if(!threadshareData.GetHisPreviewflag())
		return HisCCMError_NotPreivew;

	int iresult	=	getccmhardwareParameter(false);
	if(iresult)
		return iresult;

	itemshareData.itemparameterLock.lockForRead();

	int iWidth	=	itemshareData.previewParameter->iWidth;
	int iHeight	=	itemshareData.previewParameter->iHeight;

	QString strFilePath	=	QDir::currentPath() % "/rolongotemplate/" % itemshareData.ccmhardwareParameter->projectname % \
		"[" % QString::number(itemshareData.previewParameter->iWidth) % "x" % \
		QString::number(itemshareData.previewParameter->iHeight) % "]";
	QDir classDir;
	classDir.mkpath(strFilePath);

	QString strText	=	strFilePath % "/lscha.bin";
	bool bExist			=	QFile::exists(strText);

	if(bExist)
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("LSC模板存在"));
	else
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("LSC模板不存在"));

	unsigned char ucframetype = _FrameType_Raw | _FrameType_ALL_ADD_ORIGINAL;

	if(!bExist || breplace){
		unsigned char* pucRaw1	=	(unsigned char*)_aligned_malloc(iWidth *iHeight, _HisCacheLine_Aligned);
		unsigned char* pucRaw2	=	(unsigned char*)_aligned_malloc(iWidth *iHeight, _HisCacheLine_Aligned);
		unsigned char* pucRaw3	=	(unsigned char*)_aligned_malloc(iWidth *iHeight, _HisCacheLine_Aligned);
		unsigned char* pucRaw4	=	(unsigned char*)_aligned_malloc(iWidth *iHeight, _HisCacheLine_Aligned);
		unsigned char* pucRaw5	=	(unsigned char*)_aligned_malloc(iWidth *iHeight, _HisCacheLine_Aligned);
		unsigned char* pucRaw6	=	(unsigned char*)_aligned_malloc(iWidth *iHeight, _HisCacheLine_Aligned);
		unsigned char* pucRaw7	=	(unsigned char*)_aligned_malloc(iWidth *iHeight, _HisCacheLine_Aligned);
		unsigned char* pucRaw8	=	(unsigned char*)_aligned_malloc(iWidth *iHeight, _HisCacheLine_Aligned);
		if(!(pucRaw1 && pucRaw2 && pucRaw3 && pucRaw4 && pucRaw5 && pucRaw6 && pucRaw7 && pucRaw8)){
			HisReleaseMalloc(pucRaw1);
			HisReleaseMalloc(pucRaw2);
			HisReleaseMalloc(pucRaw3);
			HisReleaseMalloc(pucRaw4);
			HisReleaseMalloc(pucRaw5);
			HisReleaseMalloc(pucRaw6);
			HisReleaseMalloc(pucRaw7);
			HisReleaseMalloc(pucRaw8);
			itemshareData.itemparameterLock.unlock();
			return HisFX3Error_MallocBuffer;
		}

		iresult =	GetFreshframe(pucRaw1, iWidth*iHeight, ucframetype, true);
		unsigned char* pucDes;
		for(int x=0;	x<8;	++x){
			switch (x){
			case 0:
				pucDes	=	pucRaw1;
				break;
			case 1:
				pucDes	=	pucRaw2;
				break;
			case 2:
				pucDes	=	pucRaw3;
				break;
			case 3:
				pucDes	=	pucRaw4;
				break;
			case 4:
				pucDes	=	pucRaw5;
				break;
			case 5:
				pucDes	=	pucRaw6;
				break;
			case 6:
				pucDes	=	pucRaw7;
				break;
			case 7:
			default:
				pucDes	=	pucRaw8;
				break;
			}

			iresult =	GetFreshframe(pucDes, iWidth*iHeight, ucframetype, false);
			if(iresult)
				break;
		}

		if(iresult){
			HisReleaseMalloc(pucRaw1);
			HisReleaseMalloc(pucRaw2);
			HisReleaseMalloc(pucRaw3);
			HisReleaseMalloc(pucRaw4);
			HisReleaseMalloc(pucRaw5);
			HisReleaseMalloc(pucRaw6);
			HisReleaseMalloc(pucRaw7);
			HisReleaseMalloc(pucRaw8);
			itemshareData.itemparameterLock.unlock();
			return iresult;
		}

		emit information(QTextCodec::codecForName( "GBK")->toUnicode("计算模板......"));
		wchar_t wstrPath[256];
		strFilePath.toWCharArray(wstrPath);
		wstrPath[strFilePath.size()]	=	L'\0';
		iresult	=	classAlgorithm.HisCCMLSCHA_SaveTemplate(pucRaw1, pucRaw2, pucRaw3, pucRaw4, pucRaw5, \
			pucRaw6, pucRaw7, pucRaw8, iWidth, iHeight, itemshareData.previewParameter->ucDataFormat, \
			static_cast<double>(uiShading) /100.0, ucType, wstrPath);
		HisReleaseMalloc(pucRaw1);
		HisReleaseMalloc(pucRaw2);
		HisReleaseMalloc(pucRaw3);
		HisReleaseMalloc(pucRaw4);
		HisReleaseMalloc(pucRaw5);
		HisReleaseMalloc(pucRaw6);
		HisReleaseMalloc(pucRaw7);
		HisReleaseMalloc(pucRaw8);

		if(iresult){
			emit information(QTextCodec::codecForName( "GBK")->toUnicode("生成LSC模板失败"));
			itemshareData.itemparameterLock.unlock();
			return iresult;
		}
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("完成LSC模板生成"));
	}

	itemshareData.itemparameterLock.unlock();

	return 0;
}

int itemprocess::getworkcurrentParameter(bool bupdate, bool bcheck )
{
	itemshareData.itemparameterLock.lockForRead();
	if(!bupdate && itemshareData.workcurrentParameter){
		itemshareData.itemparameterLock.unlock();
		return 0;
	}

	QMutexLocker locker(&hisglobalparameter.mutexDatabase);

	itemshareData.itemparameterLock.unlock();
	itemshareData.itemparameterLock.lockForWrite();
	if(!itemshareData.workcurrentParameter)
		itemshareData.workcurrentParameter		=	new _workcurrentParameter;
	if(!itemshareData.workcurrentParameter){
		itemshareData.itemparameterLock.unlock();
		return HisFX3Error_MallocBuffer;
	}

	itemshareData.workcurrentParameter->btestAF			=	false;
	itemshareData.workcurrentParameter->btestAVDD		=	false;
	itemshareData.workcurrentParameter->btestDOVDD	=	false;
	itemshareData.workcurrentParameter->btestDVDD		=	false;
	itemshareData.workcurrentParameter->btestVFUSE	=	false;
	itemshareData.workcurrentParameter->btestPOW		=	false;
	bool bparsesuccess	=	true, bItemExist = false;

	//读取，解析config
	for(int  w=0;	w<1;	++w){ //此处是有意义的,不要删除
		QSqlDatabase customdb = QSqlDatabase::addDatabase("QSQLITE", "querycustom");
		customdb.setDatabaseName(QDir::currentPath() % "/HisFX3Custom");
		if (!customdb.open()){
			bparsesuccess	=	false;
			break;
		}

		QString strData, strdata2;
		QStringList strname, strvalue;
		QSqlQuery query(customdb);
		query.prepare("SELECT itemsuffix2,key,value,reserve FROM " % itemshareData.currentTableName % \
			" WHERE classfy='algorithm' AND item='workcurrent' ORDER BY id ASC" );
		query.exec();

		//(dovdd:on)(dovddmin:0.3)(dovddmax:50.9)(total:on)(totalmin:10.0)(totalmax:20.0)
		//(dvdd:on)(dvddmin:0.3)(dvddmax:50.9)
		//(avdd:on)(avddmin:0.3)(avddmax:50.9)
		//(af:on)(afmin:0.3)(afmax:50.9)(vfuse:on)(vfusemin:0.3)(vfusemax:50.9)
		while (query.next()){
			bItemExist = true;
			for(int y=0;	y<4;	++y){
				strData	=	query.value(y).toString();
				ROPLOW::patchconfigstring(strData, strname, strvalue);
				for(int x=0;	x<strname.size();	++x){
					if(strname.at(x) == "dovdd")	itemshareData.workcurrentParameter->btestDOVDD	=	(strvalue.at(x) == "on");
					else if(strname.at(x) == "dvdd")	itemshareData.workcurrentParameter->btestDVDD	=	(strvalue.at(x) == "on");
					else if(strname.at(x) == "avdd")	itemshareData.workcurrentParameter->btestAVDD	=	(strvalue.at(x) == "on");
					else if(strname.at(x) == "af")	itemshareData.workcurrentParameter->btestAF	=	(strvalue.at(x) == "on");
					else if(strname.at(x) == "vfuse")	itemshareData.workcurrentParameter->btestVFUSE	=	(strvalue.at(x) == "on");
					else if(strname.at(x) == "pow")	itemshareData.workcurrentParameter->btestPOW	=	(strvalue.at(x) == "on");
					else if(strname.at(x) == "total")	itemshareData.workcurrentParameter->btestTotal	=	(strvalue.at(x) == "on");
					else if(strname.at(x) == "totalmin")	itemshareData.workcurrentParameter->flTotalMin	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "totalmax")	itemshareData.workcurrentParameter->flTotalMax	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "dvddmin")	itemshareData.workcurrentParameter->flSpecDVDDMin	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "avddmin")	itemshareData.workcurrentParameter->flSpecAVDDMin	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "dovddmin")	itemshareData.workcurrentParameter->flSpecDOVDDMin	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "afmin")	itemshareData.workcurrentParameter->flSpecAFMin	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "vfusemin")	itemshareData.workcurrentParameter->flSpecVFUSEMin	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "powmin")	itemshareData.workcurrentParameter->flSpecPOWMin	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "dvddmax")	itemshareData.workcurrentParameter->flSpecDVDDMax	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "avddmax")	itemshareData.workcurrentParameter->flSpecAVDDMax	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "dovddmax")	itemshareData.workcurrentParameter->flSpecDOVDDMax	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "afmax")	itemshareData.workcurrentParameter->flSpecAFMax	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "vfusemax")	itemshareData.workcurrentParameter->flSpecVFUSEMax	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "powmax")	itemshareData.workcurrentParameter->flSpecPOWMax	=	strvalue.at(x).toFloat();
				}
			}
		}

		customdb.close();
	}

	QSqlDatabase::removeDatabase("querycustom");

	if(!bparsesuccess || !bItemExist){
		HisReleaseNewO(itemshareData.workcurrentParameter);
		itemshareData.itemparameterLock.unlock();
		return HisCCMError_Database;
	}

	if(!bcheck) {itemshareData.itemparameterLock.unlock(); return 0; }

	if(!(itemshareData.workcurrentParameter->btestAF || itemshareData.workcurrentParameter->btestAVDD || \
		itemshareData.workcurrentParameter->btestDOVDD || itemshareData.workcurrentParameter->btestDVDD || \
		itemshareData.workcurrentParameter->btestVFUSE || itemshareData.workcurrentParameter->btestPOW)){
			emit information(QTextCodec::codecForName( "GBK")->toUnicode("参数错误：未选择工作电流测试通道"));
			HisReleaseNewO(itemshareData.workcurrentParameter);
			itemshareData.itemparameterLock.unlock();
			return HisFX3Error_Parameter;
	}

	itemshareData.itemparameterLock.unlock();
	return 0;
}

int itemprocess::testworkcurrent()
{
	//判断图像是否点亮中
	// 	if(!GetHisPreviewflag())
	// 		return HisCCMError_NotPreivew;

	int iresult;

	if(itemshareData.workcurrentParameter == NULL)
	{
		unsigned int uiHardKey[4];
		if(iresult = classPlatform.HisFX3GetHardwareKey(uiHardKey))	return iresult;
		_HisFX3_Current_Calibration stCalData;
		if(iresult = ROPLOW::currentCalFromDB(uiHardKey, &stCalData, (bBoxChannel1)?(1):(2))){
			// 			emit information(tr("Error: please do current self-calibration first"));
			// 			return iresult;
			emit information(tr("Warning: The Current Calibration Has Not Been Done."));
		}
		else
		{
			if(bBoxChannel1){
				if(iresult = classPlatform.HisFX3SetCurrentCalData(&stCalData)) return iresult;
			}
			else{
				if(iresult = classPlatform.HisFX3SetCurrentCalData_S2(&stCalData)) return iresult;
			}
		}

	}

	//取得配置参数和规格
	if(iresult	=	getworkcurrentParameter(false))	return iresult;

	itemshareData.itemparameterLock.lockForRead();

	float flCurrentAVDD, flCurrentDOVDD, flCurrentDVDD, flCurrentAF, flCurrentVFuse, flCurrentPOW;
	unsigned int uiFlag	=	(itemshareData.workcurrentParameter->btestAF)?(_HisFX3_Platform_VlotOn_AF):(0);
	uiFlag	=	(itemshareData.workcurrentParameter->btestAVDD)?(uiFlag|_HisFX3_Platform_VlotOn_AVDD):(uiFlag);
	uiFlag	=	(itemshareData.workcurrentParameter->btestDOVDD)?(uiFlag|_HisFX3_Platform_VlotOn_DOVDD):(uiFlag);
	uiFlag	=	(itemshareData.workcurrentParameter->btestDVDD)?(uiFlag|_HisFX3_Platform_VlotOn_DVDD):(uiFlag);
	uiFlag	=	(itemshareData.workcurrentParameter->btestVFUSE)?(uiFlag|_HisFX3_Platform_VlotOn_OTP):(uiFlag);
	uiFlag	=	(itemshareData.workcurrentParameter->btestPOW)?(uiFlag|_HisFX3_Platform_VlotOn_POW):(uiFlag);

	if(bBoxChannel1)
	{
		iresult	=	classPlatform.HisFX3GetWorkCurrent(flCurrentAVDD, flCurrentDVDD, flCurrentDOVDD, flCurrentAF, flCurrentVFuse, flCurrentPOW, uiFlag);
	}
	else
	{
		iresult	=	classPlatform.HisFX3GetWorkCurrent_S2(flCurrentAVDD, flCurrentDVDD, flCurrentDOVDD, flCurrentAF, flCurrentVFuse, flCurrentPOW, uiFlag);
	}


	if(iresult){
		emit information(tr("work current funtion abnormal"));
		itemshareData.itemparameterLock.unlock();
		return iresult;
	}

	emit information(tr("work current test data:"));
	if(itemshareData.workcurrentParameter->btestDVDD)
		emit information("DVDD: " % QString::number(flCurrentDVDD, 'f', 2) % "mA");
	if(itemshareData.workcurrentParameter->btestDOVDD)
		emit information("DOVDD: " % QString::number(flCurrentDOVDD, 'f', 2) % "mA");
	if(itemshareData.workcurrentParameter->btestAVDD)
		emit information("AVDD: " % QString::number(flCurrentAVDD, 'f', 2) % "mA");
	if(itemshareData.workcurrentParameter->btestAF)
		emit information("AF: " % QString::number(flCurrentAF, 'f', 2) % "mA");
	if(itemshareData.workcurrentParameter->btestVFUSE)
		emit information("VFUSE: " % QString::number(flCurrentVFuse, 'f', 2) % "mA");
	if(itemshareData.workcurrentParameter->btestPOW)
		emit information("POW: " % QString::number(flCurrentPOW, 'f', 2) % "mA");

	double dflTotalCurrent = 0.0;
	if(itemshareData.workcurrentParameter->btestAF) dflTotalCurrent += flCurrentAF;
	if(itemshareData.workcurrentParameter->btestDOVDD) dflTotalCurrent += flCurrentDOVDD;
	if(itemshareData.workcurrentParameter->btestDVDD) dflTotalCurrent += flCurrentDVDD;
	if(itemshareData.workcurrentParameter->btestAVDD) dflTotalCurrent += flCurrentAVDD;
	if(itemshareData.workcurrentParameter->btestVFUSE) dflTotalCurrent += flCurrentVFuse;
	if(itemshareData.workcurrentParameter->btestPOW) dflTotalCurrent += flCurrentPOW;
	if(itemshareData.workcurrentParameter->btestTotal)
		emit information("Total: " % QString::number(dflTotalCurrent, 'f', 2) % "mA");

	iresult	=	0;
	if(itemshareData.workcurrentParameter->btestAF && \
		(flCurrentAF > itemshareData.workcurrentParameter->flSpecAFMax || \
		flCurrentAF < itemshareData.workcurrentParameter->flSpecAFMin))
		iresult	=	HisCCMError_Result;
	if(itemshareData.workcurrentParameter->btestDOVDD && \
		(flCurrentDOVDD > itemshareData.workcurrentParameter->flSpecDOVDDMax || \
		flCurrentDOVDD < itemshareData.workcurrentParameter->flSpecDOVDDMin))
		iresult	=	HisCCMError_Result;
	if(itemshareData.workcurrentParameter->btestDVDD && \
		(flCurrentDVDD > itemshareData.workcurrentParameter->flSpecDVDDMax || \
		flCurrentDVDD < itemshareData.workcurrentParameter->flSpecDVDDMin))
		iresult	=	HisCCMError_Result;
	if(itemshareData.workcurrentParameter->btestAVDD && \
		(flCurrentAVDD > itemshareData.workcurrentParameter->flSpecAVDDMax || \
		flCurrentAVDD < itemshareData.workcurrentParameter->flSpecAVDDMin))
		iresult	=	HisCCMError_Result;
	if(itemshareData.workcurrentParameter->btestVFUSE && \
		(flCurrentVFuse > itemshareData.workcurrentParameter->flSpecVFUSEMax || \
		flCurrentVFuse < itemshareData.workcurrentParameter->flSpecVFUSEMin))
		iresult	=	HisCCMError_Result;
	if(itemshareData.workcurrentParameter->btestPOW && \
		(flCurrentPOW > itemshareData.workcurrentParameter->flSpecPOWMax || \
		flCurrentPOW < itemshareData.workcurrentParameter->flSpecPOWMin))
		iresult	=	HisCCMError_Result;
	if(itemshareData.workcurrentParameter->btestTotal && \
		(dflTotalCurrent > itemshareData.workcurrentParameter->flTotalMax || \
		dflTotalCurrent < itemshareData.workcurrentParameter->flTotalMin))
		iresult	=	HisCCMError_Result;

	itemshareData.itemparameterLock.unlock();

	stLogItem.itemtype		=	classLog->getmaxtypeindex(_HISLOG_CLASSIFY_WORKCURRENT);
	stLogItem.itemkey		=	"Work_Current Result";
	stLogItem.itemvalue	=	(iresult)?("NG"):("OK");
	classLog->push_back(stLogItem);
	if(itemshareData.workcurrentParameter->btestAVDD){
		++(stLogItem.itemtype);
		stLogItem.itemkey		=	"AVDD_Work_Current";
		stLogItem.itemvalue	=	flCurrentAVDD;
		classLog->push_back(stLogItem);
	}
	if(itemshareData.workcurrentParameter->btestDVDD){
		++(stLogItem.itemtype);
		stLogItem.itemkey		=	"DVDD_Work_Current";
		stLogItem.itemvalue	=	flCurrentDVDD;
		classLog->push_back(stLogItem);
	}
	if(itemshareData.workcurrentParameter->btestDOVDD){
		++(stLogItem.itemtype);
		stLogItem.itemkey		=	"DOVDD_Work_Current";
		stLogItem.itemvalue	=	flCurrentDOVDD;
		classLog->push_back(stLogItem);
	}
	if(itemshareData.workcurrentParameter->btestAF){
		++(stLogItem.itemtype);
		stLogItem.itemkey		=	"AF_Work_Current";
		stLogItem.itemvalue	=	flCurrentAF;
		classLog->push_back(stLogItem);
	}
	if(itemshareData.workcurrentParameter->btestVFUSE){
		++(stLogItem.itemtype);
		stLogItem.itemkey		=	"VFuse_Work_Current";
		stLogItem.itemvalue	=	flCurrentVFuse;
		classLog->push_back(stLogItem);
	}
	if(itemshareData.workcurrentParameter->btestPOW){
		++(stLogItem.itemtype);
		stLogItem.itemkey		=	"POW_Work_Current";
		stLogItem.itemvalue	=	flCurrentPOW;
		classLog->push_back(stLogItem);
	}
	if(itemshareData.workcurrentParameter->btestTotal){
		++(stLogItem.itemtype);
		stLogItem.itemkey		=	"Total_Work_Current";
		stLogItem.itemvalue	=	dflTotalCurrent;
		classLog->push_back(stLogItem);
	}

	return iresult;
}

int itemprocess::getstandbycurrentParameter(bool bupdate, bool bcheck)
{
	itemshareData.itemparameterLock.lockForRead();
	if(!bupdate && itemshareData.standbycurrentParameter){
		itemshareData.itemparameterLock.unlock();
		return 0;
	}

	QMutexLocker locker(&hisglobalparameter.mutexDatabase);

	itemshareData.itemparameterLock.unlock();
	itemshareData.itemparameterLock.lockForWrite();
	if(!itemshareData.standbycurrentParameter)
		itemshareData.standbycurrentParameter		=	new _standbycurrentParameter;
	if(!itemshareData.standbycurrentParameter){
		itemshareData.itemparameterLock.unlock();
		return HisFX3Error_MallocBuffer;
	}

	itemshareData.standbycurrentParameter->btestAVDD			=	false;
	itemshareData.standbycurrentParameter->btestDVDD		=	false;
	itemshareData.standbycurrentParameter->btestDOVDD		=	false;
	itemshareData.standbycurrentParameter->btestAF				=	false;
	itemshareData.standbycurrentParameter->btestPOW			=	false;

	bool bparsesuccess	=	true, bItemExist = false;

	//读取，解析config
	for(int  w=0;	w<1;	++w){ //此处是有意义的,不要删除
		QSqlDatabase customdb = QSqlDatabase::addDatabase("QSQLITE", "querycustom");
		customdb.setDatabaseName(QDir::currentPath() % "/HisFX3Custom");
		if (!customdb.open()){
			bparsesuccess	=	false;
			break;
		}

		QString strData, strdata2;
		QStringList strname, strvalue;
		QSqlQuery query(customdb);
		query.prepare("SELECT itemsuffix2,key,value,reserve FROM " % itemshareData.currentTableName % \
			" WHERE classfy='algorithm' AND item='standbycurrent' ORDER BY id ASC" );
		query.exec();

		//(dovdd:on)(dovddmin:0.3)(dovddmax:50.9)(dovddgrade:0)(pwnd:on)(reset:off)(mclk:on)(dvdddown:off)(delay:5000)
		//(dvdd:on)(dvddmin:0.3)(dvddmax:50.9)(dvddgrade:0)(total:on)(totalmin:10.0)(totalmax:20.0)
		//(avdd:on)(avddmin:0.3)(avddmax:50.9)(avddgrade:0)
		//(af:on)(afmin:0.3)(afmax:50.9)(afgrade:0)

		while (query.next()){
			bItemExist = true;
			for(int y=0;	y<4;	++y){
				strData	=	query.value(y).toString();
				ROPLOW::patchconfigstring(strData, strname, strvalue);
				for(int x=0;	x<strname.size();	++x){
					if(strname.at(x) == "dovdd")	itemshareData.standbycurrentParameter->btestDOVDD	=	(strvalue.at(x) == "on");
					else if(strname.at(x) == "dvdd")	itemshareData.standbycurrentParameter->btestDVDD	=	(strvalue.at(x) == "on");
					else if(strname.at(x) == "avdd")	itemshareData.standbycurrentParameter->btestAVDD	=	(strvalue.at(x) == "on");
					else if(strname.at(x) == "af")	itemshareData.standbycurrentParameter->btestAF	=	(strvalue.at(x) == "on");
					else if(strname.at(x) == "pow")	itemshareData.standbycurrentParameter->btestPOW	=	(strvalue.at(x) == "on");
					else if(strname.at(x) == "pwnd")	itemshareData.standbycurrentParameter->bPWND	=	(strvalue.at(x) == "on");
					else if(strname.at(x) == "reset")	itemshareData.standbycurrentParameter->bReset	=	(strvalue.at(x) == "on");
					else if(strname.at(x) == "mclk")	itemshareData.standbycurrentParameter->bMCLK	=	(strvalue.at(x) == "on");
					else if(strname.at(x) == "dvdddown")	itemshareData.standbycurrentParameter->bDVDDDown	=	(strvalue.at(x) == "on");
					else if(strname.at(x) == "total")	itemshareData.standbycurrentParameter->btestTotal	=	(strvalue.at(x) == "on");
					else if(strname.at(x) == "totalmin")	itemshareData.standbycurrentParameter->flTotalMin	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "totalmax")	itemshareData.standbycurrentParameter->flTotalMax	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "dvddmin")	itemshareData.standbycurrentParameter->flSpecDVDDMin	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "avddmin")	itemshareData.standbycurrentParameter->flSpecAVDDMin	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "dovddmin")	itemshareData.standbycurrentParameter->flSpecDOVDDMin	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "afmin")	itemshareData.standbycurrentParameter->flSpecAFMin	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "powmin")	itemshareData.standbycurrentParameter->flSpecPOWMin	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "dvddmax")	itemshareData.standbycurrentParameter->flSpecDVDDMax	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "avddmax")	itemshareData.standbycurrentParameter->flSpecAVDDMax	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "dovddmax")	itemshareData.standbycurrentParameter->flSpecDOVDDMax	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "afmax")	itemshareData.standbycurrentParameter->flSpecAFMax	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "powmax")	itemshareData.standbycurrentParameter->flSpecPOWMax	=	strvalue.at(x).toFloat();
					else if(strname.at(x) == "delay")	itemshareData.standbycurrentParameter->uiDelay	=	strvalue.at(x).toUInt();
				}
			}
		}

		customdb.close();
	}

	QSqlDatabase::removeDatabase("querycustom");

	if(!bparsesuccess){
		HisReleaseNewO(itemshareData.standbycurrentParameter);
		itemshareData.itemparameterLock.unlock();
		return HisCCMError_Database;
	}

	if(!bItemExist)
	{
		HisReleaseNewO(itemshareData.standbycurrentParameter);
		itemshareData.itemparameterLock.unlock();
		return HisFX3Error_Parameter;
	}

	if(!bcheck) {itemshareData.itemparameterLock.unlock(); return 0; }

	if(!(itemshareData.standbycurrentParameter->btestAF || itemshareData.standbycurrentParameter->btestAVDD || \
		itemshareData.standbycurrentParameter->btestDOVDD || itemshareData.standbycurrentParameter->btestDVDD || itemshareData.standbycurrentParameter->btestPOW)){
			emit information(QTextCodec::codecForName( "GBK")->toUnicode("参数错误：未选择静态电流测试通道"));
			HisReleaseNewO(itemshareData.standbycurrentParameter);
			itemshareData.itemparameterLock.unlock();
			return HisFX3Error_Parameter;
	}
	itemshareData.itemparameterLock.unlock();
	return 0;
}

int itemprocess::teststandbycurrent()
{
	//判断图像是否点亮中
	// 	if(!GetHisPreviewflag())
	// 		return HisCCMError_NotPreivew;

	int iresult;

	if(itemshareData.standbycurrentParameter == NULL)
	{
		unsigned int uiHardKey[4];
		if(iresult = classPlatform.HisFX3GetHardwareKey(uiHardKey))	return iresult;
		_HisFX3_Current_Calibration stCalData;

		if(iresult = ROPLOW::currentCalFromDB(uiHardKey, &stCalData, (bBoxChannel1)?(1):(2))){
			// 			emit information(tr("Error: please do current self-calibration first"));
			// 			return iresult;
			emit information(tr("Warning: The Current Calibration Has Not Been Done."));
		}
		else
		{
			if(bBoxChannel1){
				if(iresult = classPlatform.HisFX3SetCurrentCalData(&stCalData)) return iresult;
			}
			else{
				if(iresult = classPlatform.HisFX3SetCurrentCalData_S2(&stCalData)) return iresult;
			}	
		}

	}

	//取得配置参数和规格
	if(iresult	=	getstandbycurrentParameter(false))	return iresult;

	threadshareData.SetHisPreviewflag(false);

	itemshareData.itemparameterLock.lockForRead();

	const float cflAVDD_Cal		=	0.0f;
	const float cflDVDD_Cal		=	0.0f;
	const float cflDOVDD_Cal	=	0.0f;
	const float cflAF_Cal			=	0.0f;

	float flCurrentAVDD, flCurrentDOVDD, flCurrentDVDD, flCurrentAF, flCurrentPOW;
	unsigned int uiFlag	=	(itemshareData.standbycurrentParameter->btestAF)?(_HisFX3_Platform_VlotOn_AF):(0);
	uiFlag	=	(itemshareData.standbycurrentParameter->btestAVDD)?(uiFlag|_HisFX3_Platform_VlotOn_AVDD):(uiFlag);
	uiFlag	=	(itemshareData.standbycurrentParameter->btestDOVDD)?(uiFlag|_HisFX3_Platform_VlotOn_DOVDD):(uiFlag);
	uiFlag	=	(itemshareData.standbycurrentParameter->btestDVDD)?(uiFlag|_HisFX3_Platform_VlotOn_DVDD):(uiFlag);
	uiFlag	=	(itemshareData.standbycurrentParameter->btestPOW)?(uiFlag|_HisFX3_Platform_VlotOn_POW):(uiFlag);

	if(bBoxChannel1)
	{
		iresult	=	classPlatform.HisFX3GetStandbyCurrent(flCurrentAVDD, flCurrentDVDD, flCurrentDOVDD, flCurrentAF, flCurrentPOW, uiFlag, \
			itemshareData.standbycurrentParameter->bPWND, itemshareData.standbycurrentParameter->bReset, \
			itemshareData.standbycurrentParameter->bMCLK, itemshareData.standbycurrentParameter->bDVDDDown, \
			itemshareData.standbycurrentParameter->uiDelay);
	}
	else
	{
		iresult	=	classPlatform.HisFX3GetStandbyCurrent_S2(flCurrentAVDD, flCurrentDVDD, flCurrentDOVDD, flCurrentAF, flCurrentPOW, uiFlag, \
			itemshareData.standbycurrentParameter->bPWND, itemshareData.standbycurrentParameter->bReset, \
			itemshareData.standbycurrentParameter->bMCLK, itemshareData.standbycurrentParameter->bDVDDDown, \
			itemshareData.standbycurrentParameter->uiDelay);
	}

	if(iresult){
		emit information(tr("standby current funtion abnormal"));
		itemshareData.itemparameterLock.unlock();
		return iresult;
	}

	emit information(tr("standby current test data:"));
	if(itemshareData.standbycurrentParameter->btestDVDD)
		emit information("DVDD: " % QString::number(flCurrentDVDD, 'f', 2) % "uA");
	if(itemshareData.standbycurrentParameter->btestDOVDD)
		emit information("DOVDD: " % QString::number(flCurrentDOVDD, 'f', 2) % "uA");
	if(itemshareData.standbycurrentParameter->btestAVDD)
		emit information("AVDD: " % QString::number(flCurrentAVDD, 'f', 2) % "uA");
	if(itemshareData.standbycurrentParameter->btestAF)
		emit information("AF: " % QString::number(flCurrentAF, 'f', 2) % "uA");
	if(itemshareData.standbycurrentParameter->btestPOW)
		emit information("POW: " % QString::number(flCurrentPOW, 'f', 2) % "uA");

	double dflTotalCurrent = 0.0;
	if(itemshareData.standbycurrentParameter->btestDVDD) dflTotalCurrent += flCurrentDVDD;
	if(itemshareData.standbycurrentParameter->btestDOVDD) dflTotalCurrent += flCurrentDOVDD;
	if(itemshareData.standbycurrentParameter->btestAVDD) dflTotalCurrent += flCurrentAVDD;
	if(itemshareData.standbycurrentParameter->btestAF) dflTotalCurrent += flCurrentAF;
	if(itemshareData.standbycurrentParameter->btestPOW) dflTotalCurrent += flCurrentPOW;
	if(itemshareData.standbycurrentParameter->btestTotal)
		emit information("Total: " % QString::number(dflTotalCurrent, 'f', 2) % "uA");

	iresult	=	0;
	if(itemshareData.standbycurrentParameter->btestAF && \
		(flCurrentAF > itemshareData.standbycurrentParameter->flSpecAFMax || \
		flCurrentAF < itemshareData.standbycurrentParameter->flSpecAFMin))
		iresult	=	HisCCMError_Result;
	if(itemshareData.standbycurrentParameter->btestDOVDD && \
		(flCurrentDOVDD > itemshareData.standbycurrentParameter->flSpecDOVDDMax || \
		flCurrentDOVDD < itemshareData.standbycurrentParameter->flSpecDOVDDMin))
		iresult	=	HisCCMError_Result;
	if(itemshareData.standbycurrentParameter->btestDVDD && \
		(flCurrentDVDD > itemshareData.standbycurrentParameter->flSpecDVDDMax || \
		flCurrentDVDD < itemshareData.standbycurrentParameter->flSpecDVDDMin))
		iresult	=	HisCCMError_Result;
	if(itemshareData.standbycurrentParameter->btestAVDD && \
		(flCurrentAVDD > itemshareData.standbycurrentParameter->flSpecAVDDMax || \
		flCurrentAVDD < itemshareData.standbycurrentParameter->flSpecAVDDMin))
		iresult	=	HisCCMError_Result;
	if(itemshareData.standbycurrentParameter->btestPOW && \
		(flCurrentPOW > itemshareData.standbycurrentParameter->flSpecPOWMax || \
		flCurrentPOW < itemshareData.standbycurrentParameter->flSpecPOWMin))
		iresult	=	HisCCMError_Result;
	if(itemshareData.standbycurrentParameter->btestTotal && \
		(dflTotalCurrent > itemshareData.standbycurrentParameter->flTotalMax || \
		dflTotalCurrent < itemshareData.standbycurrentParameter->flTotalMin))
		iresult	=	HisCCMError_Result;
	itemshareData.itemparameterLock.unlock();

	stLogItem.itemtype		=	classLog->getmaxtypeindex(_HISLOG_CLASSIFY_WORKCURRENT);
	stLogItem.itemkey		=	"Standby_Current Result";
	stLogItem.itemvalue	=	(iresult)?("NG"):("OK");
	classLog->push_back(stLogItem);
	if(itemshareData.standbycurrentParameter->btestAVDD){
		++(stLogItem.itemtype);
		stLogItem.itemkey		=	"AVDD_Standby_Current";
		stLogItem.itemvalue	=	flCurrentAVDD;
		classLog->push_back(stLogItem);
	}
	if(itemshareData.standbycurrentParameter->btestDVDD){
		++(stLogItem.itemtype);
		stLogItem.itemkey		=	"DVDD_Standby_Current";
		stLogItem.itemvalue	=	flCurrentDVDD;
		classLog->push_back(stLogItem);
	}
	if(itemshareData.standbycurrentParameter->btestDOVDD){
		++(stLogItem.itemtype);
		stLogItem.itemkey		=	"DOVDD_Standby_Current";
		stLogItem.itemvalue	=	flCurrentDOVDD;
		classLog->push_back(stLogItem);
	}
	if(itemshareData.standbycurrentParameter->btestAF){
		++(stLogItem.itemtype);
		stLogItem.itemkey		=	"AF_Standby_Current";
		stLogItem.itemvalue	=	flCurrentAF;
		classLog->push_back(stLogItem);
	}
	if(itemshareData.standbycurrentParameter->btestPOW){
		++(stLogItem.itemtype);
		stLogItem.itemkey		=	"POW_Standby_Current";
		stLogItem.itemvalue	=	flCurrentPOW;
		classLog->push_back(stLogItem);
	}
	if(itemshareData.standbycurrentParameter->btestTotal){
		++(stLogItem.itemtype);
		stLogItem.itemkey		=	"Total_Standby_Current";
		stLogItem.itemvalue	=	dflTotalCurrent;
		classLog->push_back(stLogItem);
	}

	return iresult;
}

int itemprocess::getOSParameter(bool bupdate, bool bcheck)
{
	itemshareData.itemparameterLock.lockForRead();
	if(!bupdate && itemshareData.openshortParameter){
		itemshareData.itemparameterLock.unlock();
		return 0;
	}

	QMutexLocker locker(&hisglobalparameter.mutexDatabase);

	itemshareData.itemparameterLock.unlock();
	itemshareData.itemparameterLock.lockForWrite();
	HisReleaseNewO(itemshareData.openshortParameter);
	if(!itemshareData.openshortParameter)
		itemshareData.openshortParameter		=	new _openshortParameter;
	if(!itemshareData.openshortParameter){
		itemshareData.itemparameterLock.unlock();
		return HisFX3Error_MallocBuffer;
	}

	bool bparsesuccess	=	true, bDBItemExist = false;

	//读取，解析config
	for(int  w=0;	w<1;	++w){ //此处是有意义的,不要删除
		QSqlDatabase customdb = QSqlDatabase::addDatabase("QSQLITE", "querycustom");
		customdb.setDatabaseName(QDir::currentPath() % "/HisFX3Custom");
		if (!customdb.open()){
			bparsesuccess	=	false;
			break;
		}

		bool bFullPin = false;
		classPlatform.isOpenShortSupported(&bFullPin);

		QString strData, strdata2;
		QStringList strname, strvalue;
		QSqlQuery query(customdb);
		query.prepare("SELECT itemsuffix2,key,value,reserve FROM " % itemshareData.currentTableName % \
			" WHERE classfy='algorithm' AND item='openshort' AND itemsuffix1='total' ORDER BY id ASC" );
		query.exec();

		//(positive:true)(negtive:true)(short:true)(open:true)(ohm:true)
		//(channel:mipi)(positivedelay:12)(negtivedelay:12)(shortdelay:12)(ohmdelay:12)
		while (query.next()){
			bDBItemExist = true;
			for(int y=0;	y<4;	++y){
				strData	=	query.value(y).toString();
				ROPLOW::patchconfigstring(strData, strname, strvalue);
				for(int x=0;	x<strname.size();	++x){
					if(strname.at(x) == "positive")	itemshareData.openshortParameter->bTestPositive	=	(strvalue.at(x) == "true");
					else if(strname.at(x) == "negtive")	itemshareData.openshortParameter->bTestNegtive	=	(strvalue.at(x) == "true");
					else if(strname.at(x) == "short")	itemshareData.openshortParameter->bTestShort	=	(strvalue.at(x) == "true");
					else if(strname.at(x) == "open")	itemshareData.openshortParameter->bTestOpen	=	(strvalue.at(x) == "true");
					else if(strname.at(x) == "ohm")	itemshareData.openshortParameter->bTestOhm	=	(strvalue.at(x) == "true");
					else if(strname.at(x) == "channel")	itemshareData.openshortParameter->ucOSSwitch	=	(strvalue.at(x).toUpper() == "DVP")?(1):(0);
					else if(strname.at(x) == "positivedelay")	itemshareData.openshortParameter->usPositiveDelay	=	strvalue.at(x).toUShort();
					else if(strname.at(x) == "negtivedelay")	itemshareData.openshortParameter->usNegtiveDelay	=	strvalue.at(x).toUShort();
					else if(strname.at(x) == "shortdelay")	itemshareData.openshortParameter->usShortDelay	=	strvalue.at(x).toUShort();
					else if(strname.at(x) == "opendelay")	itemshareData.openshortParameter->usOpenDelay	=	strvalue.at(x).toUShort();
					else if(strname.at(x) == "ohmdelay")	itemshareData.openshortParameter->usOhmDelay	=	strvalue.at(x).toUShort();
				}
			}
		}

		if (itemshareData.openshortParameter->bTestPositive){
			query.prepare("SELECT itemsuffix2,key,value,reserve FROM " % itemshareData.currentTableName % \
				" WHERE classfy='algorithm' AND item='openshort' AND itemsuffix1='positive' ORDER BY id ASC" );
			query.exec();

			//positive
			//(test:true)(name:dvdd)(in:dgnd)
			//(specmin:200)(specmax:600)
			while (query.next())
			{
				bDBItemExist = true;
				_HisFX3OS_Positive_Item stItem;
				for(int y=0;	y<4;	++y){
					strData	=	query.value(y).toString();
					ROPLOW::patchconfigstring(strData, strname, strvalue);
					for(int x=0;	x<strname.size();	++x){
						if(strname.at(x) == "test")	stItem.bTest		=	(strvalue.at(x) == "true");
						else if(strname.at(x) == "in")	{
							if(bFullPin) sprintf(stItem.strGNDName, "%s", strvalue.at(x).toUpper().toAscii().data());
							else	stItem.bAGND	=	strvalue.at(x).toUpper().contains("AGND");
						}
						else if(strname.at(x) == "specmin") stItem.flSpecMin	=	strvalue.at(x).toFloat();
						else if(strname.at(x) == "specmax") stItem.flSpecMax	=	strvalue.at(x).toFloat();
						else if(strname.at(x) == "name") sprintf_s(stItem.strName, _HisFX3_OS_PinName_MaxByte, "%s", strvalue.at(x).toUpper().toAscii().data());
					}
				}
				itemshareData.openshortParameter->vectorPositive.push_back(stItem);
			}

		}

		if (itemshareData.openshortParameter->bTestNegtive){
			query.prepare("SELECT itemsuffix2,key,value,reserve FROM " % itemshareData.currentTableName % \
				" WHERE classfy='algorithm' AND item='openshort' AND itemsuffix1='negtive' ORDER BY id ASC" );
			query.exec();

			//negtive
			//(test:true)(name:dvdd)(out:dovdd)
			//(specmin:200)(specmax:600)
			while (query.next()){
				bDBItemExist = true;
				_HisFX3OS_Negtive_Item stItem;
				for(int y=0;	y<4;	++y){
					strData	=	query.value(y).toString();
					ROPLOW::patchconfigstring(strData, strname, strvalue);
					for(int x=0;	x<strname.size();	++x){
						if(strname.at(x) == "test")	stItem.bTest		=	(strvalue.at(x) == "true");
						else if(strname.at(x) == "specmin") stItem.flSpecMin	=	strvalue.at(x).toFloat();
						else if(strname.at(x) == "specmax") stItem.flSpecMax	=	strvalue.at(x).toFloat();
						else if(strname.at(x) == "name") sprintf_s(stItem.strName, _HisFX3_OS_PinName_MaxByte, "%s", strvalue.at(x).toUpper().toAscii().data());
						else if(strname.at(x) == "out") sprintf_s(stItem.strDOVDDName, _HisFX3_OS_PinName_MaxByte, "%s", strvalue.at(x).toUpper().toAscii().data());
					}
				}
				itemshareData.openshortParameter->vectorNegtive.push_back(stItem);
			}

		}

		if (itemshareData.openshortParameter->bTestShort)
		{
			query.prepare("SELECT itemsuffix2,key,value,reserve FROM " % itemshareData.currentTableName % \
				" WHERE classfy='algorithm' AND item='openshort' AND itemsuffix1='short' ORDER BY id ASC" );
			query.exec();

			//short
			//(test:true)(name:dvdd)
			//(specmin:200)
			while (query.next())
			{
				bDBItemExist = true;
				_HisFX3OS_Short_Item stItem;
				for(int y=0;	y<4;	++y){
					strData	=	query.value(y).toString();
					ROPLOW::patchconfigstring(strData, strname, strvalue);
					for(int x=0;	x<strname.size();	++x){
						if(strname.at(x) == "test")	stItem.bTest		=	(strvalue.at(x) == "true");
						else if(strname.at(x) == "specmin") stItem.flShortSpec	=	strvalue.at(x).toFloat();
						else if(strname.at(x) == "name") sprintf_s(stItem.strName, _HisFX3_OS_PinName_MaxByte, "%s", strvalue.at(x).toUpper().toAscii().data());
					}
				}
				itemshareData.openshortParameter->vectorShort.push_back(stItem);
			}

		}

		if (itemshareData.openshortParameter->bTestOpen)
		{
			query.prepare("SELECT itemsuffix2,key,value,reserve FROM " % itemshareData.currentTableName % \
				" WHERE classfy='algorithm' AND item='openshort' AND itemsuffix1='open' ORDER BY id ASC" );
			query.exec();

			//open
			//(test:true)(name:dvdd)
			//(specmax:200)
			while (query.next())
			{
				bDBItemExist = true;
				_HisFX3OS_Open_Item stItem;
				for(int y=0;	y<4;	++y){
					strData	=	query.value(y).toString();
					ROPLOW::patchconfigstring(strData, strname, strvalue);
					for(int x=0;	x<strname.size();	++x){
						if(strname.at(x) == "test")	stItem.bTest		=	(strvalue.at(x) == "true");
						else if(strname.at(x) == "specmax") stItem.flOpenSpec	=	strvalue.at(x).toFloat();
						else if(strname.at(x) == "name") sprintf_s(stItem.strName, _HisFX3_OS_PinName_MaxByte, "%s", strvalue.at(x).toUpper().toAscii().data());
					}
				}
				itemshareData.openshortParameter->vectorOpen.push_back(stItem);
			}

		}

		if (itemshareData.openshortParameter->bTestOhm){
			query.prepare("SELECT itemsuffix2,key,value,reserve FROM " % itemshareData.currentTableName % \
				" WHERE classfy='algorithm' AND item='openshort' AND itemsuffix1='ohm' ORDER BY id ASC" );
			query.exec();

			//ohm
			//(test:true)(inname:dgnd)(outname:io2)
			//(specmin:0.0)(specmax:5.0)	
			while (query.next()){
				bDBItemExist = true;
				_HisFX3OS_OHM_Item stItem;
				bool bTest = false;
				for(int y=0;	y<4;	++y){
					strData	=	query.value(y).toString();
					ROPLOW::patchconfigstring(strData, strname, strvalue);
					for(int x=0;	x<strname.size();	++x){
						if(strname.at(x) == "test")	bTest		=	(strvalue.at(x) == "true");
						else if(strname.at(x) == "specmin") stItem.flSpecMin	=	strvalue.at(x).toFloat();
						else if(strname.at(x) == "specmax") stItem.flSpecMax	=	strvalue.at(x).toFloat();
						else if(strname.at(x) == "inname") sprintf_s(stItem.str1stName, _HisFX3_OS_PinName_MaxByte, "%s", strvalue.at(x).toUpper().toAscii().data());
						else if(strname.at(x) == "outname") sprintf_s(stItem.str2ndName, _HisFX3_OS_PinName_MaxByte, "%s", strvalue.at(x).toUpper().toAscii().data());
					}
				}
				if(bTest)	itemshareData.openshortParameter->vectorOhm.push_back(stItem);
			}

		}

		customdb.close();
	}

	QSqlDatabase::removeDatabase("querycustom");

	if(!bparsesuccess){
		HisReleaseNewO(itemshareData.openshortParameter);
		itemshareData.itemparameterLock.unlock();
		return HisCCMError_Database;
	}

	if(!bDBItemExist)
	{
		HisReleaseNewO(itemshareData.openshortParameter);
		itemshareData.itemparameterLock.unlock();
		return HisFX3Error_Parameter;
	}

	if(!bcheck) {itemshareData.itemparameterLock.unlock(); return 0; }

	bool bItemExist	=	false;
	for(unsigned int x=0;	x<itemshareData.openshortParameter->vectorPositive.size();	++x){
		if(itemshareData.openshortParameter->vectorPositive.at(x).bTest){
			bItemExist	=	true;
			break;
		}
	}
	if(!bItemExist)	itemshareData.openshortParameter->bTestPositive	=	false;

	bItemExist	=	false;
	for(unsigned int x=0;	x<itemshareData.openshortParameter->vectorNegtive.size();	++x){
		if(itemshareData.openshortParameter->vectorNegtive.at(x).bTest){
			bItemExist	=	true;
			break;
		}
	}
	if(!bItemExist)	itemshareData.openshortParameter->bTestNegtive	=	false;

	unsigned int uiItemCount	=	0;
	for(unsigned int x=0;	x<itemshareData.openshortParameter->vectorShort.size();	++x){
		if(itemshareData.openshortParameter->vectorShort.at(x).bTest)	
			++uiItemCount;
	}
	if(uiItemCount < 2)	itemshareData.openshortParameter->bTestShort	=	false;

	if(itemshareData.openshortParameter->vectorOhm.size() < 1) itemshareData.openshortParameter->bTestOhm = false;

	if(!(itemshareData.openshortParameter->bTestPositive || itemshareData.openshortParameter->bTestNegtive || \
		itemshareData.openshortParameter->bTestOhm || itemshareData.openshortParameter->bTestShort || itemshareData.openshortParameter->bTestOpen)){
			HisReleaseNewO(itemshareData.openshortParameter);
			itemshareData.itemparameterLock.unlock();
			emit information(tr("Has not set os parameter yet, please finish it first."));
			return HisFX3Error_Parameter;
	}

	if(!itemshareData.openshortParameter->ucOSSwitch && !bBoxChannel1) itemshareData.openshortParameter->ucOSSwitch = 2;

	itemshareData.itemparameterLock.unlock();
	return 0;
}

int itemprocess::openshortTest()
{
	int iresult;
	if(itemshareData.openshortParameter == NULL)
	{
		unsigned int uiHardKey[4];
		if(iresult = classPlatform.HisFX3GetHardwareKey(uiHardKey))	{
			emit information(QTextCodec::codecForName( "GBK")->toUnicode("警告：OS还未经过校正，校正之后数据会更精确"));
		}

		_HisFX3R2_OSCal_Item stCalData[500];
		unsigned int uiItemCount	=	0;
		if(!iresult && (iresult = HISPLATFORMOS::OSCalFromDB(uiHardKey, stCalData, &uiItemCount, hisglobalparameter.mutexDatabase))){
			emit information(QTextCodec::codecForName( "GBK")->toUnicode("警告：OS还未经过校正，校正之后数据会更精确"));
			emit information(QTextCodec::codecForName( "GBK")->toUnicode("还未校正电流，请用调试菜单里面的OS自校正功能进行校正"));
		}

		// 		if(!iresult && !uiItemCount){
		// 			emit information(QTextCodec::codecForName( "GBK")->toUnicode("警告：OS还未经过校正，校正之后数据会更精确"));
		// 			emit information(QTextCodec::codecForName( "GBK")->toUnicode("还未校正电流，请用调试菜单里面的OS自校正功能进行校正"));
		// 			iresult	=	HisFX3Error_Other;
		// 		}

		if(!iresult && !uiItemCount && (iresult = classPlatform.HisFX3SetOSCalData(stCalData, uiItemCount))) {
			emit information(QTextCodec::codecForName( "GBK")->toUnicode("导入OS校正数据失败"));
			return iresult;
		}
	}

	iresult	=	getOSParameter(false);
	if(iresult)	return iresult;

	if(threadshareData.GetHisPreviewflag()){
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("错误：OS测试时需要关闭图像"));
		return HisFX3Error_Other;
	}

	itemshareData.itemparameterLock.lockForRead();

	QElapsedTimer classTime;
	classTime.start();

	QString strText;
	bool bPositiveRel = true, bNegtiveRel = true, bShortRel = true, bOhmRel = true, bOpenRel = true;
	if(itemshareData.openshortParameter->bTestPositive)
	{
		if(iresult = classPlatform.HisFX3OSPositiveTest(itemshareData.openshortParameter->ucOSSwitch, \
			itemshareData.openshortParameter->vectorPositive, itemshareData.openshortParameter->usPositiveDelay)) {
				emit information(QString::fromWCharArray(classPlatform.GetLastError()));
				return iresult;
		}
		for(unsigned int x=0;	x<itemshareData.openshortParameter->vectorPositive.size(); ++x){
			if(itemshareData.openshortParameter->vectorPositive.at(x).bTest){
				if(itemshareData.openshortParameter->vectorPositive.at(x).flVoltValue < itemshareData.openshortParameter->vectorPositive.at(x).flSpecMin)
					strText	=	QTextCodec::codecForName( "GBK")->toUnicode("短路");
				else if(itemshareData.openshortParameter->vectorPositive.at(x).flVoltValue > itemshareData.openshortParameter->vectorPositive.at(x).flSpecMax)
					strText	=	QTextCodec::codecForName( "GBK")->toUnicode("开路");
				else
					continue;

				bPositiveRel	=	false;
				emit information(QString::fromAscii(itemshareData.openshortParameter->vectorPositive.at(x).strName) % strText % ": " % \
					QString::number(itemshareData.openshortParameter->vectorPositive.at(x).flVoltValue) % "mV(spec:" % \
					QString::number(itemshareData.openshortParameter->vectorPositive.at(x).flSpecMin) % "--" % \
					QString::number(itemshareData.openshortParameter->vectorPositive.at(x).flSpecMax) % ")");
			}
		}

		if(hisglobalparameter.bDebugMode){
			emit information(QTextCodec::codecForName( "GBK")->toUnicode("OS(正向)所有测试数据："));
			for(unsigned int x=0;	x<itemshareData.openshortParameter->vectorPositive.size(); ++x){
				if(!itemshareData.openshortParameter->vectorPositive.at(x).bTest) continue;
				emit information(QString::fromAscii(itemshareData.openshortParameter->vectorPositive.at(x).strName) % ": " % \
					QString::number(itemshareData.openshortParameter->vectorPositive.at(x).flVoltValue) % "mV(spec:" % \
					QString::number(itemshareData.openshortParameter->vectorPositive.at(x).flSpecMin) % "--" % \
					QString::number(itemshareData.openshortParameter->vectorPositive.at(x).flSpecMax) % ")");
			}
		}	
	}

	emit information("positive time: " % QString::number(classTime.restart()));

	if(itemshareData.openshortParameter->bTestNegtive){
		if(iresult = classPlatform.HisFX3OSNegtiveTest(itemshareData.openshortParameter->ucOSSwitch, \
			itemshareData.openshortParameter->vectorNegtive, itemshareData.openshortParameter->usNegtiveDelay)) return iresult;
		for(unsigned int x=0;	x<itemshareData.openshortParameter->vectorNegtive.size(); ++x){
			if(itemshareData.openshortParameter->vectorNegtive.at(x).bTest){
				if(itemshareData.openshortParameter->vectorNegtive.at(x).flVoltValue < itemshareData.openshortParameter->vectorNegtive.at(x).flSpecMin)
					strText	=	QTextCodec::codecForName( "GBK")->toUnicode("短路");
				else if(itemshareData.openshortParameter->vectorNegtive.at(x).flVoltValue > itemshareData.openshortParameter->vectorNegtive.at(x).flSpecMax)
					strText	=	QTextCodec::codecForName( "GBK")->toUnicode("开路");
				else
					continue;

				bNegtiveRel	=	false;
				emit information(QString::fromAscii(itemshareData.openshortParameter->vectorNegtive.at(x).strName) % strText % ": " % \
					QString::number(itemshareData.openshortParameter->vectorNegtive.at(x).flVoltValue) % "mV(spec:" % \
					QString::number(itemshareData.openshortParameter->vectorNegtive.at(x).flSpecMin) % "--" % \
					QString::number(itemshareData.openshortParameter->vectorNegtive.at(x).flSpecMax) % ")");
			}
		}

		if(hisglobalparameter.bDebugMode){
			emit information(QTextCodec::codecForName( "GBK")->toUnicode("OS(负向)所有测试数据："));
			for(unsigned int x=0;	x<itemshareData.openshortParameter->vectorNegtive.size(); ++x){
				if(!itemshareData.openshortParameter->vectorNegtive.at(x).bTest) continue;
				emit information(QString::fromAscii(itemshareData.openshortParameter->vectorNegtive.at(x).strName) % ": " % \
					QString::number(itemshareData.openshortParameter->vectorNegtive.at(x).flVoltValue) % "mV(spec:" % \
					QString::number(itemshareData.openshortParameter->vectorNegtive.at(x).flSpecMin) % "--" % \
					QString::number(itemshareData.openshortParameter->vectorNegtive.at(x).flSpecMax) % ")");
			}
		}	
	}

	emit information("negtive time: " % QString::number(classTime.restart()));

	if(itemshareData.openshortParameter->bTestShort)
	{
		if(iresult = classPlatform.HisFX3OSShortTest(itemshareData.openshortParameter->ucOSSwitch, \
			itemshareData.openshortParameter->vectorShort, itemshareData.openshortParameter->usShortDelay)) return iresult;
		for(unsigned int x=0;	x<itemshareData.openshortParameter->vectorShort.size(); ++x){
			if(itemshareData.openshortParameter->vectorShort.at(x).bTest && itemshareData.openshortParameter->vectorShort.at(x).ucShortIndex){
				bShortRel	=	false;
				strText	=	QString::fromAscii(itemshareData.openshortParameter->vectorShort.at(x).strName) % ": " % \
					QString::number(itemshareData.openshortParameter->vectorShort.at(x).flVoltValue) % "mV(spec:" % \
					QString::number(itemshareData.openshortParameter->vectorShort.at(x).flShortSpec) % ")";
				strText = strText % "---short with" % QString::fromAscii(itemshareData.openshortParameter->vectorShort.at(x).strShortName) % \
					"(" % QString::number(itemshareData.openshortParameter->vectorShort.at(x).ucShortIndex) % ")";
				emit information(strText);
			}
		}

		if(hisglobalparameter.bDebugMode){
			emit information(QTextCodec::codecForName( "GBK")->toUnicode("OS(短路)所有测试数据："));
			for(unsigned int x=0;	x<itemshareData.openshortParameter->vectorShort.size(); ++x){
				if(!itemshareData.openshortParameter->vectorShort.at(x).bTest) continue;
				strText	=	QString::fromAscii(itemshareData.openshortParameter->vectorShort.at(x).strName) % ": " % \
					QString::number(itemshareData.openshortParameter->vectorShort.at(x).flVoltValue) % "mV(spec:" % \
					QString::number(itemshareData.openshortParameter->vectorShort.at(x).flShortSpec) % ")";
				if(itemshareData.openshortParameter->vectorShort.at(x).ucShortIndex)
					strText = strText % "---short with" % QString::fromAscii(itemshareData.openshortParameter->vectorShort.at(x).strShortName) % \
					"(" % QString::number(itemshareData.openshortParameter->vectorShort.at(x).ucShortIndex) % ")";
				emit information(strText);
			}
		}	
	}

	emit information("short time: " % QString::number(classTime.restart()));

	if(itemshareData.openshortParameter->bTestOpen)
	{
		if(iresult = classPlatform.HisFX3OSOpenTest(itemshareData.openshortParameter->ucOSSwitch, \
			itemshareData.openshortParameter->vectorOpen, itemshareData.openshortParameter->usOpenDelay)) return iresult;
		for(unsigned int x=0;	x<itemshareData.openshortParameter->vectorOpen.size(); ++x)
		{
			if(itemshareData.openshortParameter->vectorOpen.at(x).bTest && itemshareData.openshortParameter->vectorOpen.at(x).ucOpenIndex){
				bOpenRel	=	false;
				strText	=	QString::fromAscii(itemshareData.openshortParameter->vectorOpen.at(x).strName) % ": " % \
					QString::number(itemshareData.openshortParameter->vectorOpen.at(x).flVoltValue) % "mV(spec:" % \
					QString::number(itemshareData.openshortParameter->vectorOpen.at(x).flOpenSpec) % ")";
				strText = strText % "---open with" % QString::fromAscii(itemshareData.openshortParameter->vectorOpen.at(x).strOpenName) % \
					"(" % QString::number(itemshareData.openshortParameter->vectorOpen.at(x).ucOpenIndex) % ")";
				emit information(strText);
			}
		}

		if(hisglobalparameter.bDebugMode)
		{
			emit information(QTextCodec::codecForName( "GBK")->toUnicode("OS(开路)所有测试数据："));
			for(unsigned int x=0;	x<itemshareData.openshortParameter->vectorOpen.size(); ++x){
				if(!itemshareData.openshortParameter->vectorOpen.at(x).bTest) continue;
				strText	=	QString::fromAscii(itemshareData.openshortParameter->vectorOpen.at(x).strName) % ": " % \
					QString::number(itemshareData.openshortParameter->vectorOpen.at(x).flVoltValue) % "mV(spec:" % \
					QString::number(itemshareData.openshortParameter->vectorOpen.at(x).flOpenSpec) % ")";
				if(itemshareData.openshortParameter->vectorOpen.at(x).ucOpenIndex)
					strText = strText % "---open with" % QString::fromAscii(itemshareData.openshortParameter->vectorOpen.at(x).strOpenName) % \
					"(" % QString::number(itemshareData.openshortParameter->vectorOpen.at(x).ucOpenIndex) % ")";
				emit information(strText);
			}
		}	
	}

	emit information("open time: " % QString::number(classTime.restart()));

	if(itemshareData.openshortParameter->bTestOhm){
		if(hisglobalparameter.bDebugMode)
			emit information(QTextCodec::codecForName( "GBK")->toUnicode("OS(电阻)所有测试数据："));

		for(unsigned int x=0;	x<itemshareData.openshortParameter->vectorOhm.size(); ++x)
		{
			if(iresult = classPlatform.HisFX3OSOhmTest(itemshareData.openshortParameter->ucOSSwitch, \
				itemshareData.openshortParameter->vectorOhm.at(x), 0.0f, itemshareData.openshortParameter->usOhmDelay)) {
					itemshareData.itemparameterLock.unlock();
					return iresult;
			}

			if(hisglobalparameter.bDebugMode || \
				itemshareData.openshortParameter->vectorOhm.at(x).flOhmValue < itemshareData.openshortParameter->vectorOhm.at(x).flSpecMin || \
				itemshareData.openshortParameter->vectorOhm.at(x).flOhmValue > itemshareData.openshortParameter->vectorOhm.at(x).flSpecMax){
					strText = QString::fromAscii(itemshareData.openshortParameter->vectorOhm.at(x).str1stName) % "--" % \
						QString::fromAscii(itemshareData.openshortParameter->vectorOhm.at(x).str2ndName) % "  ohm: " % \
						QString::number(itemshareData.openshortParameter->vectorOhm.at(x).flOhmValue) % "(spec:" % \
						QString::number(itemshareData.openshortParameter->vectorOhm.at(x).flSpecMin) % "--" % \
						QString::number(itemshareData.openshortParameter->vectorOhm.at(x).flSpecMax) % ")";
					emit information(strText);
					if(itemshareData.openshortParameter->vectorOhm.at(x).flOhmValue < itemshareData.openshortParameter->vectorOhm.at(x).flSpecMin || \
						itemshareData.openshortParameter->vectorOhm.at(x).flOhmValue > itemshareData.openshortParameter->vectorOhm.at(x).flSpecMax)
						bOhmRel	=	false;
			}
		}
	}

	emit information("ohm time: " % QString::number(classTime.restart()));

	ROPLOW::OSSaveLog(bPositiveRel, bNegtiveRel, bShortRel, bOhmRel, bOpenRel, *(itemshareData.openshortParameter), *classLog);
	itemshareData.itemparameterLock.unlock();

	return (bPositiveRel && bNegtiveRel && bShortRel && bOhmRel && bOpenRel)?(0):(HisCCMError_Result);
}

int itemprocess::manualModeBLoop1()
{
	unsigned long long ui64FrameIndex = 0;
	unsigned int uiScene, uiNowScene = 0xFF, uiDetectFrameCount = 0;
	unsigned int uiImageTimeOut = 200;
	_itemStatus itemstatus;
	unsigned char* pucRGB24 = 0;

	while(1)
	{	
		if(bBoxChannel1 && !globalFunPointer.IsHisFX3DataStreaming(uiImageTimeOut))
		{
			emit information("IsHisFX3DataStreaming");
			stopPreview();
			while(HISMANUALMODE::isModuleHotPlugIn()) Sleep(20);
			break;
		}

		if(bBoxChannel1 && !HISMANUALMODE::isManualModeBStreaming(threadshareData, ui64FrameIndex, 300))
		{
			++uiDetectFrameCount;
			if(uiDetectFrameCount > 6)
			{
				emit information("isManualModeBStreaming");
				stopPreview();
				while(HISMANUALMODE::isModuleHotPlugIn()) Sleep(20);
				break;
			}
			else
			{
				continue;
			}
		}

		uiDetectFrameCount	=	0;
		uiScene	=	hisglobalparameter.stOperatorMode.ucPlugScene;

		int iresult	=	0;
		if(uiScene == 1)
		{
			uiScene	=	0xFF;

			if(!pucRGB24)
				pucRGB24	=	(unsigned char*)_aligned_malloc(itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight *3, _HisCacheLine_Aligned);

			if(pucRGB24)
			{
				iresult =	threadshareData.GetFreshframe(pucRGB24, itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight *3, _FrameType_RGB24, true);

				if(!iresult)
				{
					RECT stROI;
					double dflROIRatio	=	0.8;

					int iGetScene;
					stROI.left			=	itemshareData.previewParameter->iWidth *(1.0 - dflROIRatio) *0.5;
					stROI.right		=	stROI.left	+ itemshareData.previewParameter->iWidth *dflROIRatio;
					stROI.top			=	itemshareData.previewParameter->iHeight *(1.0 - dflROIRatio) *0.5;
					stROI.bottom	=	stROI.top	+ itemshareData.previewParameter->iHeight *dflROIRatio;

					int iResize			=	(int)((double)(itemshareData.previewParameter->iHeight) /1080.0 + 0.3);
					iResize				=	max(1, iResize);
					stROI.left				=	((stROI.left / iResize) *iResize);
					stROI.right			=	((stROI.right / iResize) *iResize);
					stROI.top				=	((stROI.top / iResize) *iResize);
					stROI.bottom		=	((stROI.bottom / iResize) *iResize);

					iresult = classRolongoTest.RolongoTestenvironmentDetection(pucRGB24, itemshareData.previewParameter->iWidth, itemshareData.previewParameter->iHeight, \
						stROI, iResize, iGetScene, false);

					if(!iresult)
					{
						if(iGetScene == _EnvironmentType_Mtf) uiScene = 2;
						else if(iGetScene == _EnvironmentType_WhitePanel) uiScene = 3;
						else if(iGetScene == _EnvironmentType_Blackboard) uiScene = 4;
					}
				}		
			}

		}


		if(uiScene == 2) //FA
		{
			if(uiNowScene != uiScene)
			{
				threadshareData.SetBlemishEnhanceShowFlag(false);
				uiNowScene	=	uiScene;
				_CODE_CLEAR_IMAGEDRAW
					iresult = setexposureTimeExe(itemshareData.stManualModeA.uiExposureValue_FA);
				if(iresult)	emit information(GetHisFX3ErrorInfo(iresult));
				Sleep(itemshareData.stManualModeA.usDelay);			
			}

			hisglobalparameter.setfaflag(true);

			if(hisglobalparameter.stOperatorMode.ucChartType_B == _HisCCMAlg_Rolongo_Chart_MTF_A){
				itemstatus.usitem	=	mtffaitem;
				updateItemstatus(itemstatus);
				iresult	=	mtfFA(1);
			}
			else if(hisglobalparameter.stOperatorMode.ucChartType_B == _HisCCMAlg_Rolongo_Chart_SFR_A){

			}
			else if(hisglobalparameter.stOperatorMode.ucChartType_B == _HisCCMAlg_Rolongo_Chart_LP_A){

			}
			hisglobalparameter.setfaflag(false);

			itemstatus.ucstatus	=	_His_ItemStatus_PASS;
			if(iresult){
				itemstatus.ucstatus	=	_His_ItemStatus_NG;
			}
			updateItemstatus(itemstatus);

			Sleep(30);
		}
		else if(uiScene == 3) //White Field
		{
			if(uiNowScene != uiScene)
			{
				uiNowScene	=	uiScene;
				_CODE_CLEAR_IMAGEDRAW
					iresult = setexposureTimeExe(itemshareData.stManualModeA.uiExposureValue_WhiteField);
				if(iresult)	emit information(GetHisFX3ErrorInfo(iresult));
				Sleep(itemshareData.stManualModeA.usDelay);
				threadshareData.SetBlemishEnhanceShowFlag(true);
			}

			if (!iresult)
			{
				if(itemshareData.stManualModeA.bBlemishON)
				{
					iresult = blemish();
					itemstatus.usitem	=	whitepanelitem_blemish;
					itemstatus.ucstatus	=	iresult?_His_ItemStatus_NG:_His_ItemStatus_PASS;
					updateItemstatus(itemstatus);
				}

				if(itemshareData.stManualModeA.bOCON)
				{
					iresult = whitePanelOC();
					itemstatus.usitem	=	whitepanelitem_oc;
					itemstatus.ucstatus	=	iresult?_His_ItemStatus_NG:_His_ItemStatus_PASS;
					updateItemstatus(itemstatus);
				}

				if(itemshareData.stManualModeA.bColorON)
				{
					iresult = whitePanelColor();
					itemstatus.usitem	=	whitepanelitem_color;
					itemstatus.ucstatus	=	iresult?_His_ItemStatus_NG:_His_ItemStatus_PASS;
					updateItemstatus(itemstatus);
				}

				if(itemshareData.stManualModeA.bDefectPixelON)
				{
					iresult = whitePanelDefectPixel();
					itemstatus.usitem	=	whitepanelitem_pixel;
					itemstatus.ucstatus	=	iresult?_His_ItemStatus_NG:_His_ItemStatus_PASS;
					updateItemstatus(itemstatus);
				}

				if(itemshareData.stManualModeA.bShadingON)
				{
					iresult = whitePanelShading();
					itemstatus.usitem	=	whitepanelitem_shading;
					itemstatus.ucstatus	=	iresult?_His_ItemStatus_NG:_His_ItemStatus_PASS;
					updateItemstatus(itemstatus);
				}

				if(itemshareData.stManualModeA.bVignetON)
				{
					iresult = whitePanelVignetting();
					itemstatus.usitem	=	whitepanelitem_vignetting;
					itemstatus.ucstatus	=	iresult?_His_ItemStatus_NG:_His_ItemStatus_PASS;
					updateItemstatus(itemstatus);
				}

				if(itemshareData.stManualModeA.bLineON)
				{
					iresult = whitePanelDefectLine();
					itemstatus.usitem	=	whitepanelitem_line;
					itemstatus.ucstatus	=	iresult?_His_ItemStatus_NG:_His_ItemStatus_PASS;
					updateItemstatus(itemstatus);
				}
			}

			Sleep(250);
		}
		else if(uiScene == 4) //Black Field
		{
			if(uiNowScene != uiScene)
			{
				threadshareData.SetBlemishEnhanceShowFlag(false);
				uiNowScene	=	uiScene;
				_CODE_CLEAR_IMAGEDRAW			
			}

			iresult	=	blackfield();
			itemstatus.usitem	=	blackfielditem;
			itemstatus.ucstatus	=	_His_ItemStatus_PASS;
			if(iresult){
				itemstatus.ucstatus	=	_His_ItemStatus_NG;
			}
			updateItemstatus(itemstatus);

			Sleep(150);
		}
		else
		{
			Sleep(80);
		}

		if(iresult && iresult != HisCCMError_Result)	 emit information(GetHisFX3ErrorInfo(iresult));
	}

	HisReleaseMalloc(pucRGB24);
	emit signalPlugInDetect();

	return 0;
}

int itemprocess::playAudio(unsigned int cuiSource, unsigned int cuiPlayTime, float flSampleRateMultiple)
{
	int iresult = 0;

	if(cuiSource == 0)
	{
		if(iresult = classPlatform.HisFX3StartAudio()) return iresult;

		QElapsedTimer classTime;
		classTime.start();

		_HisPlatformAudio_Buffer stAudioBuffer;
		bool bFirst	=	true;
		QAudioOutput* classAudioOutput = 0;
		QIODevice* classStreamOut			=	0;
		int iPeriodSize;

		while(classTime.elapsed() < cuiPlayTime)
		{
			if(iresult = classPlatform.HisFX3GrabAudioBuffer(&stAudioBuffer)) continue;

			if(bFirst)
			{
				bFirst	=	false;
				QAudioFormat audioFormat;  
				audioFormat.setSampleRate(stAudioBuffer.samplerate *flSampleRateMultiple);  
				audioFormat.setChannelCount(stAudioBuffer.channels);  
				audioFormat.setSampleSize(stAudioBuffer.sampleSize);  
				audioFormat.setCodec("audio/pcm");  
				audioFormat.setByteOrder(QAudioFormat::LittleEndian);  
				audioFormat.setSampleType(QAudioFormat::SignedInt);  
				QAudioDeviceInfo info = QAudioDeviceInfo::defaultOutputDevice();  
				if (!info.isFormatSupported(audioFormat)) {  
					emit information("default format not supported try to use nearest");
					audioFormat = info.nearestFormat(audioFormat);  
				}  

				// 				emit information("stAudioBuffer.channels" % QString::number(stAudioBuffer.channels));
				// 				emit information("stAudioBuffer.samplerate" % QString::number(stAudioBuffer.samplerate));
				// 				emit information("stAudioBuffer.sampleSize" % QString::number(stAudioBuffer.sampleSize));

				classAudioOutput = new QAudioOutput(audioFormat, this);  
				classStreamOut	  = classAudioOutput->start();  
				iPeriodSize			 =	classAudioOutput->periodSize();			
			}

			// 			if(classAudioOutput->state() != QAudio::IdleState) Sleep(2);

			for(unsigned int uiBufWrited = 0; uiBufWrited < stAudioBuffer.uiBufSize; )
			{
				int iByteFree	=	classAudioOutput->bytesFree();
				if(iByteFree < iPeriodSize) Sleep(3);
				iByteFree	=	min(iByteFree, stAudioBuffer.uiBufSize - uiBufWrited);
				classStreamOut->write((const char *)(stAudioBuffer.pucBuf + uiBufWrited), (qint64)iByteFree);
				uiBufWrited	+=	iByteFree;
			}

		}

		if(classAudioOutput) delete classAudioOutput;
		classPlatform.HisFX3StopAudio();

		return 0;
	}

	return iresult;
}

int itemprocess::testMIC()
{
	int iresult = 0;



	return iresult;
}

int itemprocess::testLED()
{
	int iresult = 0;



	return iresult;
}

int itemprocess::fwBurn()
{
	int iresult = 0;



	return iresult;

}

#ifdef _HisFX3_Platform_Jigboard
int itemprocess::Jig_StartPreview()
{
	SetHisPreviewflag(false);

	bool bIs	=	true;
	DWORD uistart	=	GetTickCount();
	while(GetTickCount() < uistart + _ThreadExit_TimeOut){
		threadshareData.flaglock.lockForRead();
		if(!(threadshareData.brawrun || threadshareData.brenderrun || threadshareData.brgbrun)){
			threadshareData.flaglock.unlock();
			bIs	=	false;
			break;
		}
		threadshareData.flaglock.unlock();
		::Sleep(10);
	}

	if(bIs)	return HisFX3Error_Timeout;

	wchar_t Jig_strIniPath[MAX_PATH]		=	L".\\RolongoJigboard.ini";
	if(itemshareData.previewParameter == NULL) itemshareData.previewParameter	=	new _HisFX3_PreviewStruct;
	itemshareData.previewParameter->ucDataFormat	=	HisRGB_RGB24;

	int iPreviewWidth	=	::GetPrivateProfileIntW(L"PREVIEW MODE", L"preview_width", 0, Jig_strIniPath);
	int iPreviewHeight	=	::GetPrivateProfileIntW(L"PREVIEW MODE", L"preview_height", 0, Jig_strIniPath);
	int iCaptureWidth	=	::GetPrivateProfileIntW(L"CAPTURE MODE", L"image_width", 0, Jig_strIniPath);
	int iCaptureHeight	=	::GetPrivateProfileIntW(L"CAPTURE MODE", L"image_height", 0, Jig_strIniPath);
	itemshareData.previewParameter->uiFrameByteCount = iPreviewWidth *iPreviewHeight *3;
	threadshareData.uiRawBufByte	=	iPreviewWidth *iPreviewHeight *3;
	itemshareData.previewParameter->iWidth		=	iPreviewWidth;
	itemshareData.previewParameter->iHeight		=	iPreviewHeight;

	int iresult	=	classPlatform.HisFX3StartPreview(itemshareData.previewParameter);
	if(iresult){
		emit information(QString::fromWCharArray(classPlatform.GetLastError()));
		return iresult;
	}

	threadshareData.flaglock.lockForWrite();
	HisReleaseMalloc(threadshareData.pucRaw1);
	HisReleaseMalloc(threadshareData.pucRaw2);
	HisReleaseMalloc(threadshareData.pucRGB1);
	HisReleaseMalloc(threadshareData.pucRGB2);
	threadshareData.pucRaw1	=	(unsigned char*)_aligned_malloc(iCaptureWidth *iCaptureHeight *3, _HisCacheLine_Aligned);
	threadshareData.pucRaw2	=	(unsigned char*)_aligned_malloc(iCaptureWidth *iCaptureHeight *3, _HisCacheLine_Aligned);
	threadshareData.pucRGB1	=	(unsigned char*)_aligned_malloc(iCaptureWidth *iCaptureHeight *3, _HisCacheLine_Aligned);
	threadshareData.pucRGB2	=	(unsigned char*)_aligned_malloc(iCaptureWidth *iCaptureHeight *3, _HisCacheLine_Aligned);

	if(!(threadshareData.pucRaw1 && threadshareData.pucRaw2 && threadshareData.pucRGB1 && threadshareData.pucRGB2)){
		HisReleaseMalloc(threadshareData.pucRaw1);
		HisReleaseMalloc(threadshareData.pucRaw2);
		HisReleaseMalloc(threadshareData.pucRGB1);
		HisReleaseMalloc(threadshareData.pucRGB2);
		threadshareData.flaglock.unlock();
		classPlatform.HisFX3StopPreview();
		return HisFX3Error_MallocBuffer;
	}

	threadshareData.ucFormat		=	itemshareData.previewParameter->ucDataFormat;
	threadshareData.uiWidth			=	itemshareData.previewParameter->iWidth;
	threadshareData.uiHeight			=	itemshareData.previewParameter->iHeight;
	threadshareData.uiRawBufByte	=	itemshareData.previewParameter->uiFrameByteCount;

	threadshareData.ui64Raw2Index = threadshareData.ui64Raw1Index = threadshareData.ui64RGB2Index = 0;
	threadshareData.flaglock.unlock();

	SetHisPreviewflag(true);

	switch (threadshareData.stImageShowPolicy.ucMode)
	{
	case 2:
		horizontalScrollBar.setMaximum(itemshareData.previewParameter->iWidth - imageframe.width());
		verticalScrollBar.setMaximum(itemshareData.previewParameter->iHeight - imageframe.height());
		horizontalScrollBar.setValue((horizontalScrollBar.maximum() >>1));
		verticalScrollBar.setValue((verticalScrollBar.maximum() >>1));
		break;
	case 3:
		horizontalScrollBar.setMaximum((itemshareData.previewParameter->iWidth <<1) - imageframe.width());
		verticalScrollBar.setMaximum((itemshareData.previewParameter->iHeight <<1) - imageframe.height());
		horizontalScrollBar.setValue((horizontalScrollBar.maximum() >>1));
		verticalScrollBar.setValue((verticalScrollBar.maximum() >>1));
		break;
	case 4:
		horizontalScrollBar.setMaximum((itemshareData.previewParameter->iWidth <<2) - imageframe.width());
		verticalScrollBar.setMaximum((itemshareData.previewParameter->iHeight <<2) - imageframe.height());
		horizontalScrollBar.setValue((horizontalScrollBar.maximum() >>1));
		verticalScrollBar.setValue((verticalScrollBar.maximum() >>1));
		break;
	default:
		break;
	}

	emit startpreview();

	itemshareData.drawLock.lockForWrite();
	itemshareData.itemdrawList.clear();
	itemshareData.drawLock.unlock();

	uistart	=	::GetTickCount();
	unsigned __int64 ui64Index	=	0;
	while(!ui64Index && ::GetTickCount() < uistart + _Firstframe_Timeout){
		::Sleep(10);
		ui64Index	=	GetHisRawFrameIndex();
	}

	//20141104
	if(!ui64Index){	stopPreview();	return HisCCMError_NoFrame;	}
	return 0;
}

int itemprocess::Jig_Change2Capture()
{
	wchar_t Jig_strIniPath[MAX_PATH]		=	L".\\RolongoJigboard.ini";
	int iPrevieMode	=	::GetPrivateProfileIntW(L"BASIC", L"preview_mode", 0, Jig_strIniPath);
	int iCaptureMode	=	::GetPrivateProfileIntW(L"BASIC", L"capture_mode", 0, Jig_strIniPath);

	int iPreviewWidth	=	::GetPrivateProfileIntW(L"PREVIEW MODE", L"preview_width", 0, Jig_strIniPath);
	int iPreviewHeight	=	::GetPrivateProfileIntW(L"PREVIEW MODE", L"preview_height", 0, Jig_strIniPath);
	int iCaptureWidth	=	::GetPrivateProfileIntW(L"CAPTURE MODE", L"image_width", 0, Jig_strIniPath);
	int iCaptureHeight	=	::GetPrivateProfileIntW(L"CAPTURE MODE", L"image_height", 0, Jig_strIniPath);

	threadshareData.flaglock.lockForWrite();
	threadshareData.uiWidth			=	itemshareData.previewParameter->iWidth	=	iCaptureWidth;
	threadshareData.uiHeight			=	itemshareData.previewParameter->iHeight	=	iCaptureHeight;
	threadshareData.flaglock.unlock();

	::WritePrivateProfileStringW(L"BASIC", L"preview_enable", L"0", Jig_strIniPath);
	::WritePrivateProfileStringW(L"BASIC", L"capture_enable", L"0", Jig_strIniPath);

	::WritePrivateProfileStringW(L"BASIC", L"preview_mode", L"0", Jig_strIniPath);
	::WritePrivateProfileStringW(L"BASIC", L"capture_mode", L"1", Jig_strIniPath);

	unsigned int uiLoop	=	100;
	while(uiLoop){
		--uiLoop;
		unsigned int uiStatus	=	::GetPrivateProfileIntW(L"BASIC", L"capture_enable", 0, Jig_strIniPath);
		if(uiStatus)	break;
		::Sleep(100);
	}

	return (uiLoop)?(0):(HisFX3Error_Timeout);
}

int itemprocess::Jig_Change2Preview()
{
	wchar_t Jig_strIniPath[MAX_PATH]		=	L".\\RolongoJigboard.ini";
	int iPrevieMode	=	::GetPrivateProfileIntW(L"BASIC", L"preview_mode", 0, Jig_strIniPath);
	int iCaptureMode	=	::GetPrivateProfileIntW(L"BASIC", L"capture_mode", 0, Jig_strIniPath);
	if(iPrevieMode == 1) return 0;

	int iPreviewWidth	=	::GetPrivateProfileIntW(L"PREVIEW MODE", L"preview_width", 0, Jig_strIniPath);
	int iPreviewHeight	=	::GetPrivateProfileIntW(L"PREVIEW MODE", L"preview_height", 0, Jig_strIniPath);
	int iCaptureWidth	=	::GetPrivateProfileIntW(L"CAPTURE MODE", L"image_width", 0, Jig_strIniPath);
	int iCaptureHeight	=	::GetPrivateProfileIntW(L"CAPTURE MODE", L"image_height", 0, Jig_strIniPath);

	threadshareData.flaglock.lockForWrite();
	threadshareData.uiWidth			=	itemshareData.previewParameter->iWidth	=	iPreviewWidth;
	threadshareData.uiHeight			=	itemshareData.previewParameter->iHeight	=	iPreviewHeight;
	threadshareData.flaglock.unlock();

	::WritePrivateProfileStringW(L"BASIC", L"preview_enable", L"0", Jig_strIniPath);
	::WritePrivateProfileStringW(L"BASIC", L"capture_enable", L"0", Jig_strIniPath);

	::WritePrivateProfileStringW(L"BASIC", L"capture_mode", L"0", Jig_strIniPath);
	::WritePrivateProfileStringW(L"BASIC", L"preview_mode", L"1", Jig_strIniPath);

	unsigned int uiLoop	=	100;
	while(uiLoop){
		--uiLoop;
		unsigned int uiStatus	=	::GetPrivateProfileIntW(L"BASIC", L"preview_enable", 0, Jig_strIniPath);
		if(uiStatus)	break;
		::Sleep(100);
	}

	return (uiLoop)?(0):(HisFX3Error_Timeout);
}

int itemprocess::Jig_afBurn()
{
	emit information(QTextCodec::codecForName( "GBK")->toUnicode("近焦马达烧录位置：") % QString::number(iNearPeakMotorDec));
	emit information(QTextCodec::codecForName( "GBK")->toUnicode("远焦马达烧录位置：") % QString::number(iFarPeakMotorDec));
	if(iNearPeakMotorDec == 0x00FFFFFF || iFarPeakMotorDec == 0x00FFFFFF)	return HisFX3Error_Parameter;
	int Jig_result	=	jigboard_AFBurn_Write_Rule1(iNearPeakMotorDec, iFarPeakMotorDec, &classPlatform);

	stLogItem.itemtype	=	classLog->getmaxtypeindex(_HISLOG_CLASSIFY_AFBURN);
	stLogItem.itemkey	=	"AF_BURN_Result";
	stLogItem.itemvalue=	(Jig_result)?("NG"):("OK");
	classLog->push_back(stLogItem);

	++(stLogItem.itemtype);
	stLogItem.itemkey	=	"AF_BURN_Near_Motor";
	stLogItem.itemvalue=	iNearPeakMotorDec;
	classLog->push_back(stLogItem);

	++(stLogItem.itemtype);
	stLogItem.itemkey	=	"AF_BURN_Infinite_Motor";
	stLogItem.itemvalue=	iFarPeakMotorDec;
	classLog->push_back(stLogItem);

	return Jig_result;
}

int itemprocess::Jig_afBurnCheck(unsigned char ucType) //0:near 1:middle 2:infinite
{
	if(ucType != 0 && ucType != 2) return HisFX3Error_Parameter;

	wchar_t Jig_strIniPath[MAX_PATH]		=	L".\\RolongoJigboard.ini";
	wchar_t jig_strAppName[32];
	if(ucType == 1) swprintf(jig_strAppName, L"AF MIDDLE");
	else if(ucType == 2) swprintf(jig_strAppName, L"AF FAR");
	else swprintf(jig_strAppName, L"AF NEAR");
	int jig_DecDiff			=	::GetPrivateProfileIntW(jig_strAppName, L"af_dec_check_diff", 5, Jig_strIniPath);
	bool jig_bRefoucs	=	!!::GetPrivateProfileIntW(jig_strAppName, L"refoucscheck", 5, Jig_strIniPath);
	int jig_DecMin			=	::GetPrivateProfileIntW(jig_strAppName, L"af_dec_min", 5, Jig_strIniPath);
	int jig_DecMax			=	::GetPrivateProfileIntW(jig_strAppName, L"af_dec_max", 5, Jig_strIniPath);
	int jig_NearPos=0x00FFFFFF, jig_FarPos	=	0x00FFFFFF;
	int jig_result	=	jigboard_AFBurn_Read_Rule1(jig_NearPos, jig_FarPos, &classPlatform);
	if(jig_result)	return jig_result;
	jig_bRefoucs = false;

	QString strTitle;
	int Jig_iMotorPeak;
	if(ucType == 2){
		strTitle	=	"Infinite";
		Jig_iMotorPeak	=	jig_FarPos;
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("远焦马达烧录值：") % QString::number(Jig_iMotorPeak));
	}
	else{
		strTitle	=	"Near";
		Jig_iMotorPeak	=	jig_NearPos;
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("近焦马达烧录值：") % QString::number(Jig_iMotorPeak));
	}

	int jig_ReCheckPos	=	0x00FFFFFF;
	int jig_DecRealD;
	if(jig_bRefoucs){	
		jig_result	=	 jigboard_GetAFFoucsPos(jig_ReCheckPos, ucType, &classPlatform);
		if(jig_result)	return jig_result;
		if(ucType == 2)
			emit information(QTextCodec::codecForName( "GBK")->toUnicode("远焦再次对焦马达值：") % QString::number(jig_ReCheckPos));
		else
			emit information(QTextCodec::codecForName( "GBK")->toUnicode("近焦再次对焦马达值：") % QString::number(jig_ReCheckPos));
		jig_DecRealD	=	abs(Jig_iMotorPeak - jig_ReCheckPos);
		jig_result	=	(jig_DecRealD > jig_DecDiff)?(HisCCMError_Result):(0);
	}
	else{
		jig_result	=	(Jig_iMotorPeak > jig_DecMax || Jig_iMotorPeak < jig_DecMin)?(HisCCMError_Result):(0);
	}

	if(ucType == 2){
		TOtpSetting stOtpSetting = {0};
		if (classPlatform.Jig_ReadSetting(classPlatform.Jig_m_uPhoneIndex, &stOtpSetting) != TOtpResult::Success){
			return HisFX3Error_CameraON;
		}

		UINT backuAfMode	=	stOtpSetting.uAfMode;
		stOtpSetting.uAfMode	=	1;
		stOtpSetting.uAfPosition	=	jig_FarPos;

		if (classPlatform.Jig_WriteSetting(classPlatform.Jig_m_uPhoneIndex, &stOtpSetting) != TOtpResult::Success){
			return HisFX3Error_CameraON;
		}

		emit information(QTextCodec::codecForName( "GBK")->toUnicode("马达运动到：") % QString::number(jig_FarPos));

		::Sleep(500);
		if (classPlatform.Jig_StartLsc(classPlatform.Jig_m_uPhoneIndex) != TOtpResult::Success){
			return HisFX3Error_CameraON;
		}
		::Sleep(500);
		if (classPlatform.Jig_StartAwb(classPlatform.Jig_m_uPhoneIndex) != TOtpResult::Success){
			return HisFX3Error_CameraON;
		}
		::Sleep(500);
	}

	stLogItem.itemtype	=	classLog->getmaxtypeindex(_HISLOG_CLASSIFY_AFBURNCHECK);
	stLogItem.itemkey	=	strTitle % "_BURNCheck_Result";
	stLogItem.itemvalue=	(!jig_result)?("OK"):("NG");
	classLog->push_back(stLogItem);

	++(stLogItem.itemtype);
	stLogItem.itemkey	=	"AF_BURN_" % strTitle % "_Motor";
	stLogItem.itemvalue=	Jig_iMotorPeak;
	classLog->push_back(stLogItem);

	if(jig_bRefoucs){
		++(stLogItem.itemtype);
		stLogItem.itemkey	=	"AF_ReFoucs_" % strTitle % "_Motor";
		stLogItem.itemvalue=	jig_ReCheckPos;
		classLog->push_back(stLogItem);
		++(stLogItem.itemtype);
		stLogItem.itemkey	=	"AF_ReFoucs_" % strTitle % "_Motor_D";
		stLogItem.itemvalue=	jig_DecRealD;
		classLog->push_back(stLogItem);
	}

	return jig_result;
}
#endif

#ifdef USE_EQUIPMENT_GB_AFBURN
int itemprocess::movetopos(unsigned char uctype, unsigned int uiIO, unsigned int uiOut)
{

#define _AFCBURN_NEAR_IO_DELAY				1000
#define _AFCBURN_MIDDLE_IO_DELAY			1000
#define _AFCBURN_LENS_IO_DELAY				800
#define _AFCBURN_BLACK_IO_DELAY			500
#define _AFCBURN_WHITE_IO_DELAY			500

	//1: 15cm 2:middle 3:50cm 4:whitepanel 5:blackfield
	unsigned int iStatus;
	if(uctype == 1){ //near
		classMotion.IOReadOutBit(0, 0, 4, &iStatus); 
		if(iStatus != 1){
			classMotion.IOWriteOutBit(0, 0, 4, 1);
			::Sleep(_AFCBURN_LENS_IO_DELAY);
		}
		classMotion.IOReadOutBit(0, 0, 7, &iStatus); 
		if(iStatus != 1){
			classMotion.IOWriteOutBit(0, 0, 7, 1);
			::Sleep(_AFCBURN_WHITE_IO_DELAY);
		}
		classMotion.IOReadOutBit(0, 0, 8, &iStatus); 
		if(iStatus != 1){
			classMotion.IOWriteOutBit(0, 0, 8, 1);
			::Sleep(_AFCBURN_BLACK_IO_DELAY);
		}
		classMotion.IOReadOutBit(0, 0, 5, &iStatus); 
		if(iStatus != 0){
			classMotion.IOWriteOutBit(0, 0, 5, 0);
			::Sleep(_AFCBURN_NEAR_IO_DELAY);
		}
	}
	else if(uctype ==3){ //50cm
		classMotion.IOReadOutBit(0, 0, 4, &iStatus); 
		if(iStatus != 0){
			classMotion.IOWriteOutBit(0, 0, 4, 0);
			::Sleep(_AFCBURN_LENS_IO_DELAY);
		}
		classMotion.IOReadOutBit(0, 0, 7, &iStatus); 
		if(iStatus != 1){
			classMotion.IOWriteOutBit(0, 0, 7, 1);
			::Sleep(_AFCBURN_WHITE_IO_DELAY);
		}
		classMotion.IOReadOutBit(0, 0, 8, &iStatus); 
		if(iStatus != 1){
			classMotion.IOWriteOutBit(0, 0, 8, 1);
			::Sleep(_AFCBURN_BLACK_IO_DELAY);
		}
		classMotion.IOReadOutBit(0, 0, 5, &iStatus); 
		if(iStatus != 1){
			classMotion.IOWriteOutBit(0, 0, 5, 1);
			::Sleep(_AFCBURN_NEAR_IO_DELAY);
		}
		classMotion.IOReadOutBit(0, 0, 6, &iStatus); 
		if(iStatus != 1){
			classMotion.IOWriteOutBit(0, 0, 6, 1);
			::Sleep(_AFCBURN_MIDDLE_IO_DELAY);
		}
	}
	else if(uctype == 2){ //middle
		classMotion.IOReadOutBit(0, 0, 4, &iStatus);  
		if(iStatus != 0){
			classMotion.IOWriteOutBit(0, 0, 4, 0);
			::Sleep(_AFCBURN_LENS_IO_DELAY);
		}
		classMotion.IOReadOutBit(0, 0, 7, &iStatus); 
		if(iStatus != 1){
			classMotion.IOWriteOutBit(0, 0, 7, 1);
			::Sleep(_AFCBURN_WHITE_IO_DELAY);
		}
		classMotion.IOReadOutBit(0, 0, 8, &iStatus); 
		if(iStatus != 1){
			classMotion.IOWriteOutBit(0, 0, 8, 1);
			::Sleep(_AFCBURN_BLACK_IO_DELAY);
		}
		classMotion.IOReadOutBit(0, 0, 5, &iStatus); 
		if(iStatus != 1){
			classMotion.IOWriteOutBit(0, 0, 5, 1);
			::Sleep(_AFCBURN_NEAR_IO_DELAY);
		}
		classMotion.IOReadOutBit(0, 0, 6, &iStatus); 
		if(iStatus != 0){
			classMotion.IOWriteOutBit(0, 0, 6, 0);
			::Sleep(_AFCBURN_MIDDLE_IO_DELAY);
		}
	}
	else if(uctype == 5){ //backfield-add 5-other  4-JSL
		classMotion.IOReadOutBit(0, 0, 7, &iStatus); 
		if(iStatus != 1){
			classMotion.IOWriteOutBit(0, 0, 7, 1);
			::Sleep(_AFCBURN_WHITE_IO_DELAY);
		}
		classMotion.IOReadOutBit(0, 0, 4, &iStatus); 
		if(iStatus != 1){
			classMotion.IOWriteOutBit(0, 0, 4, 1);
			::Sleep(_AFCBURN_LENS_IO_DELAY);
		}
		classMotion.IOReadOutBit(0, 0, 8, &iStatus); 
		if(iStatus != 0){
			classMotion.IOWriteOutBit(0, 0, 8, 0);
			::Sleep(_AFCBURN_BLACK_IO_DELAY);
		}
	}
	else if(uctype == 0xFF){
		classMotion.IOWriteOutBit(0, 0, uiIO, uiOut);
	}
	else{ //white
		classMotion.IOReadOutBit(0, 0, 8, &iStatus); 
		if(iStatus != 1){
			classMotion.IOWriteOutBit(0, 0, 8, 1);
			::Sleep(_AFCBURN_BLACK_IO_DELAY);
		}
		classMotion.IOReadOutBit(0, 0, 4, &iStatus); 
		if(iStatus != 1){
			classMotion.IOWriteOutBit(0, 0, 4, 1);
			::Sleep(_AFCBURN_LENS_IO_DELAY);
		}
		classMotion.IOReadOutBit(0, 0, 7, &iStatus); 
		if(iStatus != 0){
			classMotion.IOWriteOutBit(0, 0, 7, 0);
			::Sleep(_AFCBURN_WHITE_IO_DELAY);
		}
	}
	return 0;
}
#endif

#ifdef USE_EQUIPMENT_GB_PDAF
int itemprocess::movetopos(unsigned char uctype)
{
	//1: 6cm   2: 15cm   3: 50cm   5:near   6: far 7: whitefield   8:blackfield
	int iresult	=	getpdafParameter(false);
	if(iresult)
		return iresult;

	itemshareData.itemparameterLock.lockForRead();

	unsigned int iStatus;
	if(uctype == 5){ //near
		int irel = classMotion.IOReadOutBit(0, 0, 4, &iStatus); 
		if(irel)
		{
			emit information("IOReadOutBit: " % QString::number(irel, 16));
			emit information(classMotion.GetLastError());
		}
		if(iStatus != 1){
			classMotion.IOWriteOutBit(0, 0, 4, 1);
			::Sleep(itemshareData.pdafParameter->uiIO4Sleep);
		}
		classMotion.IOReadOutBit(0, 0, 3, &iStatus);  
		if(iStatus != 1){
			classMotion.IOWriteOutBit(0, 0, 3, 1);
			::Sleep(itemshareData.pdafParameter->uiIO3Sleep);
		}
		classMotion.IOWriteOutBit(0, 0, 5, 0);
		::Sleep(itemshareData.pdafParameter->uiIO5Sleep);
	}
	else if(uctype == 6){ //far
		classMotion.IOReadOutBit(0, 0, 4, &iStatus);  
		if(iStatus != 1){
			classMotion.IOWriteOutBit(0, 0, 4, 1);
			::Sleep(itemshareData.pdafParameter->uiIO4Sleep);
		}
		classMotion.IOReadOutBit(0, 0, 3, &iStatus); 
		if(iStatus != 0){
			classMotion.IOWriteOutBit(0, 0, 3, 0);
			::Sleep(itemshareData.pdafParameter->uiIO3Sleep);
		}
		classMotion.IOReadOutBit(0, 0, 5, &iStatus); 
		if(iStatus != 1){
			classMotion.IOWriteOutBit(0, 0, 5, 1);
			::Sleep(itemshareData.pdafParameter->uiIO5Sleep);
		}
		classMotion.IOReadOutBit(0, 0, 6, &iStatus); 
		if(iStatus != 1){
			classMotion.IOWriteOutBit(0, 0, 6, 1);
			::Sleep(itemshareData.pdafParameter->uiIO6Sleep);
		}
		classMotion.IOWriteOutBit(0, 0, 9, 0);
		::Sleep(itemshareData.pdafParameter->uiIO9Sleep);
	}
	else if(uctype == 1){ //6cm
		classMotion.IOReadOutBit(0, 0, 3, &iStatus);  
		if(iStatus != 1){
			classMotion.IOWriteOutBit(0, 0, 3, 1);
			::Sleep(itemshareData.pdafParameter->uiIO3Sleep);
		}
		classMotion.IOReadOutBit(0, 0, 4, &iStatus);  
		if(iStatus != 0){
			classMotion.IOWriteOutBit(0, 0, 4, 0);
			::Sleep(itemshareData.pdafParameter->uiIO4Sleep);
		}
		classMotion.IOReadOutBit(0, 0, 7, &iStatus); 
		if(iStatus != 1){
			classMotion.IOWriteOutBit(0, 0, 7, 1);
			::Sleep(itemshareData.pdafParameter->uiIO7Sleep);
		}
		classMotion.IOReadOutBit(0, 0, 8, &iStatus); 
		if(iStatus != 1){
			classMotion.IOWriteOutBit(0, 0, 8, 1);
			::Sleep(itemshareData.pdafParameter->uiIO8Sleep);
		}
		classMotion.IOReadOutBit(0, 0, 5, &iStatus); 
		if(iStatus != 0){
			classMotion.IOWriteOutBit(0, 0, 5, 0);
			::Sleep(itemshareData.pdafParameter->uiIO5Sleep);
		}
	}
	else if(uctype ==3){ //50cm
		classMotion.IOReadOutBit(0, 0, 4, &iStatus);  
		if(iStatus != 1){
			classMotion.IOWriteOutBit(0, 0, 4, 1);
			::Sleep(itemshareData.pdafParameter->uiIO4Sleep);
		}
		classMotion.IOReadOutBit(0, 0, 3, &iStatus); 
		if(iStatus != 1){
			classMotion.IOWriteOutBit(0, 0, 3, 1);
			::Sleep(itemshareData.pdafParameter->uiIO3Sleep);
		}
		classMotion.IOReadOutBit(0, 0, 5, &iStatus); 
		if(iStatus != 1){
			classMotion.IOWriteOutBit(0, 0, 5, 1);
			::Sleep(itemshareData.pdafParameter->uiIO5Sleep);
		}
		classMotion.IOReadOutBit(0, 0, 6, &iStatus); 
		if(iStatus != 1){
			classMotion.IOWriteOutBit(0, 0, 6, 1);
			::Sleep(itemshareData.pdafParameter->uiIO6Sleep);
		}
		classMotion.IOReadOutBit(0, 0, 9, &iStatus); 
		if(iStatus != 1){
			classMotion.IOWriteOutBit(0, 0, 9, 1);
			::Sleep(itemshareData.pdafParameter->uiIO9Sleep);
		}
	}
	else if(uctype == 2){ //15cm
		classMotion.IOReadOutBit(0, 0, 4, &iStatus); 
		if(iStatus != 1){
			classMotion.IOWriteOutBit(0, 0, 4, 1);
			::Sleep(itemshareData.pdafParameter->uiIO4Sleep);
		}
		classMotion.IOReadOutBit(0, 0, 3, &iStatus); 
		if(iStatus != 1){
			classMotion.IOWriteOutBit(0, 0, 3, 1);
			::Sleep(itemshareData.pdafParameter->uiIO3Sleep);
		}
		classMotion.IOReadOutBit(0, 0, 5, &iStatus); 
		if(iStatus != 1){
			classMotion.IOWriteOutBit(0, 0, 5, 1);
			::Sleep(itemshareData.pdafParameter->uiIO5Sleep);
		}
		classMotion.IOReadOutBit(0, 0, 6, &iStatus); 
		if(iStatus != 0){
			classMotion.IOWriteOutBit(0, 0, 6, 0);
			::Sleep(itemshareData.pdafParameter->uiIO6Sleep);
		}
	}
	else if(uctype == 8){ //backfield
		classMotion.IOReadOutBit(0, 0, 3, &iStatus); 
		if(iStatus != 1){
			classMotion.IOWriteOutBit(0, 0, 3, 1);
			::Sleep(itemshareData.pdafParameter->uiIO3Sleep);
		}
		classMotion.IOReadOutBit(0, 0, 4, &iStatus); 
		if(iStatus != 0){
			classMotion.IOWriteOutBit(0, 0, 4, 0);
			::Sleep(itemshareData.pdafParameter->uiIO4Sleep);
		}
		classMotion.IOReadOutBit(0, 0, 8, &iStatus); 
		if(iStatus != 1){
			classMotion.IOWriteOutBit(0, 0, 8, 1);
			::Sleep(itemshareData.pdafParameter->uiIO8Sleep);
		}
		classMotion.IOReadOutBit(0, 0, 7, &iStatus); 
		if(iStatus != 0){
			classMotion.IOWriteOutBit(0, 0, 7, 0);
			::Sleep(itemshareData.pdafParameter->uiIO7Sleep);
		}
	}
	else{ //white-7
		classMotion.IOReadOutBit(0, 0, 3, &iStatus); 
		if(iStatus != 1){
			classMotion.IOWriteOutBit(0, 0, 3, 1);
			::Sleep(itemshareData.pdafParameter->uiIO3Sleep);
		}
		classMotion.IOReadOutBit(0, 0, 4, &iStatus); 
		if(iStatus != 0){
			classMotion.IOWriteOutBit(0, 0, 4, 0);
			::Sleep(itemshareData.pdafParameter->uiIO4Sleep);
		}
		classMotion.IOReadOutBit(0, 0, 7, &iStatus); 
		if(iStatus != 1){
			classMotion.IOWriteOutBit(0, 0, 7, 1);
			::Sleep(itemshareData.pdafParameter->uiIO7Sleep);
		}
		classMotion.IOReadOutBit(0, 0, 8, &iStatus); 
		if(iStatus != 0){
			classMotion.IOWriteOutBit(0, 0, 8, 0);
			::Sleep(itemshareData.pdafParameter->uiIO8Sleep);
		}
	}

	itemshareData.itemparameterLock.unlock();
	return 0;
}

#endif

typedef struct sDataArrary{
	int index;
	float data;
}DataArrary;

int itemprocess::MTkErrorcodeConvert(int errorcode)
{
	int iresult	=	0;
	switch (errorcode){
	case PD_ERR_OK:
		iresult	=	0;
		break;
	case PD_ERR_INVALID_PARAM:
		iresult	=	HisCCMError_OtpFucExec;
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("MTK DLL: 参数错误"));
		break;
	case PD_ERR_FILE_NOT_FOUND:
		iresult	=	HisCCMError_OtpFucExec;
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("MTK DLL: 指定文件不存在"));
		break;
	case PD_ERR_INIT_FAIL:
		iresult	=	HisCCMError_OtpFucExec;
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("MTK DLL: INI格式错误"));
		break;
	case PD_ERR_OUTPUT_MEM_NOT_SUFFICIENT:
		iresult	=	HisCCMError_OtpFucExec;
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("MTK DLL: 没有分配足够的内存空间"));
		break;
	case PD_ERR_NOT_INITIALIZED:
		iresult	=	HisCCMError_OtpFucExec;
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("MTK DLL: 没有初始化"));
		break;
	case PD_ERR_INPUT_DATA_VERIFIED_FAIL:
		iresult	=	HisCCMError_OtpFucExec;
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("MTK DLL: 输入图像不能满足要求"));
		break;
	case PD_ERR_OUTPUT_DATA_VERIFIED_FAIL:
		iresult	=	HisCCMError_OtpFucExec;
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("MTK DLL: 输出数据异常"));
		break;
	case PD_ERR_QUALITY_VERIFIED_FAIL:
		iresult	=	HisCCMError_OtpFucExec;
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("MTK DLL: 画质不符合要求"));
		break;
	case PD_ERR_GENERAL_ERROR:
		iresult	=	HisCCMError_OtpFucExec;
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("MTK DLL: 验证失败"));
		break;
	default:
		iresult	=	HisFX3Error_Other;
		break;
	}

	return iresult;
}

int itemprocess::getpdafParameter(bool bupdate, bool bcheck )
{
	itemshareData.itemparameterLock.lockForRead();
	if(!bupdate && itemshareData.pdafParameter){
		itemshareData.itemparameterLock.unlock();
		return 0;
	}

	QMutexLocker locker(&hisglobalparameter.mutexDatabase);

	itemshareData.itemparameterLock.unlock();
	itemshareData.itemparameterLock.lockForWrite();
	if(!itemshareData.pdafParameter)
		itemshareData.pdafParameter		=	new _pdafParameter;
	if(!itemshareData.pdafParameter){
		itemshareData.itemparameterLock.unlock();
		return HisFX3Error_MallocBuffer;
	}

	bool bparsesuccess	=	true, bItemExist = false;

	//读取，解析config
	for(int  w=0;	w<1;	++w){ //此处是有意义的,不要删除
		QSqlDatabase customdb = QSqlDatabase::addDatabase("QSQLITE", "querycustom");
		customdb.setDatabaseName(QDir::currentPath() % "/HisFX3Custom");
		if (!customdb.open()){
			bparsesuccess	=	false;
			break;
		}

		QString strData, strdata2;
		QStringList strname, strvalue;
		QSqlQuery query(customdb);
		query.prepare("SELECT itemsuffix2,key,value,reserve FROM " % itemshareData.currentTableName % \
			" WHERE classfy='algorithm' AND item='mtkpdaf' ORDER BY id ASC" );
		query.exec();

		//(qualcommchoose:3m2)(afchoose:3m2)(pdafchoose:3m2)(version3:2)(version2:0)(version1:0)(version0:299)
		//(blacksleep:1000)(whitesleep:1000)(6cmsleep:1000)(relaysleep:1000)(nearsleep:1000)(infinitesleep:1000)(15cmsleep:1000)
		//(motorsleep:1000(white2near:true)(platform:MTK)(qualcommversion:J)(coefkdiff:20)

		while (query.next()){
			bItemExist = true;
			for(int y=0;	y<4;	++y){
				strData	=	query.value(y).toString();
				ROPLOW::patchconfigstring(strData, strname, strvalue);
				for(int x=0;	x<strname.size();	++x){
					if(strname.at(x) == "qualcommchoose")	itemshareData.pdafParameter->strQualcommChoose		=	strvalue.at(x).toUpper();
					else if(strname.at(x) == "afchoose")	itemshareData.pdafParameter->strAFChoose			=	strvalue.at(x).toUpper();
					else if(strname.at(x) == "pdafchoose")	itemshareData.pdafParameter->strPDAFChoose		=	strvalue.at(x).toUpper();
					else if(strname.at(x) == "relaysleep")	itemshareData.pdafParameter->uiIO3Sleep	=	strvalue.at(x).toUShort();
					else if(strname.at(x) == "6cmsleep")	itemshareData.pdafParameter->uiIO4Sleep	=	strvalue.at(x).toUShort();
					else if(strname.at(x) == "nearsleep")	itemshareData.pdafParameter->uiIO5Sleep	=	strvalue.at(x).toUShort();
					else if(strname.at(x) == "15cmsleep")	itemshareData.pdafParameter->uiIO6Sleep	=	strvalue.at(x).toUShort();
					else if(strname.at(x) == "blacksleep")	itemshareData.pdafParameter->uiIO7Sleep	=	strvalue.at(x).toUShort();
					else if(strname.at(x) == "whitesleep")	itemshareData.pdafParameter->uiIO8Sleep	=	strvalue.at(x).toUShort();
					else if(strname.at(x) == "infinitesleep")	itemshareData.pdafParameter->uiIO9Sleep	=	strvalue.at(x).toUShort();
					else if(strname.at(x) == "motorsleep")	itemshareData.pdafParameter->uiMotorSleep	=	strvalue.at(x).toUShort();
					else if(strname.at(x) == "version3")	itemshareData.pdafParameter->usVersion[3]	=	strvalue.at(x).toUShort();
					else if(strname.at(x) == "version2")	itemshareData.pdafParameter->usVersion[2]	=	strvalue.at(x).toUShort();
					else if(strname.at(x) == "version1")	itemshareData.pdafParameter->usVersion[1]	=	strvalue.at(x).toUShort();
					else if(strname.at(x) == "version0")	itemshareData.pdafParameter->usVersion[0]	=	strvalue.at(x).toUShort();
					else if(strname.at(x) == "white2near") itemshareData.pdafParameter->bWhiteMove2NearFocus = (strvalue.at(x) == "true");
					else if(strname.at(x)== "pdafverify")   itemshareData.pdafParameter->bQualcommpdafverify =(strvalue.at(x)=="true");
					else if(strname.at(x)== "pdafverifyoffest") itemshareData.pdafParameter->usQualcommkverifyoffest=strvalue.at(x).toUShort();
					else if(strname.at(x)== "pdafstep2_50cmatuoexposure")   itemshareData.pdafParameter->bQualcomm50CMexp =(strvalue.at(x)=="true");
					else if(strname.at(x)== "KVerify_DACShiftSTEP") itemshareData.pdafParameter->usVerifyDACShiftCount=strvalue.at(x).toUShort();
					else if(strname.at(x)== "KVerify_VCMSTEP") itemshareData.pdafParameter->usDACMoveStep=strvalue.at(x).toUShort();
					else if(strname.at(x) == "pdafverifyMTFdropstop") itemshareData.pdafParameter->bPDAFVerifyMTFDropStop = (strvalue.at(x) == "true");
					else if(strname.at(x) == "platform"){
						if(strvalue.at(x) == "Qualcomm")	itemshareData.pdafParameter->ucPlatform	=	1;
						else if(strvalue.at(x) == "SONY")	itemshareData.pdafParameter->ucPlatform	=	2;
						else if(strvalue.at(x)=="His") itemshareData.pdafParameter->ucPlatform	=	3;
						else itemshareData.pdafParameter->ucPlatform	=	0;
					}
					else if(strname.at(x) == "qualcommversion" && strvalue.at(x).size() > 0)  itemshareData.pdafParameter->cVersion = strvalue[x][0];
					else if(strname.at(x)== "pdafstep2_50cmAEROIW") itemshareData.pdafParameter->usAutoExpsoureROIW=strvalue.at(x).toUShort();
					else if(strname.at(x)== "pdafstep2_50cmAEROIH") itemshareData.pdafParameter->usAutoExposureROIH=strvalue.at(x).toUShort();
					else if(strname.at(x)== "CDAFmtfsearchROIW") itemshareData.pdafParameter->usCDAFmtfROIW=strvalue.at(x).toUShort();
					else if(strname.at(x)== "CDAFmtfsearchROIH") itemshareData.pdafParameter->usCDAFmtfROIH=strvalue.at(x).toUShort();
					else if(strname.at(x)== "pdafstep2_50cmEVdelaytime") itemshareData.pdafParameter->us50CMEVDelayTime=strvalue.at(x).toUShort();
					else if(strname.at(x)=="sony258_pdafspccal")   itemshareData.pdafParameter->bSONY258MTKCal =(strvalue.at(x)=="true");
					else if(strname.at(x) == "sonypdafchoose")	itemshareData.pdafParameter->strSONYPDAFChoose		=	strvalue.at(x).toUpper();
					else if(strname.at(x) == "qualcommgainmapformat" && strvalue.at(x).size() > 0)  itemshareData.pdafParameter->strQualcommGainMapStruct = strvalue.at(x).toStdString();
					else if(strname.at(x)== "qualcommgainmapsize") itemshareData.pdafParameter->usQualcommGainMapSize=strvalue.at(x).toUShort();
					else if(strname.at(x)== "sonyspctablesize") itemshareData.pdafParameter->usSonySPCTableSize=strvalue.at(x).toUShort();
					else if(strname.at(x)== "qualcommpdsensortype") itemshareData.pdafParameter->ucpdafsensortype=strvalue.at(x).toInt();
					else if(strname.at(x)== "qualcommpdsensorblacklevel") itemshareData.pdafParameter->usSensorBlackLevel=strvalue.at(x).toUShort();
					else if(strname.at(x) == "sonydccwindow"){
						if(strvalue.at(x) == "Fixed_8*6") {	itemshareData.pdafParameter->ucSonyDCCWindow	=	0;}
						else if(strvalue.at(x) == "Fixed_16*12") {itemshareData.pdafParameter->ucSonyDCCWindow	=	1;}
						else if(strvalue.at(x) == "Flexible ") {itemshareData.pdafParameter->ucSonyDCCWindow	=	2;}
					}
					else if(strname.at(x) == "sonysensormode"){
						if(strvalue.at(x) == "IMX230") {	itemshareData.pdafParameter->ucSonySensorMode	=	0;}
						else if(strvalue.at(x) == "IMX298") {itemshareData.pdafParameter->ucSonySensorMode	=	1;}
						else if(strvalue.at(x) == "IMX258") {itemshareData.pdafParameter->ucSonySensorMode	=	2;}
						else if(strvalue.at(x) == "IMX386") {itemshareData.pdafParameter->ucSonySensorMode	=	3;}
						else if(strvalue.at(x) == "IMX378") {itemshareData.pdafParameter->ucSonySensorMode	=	4;}
					}
					else if(strname.at(x)== "dccverifyspec") itemshareData.pdafParameter->dDCCVerifySpec=strvalue.at(x).toDouble();
					else if(strname.at(x)== "mtkv2step1datasize") itemshareData.pdafParameter->usMTKV2Step1dataSize=strvalue.at(x).toUShort();
					else if(strname.at(x)== "mtkv2step2datasize") itemshareData.pdafParameter->usMTKV2Step2dataSize=strvalue.at(x).toUShort();
					else if(strname.at(x)=="mtkstep2verify")   itemshareData.pdafParameter->bEnableMTKStep2Verify=(strvalue.at(x)=="true");
					else if(strname.at(x)=="hisipdafchoose")   itemshareData.pdafParameter->strHISIPDAFChoose		=	strvalue.at(x).toUpper();
				}
			}
		}

		customdb.close();
	}

	QSqlDatabase::removeDatabase("querycustom");
	if(!bparsesuccess || !bItemExist)
	{
		emit information(tr("PDAF setting parameter is not configured ok "));
		HisReleaseNewO(itemshareData.pdafParameter);
		itemshareData.itemparameterLock.unlock();
		return HisFX3Error_Parameter;
	}

	if(!bcheck) {itemshareData.itemparameterLock.unlock(); return 0; }

	if(itemshareData.pdafParameter->strAFChoose.isEmpty()){
		emit information(tr("af burn rule is not select"));
		HisReleaseNewO(itemshareData.pdafParameter);
		itemshareData.itemparameterLock.unlock();
		return HisFX3Error_Parameter;
	}

	if( itemshareData.pdafParameter->ucPlatform==0) //MTK
	{
		if(itemshareData.pdafParameter->usVersion[3] == 0)
		{
			emit information(tr("Has Not Choose The MTK PDAF Lib Version"));
			HisReleaseNewO(itemshareData.pdafParameter);
			itemshareData.itemparameterLock.unlock();
			return HisFX3Error_Parameter;
		}
		if(itemshareData.pdafParameter->strPDAFChoose.isEmpty())
		{
			emit information(tr("mtk pdaf burn rule is not select"));
			HisReleaseNewO(itemshareData.pdafParameter);
			itemshareData.itemparameterLock.unlock();
			return HisFX3Error_Parameter;
		}
	}
	else if(itemshareData.pdafParameter->ucPlatform==1)
	{
		if(itemshareData.pdafParameter->strQualcommChoose.isEmpty())
		{
			emit information(tr("qualcom pdaf  burn rule is not select"));
			HisReleaseNewO(itemshareData.pdafParameter);
			itemshareData.itemparameterLock.unlock();
			return HisFX3Error_Parameter;
		}
	}
	else if(itemshareData.pdafParameter->ucPlatform==2)
	{
		if(itemshareData.pdafParameter->strSONYPDAFChoose.isEmpty())
		{
			emit information(tr("sony pdaf  burn rule is not select"));
			HisReleaseNewO(itemshareData.pdafParameter);
			itemshareData.itemparameterLock.unlock();
			return HisFX3Error_Parameter;
		}
	}else if(itemshareData.pdafParameter->ucPlatform==3)
	{
		if(itemshareData.pdafParameter->strHISIPDAFChoose.isEmpty())
		{
			emit information(tr("hisi pdaf  burn rule is not select"));
			HisReleaseNewO(itemshareData.pdafParameter);
			itemshareData.itemparameterLock.unlock();
			return HisFX3Error_Parameter;
		}

	}
	itemshareData.itemparameterLock.unlock();
	return 0;
}

float itemprocess::PDAFGetWhiteGAver(unsigned char* pucBarlor, _HisFX3_BaylorMode enDataFormat, RECT stroi, int iWidth, int iHeight)
{
	unsigned int uiPixelCount	=	(((stroi.right-stroi.left) *(stroi.bottom-stroi.top)) >>1);
	unsigned char* pucG	=	new unsigned char[uiPixelCount];
	unsigned char* pucLine1, *pucLine2, *pucData1, *pucData2;
	unsigned char* pucDes	=	pucG;
	unsigned int uiHistogram[256]	=	{0};
	switch (enDataFormat){
	case HisBaylor8_BGGR:
	case HisBaylor8_MONO:
		pucLine1	=	pucBarlor + (stroi.top *iWidth + stroi.left +1);
		pucLine2	=	pucBarlor + ((stroi.top+1) *iWidth + stroi.left);
		break;
	case HisBaylor8_RGGB:
		pucLine1	=	pucBarlor + (stroi.top *iWidth + stroi.left +1);
		pucLine2	=	pucBarlor + ((stroi.top+1) *iWidth + stroi.left);
		break;
	case HisBaylor8_GBRG:
		pucLine1	=	pucBarlor + (stroi.top *iWidth + stroi.left);
		pucLine2	=	pucBarlor + ((stroi.top+1) *iWidth + stroi.left +1);
		break;
	case HisBaylor8_GRBG:
		pucLine1	=	pucBarlor + (stroi.top *iWidth + stroi.left);
		pucLine2	=	pucBarlor + ((stroi.top+1) *iWidth + stroi.left + 1);
		break;
	default:
		break;
	}

	unsigned int uiLimit	=	static_cast<unsigned int>(static_cast<double>(uiPixelCount) *0.2);
	unsigned int uiCount, uiSum, uiLeft;
	float flValue	=	0.0f;

	switch (enDataFormat){
	case HisBaylor8_BGGR:
	case HisBaylor8_RGGB:
	case HisBaylor8_GBRG:
	case HisBaylor8_GRBG:
	case HisBaylor8_MONO:
		for(unsigned int y=stroi.top;	y<stroi.bottom;	y+=2){
			pucData1	=	pucLine1;
			pucData2	=	pucLine2;
			pucLine1	+=	(iWidth <<1);
			pucLine2	+=	(iWidth <<1);
			for(unsigned int x=stroi.left;		x<stroi.right;	x+=2){
				*pucDes	=	*pucData1;
				++(uiHistogram[*pucDes]);
				++pucDes;
				pucData1	+=	2;
				*pucDes	=	*pucData2;
				++(uiHistogram[*pucDes]);
				++pucDes;
				pucData2	+=	2;
			}
		}

		uiCount	=	uiSum	=	0;
		for(unsigned int x=0;	x<255;	++x){
			uiCount	=	uiCount + uiHistogram[x];
			uiSum		=	uiSum + x *uiHistogram[x];
			if(uiCount >= uiLimit)
				break;
		}
		uiLeft	=	uiSum /uiCount;

		uiCount	=	uiSum	=	0;
		for(int x=254;	x>=0;	--x){
			uiCount	=	uiCount + uiHistogram[x];
			uiSum		=	uiSum + x *uiHistogram[x];
			if(uiCount >= uiLimit)
				break;
		}
		uiSum	=	uiSum /uiCount;

		uiLimit		=	((uiLeft + uiSum) >>1);
		pucDes	=	pucG;
		uiSum	=	uiCount	=	0;
		for(unsigned int x=0;	x<uiPixelCount;	++x){
			if(static_cast<unsigned int>(*pucDes) > uiLimit){
				uiSum	=	uiSum + static_cast<unsigned int>(*pucDes);
				++uiCount;
			}
			++pucDes;
		}

		flValue	=	static_cast<float>(static_cast<double>(uiSum) /static_cast<double>(uiCount));
		break;
	default:
		break;
	}

	HisReleaseNewB(pucG);
	return flValue;
}

int itemprocess::PDAFautoExposure(RECT stroi,unsigned int uimin, unsigned int uimax, unsigned int uisleep, unsigned int uiindex)
{
	stroi.left		=	((stroi.left >>1) <<1);
	stroi.right		=	((stroi.right >>1) <<1);
	stroi.top		=	((stroi.top >>1) <<1);
	stroi.bottom	=	((stroi.bottom >>1) <<1);
	itemshareData.drawLock.lockForWrite();
	itemshareData.itemdrawList.clear();
	itemshareData.drawLock.unlock();

	if(!threadshareData.GetHisPreviewflag())
		return HisCCMError_NotPreivew;

	int iresult	=		getccmhardwareParameter(false);
	if(iresult)
		return iresult;

	itemshareData.itemparameterLock.lockForRead();
	unsigned int iwidth	=	itemshareData.previewParameter->iWidth;
	unsigned int iheight	=	itemshareData.previewParameter->iHeight;
	QString sensortype	=	itemshareData.ccmhardwareParameter->sensortype;
	QString tablename	=	itemshareData.currentTableName;
	_HisFX3_BaylorMode enDataFormat	=	 itemshareData.previewParameter->ucDataFormat;
	itemshareData.itemparameterLock.unlock();

	if(sensortype.size() < 1){
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("sensor类型设置不正确"));
		return HisFX3Error_Parameter;
	}
	if(uimin > uimax || uimax > 0xFF){
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("自动曝光目标区间设置不正确"));
		return HisFX3Error_Parameter;
	}
	if(stroi.left+20 >= stroi.right || stroi.top+20 >= stroi.bottom || stroi.left < 0 || \
		stroi.top < 0 || stroi.right > iwidth || stroi.bottom > iheight){
			emit information(QTextCodec::codecForName( "GBK")->toUnicode("自动曝光ROI设置不正确"));
			return HisFX3Error_Parameter;
	}
	if(!uisleep || uisleep > 5000){
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("自动曝光延迟时间设置不正确"));
		return HisFX3Error_Parameter;
	}
	if(uiindex == 0 || uiindex > 45){
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("自动曝光数据库设置不正确"));
		return HisFX3Error_Parameter;
	}

	bool bG	=	true;

	if(pstAeData[uiindex-1] != 0){
		if(pstAeData[uiindex-1]->uimin != uimin || pstAeData[uiindex-1]->uimax != uimax || \
			pstAeData[uiindex-1]->strTableName != tablename || pstAeData[uiindex-1]->stroi.left != stroi.left || \
			pstAeData[uiindex-1]->stroi.right != stroi.right || pstAeData[uiindex-1]->stroi.top != stroi.top || \
			pstAeData[uiindex-1]->stroi.bottom != stroi.bottom ||  pstAeData[uiindex-1]->bChannel_Gr != bG){
				pstAeData[uiindex-1]->strTableName=	tablename;
				pstAeData[uiindex-1]->stroi					=	stroi;
				pstAeData[uiindex-1]->uimin				=	uimin;
				pstAeData[uiindex-1]->uimax				=	uimax;
				pstAeData[uiindex-1]->unIndex			=	uiindex;
				pstAeData[uiindex-1]->usdatacount	=	0;
				pstAeData[uiindex-1]->bChannel_Gr	= bG;

				iresult	=	getautoexposuredata(pstAeData[uiindex-1]);
				if(iresult){
					HisReleaseNewO(pstAeData[uiindex-1]);
					return iresult;
				}
		}
	}
	else{
		pstAeData[uiindex-1]	=	new _autoExposreData;
		if(!pstAeData[uiindex-1]){
			return HisFX3Error_MallocBuffer;
		}

		pstAeData[uiindex-1]->strTableName		=	tablename;
		pstAeData[uiindex-1]->stroi							=	stroi;
		pstAeData[uiindex-1]->uimin						=	uimin;
		pstAeData[uiindex-1]->uimax						=	uimax;
		pstAeData[uiindex-1]->unIndex					=	uiindex;
		pstAeData[uiindex-1]->usdatacount			=	0;
		pstAeData[uiindex-1]->bChannel_Gr			= bG;

		iresult	=	getautoexposuredata(pstAeData[uiindex-1]);
		if(iresult){
			HisReleaseNewO(pstAeData[uiindex-1]);
			return iresult;
		}
	}

	_autoExposreData *pstTheData	=	pstAeData[uiindex-1];

	// 	emit information("data count:  " % QString::number(pstTheData->usdatacount));

	unsigned int uibuffersize	=	(bG)?(iwidth *iheight):(iwidth *iheight *3);
	unsigned char* pucrgb	=	(unsigned char*)_aligned_malloc(uibuffersize, _HisCacheLine_Aligned);
	if(!pucrgb)
		return HisFX3Error_MallocBuffer;

	iresult	=	HisFX3Error_Timeout;

	float flgrayValue;
	unsigned int uivalue, uimin_s, uimax_s, uispect;
	bool binitframe	=	true;
	_autoexposureItem stnewdata;
	stnewdata.uifirstet	=	0;

	std::vector<_itemDraw>::iterator theIterator;
	itemshareData.drawLock.lockForWrite();
	itemshareData.itemdrawList.resize(3);
	theIterator=itemshareData.itemdrawList.begin();

	theIterator->uctype				=	HisDrawType_Block;
	theIterator->strinfo.stblock	=	stroi;
	theIterator->stcolor				=	QColor::fromRgb(255, 0, 0);
	theIterator++;

	theIterator->uctype				=	0;
	theIterator->idata[0]				=	stroi.left;
	theIterator->idata[1]				=	stroi.top;
	theIterator->stcolor				=	QColor::fromRgb(255, 0, 0);
	theIterator++;

	theIterator->uctype				=	HisDrawType_Text;
	theIterator->stcolor				=	QColor::fromRgb(255, 255, 0);
	theIterator->idata[0]	=	stroi.left;
	theIterator->idata[1]	=	stroi.bottom;
	sprintf_s(theIterator->strinfo.strtext,	15, "spec:(%d,%d)", uimin, uimax);
	itemshareData.drawLock.unlock();

	for(int i=0;	i<_AE_MaxTimes && threadshareData.GetHisPreviewflag(); ++i){
		iresult				=	GetFreshframe(pucrgb, uibuffersize, (bG)?(_FrameType_Raw):(_FrameType_RGB24), binitframe);
		binitframe		=	false;
		if(iresult)
			break;

		flgrayValue	=	PDAFGetWhiteGAver(pucrgb, enDataFormat, stroi, iwidth, iheight);

		iresult	=	getExposureTime((sensortype.toAscii()).data(), itemshareData.previewParameter->ucSlave, \
			uivalue, uimin_s, uimax_s, globalFunPointer.ReadHisFX3IIC, globalFunPointer.WriteHisFX3IIC, globalFunPointer.SetHisFX3IICSpeed, globalFunPointer.PullHisFX3RESET, globalFunPointer.PullHisFX3PWND, \
			globalFunPointer.PageWriteHisFX3IIC, globalFunPointer.PageReadHisFX3IIC, globalFunPointer.HisFX3PageWriteSPI, globalFunPointer.HisFX3PageReadSPI);
		if(iresult)
			iresult	=	getExposureTime((sensortype.toAscii()).data(), itemshareData.previewParameter->ucSlave, \
			uivalue, uimin_s, uimax_s, globalFunPointer.ReadHisFX3IIC, globalFunPointer.WriteHisFX3IIC, globalFunPointer.SetHisFX3IICSpeed, globalFunPointer.PullHisFX3RESET, globalFunPointer.PullHisFX3PWND, \
			globalFunPointer.PageWriteHisFX3IIC, globalFunPointer.PageReadHisFX3IIC, globalFunPointer.HisFX3PageWriteSPI, globalFunPointer.HisFX3PageReadSPI);
		if(iresult)
			break;

		if(!uivalue || uimin_s >= uimax_s || uivalue == 0xFFFFFFFF){
			emit information(QTextCodec::codecForName( "GBK")->toUnicode("当前曝光值：") % QString::number(uivalue, 10));
			emit information(QTextCodec::codecForName( "GBK")->toUnicode("最小曝光值：") % QString::number(uimin_s, 10));
			emit information(QTextCodec::codecForName( "GBK")->toUnicode("最大曝光值：") % QString::number(uimax_s, 10));
			iresult	=	HisCCMError_readIIC;
			break;
		}

		if(flgrayValue > static_cast<float>(uimin) && flgrayValue < static_cast<float>(uimax)){
			iresult						=	0;
			itemshareData.drawLock.lockForWrite();
			theIterator=itemshareData.itemdrawList.begin();
			theIterator->stcolor	=	QColor::fromRgb(0, 255, 0);
			theIterator++;
			theIterator->stcolor	=	QColor::fromRgb(0, 255, 0);
			theIterator->uctype	=	HisDrawType_Text;
			sprintf_s(theIterator->strinfo.strtext,	15, "Lux:%.2f", flgrayValue);
			itemshareData.drawLock.unlock();

			if(bG)
				emit information(QTextCodec::codecForName( "GBK")->toUnicode("曝光值：") % QString::number(uivalue, 10) % \
				QTextCodec::codecForName( "GBK")->toUnicode("        亮度(Gr)：") %  QString::number(static_cast<double>(flgrayValue), 'f', 6));
			else
				emit information(QTextCodec::codecForName( "GBK")->toUnicode("曝光值：") % QString::number(uivalue, 10) % \
				QTextCodec::codecForName( "GBK")->toUnicode("        亮度(Y)：") %  QString::number(static_cast<double>(flgrayValue), 'f', 6));

			stnewdata.flfinallux		=	flgrayValue;
			stnewdata.uifinalet		=	uivalue;

			break;
		}

		iresult	=	classAlgorithm.HisCCMGetnextet(pstTheData->stAEData, pstTheData->usdatacount, flgrayValue, uivalue, \
			static_cast<float>(uimin), static_cast<float>(uimax), uimin_s, uimax_s, uispect, i);
		if(iresult)
			break;

		iresult	=	setExposureTime((sensortype.toAscii()).data(), itemshareData.previewParameter->ucSlave, \
			uispect, globalFunPointer.ReadHisFX3IIC, globalFunPointer.WriteHisFX3IIC, globalFunPointer.SetHisFX3IICSpeed, globalFunPointer.PullHisFX3RESET, globalFunPointer.PullHisFX3PWND, \
			globalFunPointer.PageWriteHisFX3IIC, globalFunPointer.PageReadHisFX3IIC, globalFunPointer.HisFX3PageWriteSPI, globalFunPointer.HisFX3PageReadSPI);
		if(iresult)
			iresult	=	setExposureTime((sensortype.toAscii()).data(), itemshareData.previewParameter->ucSlave, \
			uispect, globalFunPointer.ReadHisFX3IIC, globalFunPointer.WriteHisFX3IIC, globalFunPointer.SetHisFX3IICSpeed, globalFunPointer.PullHisFX3RESET, globalFunPointer.PullHisFX3PWND, \
			globalFunPointer.PageWriteHisFX3IIC, globalFunPointer.PageReadHisFX3IIC, globalFunPointer.HisFX3PageWriteSPI, globalFunPointer.HisFX3PageReadSPI);
		if(iresult)
			break;

		DWORD dwstart	=	GetTickCount();
		iresult	=	HisFX3Error_Timeout;

		if(!i){
			stnewdata.flfirstlux	=	flgrayValue;
			stnewdata.uifirstet	=	uivalue;
		}

		if(!i && flgrayValue < 10)
			emit information(QTextCodec::codecForName( "GBK")->toUnicode("警告：自动曝光的初始亮度过低，可能会影响自动曝光的效率"));
		else if(!i && flgrayValue > 240)
			emit information(QTextCodec::codecForName( "GBK")->toUnicode("警告：自动曝光的初始亮度过高，可能会影响自动曝光的效率"));

		if(i && (flgrayValue + 20< uimin || flgrayValue  > uimax + 20)){
			emit information(QTextCodec::codecForName( "GBK")->toUnicode("警告：自动曝光效率偏低，原因可能如下："));
			emit information(QTextCodec::codecForName( "GBK")->toUnicode("              1. 环境亮度在不断变化；"));
			emit information(QTextCodec::codecForName( "GBK")->toUnicode("              2. 模组在不断移动；"));
			emit information(QTextCodec::codecForName( "GBK")->toUnicode("              3. 对模组曝光值的操作可能有误；"));
			emit information(QTextCodec::codecForName( "GBK")->toUnicode("              4. 延时时间偏短；"));
		}

		itemshareData.drawLock.lockForWrite();
		itemshareData.itemdrawList.at(1).uctype	=	HisDrawType_Text;
		sprintf_s(itemshareData.itemdrawList.at(1).strinfo.strtext,	15, "Lux:%.2f", flgrayValue);
		itemshareData.drawLock.unlock();

		dwstart	=	GetTickCount() - dwstart;
		if(uisleep + _FRAME_SLEEP_ADVANCE > dwstart)
			::Sleep(uisleep + _FRAME_SLEEP_ADVANCE - dwstart);
	}

	if(!iresult && stnewdata.uifirstet){
		iresult	=	updateautoexposuredata(pstTheData, &stnewdata);
		if(iresult)
			emit information(QTextCodec::codecForName( "GBK")->toUnicode("更新自动曝光数据库失败"));
	}

	if(iresult)
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("自动曝光失败"));

	HisReleaseMalloc(pucrgb);
	return iresult;
}

int itemprocess::PDAFCalibrationWhitePanel()
{
	if(!classPlatform.HisFX3isstart()) return HisFX3Error_IsNotPreview;

	unsigned char ucApplication	=	0x0;
	int iresult = classPlatform.HisFX3GetLInfo(NULL, &ucApplication, NULL, NULL, NULL, NULL);
	if(iresult) return iresult;
#if (defined PDAF_LICENSE_ONLY_AUTHORIZE)
	if(ucApplication != 0x2){
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("此主板没有操作PDAF的授权"));
		return HisFX3Error_License;
	}
#else
	// 	if(ucApplication != 0x2 && ucApplication != 0xff){
	// 		emit information(QTextCodec::codecForName( "GBK")->toUnicode("此主板没有操作PDAF的授权"));
	// 		return HisFX3Error_License;
	// 	}
#endif
	_CODE_CLEAR_IMAGEDRAW
		if(iresult	=	getccmhardwareParameter(false))	return iresult;
	if(iresult		=	getpdafParameter(false))	return iresult;

	itemshareData.itemparameterLock.lockForRead();
	if(itemshareData.previewParameter->ucDataFormat > HisBaylor10_GBRG){
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("图像格式错误：不是BAYLOR模式"));
		itemshareData.itemparameterLock.unlock();
		return iresult;
	}
	itemshareData.itemparameterLock.unlock();

	if(itemshareData.pdafParameter->ucPlatform== 0) //MTK
	{
		iresult=this->MTKPDAFSTEP1_WhitePannel();     
	}
	else if(itemshareData.pdafParameter->ucPlatform== 1)//Qualcomm
	{
		if(itemshareData.pdafParameter->cVersion=='L')
		{
			iresult=this->QualCommPDAF_LVersion_GainCalibration();
		}
		else iresult=this->QualCommPDAFStep1();    
	}
	else if(itemshareData.pdafParameter->ucPlatform== 2)//SONY
	{
		iresult=this->SONYPDAF_SPCCal();
	}else if(itemshareData.pdafParameter->ucPlatform== 3)// His
	{
		iresult=this->HISIPDAFSTEP1_WhitePannel(); 
	}
	return iresult;
}

int itemprocess::QualcommPDAFCheck()
{
	QString strSerialNumber;
	classLog->getserialnumber(strSerialNumber);

	_HisQualcommPDAFBurn_Config stPDAFConfig;
	stPDAFConfig.bDebug					=		hisglobalparameter.bDebugMode;
	stPDAFConfig.ucSensorSlave		=		itemshareData.previewParameter->ucSlave;
	stPDAFConfig.strproject					=		itemshareData.ccmhardwareParameter->projectname.toAscii().data();
	stPDAFConfig.strsensor					=		itemshareData.ccmhardwareParameter->sensortype.toAscii().data();
	stPDAFConfig.strDriverIC				=		itemshareData.ccmhardwareParameter->motortype.toAscii().data();
	stPDAFConfig.strFunctionChoose	=	itemshareData.pdafParameter->strQualcommChoose.toAscii().data();
	stPDAFConfig.ucEESlave				=	itemshareData.ccmhardwareParameter->ucEESlave;
	stPDAFConfig.usGainMapSize=itemshareData.pdafParameter->usQualcommGainMapSize;
	stPDAFConfig.ucTpye=0xFF;
	stPDAFConfig.strSerialNumber	=	strSerialNumber.toAscii().data();

#if (defined _WIN64) && (defined _DEBUG)
	QString strLibPath	=	QDir::currentPath() % "/HisCCMOTP64D";
#elif (defined _WIN64) && !(defined _DEBUG)
	QString strLibPath	=	QDir::currentPath() % "/HisCCMOTP64";
#elif (defined _WIN32) && (defined _DEBUG)
	QString strLibPath	=	QDir::currentPath() % "/HisCCMOTP32D";
#else
	QString strLibPath	=	QDir::currentPath() % "/HisCCMOTP32";
#endif

	RolongoOTPAPIVersion getRolongoOTPAPIVersion = (RolongoOTPAPIVersion)(QLibrary::resolve(strLibPath, "getRolongoOTPAPIVersion"));
	RolongocheckQualcommPDAF checkQualcommPDAF = (RolongocheckQualcommPDAF)(QLibrary::resolve(strLibPath, "checkQualcommPDAF"));

	if(!(getRolongoOTPAPIVersion && checkQualcommPDAF)){
		emit information(tr("Resolve HisCCMOTP DLL Function Fail"));
		itemshareData.itemparameterLock.unlock();
		return HisCCMError_LoadDLLFuc;
	}

	memset(&stPDAFConfig.GainMapData2D,0,sizeof(GainMap2DDataStruct));
	memset(stPDAFConfig.CalibrationKOutputValues,0,sizeof(CalibrationKOutputParams));
	emit enableinfotimer(1);
	int iresult	=	checkQualcommPDAF(*globalFunPointer.vectorHisCCMOTPInfoW, &stPDAFConfig, globalFunPointer.ReadHisFX3IIC, globalFunPointer.WriteHisFX3IIC, globalFunPointer.SetHisFX3IICSpeed, \
		globalFunPointer.SetHisFX3Voltage, globalFunPointer.GetHisFX3Voltage, SetHisFX3VFuseVolt, GetHisFX3VFuseVolt, GetFreshframe, \
		globalFunPointer.BatchWriteHisFX3IIC, globalFunPointer.BatchReadHisFX3IIC, SetHisFX3GPIO, GetHisFX3GPIO, globalFunPointer.PullHisFX3RESET, globalFunPointer.PullHisFX3PWND, \
		globalFunPointer.BatchReadHisFX3IICNoLimit, globalFunPointer.BatchWriteHisFX3IICNoLimit,globalFunPointer.HisFX3LogPush_back, globalFunPointer.PageWriteHisFX3IIC, globalFunPointer.PageReadHisFX3IIC, \
		globalFunPointer.HisFX3PageWriteSPI, globalFunPointer.HisFX3PageReadSPI);
	emit enableinfotimer(0);
	if(iresult)
	{
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("PDAF 检查错误"));
	}
	QDir classDir;
	QString strIniPath	=	QDir::currentPath() % "/QualcommPDAFLog";
	classDir.mkpath(strIniPath);
	strIniPath	=	strIniPath % "/" % strSerialNumber % "_Qualcomm_PDAF_Check_"%(QDateTime::currentDateTime()).toString("yyyyMMdd_hhmmss")%".txt";
	FILE* fileStep1	=	fopen(strIniPath.toAscii().data(), "wb");
	if(fileStep1 != NULL)
	{
		fprintf(fileStep1,"VersionNum:0x%04X\r\n",stPDAFConfig.GainMapData2D.VersionNum);
		fprintf(fileStep1,"OffsetX:0x%04X\r\n",stPDAFConfig.GainMapData2D.OffsetX);
		fprintf(fileStep1,"OffsetY:0x%04X\r\n",stPDAFConfig.GainMapData2D.OffsetY);
		fprintf(fileStep1,"RatioX:0x%04X\r\n",stPDAFConfig.GainMapData2D.RatioX);
		fprintf(fileStep1,"RatioY:0x%04X\r\n",stPDAFConfig.GainMapData2D.RatioY);
		fprintf(fileStep1,"MapWidth:0x%04X\r\n",stPDAFConfig.GainMapData2D.MapWidth);
		fprintf(fileStep1,"MapHeight:0x%04X\r\n",stPDAFConfig.GainMapData2D.MapHeight);
		fprintf(fileStep1,"2DGainMap_Left:\r\n");
		for (unsigned int i = 0; i < stPDAFConfig.GainMapData2D.MapHeight*stPDAFConfig.GainMapData2D.MapWidth; i ++)
			fprintf(fileStep1,"0x%04X,",stPDAFConfig.GainMapData2D.Left_GainMap[i]);
		fprintf(fileStep1,"\r\n");
		fprintf(fileStep1,"2DGainMap_Right:\r\n");
		for (unsigned int i = 0; i < stPDAFConfig.GainMapData2D.MapHeight*stPDAFConfig.GainMapData2D.MapWidth; i ++)
			fprintf(fileStep1,"0x%04X,",stPDAFConfig.GainMapData2D.Right_GainMap[i]);
		fprintf(fileStep1,"\r\n");
		fprintf(fileStep1,"K Value:%d\r\n",stPDAFConfig.CalibrationKOutputValues[0].PDConversionCoef[0]);
		fclose(fileStep1);
	}
	itemshareData.itemparameterLock.unlock();
	return iresult;
}

int itemprocess::print_return_code(int rc)
{
	int iresult=0;
	if (rc & 0x0001)
	{
		iresult	=	HisCCMError_QualcommPDAFStep1;
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("Error code 0x0001: Memory allocation error."));
		return iresult;
	}
	if (rc & 0x0002)
	{
		iresult	=	HisCCMError_QualcommPDAFStep1;
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("Error code 0x0002: Invalid sensor configuration or sensor gain."));
		return iresult;
	}
	if (rc & 0x0004)
	{
		iresult	=	HisCCMError_QualcommPDAFStep1;
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("nError code 0x0004: Invalid pd pixel pattern within block."));
		return iresult;
	}
	if (rc & 0x0008)
	{	
		iresult	=	HisCCMError_QualcommPDAFStep1;
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("Error code 0x0008: Gain Map: pd pixel values too high for calibration."));
		return iresult;
	}
	if (rc & 0x0010)
	{
		iresult	=	HisCCMError_QualcommPDAFStep1;
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("Error code 0x0010: Gain Map: pd pixel values too low for calibration."));
		return iresult;
	}
	if (rc & 0x0020)
	{	
		iresult	=	HisCCMError_QualcommPDAFStep1;
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("Error code 0x0020: Gain Map: gain map shows maximum value that is too high."));	
		return iresult;
	}
	if (rc & 0x0040)
	{
		iresult	=	HisCCMError_QualcommPDAFStep2;
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("Error code 0x0040: DCC: phase disparity values out of bound. invalid input image."));
		return iresult;
	}
	if (rc & 0x0080)
	{
		iresult	=	HisCCMError_QualcommPDAFStep2;
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("Error code 0x0080: DCC: phase disparity values out of order. LEFT and RIGHT pixels may be swapped."));
		return iresult;
	}
	if (rc & 0x0100)
	{
		iresult	=	HisCCMError_QualcommPDAFStep2;
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("Error code 0x0100: DCC: insufficient number of lens sweep prior to dcc calculation."));
		return iresult;
	}
	if (rc & 0x0200)
	{
		iresult	=	HisCCMError_QualcommPDAFStep2;
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("Error code 0x0200: DCC: insufficient match between zero phase disparity focus peak."));
		return iresult;
	}
	if (rc & 0x0400)	
	{
		iresult	=	HisCCMError_QualcommPDAFStep2;
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("Error code 0x0400: DCC: insufficient range of pd values from INF to MACRO."));
		return iresult;
	}
	if (rc & 0x1000)
	{
		iresult	=	HisCCMError_QualcommPDAFStep2;
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("Error code 0x1000: DCC: Please check line chart condition."));
		return iresult;
	}
	if(rc & 0x2000)
	{
		iresult	=	HisCCMError_QualcommPDAFStep2;
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("Error code 0x2000: DCC: focus peak is out of boundary."));
		return iresult;
	}
	return 0;
}


int itemprocess::Display_GmCheckResult(int GainMapFlag)
{
	int iresult=0;
	if (GainMapFlag & 0x0200)
	{
		iresult	=	HisCCMError_QualcommPDAFStep1;
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("0x0200: GainMap Calibration, Memory error"));
		return iresult;
	}
	else if (GainMapFlag & 0x0100)
	{
		iresult	=	HisCCMError_QualcommPDAFStep1;
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("0x0100: GainMap Calibration, Input Parameter Error"));
		return iresult;
	}
	else if (GainMapFlag & 0x0080)
	{
		iresult	=	HisCCMError_QualcommPDAFStep1;
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("0x0080: Error, GainMap Calibration, PD signal too weak. "));
		return iresult;
	}
	else if (GainMapFlag & 0x0040)
	{
		iresult	=	HisCCMError_QualcommPDAFStep1;
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("0x0040: Error, GainMap Calibration, PD signal too strong."));
		return iresult;
	}
	else if (GainMapFlag & 0x0020)
	{
		iresult	=	HisCCMError_QualcommPDAFStep1;
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("0x0020: Error, GainMap Calibration, Normal Pixel too weak. "));
		return iresult;
	}
	else if (GainMapFlag & 0x0010)
	{
		iresult	=	HisCCMError_QualcommPDAFStep1;
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("0x0010: Error, GainMap Calibration, Normal Pixel too strong."));
		return iresult;
	}
	else if (GainMapFlag & 0x0008)
	{
		iresult	=	HisCCMError_QualcommPDAFStep1;
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("0x0008: Error, GainMap Calibration, max of Normal Pixel too weak."));
		return iresult;
	}
	else if (GainMapFlag & 0x0004)
	{
		iresult	=	HisCCMError_QualcommPDAFStep1;
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("0x0004: Error, GainMap Calibration, pattern file error."));
		return iresult;
	}
	else if (GainMapFlag & 0x0002)
	{
		iresult	=	HisCCMError_QualcommPDAFStep1;
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("0x0002: Warning, GainMap Calibration, GM value too small."));
		return iresult;
	}
	else if (GainMapFlag & 0x0001)
	{
		iresult	=	HisCCMError_QualcommPDAFStep1;
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("0x0001: Warning, GainMap Calibration, GM value too big."));
		return iresult;
	}
	emit information(QTextCodec::codecForName( "GBK")->toUnicode("The Gainmap is Normal."));

	return 0;
}

int itemprocess::MTKPDAFSTEP1_WhitePannel()
{
	itemshareData.itemparameterLock.lockForRead();

	QString strSerialNumber;
	classLog->getserialnumber(strSerialNumber);
	QString strMTKDir;
	if(!strSerialNumber.isEmpty()){
		strMTKDir	=	QDir::currentPath() % "/mtk_approval_log/" % strSerialNumber;
		QDir classTempDir;
		if(!classTempDir.mkpath(strMTKDir)) strMTKDir.clear();
	}


	_HisCCMAFBurn_Config stAFConfig;
	stAFConfig.bDebug						=	hisglobalparameter.bDebugMode;
	stAFConfig.strDriverIC				=	(itemshareData.ccmhardwareParameter->motortype.toAscii()).data();
	stAFConfig.strproject					=	itemshareData.ccmhardwareParameter->projectname.toAscii().data();
	stAFConfig.strsensor					=	itemshareData.ccmhardwareParameter->sensortype.toAscii().data();
	stAFConfig.bNear						=	true;
	stAFConfig.bInfinite						=	true;
	stAFConfig.iwidth						=	itemshareData.previewParameter->iWidth;
	stAFConfig.iheight						=	itemshareData.previewParameter->iHeight;
	stAFConfig.strFunctionChoose	=	itemshareData.pdafParameter->strAFChoose.toAscii().data();
	stAFConfig.ucSlave					=	itemshareData.previewParameter->ucSlave;
	stAFConfig.uiDataFormat			=	itemshareData.previewParameter->ucDataFormat;
	stAFConfig.ucEESlave				=	itemshareData.ccmhardwareParameter->ucEESlave;
	stAFConfig.strSerialNumber	=	strSerialNumber.toAscii().data();

#if (defined _WIN64) && (defined _DEBUG)
	QString strLibPath	=	QDir::currentPath() % "/HisCCMOTP64D";
#elif (defined _WIN64) && !(defined _DEBUG)
	QString strLibPath	=	QDir::currentPath() % "/HisCCMOTP64";
#elif (defined _WIN32) && (defined _DEBUG)
	QString strLibPath	=	QDir::currentPath() % "/HisCCMOTP32D";
#else
	QString strLibPath	=	QDir::currentPath() % "/HisCCMOTP32";
#endif

	RolongoOTPAPIVersion getRolongoOTPAPIVersion = (RolongoOTPAPIVersion)(QLibrary::resolve(strLibPath, "getRolongoOTPAPIVersion"));
	Rolongocheckafmotor checkafmotor = (Rolongocheckafmotor)(QLibrary::resolve(strLibPath, "checkafmotor"));
	RolongowriteMTKPDAF writeMTKPDAF = (RolongowriteMTKPDAF)(QLibrary::resolve(strLibPath, "writeMTKPDAF"));

	if(!(getRolongoOTPAPIVersion && checkafmotor && writeMTKPDAF)){
		emit information(tr("Resolve HisCCMOTP DLL Function Fail"));
		itemshareData.itemparameterLock.unlock();
		return HisCCMError_LoadDLLFuc;
	}

	int iresult=0;
	if(!threadshareData.bOfflineMode){
		emit enableinfotimer(1);
		iresult	=	checkafmotor(*globalFunPointer.vectorHisCCMOTPInfoW, &stAFConfig, globalFunPointer.ReadHisFX3IIC, globalFunPointer.WriteHisFX3IIC, globalFunPointer.SetHisFX3IICSpeed, globalFunPointer.SetHisFX3Voltage, \
			globalFunPointer.GetHisFX3Voltage, SetHisFX3VFuseVolt, GetHisFX3VFuseVolt, GetFreshframe, SetHisFX3GPIO, GetHisFX3GPIO, \
			globalFunPointer.PullHisFX3RESET, globalFunPointer.PullHisFX3PWND, globalFunPointer.BatchReadHisFX3IICNoLimit, globalFunPointer.BatchWriteHisFX3IICNoLimit, \
			globalFunPointer.HisFX3LogPush_back, globalFunPointer.PageWriteHisFX3IIC, globalFunPointer.PageReadHisFX3IIC, \
			globalFunPointer.HisFX3PageWriteSPI, globalFunPointer.HisFX3PageReadSPI);
		emit enableinfotimer(0);
		if(iresult){
			itemshareData.itemparameterLock.unlock();
			return iresult;
		}

		int iInfiniteMotor	=	stAFConfig.iInfinitMotor;
		int iMacroMotor	=	stAFConfig.iNearMotor;

		emit information(QTextCodec::codecForName( "GBK")->toUnicode("近焦位置：") % QString::number(iMacroMotor));
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("远焦位置：") % QString::number(iInfiniteMotor));

		if(itemshareData.pdafParameter->bWhiteMove2NearFocus){
			iresult	=	setMotor(itemshareData.ccmhardwareParameter->motortype.toAscii().data(), \
				itemshareData.previewParameter->ucSlave, itemshareData.ccmhardwareParameter->projectname.toAscii().data(), \
				iMacroMotor, globalFunPointer.ReadHisFX3IIC, globalFunPointer.WriteHisFX3IIC, globalFunPointer.SetHisFX3IICSpeed, globalFunPointer.PullHisFX3RESET, globalFunPointer.PullHisFX3PWND, \
				globalFunPointer.PageWriteHisFX3IIC, globalFunPointer.PageReadHisFX3IIC, globalFunPointer.HisFX3PageWriteSPI, globalFunPointer.HisFX3PageReadSPI);
			if(iresult){
				emit information(QTextCodec::codecForName( "GBK")->toUnicode("设置马达到近焦位置失败"));
				itemshareData.itemparameterLock.unlock();
				return iresult;
			}
			Sleep(itemshareData.pdafParameter->uiMotorSleep);
		}
	}

	strLibPath	=	QDir::currentPath() % "/pdaflib/mtk_" % QString::number(itemshareData.pdafParameter->usVersion[3]) % "." % \
		QString::number(itemshareData.pdafParameter->usVersion[2]) % "." % QString::number(itemshareData.pdafParameter->usVersion[1]) % \
		"." % QString::number(itemshareData.pdafParameter->usVersion[0]);
	if(itemshareData.pdafParameter->usVersion[3]==3)
	{
		strLibPath	=	QDir::currentPath() % "/pdaflib/mtk_" % QString::number(itemshareData.pdafParameter->usVersion[3]) % "." % \
			QString::number(itemshareData.pdafParameter->usVersion[2]) % "." % QString::number(itemshareData.pdafParameter->usVersion[1]) % \
			".0" % QString::number(itemshareData.pdafParameter->usVersion[0]);
	}
#ifdef _WIN64
	strLibPath	=	strLibPath % "/x64/pd_cali_dll";
#else
	strLibPath	=	strLibPath % "/x86/pd_cali_dll";
#endif

#ifdef _WIN64
	mtk_pd_cali_init pd_cali_init	=	(mtk_pd_cali_init)(QLibrary::resolve(strLibPath, "?pd_cali_init@@YA?AW4PD_ERR_CODE@@PEAD@Z"));
	mtk_pd_cali_get_max_output_size pd_cali_get_max_output_size	=	(mtk_pd_cali_get_max_output_size)(QLibrary::resolve(strLibPath, "?pd_cali_get_max_output_size@@YA?AW4PD_ERR_CODE@@AEAH@Z"));
	mtk_pd_cali_get_capture_num pd_cali_get_capture_num	=	(mtk_pd_cali_get_capture_num)(QLibrary::resolve(strLibPath, "?pd_cali_get_capture_num@@YA?AW4PD_ERR_CODE@@AEAH@Z"));
	mtk_pd_cali_get_raw_width_height pd_cali_get_raw_width_height	=	(mtk_pd_cali_get_raw_width_height)(QLibrary::resolve(strLibPath, "?pd_cali_get_raw_width_height@@YA?AW4PD_ERR_CODE@@AEAH0@Z"));
	mtk_pd_cali_proc1 pd_cali_proc1	=	(mtk_pd_cali_proc1)(QLibrary::resolve(strLibPath, "?pd_cali_proc1@@YA?AW4PD_ERR_CODE@@PEAGPEADHAEAH@Z"));
	mtk_pd_cali_proc2 pd_cali_proc2	=	(mtk_pd_cali_proc2)(QLibrary::resolve(strLibPath, "?pd_cali_proc2@@YA?AW4PD_ERR_CODE@@PEAPEADPEAHHPEADHAEAH@Z"));
	mtk_pd_cali_verify pd_cali_verify	=	(mtk_pd_cali_verify)(QLibrary::resolve(strLibPath, "?pd_cali_verify@@YA?AW4PD_ERR_CODE@@PEAE@Z"));
	mtk_pd_cali_verify_proc1 pd_cali_verify_proc1	=	(mtk_pd_cali_verify_proc1)(QLibrary::resolve(strLibPath, "?pd_cali_verify_proc1@@YA?AW4PD_ERR_CODE@@PEAE@Z"));
	mtk_pd_cali_verify_proc2 pd_cali_verify_proc2	=	(mtk_pd_cali_verify_proc2)(QLibrary::resolve(strLibPath, "?pd_cali_verify_proc2@@YA?AW4PD_ERR_CODE@@PEAE@Z"));
	mtk_pd_cali_get_DAC_proc2 pd_cali_get_DAC_proc2	=	(mtk_pd_cali_get_DAC_proc2)(QLibrary::resolve(strLibPath, "?pd_cali_get_DAC_proc2@@YA?AW4PD_ERR_CODE@@PEAEAEAH@Z"));
#else
	mtk_pd_cali_init pd_cali_init	=	(mtk_pd_cali_init)(QLibrary::resolve(strLibPath, "?pd_cali_init@@YA?AW4PD_ERR_CODE@@PAD@Z"));
	mtk_pd_cali_get_max_output_size pd_cali_get_max_output_size	=	(mtk_pd_cali_get_max_output_size)(QLibrary::resolve(strLibPath, "?pd_cali_get_max_output_size@@YA?AW4PD_ERR_CODE@@AAH@Z"));
	mtk_pd_cali_get_capture_num pd_cali_get_capture_num	=	(mtk_pd_cali_get_capture_num)(QLibrary::resolve(strLibPath, "?pd_cali_get_capture_num@@YA?AW4PD_ERR_CODE@@AAH@Z"));
	mtk_pd_cali_get_raw_width_height pd_cali_get_raw_width_height	=	(mtk_pd_cali_get_raw_width_height)(QLibrary::resolve(strLibPath, "?pd_cali_get_raw_width_height@@YA?AW4PD_ERR_CODE@@AAH0@Z"));
	mtk_pd_cali_proc1 pd_cali_proc1	=	(mtk_pd_cali_proc1)(QLibrary::resolve(strLibPath, "?pd_cali_proc1@@YA?AW4PD_ERR_CODE@@PAGPADHAAH@Z"));
	mtk_pd_cali_proc2 pd_cali_proc2	=	(mtk_pd_cali_proc2)(QLibrary::resolve(strLibPath, "?pd_cali_proc2@@YA?AW4PD_ERR_CODE@@PAPADPAHHPADHAAH@Z"));
	mtk_pd_cali_verify pd_cali_verify	=	(mtk_pd_cali_verify)(QLibrary::resolve(strLibPath, "?pd_cali_verify@@YA?AW4PD_ERR_CODE@@PAE@Z"));
	mtk_pd_cali_verify_proc1 pd_cali_verify_proc1	=	(mtk_pd_cali_verify_proc1)(QLibrary::resolve(strLibPath, "?pd_cali_verify_proc1@@YA?AW4PD_ERR_CODE@@PAE@Z"));
	mtk_pd_cali_verify_proc2 pd_cali_verify_proc2	=	(mtk_pd_cali_verify_proc2)(QLibrary::resolve(strLibPath, "?pd_cali_verify_proc2@@YA?AW4PD_ERR_CODE@@PAE@Z"));
	mtk_pd_cali_get_DAC_proc2 pd_cali_get_DAC_proc2	=	(mtk_pd_cali_get_DAC_proc2)(QLibrary::resolve(strLibPath, "?pd_cali_get_DAC_proc2@@YA?AW4PD_ERR_CODE@@PAEAAH@Z"));
#endif	
	if(!(pd_cali_init && pd_cali_get_max_output_size && pd_cali_get_capture_num && pd_cali_get_raw_width_height && \
		pd_cali_proc1 && pd_cali_proc2 && pd_cali_verify && pd_cali_verify_proc1 && pd_cali_verify_proc2 && pd_cali_get_DAC_proc2)){
			emit information(tr("Resolve MTK PDAF DLL Function Fail"));
			itemshareData.itemparameterLock.unlock();
			return HisCCMError_LoadDLLFuc;
	}
	//IMX258
	if(itemshareData.pdafParameter->bSONY258MTKCal)
	{
		iresult=ApplySONYIMX258SPC();
		if(iresult)
		{
			emit information(QTextCodec::codecForName( "GBK")->toUnicode("Apply SONY IMX258 SPC 失败"));
			itemshareData.itemparameterLock.unlock();
			return iresult;
		}
	}

	QString strIniPath	=	QDir::currentPath() % "/pdaftemplate/MTK/" % itemshareData.ccmhardwareParameter->projectname % "/pd_pos_info.ini";

	PD_ERR_CODE mtkError	=	pd_cali_init(strIniPath.toAscii().data());
	iresult	=	MTkErrorcodeConvert(mtkError);
	if(iresult){
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("pd_cali_init调用失败"));
		itemshareData.itemparameterLock.unlock();
		return iresult;
	}

	int iMaxOutputSize;
	mtkError	=	pd_cali_get_max_output_size(iMaxOutputSize);
	int iCaptureNum;
	mtkError	=	pd_cali_get_capture_num(iCaptureNum);

	emit information(QTextCodec::codecForName( "GBK")->toUnicode("最大输出尺寸：") % QString::number(iMaxOutputSize));
	emit information(QTextCodec::codecForName( "GBK")->toUnicode("抓取帧数：") % QString::number(iCaptureNum));

	unsigned int uiPixel	=	itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight *2;
	unsigned short* pusRaw10	=	(unsigned short*)_aligned_malloc(uiPixel, _HisCacheLine_Aligned);
	char* pstrOutput	=	new char[iMaxOutputSize+2];
	if(!pusRaw10 || !pstrOutput){
		HisReleaseMalloc(pusRaw10);
		HisReleaseNewB(pstrOutput);
		itemshareData.itemparameterLock.unlock();
		return HisFX3Error_MallocBuffer;
	}

	iresult	=	GetFreshframe((unsigned char*)(pusRaw10), uiPixel, _FrameType_Raw10, true);
	if(iresult){
		HisReleaseMalloc(pusRaw10);
		HisReleaseNewB(pstrOutput);
		itemshareData.itemparameterLock.unlock();
		return iresult;
	}

	int iOutputSize	=	0;
	mtkError	=	pd_cali_proc1(pusRaw10, pstrOutput, iMaxOutputSize, iOutputSize);
	iresult		=	MTkErrorcodeConvert(mtkError);
	if(iresult){
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("pd_cali_proc1调用失败"));
		HisReleaseMalloc(pusRaw10);
		HisReleaseNewB(pstrOutput);
		itemshareData.itemparameterLock.unlock();
		return iresult;
	}

	if(hisglobalparameter.bDebugMode){
		QDir classDir;
		strIniPath	=	QDir::currentPath() % "/mtkpdaflog";
		classDir.mkpath(strIniPath);
		ROPLOW::saveRaw10(strIniPath, strSerialNumber % "_MTK_WhitePanel", itemshareData.previewParameter->ucDataFormat, \
			itemshareData.previewParameter->iWidth, itemshareData.previewParameter->iHeight, (void*)(pusRaw10));
		if(!strMTKDir.isEmpty())
			ROPLOW::saveRaw10(strMTKDir, "step1", itemshareData.previewParameter->ucDataFormat, \
			itemshareData.previewParameter->iWidth, itemshareData.previewParameter->iHeight, (void*)(pusRaw10));
	}

	emit information(QTextCodec::codecForName( "GBK")->toUnicode("step1 输出大小(BYTE)：") % QString::number(iOutputSize));
	HisReleaseMalloc(pusRaw10);

	mtkError	=	pd_cali_verify_proc1((unsigned char*)(pstrOutput));
	iresult		=	MTkErrorcodeConvert(mtkError);
	if(iresult){
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("pd_cali_verify_proc1调用失败"));
		HisReleaseNewB(pstrOutput);
		itemshareData.itemparameterLock.unlock();
		return iresult;
	}

	if(hisglobalparameter.bDebugMode){
		QDir classDir;
		strIniPath	=	QDir::currentPath() % "/mtkpdaflog";
		classDir.mkpath(strIniPath);
		strIniPath	=	strIniPath % "/" % strSerialNumber % "_MTK_PDAF_Step1_Write_F1.bin";
		FILE* fileStep1	=	fopen(strIniPath.toAscii().data(), "wb");
		if(fileStep1 != NULL){
			fwrite(pstrOutput, 1, iOutputSize, fileStep1);
			fclose(fileStep1);
		}
	}

	if(threadshareData.bOfflineMode){
		HisReleaseNewB(pstrOutput);
		itemshareData.itemparameterLock.unlock();
		return 0;
	}

	_HisCCMMTKPDAFBurn_Config stPDAFConfig;
	stPDAFConfig.bDebug					=		hisglobalparameter.bDebugMode;
	stPDAFConfig.ucSensorSlave		=		itemshareData.previewParameter->ucSlave;
	stPDAFConfig.strproject					=		itemshareData.ccmhardwareParameter->projectname.toAscii().data();
	stPDAFConfig.strsensor					=		itemshareData.ccmhardwareParameter->sensortype.toAscii().data();
	stPDAFConfig.strDriverIC				=		itemshareData.ccmhardwareParameter->motortype.toAscii().data();
	stPDAFConfig.strFunctionChoose	=	itemshareData.pdafParameter->strPDAFChoose.toAscii().data();
	stPDAFConfig.ucEESlave				=	itemshareData.ccmhardwareParameter->ucEESlave;
	stPDAFConfig.ucTpye					=	1;
	stPDAFConfig.uiDataSize				=	iOutputSize;
	stPDAFConfig.uiStep1Size=iOutputSize;
	stPDAFConfig.uiStep2Size =itemshareData.pdafParameter->usMTKV2Step2dataSize;
	stPDAFConfig.Reserve1.u16value[3]	=	itemshareData.pdafParameter->usVersion[3];
	stPDAFConfig.Reserve1.u16value[2]	=	itemshareData.pdafParameter->usVersion[2];
	stPDAFConfig.Reserve1.u16value[1]	=	itemshareData.pdafParameter->usVersion[1];
	stPDAFConfig.Reserve1.u16value[0]	=	itemshareData.pdafParameter->usVersion[0];
	memset(stPDAFConfig.ucData,0,2048);
	memcpy(stPDAFConfig.ucData, pstrOutput, stPDAFConfig.uiDataSize);

	emit enableinfotimer(1);
	iresult	=	writeMTKPDAF(*globalFunPointer.vectorHisCCMOTPInfoW, &stPDAFConfig, globalFunPointer.ReadHisFX3IIC, globalFunPointer.WriteHisFX3IIC, globalFunPointer.SetHisFX3IICSpeed, \
		globalFunPointer.SetHisFX3Voltage, globalFunPointer.GetHisFX3Voltage, SetHisFX3VFuseVolt, GetHisFX3VFuseVolt, GetFreshframe, \
		globalFunPointer.BatchWriteHisFX3IIC, globalFunPointer.BatchReadHisFX3IIC, SetHisFX3GPIO, GetHisFX3GPIO, globalFunPointer.PullHisFX3RESET, globalFunPointer.PullHisFX3PWND, \
		globalFunPointer.BatchReadHisFX3IICNoLimit, globalFunPointer.BatchWriteHisFX3IICNoLimit, globalFunPointer.HisFX3LogPush_back, \
		globalFunPointer.PageWriteHisFX3IIC, globalFunPointer.PageReadHisFX3IIC, globalFunPointer.HisFX3PageWriteSPI, globalFunPointer.HisFX3PageReadSPI);
	emit enableinfotimer(0);
	if(iresult){
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("写入PDAF Step1 数据失败"));
		HisReleaseNewB(pstrOutput);
		itemshareData.itemparameterLock.unlock();
		return iresult;
	}

	HisReleaseNewB(pstrOutput);
	itemshareData.itemparameterLock.unlock();

	return 0;
}
int itemprocess::MTKPDAFSTEP2_20CM()
{
	itemshareData.itemparameterLock.lockForRead();

	if(itemshareData.pdafParameter->usVersion[3] == 1 ){
		emit information(tr("The MTK PDAF lib version you chosen is not support V1 "));
		itemshareData.itemparameterLock.unlock();
		return HisFX3Error_Parameter;
	}

	QString strSerialNumber;
	classLog->getserialnumber(strSerialNumber);

	_HisCCMAFBurn_Config stAFConfig;
	stAFConfig.bDebug						=	hisglobalparameter.bDebugMode;
	stAFConfig.strDriverIC				=	(itemshareData.ccmhardwareParameter->motortype.toAscii()).data();
	stAFConfig.strproject					=	itemshareData.ccmhardwareParameter->projectname.toAscii().data();
	stAFConfig.strsensor					=	itemshareData.ccmhardwareParameter->sensortype.toAscii().data();
	stAFConfig.bNear						=	true;
	stAFConfig.bInfinite						=	true;
	stAFConfig.iwidth						=	itemshareData.previewParameter->iWidth;
	stAFConfig.iheight						=	itemshareData.previewParameter->iHeight;
	stAFConfig.strFunctionChoose	=	itemshareData.pdafParameter->strAFChoose.toAscii().data();
	stAFConfig.ucSlave					=	itemshareData.previewParameter->ucSlave;
	stAFConfig.uiDataFormat			=	itemshareData.previewParameter->ucDataFormat;
	stAFConfig.ucEESlave				=	itemshareData.ccmhardwareParameter->ucEESlave;
	stAFConfig.strSerialNumber	=	strSerialNumber.toAscii().data();

#if (defined _WIN64) && (defined _DEBUG)
	QString strLibPath	=	QDir::currentPath() % "/HisCCMOTP64D";
#elif (defined _WIN64) && !(defined _DEBUG)
	QString strLibPath	=	QDir::currentPath() % "/HisCCMOTP64";
#elif (defined _WIN32) && (defined _DEBUG)
	QString strLibPath	=	QDir::currentPath() % "/HisCCMOTP32D";
#else
	QString strLibPath	=	QDir::currentPath() % "/HisCCMOTP32";
#endif

	RolongoOTPAPIVersion getRolongoOTPAPIVersion = (RolongoOTPAPIVersion)(QLibrary::resolve(strLibPath, "getRolongoOTPAPIVersion"));
	Rolongocheckafmotor checkafmotor = (Rolongocheckafmotor)(QLibrary::resolve(strLibPath, "checkafmotor"));
	RolongowriteMTKPDAF writeMTKPDAF = (RolongowriteMTKPDAF)(QLibrary::resolve(strLibPath, "writeMTKPDAF"));

	if(!(getRolongoOTPAPIVersion && checkafmotor && writeMTKPDAF)){
		emit information(tr("Resolve HisCCMOTP DLL Function Fail"));
		itemshareData.itemparameterLock.unlock();
		return HisCCMError_LoadDLLFuc;
	}

	emit enableinfotimer(1);
	int iresult	=	checkafmotor(*globalFunPointer.vectorHisCCMOTPInfoW, &stAFConfig, globalFunPointer.ReadHisFX3IIC, globalFunPointer.WriteHisFX3IIC, globalFunPointer.SetHisFX3IICSpeed, globalFunPointer.SetHisFX3Voltage, \
		globalFunPointer.GetHisFX3Voltage, SetHisFX3VFuseVolt, GetHisFX3VFuseVolt, GetFreshframe, SetHisFX3GPIO, GetHisFX3GPIO, \
		globalFunPointer.PullHisFX3RESET, globalFunPointer.PullHisFX3PWND, globalFunPointer.BatchReadHisFX3IICNoLimit, globalFunPointer.BatchWriteHisFX3IICNoLimit, \
		globalFunPointer.HisFX3LogPush_back, globalFunPointer.PageWriteHisFX3IIC, globalFunPointer.PageReadHisFX3IIC, \
		globalFunPointer.HisFX3PageWriteSPI, globalFunPointer.HisFX3PageReadSPI);
	emit enableinfotimer(0);
	if(iresult){
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("获取远近焦烧录数据失败"));
		itemshareData.itemparameterLock.unlock();
		return iresult;
	}

	int iInfiniteMotor	=	stAFConfig.iInfinitMotor;
	int iMacroMotor	=	stAFConfig.iNearMotor;

	emit information(QTextCodec::codecForName( "GBK")->toUnicode("近焦位置：") % QString::number(iMacroMotor));
	emit information(QTextCodec::codecForName( "GBK")->toUnicode("远焦位置：") % QString::number(iInfiniteMotor));

	strLibPath	=	QDir::currentPath() % "/pdaflib/mtk_" % QString::number(itemshareData.pdafParameter->usVersion[3]) % "." % \
		QString::number(itemshareData.pdafParameter->usVersion[2]) % "." % QString::number(itemshareData.pdafParameter->usVersion[1]) % \
		"." % QString::number(itemshareData.pdafParameter->usVersion[0]);
	if(itemshareData.pdafParameter->usVersion[3]==3)
	{
		strLibPath	=	QDir::currentPath() % "/pdaflib/mtk_" % QString::number(itemshareData.pdafParameter->usVersion[3]) % "." % \
			QString::number(itemshareData.pdafParameter->usVersion[2]) % "." % QString::number(itemshareData.pdafParameter->usVersion[1]) % \
			".0" % QString::number(itemshareData.pdafParameter->usVersion[0]);
	}
#ifdef _WIN64
	strLibPath	=	strLibPath % "/x64/pd_cali_dll";
#else
	strLibPath	=	strLibPath % "/x86/pd_cali_dll";
#endif

#ifdef _WIN64
	mtk_pd_cali_init pd_cali_init	=	(mtk_pd_cali_init)(QLibrary::resolve(strLibPath, "?pd_cali_init@@YA?AW4PD_ERR_CODE@@PEAD@Z"));
	mtk_pd_cali_get_max_output_size pd_cali_get_max_output_size	=	(mtk_pd_cali_get_max_output_size)(QLibrary::resolve(strLibPath, "?pd_cali_get_max_output_size@@YA?AW4PD_ERR_CODE@@AEAH@Z"));
	mtk_pd_cali_get_capture_num pd_cali_get_capture_num	=	(mtk_pd_cali_get_capture_num)(QLibrary::resolve(strLibPath, "?pd_cali_get_capture_num@@YA?AW4PD_ERR_CODE@@AEAH@Z"));
	mtk_pd_cali_get_raw_width_height pd_cali_get_raw_width_height	=	(mtk_pd_cali_get_raw_width_height)(QLibrary::resolve(strLibPath, "?pd_cali_get_raw_width_height@@YA?AW4PD_ERR_CODE@@AEAH0@Z"));
	mtk_pd_cali_proc1 pd_cali_proc1	=	(mtk_pd_cali_proc1)(QLibrary::resolve(strLibPath, "?pd_cali_proc1@@YA?AW4PD_ERR_CODE@@PEAGPEADHAEAH@Z"));
	mtk_pd_cali_proc2 pd_cali_proc2	=	(mtk_pd_cali_proc2)(QLibrary::resolve(strLibPath, "?pd_cali_proc2@@YA?AW4PD_ERR_CODE@@PEAPEADPEAHHPEADHAEAH@Z"));
	mtk_pd_cali_verify pd_cali_verify	=	(mtk_pd_cali_verify)(QLibrary::resolve(strLibPath, "?pd_cali_verify@@YA?AW4PD_ERR_CODE@@PEAE@Z"));
	mtk_pd_cali_verify_proc1 pd_cali_verify_proc1	=	(mtk_pd_cali_verify_proc1)(QLibrary::resolve(strLibPath, "?pd_cali_verify_proc1@@YA?AW4PD_ERR_CODE@@PEAE@Z"));
	mtk_pd_cali_verify_proc2 pd_cali_verify_proc2	=	(mtk_pd_cali_verify_proc2)(QLibrary::resolve(strLibPath, "?pd_cali_verify_proc2@@YA?AW4PD_ERR_CODE@@PEAE@Z"));
	mtk_pd_cali_get_DAC_proc2 pd_cali_get_DAC_proc2	=	(mtk_pd_cali_get_DAC_proc2)(QLibrary::resolve(strLibPath, "?pd_cali_get_DAC_proc2@@YA?AW4PD_ERR_CODE@@PEAEAEAH@Z"));
#else
	mtk_pd_cali_init pd_cali_init	=	(mtk_pd_cali_init)(QLibrary::resolve(strLibPath, "?pd_cali_init@@YA?AW4PD_ERR_CODE@@PAD@Z"));
	mtk_pd_cali_get_max_output_size pd_cali_get_max_output_size	=	(mtk_pd_cali_get_max_output_size)(QLibrary::resolve(strLibPath, "?pd_cali_get_max_output_size@@YA?AW4PD_ERR_CODE@@AAH@Z"));
	mtk_pd_cali_get_capture_num pd_cali_get_capture_num	=	(mtk_pd_cali_get_capture_num)(QLibrary::resolve(strLibPath, "?pd_cali_get_capture_num@@YA?AW4PD_ERR_CODE@@AAH@Z"));
	mtk_pd_cali_get_raw_width_height pd_cali_get_raw_width_height	=	(mtk_pd_cali_get_raw_width_height)(QLibrary::resolve(strLibPath, "?pd_cali_get_raw_width_height@@YA?AW4PD_ERR_CODE@@AAH0@Z"));
	mtk_pd_cali_proc1 pd_cali_proc1	=	(mtk_pd_cali_proc1)(QLibrary::resolve(strLibPath, "?pd_cali_proc1@@YA?AW4PD_ERR_CODE@@PAGPADHAAH@Z"));
	mtk_pd_cali_proc2 pd_cali_proc2	=	(mtk_pd_cali_proc2)(QLibrary::resolve(strLibPath, "?pd_cali_proc2@@YA?AW4PD_ERR_CODE@@PAPADPAHHPADHAAH@Z"));
	mtk_pd_cali_verify pd_cali_verify	=	(mtk_pd_cali_verify)(QLibrary::resolve(strLibPath, "?pd_cali_verify@@YA?AW4PD_ERR_CODE@@PAE@Z"));
	mtk_pd_cali_verify_proc1 pd_cali_verify_proc1	=	(mtk_pd_cali_verify_proc1)(QLibrary::resolve(strLibPath, "?pd_cali_verify_proc1@@YA?AW4PD_ERR_CODE@@PAE@Z"));
	mtk_pd_cali_verify_proc2 pd_cali_verify_proc2	=	(mtk_pd_cali_verify_proc2)(QLibrary::resolve(strLibPath, "?pd_cali_verify_proc2@@YA?AW4PD_ERR_CODE@@PAE@Z"));
	mtk_pd_cali_get_DAC_proc2 pd_cali_get_DAC_proc2	=	(mtk_pd_cali_get_DAC_proc2)(QLibrary::resolve(strLibPath, "?pd_cali_get_DAC_proc2@@YA?AW4PD_ERR_CODE@@PAEAAH@Z"));
#endif	
	if(!(pd_cali_init && pd_cali_get_max_output_size && pd_cali_get_capture_num && pd_cali_get_raw_width_height && \
		pd_cali_proc1 && pd_cali_proc2 && pd_cali_verify && pd_cali_verify_proc1 && pd_cali_verify_proc2 && pd_cali_get_DAC_proc2)){
			emit information(tr("Resolve MTK PDAF DLL Function Fail"));
			itemshareData.itemparameterLock.unlock();
			return HisCCMError_LoadDLLFuc;
	}

#ifdef _WIN64
	mtkv2_pd_cali_get_data_format_version pd_cali_get_data_format_version	=	(mtkv2_pd_cali_get_data_format_version)(QLibrary::resolve(strLibPath, "?pd_cali_get_data_format_version@@YA?AW4PD_ERR_CODE@@PEAEAEAH@Z"));
	mtkv2_pd_cali_get_linearity pd_cali_get_linearity	=	(mtkv2_pd_cali_get_linearity)(QLibrary::resolve(strLibPath, "?pd_cali_get_linearity@@YA?AW4PD_ERR_CODE@@PEAEPEAN@Z"));
	mtkv2_pd_cali_get_linearity_size pd_cali_get_linearity_size	=	(mtkv2_pd_cali_get_linearity_size)(QLibrary::resolve(strLibPath, "?pd_cali_get_linearity_size@@YA?AW4PD_ERR_CODE@@PEAEAEAH1@Z"));
#else
	mtkv2_pd_cali_get_data_format_version pd_cali_get_data_format_version	=	(mtkv2_pd_cali_get_data_format_version)(QLibrary::resolve(strLibPath, "?pd_cali_get_data_format_version@@YA?AW4PD_ERR_CODE@@PAEAAH@Z"));
	mtkv2_pd_cali_get_linearity pd_cali_get_linearity	=	(mtkv2_pd_cali_get_linearity)(QLibrary::resolve(strLibPath, "?pd_cali_get_linearity@@YA?AW4PD_ERR_CODE@@PAEPAN@Z"));
	mtkv2_pd_cali_get_linearity_size pd_cali_get_linearity_size	=	(mtkv2_pd_cali_get_linearity_size)(QLibrary::resolve(strLibPath, "?pd_cali_get_linearity_size@@YA?AW4PD_ERR_CODE@@PAEAAH1@Z"));
#endif
	if(!(pd_cali_get_data_format_version && pd_cali_get_linearity && pd_cali_get_linearity_size)){
		emit information(tr("Resolve MTK PDAF DLL Function Fail"));
		itemshareData.itemparameterLock.unlock();
		return HisCCMError_LoadDLLFuc;
	}


	//IMX258
	if(itemshareData.pdafParameter->bSONY258MTKCal)
	{
		iresult=ApplySONYIMX258SPC();
		if(iresult)
		{
			emit information(QTextCodec::codecForName( "GBK")->toUnicode("Apply SONY IMX258 SPC 失败"));
			itemshareData.itemparameterLock.unlock();
			return iresult;
		}
	}


	QString strIniPath	=	QDir::currentPath() % "/pdaftemplate/MTK/" % itemshareData.ccmhardwareParameter->projectname % "/pd_pos_info.ini";

	PD_ERR_CODE mtkError	=	pd_cali_init(strIniPath.toAscii().data());
	if(iresult	=	MTkErrorcodeConvert(mtkError)){
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("pd_cali_init调用失败"));
		itemshareData.itemparameterLock.unlock();
		return iresult;
	}

	int iMaxOutputSize;
	mtkError	=	pd_cali_get_max_output_size(iMaxOutputSize);
	int iCaptureNum;
	mtkError	=	pd_cali_get_capture_num(iCaptureNum);

	emit information(tr("max output size:") % QString::number(iMaxOutputSize));
	emit information(tr("max capture frame:") % QString::number(iCaptureNum));

	motorScaleto1023(itemshareData.ccmhardwareParameter->motortype.toAscii().data(), iInfiniteMotor, iInfiniteMotor);
	motorScaleto1023(itemshareData.ccmhardwareParameter->motortype.toAscii().data(), iMacroMotor, iMacroMotor);

	int* piMotorStep	=	new int[iCaptureNum];
	if(!piMotorStep){
		itemshareData.itemparameterLock.unlock();
		return HisFX3Error_MallocBuffer;
	}
	int iData	=	(iMacroMotor-iInfiniteMotor) /(iCaptureNum-1);
	if(iMacroMotor-iInfiniteMotor - iData *(iCaptureNum-1) >= 5) ++iData;
	piMotorStep[0]						=	iInfiniteMotor;
	piMotorStep[iCaptureNum-1]	=	iMacroMotor;
	for(int i=1;	i<iCaptureNum;	++i){
		piMotorStep[i]	=	piMotorStep[i-1] + iData;
	}

	unsigned short** ppusRaw10	=	new unsigned short*[iCaptureNum];
	if(!ppusRaw10){
		HisReleaseNewB(piMotorStep);
		itemshareData.itemparameterLock.unlock();
		return HisFX3Error_MallocBuffer;
	}
	for(int i=0;	i<iCaptureNum;	++i)
		ppusRaw10[i]	= 0;

	unsigned int uiPixel	=	itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight *2;

	int iMotorValue;
	motorScalefrom1023(itemshareData.ccmhardwareParameter->motortype.toAscii().data(), piMotorStep[0], iMotorValue);

	iresult =	setMotor((itemshareData.ccmhardwareParameter->motortype.toAscii()).data(), \
		itemshareData.previewParameter->ucSlave, \
		(itemshareData.ccmhardwareParameter->projectname.toAscii()).data(), iMotorValue, \
		globalFunPointer.ReadHisFX3IIC, globalFunPointer.WriteHisFX3IIC, globalFunPointer.SetHisFX3IICSpeed, globalFunPointer.PullHisFX3RESET, globalFunPointer.PullHisFX3PWND, \
		globalFunPointer.PageWriteHisFX3IIC, globalFunPointer.PageReadHisFX3IIC, globalFunPointer.HisFX3PageWriteSPI, globalFunPointer.HisFX3PageReadSPI);
	emit information(QTextCodec::codecForName( "GBK")->toUnicode("第1步马达：") % QString::number(iMotorValue));
	if(iresult){
		HisReleaseNewB(ppusRaw10);
		HisReleaseNewB(piMotorStep);
		itemshareData.itemparameterLock.unlock();
		return iresult;
	}
	DWORD dwend, dwstart	=	::GetTickCount();

	//****************** by feng 20180129 **************
	ppusRaw10[0]	=	(unsigned short*)_aligned_malloc(uiPixel, _HisCacheLine_Aligned);

	if(hisglobalparameter.bDebugMode){
	QDir classDir;
	strIniPath	=	QDir::currentPath() % "/mtkpdaflog";
	classDir.mkpath(strIniPath);
	ROPLOW::saveRaw10(strIniPath, strSerialNumber % "_MTK_20CM_Motor_" % QString::number(1)%"_DAC_"%QString::number(iMotorValue), itemshareData.previewParameter->ucDataFormat, \
	itemshareData.previewParameter->iWidth, itemshareData.previewParameter->iHeight, (void*)(ppusRaw10[0]));
	}



	//***************************************************


	for(int i=1;	i<=iCaptureNum;	++i){
		ppusRaw10[i-1]	=	(unsigned short*)_aligned_malloc(uiPixel, _HisCacheLine_Aligned);
		if(!ppusRaw10[i-1]){
			for(int x=0;	x<iCaptureNum;	++x)
				HisReleaseMalloc(ppusRaw10[x]);
			HisReleaseNewB(ppusRaw10);
			HisReleaseNewB(piMotorStep);
			itemshareData.itemparameterLock.unlock();
			return iresult;
		}

		dwend	=	::GetTickCount();
		if(dwstart + itemshareData.pdafParameter->uiMotorSleep > dwend)
			::Sleep(dwstart + itemshareData.pdafParameter->uiMotorSleep - dwend);
		//********** 捉图 ******************
		iresult	=	GetFreshframe((unsigned char*)(ppusRaw10[i-1]), uiPixel, _FrameType_Raw10, (i==1)?(true):(false));
		if(iresult){
			for(int x=0;	x<iCaptureNum;	++x)
				HisReleaseMalloc(ppusRaw10[x]);
			HisReleaseNewB(ppusRaw10);
			HisReleaseNewB(piMotorStep);
			itemshareData.itemparameterLock.unlock();
			return iresult;
		}
		//*************************************

		if(i != iCaptureNum){
			motorScalefrom1023(itemshareData.ccmhardwareParameter->motortype.toAscii().data(), piMotorStep[i], iMotorValue);
			iresult =	setMotor((itemshareData.ccmhardwareParameter->motortype.toAscii()).data(), \
				itemshareData.previewParameter->ucSlave, \
				(itemshareData.ccmhardwareParameter->projectname.toAscii()).data(), iMotorValue, \
				globalFunPointer.ReadHisFX3IIC, globalFunPointer.WriteHisFX3IIC, globalFunPointer.SetHisFX3IICSpeed, globalFunPointer.PullHisFX3RESET, globalFunPointer.PullHisFX3PWND, \
				globalFunPointer.PageWriteHisFX3IIC, globalFunPointer.PageReadHisFX3IIC, globalFunPointer.HisFX3PageWriteSPI, globalFunPointer.HisFX3PageReadSPI);
			emit information(QTextCodec::codecForName( "GBK")->toUnicode("第") % QString::number(i+1) % \
				QTextCodec::codecForName( "GBK")->toUnicode("步马达：") % QString::number(iMotorValue));
			if(iresult){
				for(int x=0;	x<iCaptureNum;	++x)
					HisReleaseMalloc(ppusRaw10[x]);
				HisReleaseNewB(ppusRaw10);
				HisReleaseNewB(piMotorStep);
				itemshareData.itemparameterLock.unlock();
				return iresult;
			}
			dwstart	=	::GetTickCount();
		}


		if(hisglobalparameter.bDebugMode){
			QDir classDir;
			strIniPath	=	QDir::currentPath() % "/mtkpdaflog";
			classDir.mkpath(strIniPath);
			ROPLOW::saveRaw10(strIniPath, strSerialNumber % "_MTK_20CM_Motor_" % QString::number(i)%"_DAC_"%QString::number(piMotorStep[i-1]), itemshareData.previewParameter->ucDataFormat, \
				itemshareData.previewParameter->iWidth, itemshareData.previewParameter->iHeight, (void*)(ppusRaw10[i-1]));
		}
	}

	char* pstrOutput	=	new char[iMaxOutputSize];
	if(!pstrOutput){
		for(int x=0;	x<iCaptureNum;	++x)
			HisReleaseMalloc(ppusRaw10[x]);
		HisReleaseNewB(ppusRaw10);
		HisReleaseNewB(piMotorStep);
		itemshareData.itemparameterLock.unlock();
		return HisFX3Error_MallocBuffer;
	}

	int iOutputSize	=	0;
	mtkError	=	pd_cali_proc2((char**)(ppusRaw10), piMotorStep, iCaptureNum, pstrOutput, iMaxOutputSize, iOutputSize);
	for(int x=0;	x<iCaptureNum;	++x)
	HisReleaseMalloc(ppusRaw10[x]);
	HisReleaseNewB(ppusRaw10);
	HisReleaseNewB(piMotorStep)
		if(iresult	=	MTkErrorcodeConvert(mtkError)){
			emit information(QTextCodec::codecForName( "GBK")->toUnicode("pd_cali_proc2调用失败"));
			HisReleaseNewB(pstrOutput);
			itemshareData.itemparameterLock.unlock();
			return iresult;
		}

		emit information(QTextCodec::codecForName( "GBK")->toUnicode("step2 输出大小(BYTE)：") % QString::number(iOutputSize));

		mtkError	=	pd_cali_verify_proc2((unsigned char*)(pstrOutput));
		if(iresult		=	MTkErrorcodeConvert(mtkError)){
			emit information(QTextCodec::codecForName( "GBK")->toUnicode("pd_cali_verify_proc2调用失败"));
			HisReleaseNewB(pstrOutput);
			itemshareData.itemparameterLock.unlock();
			return iresult;
		}

		if(hisglobalparameter.bDebugMode){
			QDir classDir;
			strIniPath	=	QDir::currentPath() % "/mtkpdaflog";
			classDir.mkpath(strIniPath);
			strIniPath	=	strIniPath % "/" % strSerialNumber % "_MTK_PDAF_Step2_Write_F1.bin";
			FILE* fileStep1	=	fopen(strIniPath.toAscii().data(), "wb");
			if(fileStep1 != NULL){
				fwrite(pstrOutput, 1, iOutputSize, fileStep1);
				fclose(fileStep1);
			}
		}

		mtkError	=	pd_cali_get_DAC_proc2((unsigned char*)(pstrOutput), iMotorValue);
		if(iresult		=	MTkErrorcodeConvert(mtkError)){
			emit information(QTextCodec::codecForName( "GBK")->toUnicode("pd_cali_get_DAC_proc2调用失败"));
			HisReleaseNewB(pstrOutput);

			itemshareData.itemparameterLock.unlock();
			return iresult;
		}

		motorScalefrom1023(itemshareData.ccmhardwareParameter->motortype.toAscii().data(), iMotorValue, iMotorValue);
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("20CM对焦清晰位置：") % QString::number(iMotorValue));
		iresult =	setMotor((itemshareData.ccmhardwareParameter->motortype.toAscii()).data(), \
			itemshareData.previewParameter->ucSlave, \
			(itemshareData.ccmhardwareParameter->projectname.toAscii()).data(), iMotorValue, \
			globalFunPointer.ReadHisFX3IIC, globalFunPointer.WriteHisFX3IIC, globalFunPointer.SetHisFX3IICSpeed, globalFunPointer.PullHisFX3RESET, globalFunPointer.PullHisFX3PWND, \
			globalFunPointer.PageWriteHisFX3IIC, globalFunPointer.PageReadHisFX3IIC, globalFunPointer.HisFX3PageWriteSPI, globalFunPointer.HisFX3PageReadSPI);
		if(iresult){
			emit information(QTextCodec::codecForName( "GBK")->toUnicode("设置马达位置错误"));
			HisReleaseNewB(pstrOutput);
			itemshareData.itemparameterLock.unlock();
			return iresult;
		}

		if(itemshareData.pdafParameter->bEnableMTKStep2Verify)
		{     
			int iCDAFDAC=0;
			iresult=PDAFSTEP2Verify(iMotorValue,iCDAFDAC,itemshareData.previewParameter->iWidth,itemshareData.previewParameter->iHeight);
			if(iresult)
			{
				emit information(QTextCodec::codecForName( "GBK")->toUnicode("PDAF Verify fail"));
				HisReleaseNewB(pstrOutput);
				itemshareData.itemparameterLock.unlock();
				return iresult;
			}
		}

		_HisCCMMTKPDAFBurn_Config stPDAFConfig;
		stPDAFConfig.bDebug					=		hisglobalparameter.bDebugMode;
		stPDAFConfig.ucSensorSlave		=		itemshareData.previewParameter->ucSlave;
		stPDAFConfig.strproject					=		itemshareData.ccmhardwareParameter->projectname.toAscii().data();
		stPDAFConfig.strsensor					=		itemshareData.ccmhardwareParameter->sensortype.toAscii().data();
		stPDAFConfig.strDriverIC				=		itemshareData.ccmhardwareParameter->motortype.toAscii().data();
		stPDAFConfig.strFunctionChoose	=	itemshareData.pdafParameter->strPDAFChoose.toAscii().data();
		stPDAFConfig.ucEESlave				=	itemshareData.ccmhardwareParameter->ucEESlave;
		stPDAFConfig.ucTpye					=	2;
		stPDAFConfig.uiDataSize				=	iOutputSize;
		stPDAFConfig.uiStep1Size =itemshareData.pdafParameter->usMTKV2Step1dataSize;
		stPDAFConfig.uiStep2Size =iOutputSize;
		stPDAFConfig.Reserve1.u16value[3]	=	itemshareData.pdafParameter->usVersion[3];
		stPDAFConfig.Reserve1.u16value[2]	=	itemshareData.pdafParameter->usVersion[2];
		stPDAFConfig.Reserve1.u16value[1]	=	itemshareData.pdafParameter->usVersion[1];
		stPDAFConfig.Reserve1.u16value[0]	=	itemshareData.pdafParameter->usVersion[0];

		memset(stPDAFConfig.ucData,0,2048);
		memcpy(stPDAFConfig.ucData, pstrOutput, stPDAFConfig.uiDataSize);
		if(itemshareData.pdafParameter->bSONY258MTKCal) 
		{
			stPDAFConfig.bSONYIMX258Cal=true;
		}
		else
		{
			stPDAFConfig.bSONYIMX258Cal=false;
		}

		emit enableinfotimer(1);
		iresult	=	writeMTKPDAF(*globalFunPointer.vectorHisCCMOTPInfoW, &stPDAFConfig, globalFunPointer.ReadHisFX3IIC, globalFunPointer.WriteHisFX3IIC, globalFunPointer.SetHisFX3IICSpeed, \
			globalFunPointer.SetHisFX3Voltage, globalFunPointer.GetHisFX3Voltage, SetHisFX3VFuseVolt, GetHisFX3VFuseVolt, GetFreshframe, \
			globalFunPointer.BatchWriteHisFX3IIC, globalFunPointer.BatchReadHisFX3IIC, SetHisFX3GPIO, GetHisFX3GPIO, globalFunPointer.PullHisFX3RESET, globalFunPointer.PullHisFX3PWND, \
			globalFunPointer.BatchReadHisFX3IICNoLimit, globalFunPointer.BatchWriteHisFX3IICNoLimit, globalFunPointer.HisFX3LogPush_back, \
			globalFunPointer.PageWriteHisFX3IIC, globalFunPointer.PageReadHisFX3IIC, globalFunPointer.HisFX3PageWriteSPI, globalFunPointer.HisFX3PageReadSPI);
		emit enableinfotimer(0);
		if(iresult){
			emit information(QTextCodec::codecForName( "GBK")->toUnicode("写入PDAF Step2 数据失败"));
			HisReleaseNewB(pstrOutput);
			itemshareData.itemparameterLock.unlock();
			return iresult;
		}

		HisReleaseNewB(pstrOutput);
		itemshareData.itemparameterLock.unlock();
		return 0;
}

//***************************  HISI ****************************
int itemprocess::HISIPDAFSTEP1_WhitePannel()
{
	itemshareData.itemparameterLock.lockForRead();

	QString strSerialNumber;
	classLog->getserialnumber(strSerialNumber);
	QString strHISIDir;
	if(!strSerialNumber.isEmpty()){
		strHISIDir	=	QDir::currentPath() % "/HISIPDAF/" % strSerialNumber;
		QDir classTempDir;
		if(!classTempDir.mkpath(strHISIDir)) strHISIDir.clear();
	}


	_HisCCMAFBurn_Config stAFConfig;
	stAFConfig.bDebug						=	hisglobalparameter.bDebugMode;
	stAFConfig.strDriverIC				=	(itemshareData.ccmhardwareParameter->motortype.toAscii()).data();
	stAFConfig.strproject					=	itemshareData.ccmhardwareParameter->projectname.toAscii().data();
	stAFConfig.strsensor					=	itemshareData.ccmhardwareParameter->sensortype.toAscii().data();
	stAFConfig.bNear						=	true;
	stAFConfig.bInfinite						=	true;
	stAFConfig.iwidth						=	itemshareData.previewParameter->iWidth;
	stAFConfig.iheight						=	itemshareData.previewParameter->iHeight;
	stAFConfig.strFunctionChoose	=	itemshareData.pdafParameter->strAFChoose.toAscii().data();
	stAFConfig.ucSlave					=	itemshareData.previewParameter->ucSlave;
	stAFConfig.uiDataFormat			=	itemshareData.previewParameter->ucDataFormat;
	stAFConfig.ucEESlave				=	itemshareData.ccmhardwareParameter->ucEESlave;
	stAFConfig.strSerialNumber	=	strSerialNumber.toAscii().data();

#if (defined _WIN64) && (defined _DEBUG)
	QString strLibPath	=	QDir::currentPath() % "/HisCCMOTP64D";
#elif (defined _WIN64) && !(defined _DEBUG)
	QString strLibPath	=	QDir::currentPath() % "/HisCCMOTP64";
#elif (defined _WIN32) && (defined _DEBUG)
	QString strLibPath	=	QDir::currentPath() % "/HisCCMOTP32D";
#else
	QString strLibPath	=	QDir::currentPath() % "/HisCCMOTP32";
#endif

	RolongoOTPAPIVersion getRolongoOTPAPIVersion = (RolongoOTPAPIVersion)(QLibrary::resolve(strLibPath, "getRolongoOTPAPIVersion"));
	Rolongocheckafmotor checkafmotor = (Rolongocheckafmotor)(QLibrary::resolve(strLibPath, "checkafmotor"));
	RolongowriteHISIPDAF writeHISIPDAF = (RolongowriteHISIPDAF)(QLibrary::resolve(strLibPath, "writeHISIPDAF"));

	if(!(getRolongoOTPAPIVersion && checkafmotor && writeHISIPDAF)){
		emit information(tr("Resolve HisCCMOTP DLL Function Fail"));
		itemshareData.itemparameterLock.unlock();
		return HisCCMError_LoadDLLFuc;
	}

	int iresult=0;
	if(!threadshareData.bOfflineMode){
		emit enableinfotimer(1);
		iresult	=	checkafmotor(*globalFunPointer.vectorHisCCMOTPInfoW, &stAFConfig, globalFunPointer.ReadHisFX3IIC, globalFunPointer.WriteHisFX3IIC, globalFunPointer.SetHisFX3IICSpeed, globalFunPointer.SetHisFX3Voltage, \
			globalFunPointer.GetHisFX3Voltage, SetHisFX3VFuseVolt, GetHisFX3VFuseVolt, GetFreshframe, SetHisFX3GPIO, GetHisFX3GPIO, \
			globalFunPointer.PullHisFX3RESET, globalFunPointer.PullHisFX3PWND, globalFunPointer.BatchReadHisFX3IICNoLimit, globalFunPointer.BatchWriteHisFX3IICNoLimit, \
			globalFunPointer.HisFX3LogPush_back, globalFunPointer.PageWriteHisFX3IIC, globalFunPointer.PageReadHisFX3IIC, \
			globalFunPointer.HisFX3PageWriteSPI, globalFunPointer.HisFX3PageReadSPI);
		emit enableinfotimer(0);
		if(iresult){
			itemshareData.itemparameterLock.unlock();
			return iresult;
		}

		int iInfiniteMotor	=	stAFConfig.iInfinitMotor;
		int iMacroMotor	=	stAFConfig.iNearMotor;

		emit information(QTextCodec::codecForName( "GBK")->toUnicode("近焦位置：") % QString::number(iMacroMotor));
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("远焦位置：") % QString::number(iInfiniteMotor));
	}

	unsigned int uiPixel	=	itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight *2;
	unsigned short* pusRaw10	=	(unsigned short*)_aligned_malloc(uiPixel, _HisCacheLine_Aligned);
	if(!pusRaw10){
		HisReleaseMalloc(pusRaw10);
		itemshareData.itemparameterLock.unlock();
		return HisFX3Error_MallocBuffer;
	}

	iresult	=	GetFreshframe((unsigned char*)(pusRaw10), uiPixel, _FrameType_Raw10, true);
	if(iresult){
		HisReleaseMalloc(pusRaw10);
		itemshareData.itemparameterLock.unlock();
		return iresult;
	}

	QString strPath=QDir::currentPath()+"/pdaflib/hisi";
	QDir dir(strPath);
	if(!dir.exists()){
		emit information(QString::fromLocal8Bit("创建文件夹")+dir.path());
		if(!dir.mkdir(dir.path())){
			HisReleaseMalloc(pusRaw10);
			itemshareData.itemparameterLock.unlock();
			return -1;
		}
	}

	QString strFileName=dir.path()+"/GM.raw";
	QFile file(strFileName);
	file.open(QIODevice::ReadWrite);
	file.write((char*)pusRaw10,uiPixel);
	file.close();

	HisReleaseMalloc(pusRaw10);

	//********* PDAF Gain Map ***************************
	int raw_idx = -1;
	int returnCode =pdaf_gm_cal_main(strFileName.toLocal8Bit().data(), -1);
	if (returnCode) {
		print_gm_error_code(returnCode, raw_idx);
		emit information(QString("Error Code:")+QString::number(returnCode));
		return -1;
	}
	else {
		emit information("Make a gain map(Left/Right) using flat image successfully.");
		raw_idx++;
	}

	// Make a Gain Map Data File (raw_idx : 0)
	returnCode = pdaf_gm_cal_main((strFileName.remove(".raw")+".dat").toLocal8Bit().data(), raw_idx);
	print_gm_error_code(returnCode, raw_idx);

	if(returnCode)
		return returnCode;

	//********* Burn PDAF ********************
	INT iOutputSize=1024;

	_HisCCMMTKPDAFBurn_Config stPDAFConfig;
	stPDAFConfig.bDebug					=		hisglobalparameter.bDebugMode;
	stPDAFConfig.ucSensorSlave		=		itemshareData.previewParameter->ucSlave;
	stPDAFConfig.strproject					=		itemshareData.ccmhardwareParameter->projectname.toAscii().data();
	stPDAFConfig.strsensor					=		itemshareData.ccmhardwareParameter->sensortype.toAscii().data();
	stPDAFConfig.strDriverIC				=		itemshareData.ccmhardwareParameter->motortype.toAscii().data();
	stPDAFConfig.strFunctionChoose	=	itemshareData.pdafParameter->strHISIPDAFChoose.toAscii().data();
	stPDAFConfig.ucEESlave				=	itemshareData.ccmhardwareParameter->ucEESlave;
	stPDAFConfig.ucTpye					=	1;
	stPDAFConfig.uiDataSize				=	iOutputSize;
	stPDAFConfig.uiStep1Size=iOutputSize;
	stPDAFConfig.uiStep2Size =itemshareData.pdafParameter->usMTKV2Step2dataSize;
	stPDAFConfig.Reserve1.u16value[3]	=	itemshareData.pdafParameter->usVersion[3];
	stPDAFConfig.Reserve1.u16value[2]	=	itemshareData.pdafParameter->usVersion[2];
	stPDAFConfig.Reserve1.u16value[1]	=	itemshareData.pdafParameter->usVersion[1];
	stPDAFConfig.Reserve1.u16value[0]	=	itemshareData.pdafParameter->usVersion[0];
	memset(stPDAFConfig.ucData,0,2048);

	emit enableinfotimer(1);
	iresult	=	writeHISIPDAF(*globalFunPointer.vectorHisCCMOTPInfoW, &stPDAFConfig, globalFunPointer.ReadHisFX3IIC, globalFunPointer.WriteHisFX3IIC, globalFunPointer.SetHisFX3IICSpeed, \
		globalFunPointer.SetHisFX3Voltage, globalFunPointer.GetHisFX3Voltage, SetHisFX3VFuseVolt, GetHisFX3VFuseVolt, GetFreshframe, \
		globalFunPointer.BatchWriteHisFX3IIC, globalFunPointer.BatchReadHisFX3IIC, SetHisFX3GPIO, GetHisFX3GPIO, globalFunPointer.PullHisFX3RESET, globalFunPointer.PullHisFX3PWND, \
		globalFunPointer.BatchReadHisFX3IICNoLimit, globalFunPointer.BatchWriteHisFX3IICNoLimit, globalFunPointer.HisFX3LogPush_back, \
		globalFunPointer.PageWriteHisFX3IIC, globalFunPointer.PageReadHisFX3IIC, globalFunPointer.HisFX3PageWriteSPI, globalFunPointer.HisFX3PageReadSPI);
	emit enableinfotimer(0);
	if(iresult){
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("写入PDAF Step1 数据失败"));
		itemshareData.itemparameterLock.unlock();
		return iresult;
	}

	itemshareData.itemparameterLock.unlock();

	return 0;
}

int itemprocess::HISIPDAFSTEP2_20CM(){
	itemshareData.itemparameterLock.lockForRead();

	if(itemshareData.pdafParameter->usVersion[3] == 1 ){
		emit information(tr("The MTK PDAF lib version you chosen is not support V1 "));
		itemshareData.itemparameterLock.unlock();
		return HisFX3Error_Parameter;
	}

	QString strSerialNumber;
	classLog->getserialnumber(strSerialNumber);

	_HisCCMAFBurn_Config stAFConfig;
	stAFConfig.bDebug						=	hisglobalparameter.bDebugMode;
	stAFConfig.strDriverIC				=	(itemshareData.ccmhardwareParameter->motortype.toAscii()).data();
	stAFConfig.strproject					=	itemshareData.ccmhardwareParameter->projectname.toAscii().data();
	stAFConfig.strsensor					=	itemshareData.ccmhardwareParameter->sensortype.toAscii().data();
	stAFConfig.bNear						=	true;
	stAFConfig.bInfinite						=	true;
	stAFConfig.iwidth						=	itemshareData.previewParameter->iWidth;
	stAFConfig.iheight						=	itemshareData.previewParameter->iHeight;
	stAFConfig.strFunctionChoose	=	itemshareData.pdafParameter->strAFChoose.toAscii().data();
	stAFConfig.ucSlave					=	itemshareData.previewParameter->ucSlave;
	stAFConfig.uiDataFormat			=	itemshareData.previewParameter->ucDataFormat;
	stAFConfig.ucEESlave				=	itemshareData.ccmhardwareParameter->ucEESlave;
	stAFConfig.strSerialNumber	=	strSerialNumber.toAscii().data();

#if (defined _WIN64) && (defined _DEBUG)
	QString strLibPath	=	QDir::currentPath() % "/HisCCMOTP64D";
#elif (defined _WIN64) && !(defined _DEBUG)
	QString strLibPath	=	QDir::currentPath() % "/HisCCMOTP64";
#elif (defined _WIN32) && (defined _DEBUG)
	QString strLibPath	=	QDir::currentPath() % "/HisCCMOTP32D";
#else
	QString strLibPath	=	QDir::currentPath() % "/HisCCMOTP32";
#endif

	RolongoOTPAPIVersion getRolongoOTPAPIVersion = (RolongoOTPAPIVersion)(QLibrary::resolve(strLibPath, "getRolongoOTPAPIVersion"));
	Rolongocheckafmotor checkafmotor = (Rolongocheckafmotor)(QLibrary::resolve(strLibPath, "checkafmotor"));
	RolongowriteHISIPDAF writeHISIPDAF = (RolongowriteHISIPDAF)(QLibrary::resolve(strLibPath, "writeHISIPDAF"));

	if(!(getRolongoOTPAPIVersion && checkafmotor && writeHISIPDAF)){
		emit information(tr("Resolve HisCCMOTP DLL Function Fail"));
		itemshareData.itemparameterLock.unlock();
		return HisCCMError_LoadDLLFuc;
	}

	emit enableinfotimer(1);
	int iresult	=	checkafmotor(*globalFunPointer.vectorHisCCMOTPInfoW, &stAFConfig, globalFunPointer.ReadHisFX3IIC, globalFunPointer.WriteHisFX3IIC, globalFunPointer.SetHisFX3IICSpeed, globalFunPointer.SetHisFX3Voltage, \
		globalFunPointer.GetHisFX3Voltage, SetHisFX3VFuseVolt, GetHisFX3VFuseVolt, GetFreshframe, SetHisFX3GPIO, GetHisFX3GPIO, \
		globalFunPointer.PullHisFX3RESET, globalFunPointer.PullHisFX3PWND, globalFunPointer.BatchReadHisFX3IICNoLimit, globalFunPointer.BatchWriteHisFX3IICNoLimit, \
		globalFunPointer.HisFX3LogPush_back, globalFunPointer.PageWriteHisFX3IIC, globalFunPointer.PageReadHisFX3IIC, \
		globalFunPointer.HisFX3PageWriteSPI, globalFunPointer.HisFX3PageReadSPI);
	emit enableinfotimer(0);
	if(iresult){
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("获取远近焦烧录数据失败"));
		itemshareData.itemparameterLock.unlock();
		return iresult;
	}

	int iInfiniteMotor	=	stAFConfig.iInfinitMotor;
	int iMacroMotor	=	stAFConfig.iNearMotor;

	emit information(QTextCodec::codecForName( "GBK")->toUnicode("近焦位置：") % QString::number(iMacroMotor));
	emit information(QTextCodec::codecForName( "GBK")->toUnicode("远焦位置：") % QString::number(iInfiniteMotor));

//******************** DCC *********************************************
	unsigned int uiPixel	=	itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight*2;
	unsigned short* ppusRaw10	=	new unsigned short[uiPixel/2];
	if(!ppusRaw10){
		itemshareData.itemparameterLock.unlock();
		return HisFX3Error_MallocBuffer;
	}


	//***********************  DCC AF CODE(Calculate) ***********************************
	int iMotorValue[10]={0};
	iMotorValue[0]=iInfiniteMotor;
	//iMotorValue[9]=iMacroMotor;

	int iMotorStep=int((double)(iMacroMotor-iInfiniteMotor)/9+0.5f);
	for (int i=1;i<=9;i++)
	{
		iMotorValue[i]=iInfiniteMotor+i*iMotorStep;
	}

	//**************************** Save Image ********************************
	for (int i=0;i<10;i++)
	{
		emit information(QString("Move Motor :%1 Index:%2").arg(iMotorValue[i]).arg(i));
		iresult =	setMotor((itemshareData.ccmhardwareParameter->motortype.toAscii()).data(), \
			itemshareData.previewParameter->ucSlave, \
			(itemshareData.ccmhardwareParameter->projectname.toAscii()).data(), iMotorValue[i], \
			globalFunPointer.ReadHisFX3IIC, globalFunPointer.WriteHisFX3IIC, globalFunPointer.SetHisFX3IICSpeed, globalFunPointer.PullHisFX3RESET, globalFunPointer.PullHisFX3PWND, \
			globalFunPointer.PageWriteHisFX3IIC, globalFunPointer.PageReadHisFX3IIC, globalFunPointer.HisFX3PageWriteSPI, globalFunPointer.HisFX3PageReadSPI);

		if(iresult){
			HisReleaseNewB(ppusRaw10);
			itemshareData.itemparameterLock.unlock();
			return iresult;
		}
		
		
		::Sleep(itemshareData.pdafParameter->uiMotorSleep);
		iresult	=	GetFreshframe((unsigned char*)(ppusRaw10), uiPixel, _FrameType_Raw10, (i==0)?(true):(false));
		if(iresult){
			emit information(QString::fromLocal8Bit("捉图失败！"));
			itemshareData.itemparameterLock.unlock();
			return iresult;
		}

		QString strFileName=QDir::currentPath()+"/pdaflib/hisi/"+QString("%1.raw").arg(i);
		QFile file(strFileName);
		file.open(QIODevice::ReadWrite);
		file.write((char*)ppusRaw10,uiPixel);
		file.close();
	}

	//**********************************  Calculate DCC Data ************************************
	int raw_idx = -1;
	int returnCode = 0;
	char input_name[1024];

	// Load a gain map from gain_map.dat file (raw_idx : -1)
	returnCode = pdaf_dm_cal_main((QDir::currentPath()+"/pdaflib/hisi/GM.dat").toLocal8Bit().data()\
		, raw_idx, 0);
	if (returnCode) {
		print_dm_error_code(returnCode, raw_idx);
		emit information(QString("Error Code:") + QString::number(returnCode));
		return -1;
	}
	else {
		emit information("Load a gain map(Left/Right) successfully.\n");
		raw_idx++;
	}

	// Cal. Chart Image for DCC Map (raw_idx : 0~9)
	for (int i = 0; i < 10; i++)
	{
		QString strFileName=QString("%1/pdaflib/hisi/%2.raw").arg(QDir::currentPath()).arg(i);
		returnCode = pdaf_dm_cal_main(strFileName.toLocal8Bit().data()\
			, raw_idx, iMotorValue[i]);
		if (returnCode) {
			print_dm_error_code(returnCode, raw_idx);
			emit information(QString("Error Step Index:%1\nError Code:%2").arg(i).arg(returnCode));
			itemshareData.itemparameterLock.unlock();
			return returnCode;
		}
		else {
			emit information(QString("#%1 cal. chart image was entered successfully.\n").arg(raw_idx + 1));
			if (raw_idx == 9) 
				emit information("Make a DCC map using cal. chart image successfully.\n");
			raw_idx++;
		}
	}

	// Make a Cal. Binary File (raw_idx : 10)
	QString strSaveDir=QString("%1/pdaflib/hisi/").arg(QDir::currentPath());
	returnCode = pdaf_dm_cal_main(strSaveDir.toLocal8Bit().data(), raw_idx, 0);
	print_dm_error_code(returnCode, raw_idx);
	if(returnCode){
		emit information(QString("DCC Calculate Fail!(Error Code:%1)").arg(returnCode));
		itemshareData.itemparameterLock.unlock();
		return returnCode;
	}
	
	//***************************** Verification **********************************************
	emit information("Start PDAF Verification");
	raw_idx = -1;

	// Load a Calibration Data

	returnCode = pdaf_verify_main(strSaveDir.toLocal8Bit().data(), raw_idx, 0);
	if (returnCode) {
		print_error_code(returnCode, raw_idx);
		emit information("Verify Fail!");
		itemshareData.itemparameterLock.unlock();
		return  returnCode;
	}
	else {
		emit information("Load a calibration data successfully.\n");
		raw_idx++;
	}

	// Image for Cal. Verification (raw_idx : 0~1)
	int lensPosition[] = { iMotorValue[0],iMotorValue[9]};
	for (int i = 0; i < 2; i++)
	{
		QString strFileName=QString("%1/pdaflib/hisi/0.raw").arg(QDir::currentPath());
		if(i)
			strFileName=QString("%1/pdaflib/hisi/9.raw").arg(QDir::currentPath());
		returnCode = pdaf_verify_main(strFileName.toLocal8Bit().data()\
			, raw_idx, lensPosition[i]);
		if (returnCode) {
			print_error_code(returnCode, raw_idx);
			emit information("Verify Fail!");
			itemshareData.itemparameterLock.unlock();
			return returnCode;
		}
		else {
			emit information(QString("#%1 verification chart image was entered successfully.\n").arg(raw_idx + 1));
			raw_idx++;
		}
	}

	// Decision whether calibration was passed or failed
	returnCode = pdaf_verify_main(strSaveDir.toLocal8Bit().data(), raw_idx, 0);
	print_error_code(returnCode, raw_idx);
	if(returnCode){
		emit information("Verify Fail!");
		itemshareData.itemparameterLock.unlock();
		return returnCode;
	}
	//****************************** Write *********************************************
	QFile filePdafBuffer(strSaveDir+"cal_data.bin");
	filePdafBuffer.open(QIODevice::ReadOnly);
	QByteArray pdafBuf=filePdafBuffer.readAll();
	filePdafBuffer.close();

		_HisCCMMTKPDAFBurn_Config stPDAFConfig;
		stPDAFConfig.bDebug					=		hisglobalparameter.bDebugMode;
		stPDAFConfig.ucSensorSlave		=		itemshareData.previewParameter->ucSlave;
		stPDAFConfig.strproject					=		itemshareData.ccmhardwareParameter->projectname.toAscii().data();
		stPDAFConfig.strsensor					=		itemshareData.ccmhardwareParameter->sensortype.toAscii().data();
		stPDAFConfig.strDriverIC				=		itemshareData.ccmhardwareParameter->motortype.toAscii().data();
		stPDAFConfig.strFunctionChoose	=	itemshareData.pdafParameter->strHISIPDAFChoose.toAscii().data();
		stPDAFConfig.ucEESlave				=	itemshareData.ccmhardwareParameter->ucEESlave;
		stPDAFConfig.ucTpye					=	2;
		stPDAFConfig.uiDataSize				=	filePdafBuffer.size();
		stPDAFConfig.uiStep1Size =0;
		stPDAFConfig.uiStep2Size =filePdafBuffer.size();
		stPDAFConfig.Reserve1.u16value[3]	=	itemshareData.pdafParameter->usVersion[3];
		stPDAFConfig.Reserve1.u16value[2]	=	itemshareData.pdafParameter->usVersion[2];
		stPDAFConfig.Reserve1.u16value[1]	=	itemshareData.pdafParameter->usVersion[1];
		stPDAFConfig.Reserve1.u16value[0]	=	itemshareData.pdafParameter->usVersion[0];

		memset(stPDAFConfig.ucData,0,2048);
		memcpy(stPDAFConfig.ucData, pdafBuf.data(), stPDAFConfig.uiDataSize);
		
		emit enableinfotimer(1);
		iresult	=	writeHISIPDAF(*globalFunPointer.vectorHisCCMOTPInfoW, &stPDAFConfig, globalFunPointer.ReadHisFX3IIC, globalFunPointer.WriteHisFX3IIC, globalFunPointer.SetHisFX3IICSpeed, \
			globalFunPointer.SetHisFX3Voltage, globalFunPointer.GetHisFX3Voltage, SetHisFX3VFuseVolt, GetHisFX3VFuseVolt, GetFreshframe, \
			globalFunPointer.BatchWriteHisFX3IIC, globalFunPointer.BatchReadHisFX3IIC, SetHisFX3GPIO, GetHisFX3GPIO, globalFunPointer.PullHisFX3RESET, globalFunPointer.PullHisFX3PWND, \
			globalFunPointer.BatchReadHisFX3IICNoLimit, globalFunPointer.BatchWriteHisFX3IICNoLimit, globalFunPointer.HisFX3LogPush_back, \
			globalFunPointer.PageWriteHisFX3IIC, globalFunPointer.PageReadHisFX3IIC, globalFunPointer.HisFX3PageWriteSPI, globalFunPointer.HisFX3PageReadSPI);
		emit enableinfotimer(0);
		if(iresult){
			emit information(QTextCodec::codecForName( "GBK")->toUnicode("写入PDAF Step2 数据失败"));
			itemshareData.itemparameterLock.unlock();
			return iresult;
		}
		
		itemshareData.itemparameterLock.unlock();
		return 0;
}
//*************************** END ********************************

void itemprocess::CureSmooth(float in[], float out[], int N)
{
	int i;
	if ( N < 5 )
	{
		for ( i = 0; i <= N - 1; i++ )
		{
			out[i] = in[i];
		}
	}
	else if(N<7)
	{
		out[0] = (69.0 * in[0] + 4.0 * in[1] - 6.0 * in[2] + 4.0 * in[3] - in[4]) / 70.0;
		out[1] = (2.0 * in[0] + 27.0 * in[1] + 12.0 * in[2] - 8.0 * in[3] + 2.0 * in[4]) / 35.0;
		for ( i = 2; i <= N - 3; i++ )
		{
			out[i] = (-3.0 * (in[i - 2] + in[i + 2])+ 12.0 * (in[i - 1] + in[i + 1]) + 17.0 * in[i] ) / 35.0;
		}
		out[N - 2] = (2.0 * in[N - 5] - 8.0 * in[N - 4] + 12.0 * in[N - 3] + 27.0 * in[N - 2] + 2.0 * in[N - 1]) / 35.0;
		out[N - 1] = (- in[N - 5] + 4.0 * in[N - 4] - 6.0 * in[N - 3] + 4.0 * in[N - 2] + 69.0 * in[N - 1]) / 70.0;
	}
	else
	{
		out[0] = ( 39.0 * in[0] + 8.0 * in[1] - 4.0 * in[2] - 4.0 * in[3] +
			1.0 * in[4] + 4.0 * in[5] - 2.0 * in[6] ) / 42.0;
		out[1] = ( 8.0 * in[0] + 19.0 * in[1] + 16.0 * in[2] + 6.0 * in[3] -
			4.0 * in[4] - 7.0* in[5] + 4.0 * in[6] ) / 42.0;
		out[2] = ( -4.0 * in[0] + 16.0 * in [1] + 19.0 * in[2] + 12.0 * in[3] +
			2.0 * in[4] - 4.0 * in[5] + 1.0 * in[6] ) / 42.0;
		for ( i = 3; i <= N - 4; i++ )
		{
			out[i] = ( -2.0 * (in[i - 3] + in[i + 3]) +
				3.0 * (in[i - 2] + in[i + 2]) +
				6.0 * (in[i - 1] + in[i + 1]) + 7.0 * in[i] ) / 21.0;
		}
		out[N - 3] = ( -4.0 * in[N - 1] + 16.0 * in [N - 2] + 19.0 * in[N - 3] +
			12.0 * in[N - 4] + 2.0 * in[N - 5] - 4.0 * in[N - 6] + 1.0 * in[N - 7] ) / 42.0;
		out[N - 2] = ( 8.0 * in[N - 1] + 19.0 * in[N - 2] + 16.0 * in[N - 3] +
			6.0 * in[N - 4] - 4.0 * in[N - 5] - 7.0 * in[N - 6] + 4.0 * in[N - 7] ) / 42.0;
		out[N - 1] = ( 39.0 * in[N - 1] + 8.0 * in[N - 2] - 4.0 * in[N - 3] -
			4.0 * in[N - 4] + 1.0 * in[N - 5] + 4.0 * in[N - 6] - 2.0 * in[N - 7] ) / 42.0;
	}
}

void itemprocess::FindCurePeak(float *in,int Size,float &MaxValue, int &MaxValueIndex)
{
	float maxvalue=-65535.0f;
	float minvalue=65535.0f;
	float fPeak1=0,fPeak2=0;
	int iPeakIndex[10]={0};
	//DataArrary sMTFValue[128];
	DataArrary *sMTFValue =new DataArrary[Size];
	for(int i=0;i<Size;i++)
	{
		sMTFValue[i].index=i;
		sMTFValue[i].data=in[i];
		if(maxvalue<in[i]) maxvalue=in[i];
		if(minvalue>in[i]) minvalue=in[i];
	}
	DataArrary temp;
	for (int i = 0; i < Size; ++i)
	{
		for (int j = 0; j < Size - i - 1; ++j)
		{
			if (sMTFValue[j].data> sMTFValue[j+1].data)
			{
				temp = sMTFValue[j];
				sMTFValue[j] = sMTFValue[j + 1];
				sMTFValue[j + 1] = temp;
			}
		}
	}
	iPeakIndex[0]=sMTFValue[Size-1].index;
	iPeakIndex[1]=sMTFValue[Size-2].index;
	iPeakIndex[2]=sMTFValue[Size-3].index;

	delete []sMTFValue;
	int index1=0,index2=0,index3=0,index4=0,index5=0;
	//judge peak1  //judge peak2 //judge peak3
	int startindex=0;
	int endindex=2;
	bool bpeakfind=false;
	float threshold=(maxvalue-minvalue)/2.0f;
	if((in[iPeakIndex[0]]-in[iPeakIndex[1]])>threshold){startindex=1;endindex=3;}
	for(int i=startindex;i<endindex;i++)
	{
		index1=iPeakIndex[i]-2;
		index2=iPeakIndex[i]-1;
		index3=iPeakIndex[i];
		index4=iPeakIndex[i]+1;
		index5=iPeakIndex[i]+2;
		if(index1<0) index1=0;
		if(index2<0) index2=0;
		if(index4>(Size-1)) index4=Size-1;
		if(index5>(Size-1)) index5=Size-1;
		if((in[index3]>=in[index2]) &&(in[index2]>=in[index1]) && (in[index3]>=in[index4]) &&(in[index4]>=in[index5]))
		{
			bpeakfind=true;
			MaxValueIndex=iPeakIndex[i];	
			break;
		}
	}
	if(!bpeakfind)  MaxValueIndex=iPeakIndex[1];
	MaxValue=in[MaxValueIndex];	
}


int itemprocess::QualCommPDAFStep2()
{
#ifdef _WIN64
	emit information(QTextCodec::codecForName( "GBK")->toUnicode("Qualcomm PDAF 不支持64位软件") );
	return HisCCMError_NotSupportx64;
#endif

	itemshareData.itemparameterLock.lockForRead();

	QString strSerialNumber;
	classLog->getserialnumber(strSerialNumber);

	_HisCCMAFBurn_Config stAFConfig;
	stAFConfig.bDebug						=	hisglobalparameter.bDebugMode;
	stAFConfig.strDriverIC				=	(itemshareData.ccmhardwareParameter->motortype.toAscii()).data();
	stAFConfig.strproject					=	itemshareData.ccmhardwareParameter->projectname.toAscii().data();
	stAFConfig.strsensor					=	itemshareData.ccmhardwareParameter->sensortype.toAscii().data();
	stAFConfig.bNear						=	true;
	stAFConfig.bInfinite						=	true;
	stAFConfig.iwidth						=	itemshareData.previewParameter->iWidth;
	stAFConfig.iheight						=	itemshareData.previewParameter->iHeight;
	stAFConfig.strFunctionChoose	=	itemshareData.pdafParameter->strAFChoose.toAscii().data();
	stAFConfig.ucSlave					=	itemshareData.previewParameter->ucSlave;
	stAFConfig.uiDataFormat			=	itemshareData.previewParameter->ucDataFormat;
	stAFConfig.ucEESlave				=	itemshareData.ccmhardwareParameter->ucEESlave;
	stAFConfig.strSerialNumber		=	strSerialNumber.toAscii().data();

#if (defined _WIN64) && (defined _DEBUG)
	QString strLibPath	=	QDir::currentPath() % "/HisCCMOTP64D";
#elif (defined _WIN64) && !(defined _DEBUG)
	QString strLibPath	=	QDir::currentPath() % "/HisCCMOTP64";
#elif (defined _WIN32) && (defined _DEBUG)
	QString strLibPath	=	QDir::currentPath() % "/HisCCMOTP32D";
#else
	QString strLibPath	=	QDir::currentPath() % "/HisCCMOTP32";
#endif

	RolongoOTPAPIVersion getRolongoOTPAPIVersion = (RolongoOTPAPIVersion)(QLibrary::resolve(strLibPath, "getRolongoOTPAPIVersion"));
	Rolongocheckafmotor checkafmotor = (Rolongocheckafmotor)(QLibrary::resolve(strLibPath, "checkafmotor"));
	RolongowriteQualcommPDAF writeQualcommPDAF = (RolongowriteQualcommPDAF)(QLibrary::resolve(strLibPath, "writeQualcommPDAF"));
	RolongocheckQualcommPDAF checkQualcommPDAF = (RolongocheckQualcommPDAF)(QLibrary::resolve(strLibPath, "checkQualcommPDAF"));


	if(!(getRolongoOTPAPIVersion && checkafmotor && writeQualcommPDAF && checkQualcommPDAF)){
		emit information(tr("Resolve HisCCMOTP DLL Function Fail"));
		itemshareData.itemparameterLock.unlock();
		return HisCCMError_LoadDLLFuc;
	}


	int iresult=0;
	int iInfiniteMotor=0,iMacroMotor=0;

	if(!threadshareData.bOfflineMode)
	{
		emit enableinfotimer(1);
		iresult	=	checkafmotor(*globalFunPointer.vectorHisCCMOTPInfoW, &stAFConfig, globalFunPointer.ReadHisFX3IIC, globalFunPointer.WriteHisFX3IIC, globalFunPointer.SetHisFX3IICSpeed, globalFunPointer.SetHisFX3Voltage, \
			globalFunPointer.GetHisFX3Voltage, SetHisFX3VFuseVolt, GetHisFX3VFuseVolt, GetFreshframe, SetHisFX3GPIO, GetHisFX3GPIO, \
			globalFunPointer.PullHisFX3RESET, globalFunPointer.PullHisFX3PWND, globalFunPointer.BatchReadHisFX3IICNoLimit, globalFunPointer.BatchWriteHisFX3IICNoLimit, \
			globalFunPointer.HisFX3LogPush_back, globalFunPointer.PageWriteHisFX3IIC, globalFunPointer.PageReadHisFX3IIC, \
			globalFunPointer.HisFX3PageWriteSPI, globalFunPointer.HisFX3PageReadSPI);
		emit enableinfotimer(0);
		if(iresult){
			itemshareData.itemparameterLock.unlock();
			return iresult;
		}

		iInfiniteMotor	=	stAFConfig.iInfinitMotor;
		iMacroMotor	=	stAFConfig.iNearMotor;

		emit information(QTextCodec::codecForName( "GBK")->toUnicode("近焦位置：") % QString::number(iMacroMotor));
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("远焦位置：") % QString::number(iInfiniteMotor));

		if(iInfiniteMotor==0xFFF || iInfiniteMotor==0x00 || iMacroMotor==0xFFF || iMacroMotor==0x00)
		{
			emit information(QTextCodec::codecForName( "GBK")->toUnicode("远/近焦不正确，不能为0XFFFF或者0x0000"));
			return HisCCMError_OtpFucExec;
		}
	}

	strLibPath	=	QDir::currentPath() % "/pdaflib/qualcomm";
	strLibPath	=	strLibPath % "/x86/PDAFCalibrationTools_Rev" % itemshareData.pdafParameter->cVersion % "_Dll";
	typedef int (*qualcomm_PDAF_Cal_GainMap)(short *RAWDATA,int nWidth, int nHeight, PDAFPattern PDAFPatternValue, GainMap2DDataStruct *GainMapData2D, GainMap1DDataStruct *GainMapData1D, GainMapVerifyStruct &gmvs);
	typedef int (*qualcomm_PDAF_Cal_PDConversionCoef)(short *FirstImg,short *SecondImg,int nWidth, int nHeight,float FirstImg_LensPos, float SecondImg_LensPos, GainMapStruct GainMap,PDAFPattern PDAFPatternValue, bool MultipleRegions,CalibrationKOutputParams &CalibrationKOutput);
	typedef bool (*qualcomm_PDAF_Cal_Verification)(short *Distance50cmLensPosition9_Img,int nWidth, int nHeight,GainMapStruct GainMapData, PDAFPattern PDAFPatternValue,VerificationInputParams *VerificationValue,VerificationOutputParams &VerificationOutput);
	typedef unsigned short (*qualcomm_GM_Constraint)(GainMapVerifyStruct &gmvs, GainMap2DDataStruct *gm2d, GainMap1DDataStruct *gm1d);
	typedef int (*qualcomm_OTP_single_defect_1DGainmap)(GainMap1DDataStruct &gm1d, int GainDiff);
	typedef int (*qualcomm_OTP_single_defect_2DGainmap)(GainMap2DDataStruct &gm2d, int GainDiff);
	typedef void (*qualcomm_PDAF_Cal_get_lib_version)(char *s);
	typedef void (*qualcomm_PDAF_Cal_get_lib_features)(char *s);

	qualcomm_PDAF_Cal_GainMap PDAF_Cal_GainMap	=	(qualcomm_PDAF_Cal_GainMap)(QLibrary::resolve(strLibPath, "PDAF_Cal_GainMap"));
	qualcomm_PDAF_Cal_PDConversionCoef PDAF_Cal_PDConversionCoef	=	(qualcomm_PDAF_Cal_PDConversionCoef)(QLibrary::resolve(strLibPath, "PDAF_Cal_PDConversionCoef"));
	qualcomm_PDAF_Cal_Verification PDAF_Cal_Verification	=	(qualcomm_PDAF_Cal_Verification)(QLibrary::resolve(strLibPath, "PDAF_Cal_Verification"));
	qualcomm_GM_Constraint GM_Constraint	=	(qualcomm_GM_Constraint)(QLibrary::resolve(strLibPath, "GM_Constraint"));
	qualcomm_OTP_single_defect_1DGainmap OTP_single_defect_1DGainmap	=	(qualcomm_OTP_single_defect_1DGainmap)(QLibrary::resolve(strLibPath, "OTP_single_defect_1DGainmap"));
	qualcomm_OTP_single_defect_2DGainmap OTP_single_defect_2DGainmap	=	(qualcomm_OTP_single_defect_2DGainmap)(QLibrary::resolve(strLibPath, "OTP_single_defect_2DGainmap"));
	qualcomm_PDAF_Cal_get_lib_version PDAF_Cal_get_lib_version	=	(qualcomm_PDAF_Cal_get_lib_version)(QLibrary::resolve(strLibPath, "PDAF_Cal_get_lib_version"));
	qualcomm_PDAF_Cal_get_lib_features PDAF_Cal_get_lib_features	=	(qualcomm_PDAF_Cal_get_lib_features)(QLibrary::resolve(strLibPath, "PDAF_Cal_get_lib_features"));

	if(!(PDAF_Cal_GainMap && PDAF_Cal_PDConversionCoef && PDAF_Cal_Verification && GM_Constraint && \
		OTP_single_defect_1DGainmap && OTP_single_defect_2DGainmap && PDAF_Cal_get_lib_version && PDAF_Cal_get_lib_features)){
			emit information(tr("Resolve Qulacomm PDAF DLL Function Fail"));
			itemshareData.itemparameterLock.unlock();
			return HisCCMError_LoadDLLFuc;
	}

	//IMX258
	if(itemshareData.pdafParameter->bSONY258MTKCal)
	{
		iresult=ApplySONYIMX258SPC();
		if(iresult)
		{
			emit information(QTextCodec::codecForName( "GBK")->toUnicode("Apply SONY IMX258 SPC 失败"));
			itemshareData.itemparameterLock.unlock();
			return iresult;
		}
	}

	char strLibInfo[2048];
	PDAF_Cal_get_lib_version(strLibInfo);
	emit information(QString::fromAscii(strLibInfo));
	PDAF_Cal_get_lib_features(strLibInfo);
	emit information(QString::fromAscii(strLibInfo));

	GainMapVerifyStruct gmvs;
	//gmvs.MinPixelAvg  :for 10-bit data, Pixel average value shouldn't smaller than this
	//gmvs.MaxPixelAvg  : ... shouldn't bigger than this
	//gmvs.MinPDAvg     : PD Signal average shouldn't smaller than this
	//gmvs.MaxPDAvg     : PD Signal average shouldn't bigger than this
	//gmvs.MinGain      : PD Gainmap shouldn't smaller than this
	//gmvs.MaxGain      : PD Gainmap value shouldn't bigger than this
	//gmvs.MaxPixelThresh   : max signal of normal pixel should be higher than this
	/* indicator of bit-width error: 
	if max < 256, then could be too dark for a flat image of 10-bit.
	*/
	gmvs.MinPixelAvg = 64;
	gmvs.MaxPixelAvg = 1023;    // disabled
	gmvs.MinPDAvg = 64;         // 
	gmvs.MaxPDAvg = 1023;       // disabled
	gmvs.MinGain = 64;          // 0.25x gain
	gmvs.MaxGain = 1024;        // 4x gain
	gmvs.MaxPixelThresh = 256;  // 1/4 of max range (1023)
	gmvs.GainDiff = 256;


	PDAFPattern PDAFPatternValue;
	QString strIniPath = "./pdaftemplate/Qualcomm/" % itemshareData.ccmhardwareParameter->projectname % "/Config.ini";
	if(!QFile::exists(strIniPath)){
		emit information(tr("File not exist: ") % strIniPath);
		itemshareData.itemparameterLock.unlock();
		return HisCCMError_FilePath;
	}

	_HisQualcommPDAFBurn_Config stPDAFConfig;
	stPDAFConfig.bDebug					=		hisglobalparameter.bDebugMode;
	stPDAFConfig.ucSensorSlave		=		itemshareData.previewParameter->ucSlave;
	stPDAFConfig.strproject					=		itemshareData.ccmhardwareParameter->projectname.toAscii().data();
	stPDAFConfig.strsensor					=		itemshareData.ccmhardwareParameter->sensortype.toAscii().data();
	stPDAFConfig.strDriverIC				=		itemshareData.ccmhardwareParameter->motortype.toAscii().data();
	stPDAFConfig.strFunctionChoose	=	itemshareData.pdafParameter->strQualcommChoose.toAscii().data();
	stPDAFConfig.ucEESlave				=	itemshareData.ccmhardwareParameter->ucEESlave;
	stPDAFConfig.usGainMapSize=itemshareData.pdafParameter->usQualcommGainMapSize;

	QSettings classIniConfig(strIniPath, QSettings::IniFormat);
	QStringList childKeys = classIniConfig.allKeys();
	for(int x=0;	x<childKeys.size();	++x){
		if(childKeys.at(x) == "GlobalShift_x") PDAFPatternValue.GlobalShift_x =	classIniConfig.value(childKeys.at(x)).toInt();
		else if(childKeys.at(x) == "GlobalShift_y") PDAFPatternValue.GlobalShift_y =	classIniConfig.value(childKeys.at(x)).toInt();
		else if(childKeys.at(x) == "x_step") PDAFPatternValue.x_step =	classIniConfig.value(childKeys.at(x)).toInt();
		else if(childKeys.at(x) == "y_step") PDAFPatternValue.y_step =	classIniConfig.value(childKeys.at(x)).toInt();
		else if(childKeys.at(x) == "SensorGain") PDAFPatternValue.SensorGain =	classIniConfig.value(childKeys.at(x)).toInt();
		else if(childKeys.at(x) == "ImageBits") PDAFPatternValue.ImageBits =	classIniConfig.value(childKeys.at(x)).toInt();
		else if(childKeys.at(x) == "BlackLevel") PDAFPatternValue.BlackLevel =	classIniConfig.value(childKeys.at(x)).toInt();
		else if(childKeys.at(x) == "DSRatio") PDAFPatternValue.DSRatio =	classIniConfig.value(childKeys.at(x)).toInt();
		else if(childKeys.at(x) == "PDAFonG") PDAFPatternValue.PDAFonG =	(classIniConfig.value(childKeys.at(x)).toString() == "true");
		else if(childKeys.at(x) == "OTPFormat_Type"){

		}
	}

	strIniPath = "./pdaftemplate/Qualcomm/" % itemshareData.ccmhardwareParameter->projectname % "/PDAFPattern.txt";
	if(!QFile::exists(strIniPath)){

		emit information(tr("File not exist: ") % strIniPath);
		itemshareData.itemparameterLock.unlock();
		return HisCCMError_FilePath;
	}
	strcpy(PDAFPatternValue.PDAFPatternFilename, strIniPath.toAscii().data());

	// Read GainMAP Data from EEPROM
	GainMapStruct GainMap;
	stPDAFConfig.ucTpye=1;
	if(itemshareData.pdafParameter->strQualcommGainMapStruct=="1D")
	{
		stPDAFConfig.strGainMapDataStruct="1D";
	}
	else if(itemshareData.pdafParameter->strQualcommGainMapStruct=="2D")
	{
		stPDAFConfig.strGainMapDataStruct="2D";
	}
#ifndef QT_PDAF_LoadImage
	emit enableinfotimer(1);
	iresult	=	checkQualcommPDAF(*globalFunPointer.vectorHisCCMOTPInfoW, &stPDAFConfig, globalFunPointer.ReadHisFX3IIC, globalFunPointer.WriteHisFX3IIC, globalFunPointer.SetHisFX3IICSpeed, \
		globalFunPointer.SetHisFX3Voltage, globalFunPointer.GetHisFX3Voltage, SetHisFX3VFuseVolt, GetHisFX3VFuseVolt, GetFreshframe, \
		globalFunPointer.BatchWriteHisFX3IIC, globalFunPointer.BatchReadHisFX3IIC, SetHisFX3GPIO, GetHisFX3GPIO, globalFunPointer.PullHisFX3RESET, globalFunPointer.PullHisFX3PWND, \
		globalFunPointer.BatchReadHisFX3IICNoLimit, globalFunPointer.BatchWriteHisFX3IICNoLimit,globalFunPointer.HisFX3LogPush_back, globalFunPointer.PageWriteHisFX3IIC, globalFunPointer.PageReadHisFX3IIC, \
		globalFunPointer.HisFX3PageWriteSPI, globalFunPointer.HisFX3PageReadSPI);
	emit enableinfotimer(0);
	if(iresult)
	{
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("读取PDAF Step1 数据失败"));
		itemshareData.itemparameterLock.unlock();
		return iresult;
	}
#else
	iInfiniteMotor=328; //Module actucal AF code need to be modify
	iMacroMotor=564;
	if(itemshareData.pdafParameter->strQualcommGainMapStruct=="2D")
	{
		FILE *fp_r = fopen("./Qualcomm2D_PDAF_Step1.txt","rb");
		fscanf(fp_r,"%x\n",&stPDAFConfig.GainMapData2D.VersionNum);
		fscanf(fp_r,"%x\n",&stPDAFConfig.GainMapData2D.OffsetX);
		fscanf(fp_r,"%x\n",&stPDAFConfig.GainMapData2D.OffsetY);
		fscanf(fp_r,"%x\n",&stPDAFConfig.GainMapData2D.RatioX);
		fscanf(fp_r,"%x\n",&stPDAFConfig.GainMapData2D.RatioY);
		fscanf(fp_r,"%x\n",&stPDAFConfig.GainMapData2D.MapWidth);
		fscanf(fp_r,"%x\n",&stPDAFConfig.GainMapData2D.MapHeight);
		for (int i = 0; i < stPDAFConfig.GainMapData2D.MapWidth*stPDAFConfig.GainMapData2D.MapHeight; i ++)
			fscanf(fp_r,"%x\n",&stPDAFConfig.GainMapData2D.Left_GainMap[i]);
		for (int i = 0; i < stPDAFConfig.GainMapData2D.MapWidth*stPDAFConfig.GainMapData2D.MapHeight; i ++)
			fscanf(fp_r,"%x\n",&stPDAFConfig.GainMapData2D.Right_GainMap[i]);
		fclose(fp_r);
	}
	else if(itemshareData.pdafParameter->strQualcommGainMapStruct=="1D")
	{
		FILE *fp_r = fopen("./Qualcomm1D_PDAF_Step1.txt","rb");
		fscanf(fp_r,"%x\n",&stPDAFConfig.GainMapData1D.VersionNum);
		fscanf(fp_r,"%x\n",&stPDAFConfig.GainMapData1D.DSRatio);
		fscanf(fp_r,"%x\n",&stPDAFConfig.GainMapData1D.ActualLength);
		fscanf(fp_r,"%x\n",&stPDAFConfig.GainMapData1D.DSLength);
		for (int i = 0; i < stPDAFConfig.GainMapData1D.DSLength; i ++)
			fscanf(fp_r,"%x\n",&stPDAFConfig.GainMapData1D.Left_GainMap[i]);
		for (int i = 0; i < stPDAFConfig.GainMapData1D.DSLength; i ++)
			fscanf(fp_r,"%x\n",&stPDAFConfig.GainMapData1D.Right_GainMap[i]);
		fclose(fp_r);
	}
#endif
	uint16_t GainMapFlag=0;
	if(itemshareData.pdafParameter->strQualcommGainMapStruct=="1D")
	{
		GainMapFlag = GM_Constraint(gmvs,NULL,&stPDAFConfig.GainMapData1D);
		iresult=Display_GmCheckResult(GainMapFlag);
		if(iresult!=0) return iresult;
		OTP_single_defect_1DGainmap(stPDAFConfig.GainMapData1D,gmvs.GainDiff);
		GainMap.Flag_1D_2D = stPDAFConfig.GainMapData1D.VersionNum;
		GainMap.GainMapData = &stPDAFConfig.GainMapData1D;
	}
	else if(itemshareData.pdafParameter->strQualcommGainMapStruct=="2D")
	{
		GainMapFlag = GM_Constraint(gmvs,&stPDAFConfig.GainMapData2D,NULL);
		iresult=Display_GmCheckResult(GainMapFlag);
		if(iresult!=0) return iresult;
		OTP_single_defect_2DGainmap(stPDAFConfig.GainMapData2D,gmvs.GainDiff);
		GainMap.Flag_1D_2D = stPDAFConfig.GainMapData2D.VersionNum;
		GainMap.GainMapData = &stPDAFConfig.GainMapData2D;
	}


	//Calculate lens position
	int iMidMupToInf=(iMacroMotor-iInfiniteMotor)/2;
	int iLensPos[4]={0};
	iLensPos[0]=iInfiniteMotor+iMidMupToInf*0.2;
	iLensPos[1]=iMacroMotor-iMidMupToInf*0.2;
	iLensPos[2]=iInfiniteMotor+iMidMupToInf*0.4;
	iLensPos[3]=iMacroMotor-iMidMupToInf*0.4;
	memset(stPDAFConfig.CalibrationKOutputValues,0,sizeof(CalibrationKOutputParams));
	//Using "for" cycle for 2 type of 80% and 60%
	//1:Move the lens -80% of the way towards macro from its middle position and record the lens position,then +80%
	//2:Move the lens -60% of the way towards macro from its middle position and record the lens position,then +60%
	int iKCount=0;
	QDir classDir;
	strIniPath	=	QDir::currentPath() % "/QualcommPDAFImage";
	classDir.mkpath(strIniPath);
	for(int iTestPos=0;iTestPos<2;iTestPos++)  // 20CM & 50 CM
	{
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("Move test chart to position:") % QString::number(iTestPos));
		for(int i=0;i<4;i+=2) //+/-80% +/-60%
		{
			// Move lens to negative
			emit information(QTextCodec::codecForName( "GBK")->toUnicode("Move Lens to:") % QString::number(iLensPos[i]));
			iresult	=	setMotor(itemshareData.ccmhardwareParameter->motortype.toAscii().data(), \
				itemshareData.previewParameter->ucSlave, itemshareData.ccmhardwareParameter->projectname.toAscii().data(), \
				iLensPos[i], globalFunPointer.ReadHisFX3IIC, globalFunPointer.WriteHisFX3IIC, globalFunPointer.SetHisFX3IICSpeed, globalFunPointer.PullHisFX3RESET, globalFunPointer.PullHisFX3PWND, \
				globalFunPointer.PageWriteHisFX3IIC, globalFunPointer.PageReadHisFX3IIC, globalFunPointer.HisFX3PageWriteSPI, globalFunPointer.HisFX3PageReadSPI);
			if(iresult&&(!threadshareData.bOfflineMode))
			{
				emit information(QTextCodec::codecForName( "GBK")->toUnicode("设置马达位置失败"));
				itemshareData.itemparameterLock.unlock();
				return iresult;
			}
			Sleep(itemshareData.pdafParameter->uiMotorSleep);
			if(itemshareData.pdafParameter->bQualcomm50CMexp && (iTestPos==1) &&( i==0 ))
			{
				emit information(QTextCodec::codecForName( "GBK")->toUnicode("Auto Exposure@ 50CM 测试环境:"));
				int Width=itemshareData.previewParameter->iWidth;
				int Height=itemshareData.previewParameter->iHeight;
				int iAEROIW=itemshareData.pdafParameter->usAutoExpsoureROIW/2;
				int iAEROIH=itemshareData.pdafParameter->usAutoExposureROIH/2;
				RECT sAERect;
				sAERect.left=Width/2-iAEROIW;sAERect.top=Height/2-iAEROIH;
				sAERect.right=Width/2+iAEROIW;sAERect.bottom=Height/2+iAEROIH;
				iresult=this->autoExposure(sAERect,200,230,600,40,true,true,false,0.1f);
			}
			//Capture RAW10 
			unsigned short* pusRaw10Lens1	=	(unsigned short*)_aligned_malloc(itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight *sizeof(unsigned short), _HisCacheLine_Aligned);
			if(!pusRaw10Lens1){
				itemshareData.itemparameterLock.unlock();
				return HisFX3Error_MallocBuffer;
			}
#ifndef QT_PDAF_LoadImage
			iresult	=	GetFreshframe((unsigned char*)(pusRaw10Lens1), itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight *2, _FrameType_Raw10, true);
			if(iresult){
				HisReleaseMalloc(pusRaw10Lens1);
				itemshareData.itemparameterLock.unlock();
				return iresult;
			}
#else
			wchar_t wRAWPath[MAX_PATH]={0};
			wsprintf(wRAWPath,L"./TestPosition[%d]_Image[%d].raw",iTestPos,i);
			unsigned char* pusRaw	=(unsigned char*)_aligned_malloc(itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight *sizeof(unsigned short), _HisCacheLine_Aligned);
			ROPLOW::ReadRawBuffer(wRAWPath,pusRaw,itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight*sizeof(unsigned short));
			memcpy(pusRaw10Lens1,pusRaw,itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight*sizeof(unsigned short));
			HisReleaseMalloc(pusRaw);
#endif
			if(hisglobalparameter.bDebugMode)
			{
				ROPLOW::saveRaw10(strIniPath, strSerialNumber % "_Qualcomm_Step2_DAC"%QString::number(iLensPos[i])%"_"%(QDateTime::currentDateTime()).toString("yyyyMMdd_hhmmss"), itemshareData.previewParameter->ucDataFormat, \
					itemshareData.previewParameter->iWidth, itemshareData.previewParameter->iHeight, (void*)(pusRaw10Lens1));
			}
			// Move Lens to positive
			emit information(QTextCodec::codecForName( "GBK")->toUnicode("Move Lens to:") % QString::number(iLensPos[i+1]));
			iresult	=	setMotor(itemshareData.ccmhardwareParameter->motortype.toAscii().data(), \
				itemshareData.previewParameter->ucSlave, itemshareData.ccmhardwareParameter->projectname.toAscii().data(), \
				iLensPos[i+1], globalFunPointer.ReadHisFX3IIC, globalFunPointer.WriteHisFX3IIC, globalFunPointer.SetHisFX3IICSpeed, globalFunPointer.PullHisFX3RESET, globalFunPointer.PullHisFX3PWND, \
				globalFunPointer.PageWriteHisFX3IIC, globalFunPointer.PageReadHisFX3IIC, globalFunPointer.HisFX3PageWriteSPI, globalFunPointer.HisFX3PageReadSPI);
			if(iresult&&(!threadshareData.bOfflineMode))
			{
				emit information(QTextCodec::codecForName( "GBK")->toUnicode("设置马达位置失败"));
				itemshareData.itemparameterLock.unlock();
				return iresult;
			}
			Sleep(itemshareData.pdafParameter->uiMotorSleep);
			//Capture RAW10
			unsigned short* pusRaw10Lens2	=	(unsigned short*)_aligned_malloc(itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight *sizeof(unsigned short), _HisCacheLine_Aligned);
			if(!pusRaw10Lens2){
				itemshareData.itemparameterLock.unlock();
				return HisFX3Error_MallocBuffer;
			}
#ifndef QT_PDAF_LoadImage
			iresult	=	GetFreshframe((unsigned char*)(pusRaw10Lens2), itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight *2, _FrameType_Raw10, true);
			if(iresult){
				HisReleaseMalloc(pusRaw10Lens1);
				HisReleaseMalloc(pusRaw10Lens2);
				itemshareData.itemparameterLock.unlock();
				return iresult;
			}
#else 
			wsprintf(wRAWPath,L"./TestPosition[%d]_Image[%d].raw",iTestPos,i+1);
			unsigned char* pusRaw2	=(unsigned char*)_aligned_malloc(itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight *sizeof(unsigned short), _HisCacheLine_Aligned);
			ROPLOW::ReadRawBuffer(wRAWPath,pusRaw2,itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight*sizeof(unsigned short));
			memcpy(pusRaw10Lens2,pusRaw2,itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight*sizeof(unsigned short));
			HisReleaseMalloc(pusRaw2);

#endif
			if(hisglobalparameter.bDebugMode)
			{
				ROPLOW::saveRaw10(strIniPath, strSerialNumber%"_Qualcomm_Step2_DAC"%QString::number(iLensPos[i+1])%"_"%"_TestPosition["%QString::number(iTestPos)%"]_Image["%QString::number(i)%"]"%(QDateTime::currentDateTime()).toString("yyyyMMdd_hhmmss"), itemshareData.previewParameter->ucDataFormat, \
					itemshareData.previewParameter->iWidth, itemshareData.previewParameter->iHeight, (void*)(pusRaw10Lens2));

			}
			//calculate K value by Qucalcomm tool
			int PD_ConversionCoeff_Flag = PDAF_Cal_PDConversionCoef((short*)pusRaw10Lens1,(short*)pusRaw10Lens2,itemshareData.previewParameter->iWidth, itemshareData.previewParameter->iHeight,iLensPos[i], 
				iLensPos[i+1],GainMap,PDAFPatternValue,false, stPDAFConfig.CalibrationKOutputValues[iKCount]);
			iKCount++; 
			if(PD_ConversionCoeff_Flag<0)
			{
				HisReleaseMalloc(pusRaw10Lens1);
				HisReleaseMalloc(pusRaw10Lens2);
				emit information(QTextCodec::codecForName( "GBK")->toUnicode("error return :") % QString::number(PD_ConversionCoeff_Flag));
				emit information(QTextCodec::codecForName( "GBK")->toUnicode("-1:Expected Output Width/Height in GainMap are Too Small."));
				emit information(QTextCodec::codecForName( "GBK")->toUnicode("-2:Cannot find the Pattern Definition File."));
				emit information(QTextCodec::codecForName( "GBK")->toUnicode("-3:Either Image is a Color Image."));
				itemshareData.itemparameterLock.unlock();
				return HisCCMError_QualcommPDAFStep2;
			}
			HisReleaseMalloc(pusRaw10Lens1);
			HisReleaseMalloc(pusRaw10Lens2);
		}
		if(iTestPos==0)
		{

#if (defined USE_EQUIPMENT_GB_PDAF)
			this->movetopos(3);// Move test chart to 50cm
#else
			if(hisglobalparameter.stOperatorMode.ucMode == 2){
				hisglobalparameter.bSlaveMotionFinish	=	false;
				emit signalWritePDAF50cm(1);

				QElapsedTimer classElap;
				classElap.start();
				while(!classElap.hasExpired(5000))
				{
					hisglobalparameter.flagLocker.lockForRead();
					if(hisglobalparameter.bSlaveMotionFinish){
						hisglobalparameter.flagLocker.unlock();
						break;
					}
					hisglobalparameter.flagLocker.unlock();
					Sleep(10);
				}

				if(classElap.hasExpired(5000)){
					emit information(tr("timeout of waiting for master move to 50cm position"));
					itemshareData.itemparameterLock.unlock();
					return HisMotionError_MoveFail;
				}

			}	
			else{
				emit information(tr("Not at slave mode, can not move to 50cm"));
				itemshareData.itemparameterLock.unlock();
				return HisMotionError_MoveFail;
			}
#endif

			::Sleep(itemshareData.pdafParameter->us50CMEVDelayTime);
		}

	}
	_CODE_CLEAR_IMAGEDRAW
		//calculate result and compare to specification
		int iKValueMax=-65535, iKValueMin=65535;
	//int iKCalibrationRes=0;
	int iKAverag=0;
	for(int i=0;i<4;i++)
	{
		if(stPDAFConfig.CalibrationKOutputValues[i].PDConversionCoef[0]>iKValueMax) iKValueMax=stPDAFConfig.CalibrationKOutputValues[i].PDConversionCoef[0];
		if(stPDAFConfig.CalibrationKOutputValues[i].PDConversionCoef[0]<iKValueMin) iKValueMin=stPDAFConfig.CalibrationKOutputValues[i].PDConversionCoef[0];
		iKAverag+=stPDAFConfig.CalibrationKOutputValues[i].PDConversionCoef[0];
	}
	iKAverag/=4;
	//if(itemshareData.pdafParameter->usQualcommCoefKDiffMax<(iKValueMax-iKValueMin))  iKCalibrationRes=HisCCMError_QualcommPDAFStep2;
	//if(iKCalibrationRes) iresult=iKCalibrationRes;

	//K verify
	float fMTFValue[128]={0};
	float fMTFSommth[128]={0};
	int   iDACPos[128]={0};
	int   iCDAFTrueDAC=iDACPos[0];
	int   iPDAFTrueDAC=0;
	if(itemshareData.pdafParameter->bQualcommpdafverify && (!iresult))
	{
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("Start PDAF K value verify"));
		unsigned short* pusRaw10Verify	=	(unsigned short*)_aligned_malloc(itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight *sizeof(unsigned short), _HisCacheLine_Aligned);
		if(!pusRaw10Verify){
			itemshareData.itemparameterLock.unlock();
			return HisFX3Error_MallocBuffer;
		}
		iresult	=	GetFreshframe((unsigned char*)(pusRaw10Verify), itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight*2, _FrameType_Raw10, true);
		if(iresult){
			HisReleaseMalloc(pusRaw10Verify);
			itemshareData.itemparameterLock.unlock();
			return iresult;
		}
		VerificationInputParams VerificationInputValue;
		VerificationOutputParams VerificationResult;
		VerificationInputValue.PD_ConversionCoeff = iKAverag;
		//Notes: these two parameters' values,'Distance50cmTrueFocusPosition' and 'ToleranceError', depend on module 
		//the correct true focus value need to be used.
		VerificationInputValue.Verification_Lens_Position = iLensPos[3];
		VerificationInputValue.Distance50cmTrueFocusPosition = 340.0f;
		VerificationInputValue.ToleranceError = 30.0f;
		PDAF_Cal_Verification((short*)pusRaw10Verify,itemshareData.previewParameter->iWidth ,itemshareData.previewParameter->iHeight,
			GainMap, PDAFPatternValue,&VerificationInputValue,VerificationResult);
		iPDAFTrueDAC=VerificationInputValue.Verification_Lens_Position-VerificationResult.EstimationDAC;
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("PDAF function in-focused DAC:") % QString::number(iPDAFTrueDAC));
		//Capture PDAF infocused image
		if(hisglobalparameter.bDebugMode)
		{	
			iresult	=	setMotor(itemshareData.ccmhardwareParameter->motortype.toAscii().data(), \
				itemshareData.previewParameter->ucSlave, itemshareData.ccmhardwareParameter->projectname.toAscii().data(), \
				iPDAFTrueDAC, globalFunPointer.ReadHisFX3IIC, globalFunPointer.WriteHisFX3IIC, globalFunPointer.SetHisFX3IICSpeed, globalFunPointer.PullHisFX3RESET, globalFunPointer.PullHisFX3PWND, \
				globalFunPointer.PageWriteHisFX3IIC, globalFunPointer.PageReadHisFX3IIC, globalFunPointer.HisFX3PageWriteSPI, globalFunPointer.HisFX3PageReadSPI);
			if(iresult&&(!threadshareData.bOfflineMode))
			{
				emit information(QTextCodec::codecForName( "GBK")->toUnicode("设置马达位置失败"));
				itemshareData.itemparameterLock.unlock();
				return iresult;
			}
			Sleep(itemshareData.pdafParameter->uiMotorSleep);
			iresult	=	GetFreshframe((unsigned char*)(pusRaw10Verify), itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight*2, _FrameType_Raw10, true);
			if(iresult){
				HisReleaseMalloc(pusRaw10Verify);
				itemshareData.itemparameterLock.unlock();
				return iresult;
			}
			ROPLOW::saveRaw10(strIniPath, strSerialNumber % "_Qualcomm_Step2_PDAFIn-Focused"%(QDateTime::currentDateTime()).toString("yyyyMMdd_hhmmss"), itemshareData.previewParameter->ucDataFormat, \
				itemshareData.previewParameter->iWidth, itemshareData.previewParameter->iHeight, (void*)(pusRaw10Verify));
		}
		HisReleaseMalloc(pusRaw10Verify);

		//Assign DAC 
		iDACPos[0]=iPDAFTrueDAC-(itemshareData.pdafParameter->usVerifyDACShiftCount/2)*itemshareData.pdafParameter->usDACMoveStep;
		if(iDACPos[0]<0) iDACPos[0]=0;
		for(int i=1;i<itemshareData.pdafParameter->usVerifyDACShiftCount;i++)
		{
			iDACPos[i]=iDACPos[i-1]+itemshareData.pdafParameter->usDACMoveStep;
			if( iDACPos[i]>1023) iDACPos[i]=1023; 
		}
		int Width=itemshareData.previewParameter->iWidth;
		int Height=itemshareData.previewParameter->iHeight;
		RECT stMTFAutoROI;
		stMTFAutoROI.left=(Width>>1)-(itemshareData.pdafParameter->usCDAFmtfROIW>>1);stMTFAutoROI.top=(Height>>1)-(itemshareData.pdafParameter->usCDAFmtfROIH>>1);
		stMTFAutoROI.right=(Width>>1)+(itemshareData.pdafParameter->usCDAFmtfROIW>>1);stMTFAutoROI.bottom=(Height>>1)+(itemshareData.pdafParameter->usCDAFmtfROIH>>1);
		unsigned int uiRawImgSize		=	Width* Height *3;
		//unsigned char ucFrameType		=	_FrameType_RGB24;
		unsigned int uiPixelSize	=	Width* Height ;
		unsigned char *pucRGB24		=	(unsigned char*)_aligned_malloc(uiRawImgSize, _HisCacheLine_Aligned);
		if(!pucRGB24){
			HisReleaseMalloc(pucRGB24);
			itemshareData.itemparameterLock.unlock();
			return HisFX3Error_MallocBuffer;
		}
		float iMaxMTFValue=0.0f;
		int   iMaxLensPosIndex=0;
		bool  bPeakFind=false;
		int   iPeakDropCnt=0;
		int   iPeakDropArrary[128]={0};
		unsigned char ucMinCantrast = 20;
		RECT stROI;
		std::vector<_itemDraw> vectorDraw;
		vectorDraw.reserve(100);
		//Move VCM in button position
		iresult	=	setMotor(itemshareData.ccmhardwareParameter->motortype.toAscii().data(), \
			itemshareData.previewParameter->ucSlave, itemshareData.ccmhardwareParameter->projectname.toAscii().data(), \
			iLensPos[0], globalFunPointer.ReadHisFX3IIC, globalFunPointer.WriteHisFX3IIC, globalFunPointer.SetHisFX3IICSpeed, globalFunPointer.PullHisFX3RESET, globalFunPointer.PullHisFX3PWND, \
			globalFunPointer.PageWriteHisFX3IIC, globalFunPointer.PageReadHisFX3IIC, globalFunPointer.HisFX3PageWriteSPI, globalFunPointer.HisFX3PageReadSPI);
		Sleep(itemshareData.pdafParameter->uiMotorSleep);
		for(int i=0;i<itemshareData.pdafParameter->usVerifyDACShiftCount;i++)
		{
			vectorDraw.clear();
			iresult	=	setMotor(itemshareData.ccmhardwareParameter->motortype.toAscii().data(), \
				itemshareData.previewParameter->ucSlave, itemshareData.ccmhardwareParameter->projectname.toAscii().data(), \
				iDACPos[i], globalFunPointer.ReadHisFX3IIC, globalFunPointer.WriteHisFX3IIC, globalFunPointer.SetHisFX3IICSpeed, globalFunPointer.PullHisFX3RESET, globalFunPointer.PullHisFX3PWND, \
				globalFunPointer.PageWriteHisFX3IIC, globalFunPointer.PageReadHisFX3IIC, globalFunPointer.HisFX3PageWriteSPI, globalFunPointer.HisFX3PageReadSPI);
			Sleep(itemshareData.pdafParameter->uiMotorSleep);
			/*iresult=GetFreshframe(pucRGB24, uiRawImgSize, _FrameType_RGB24,true);	
			classAlgorithm.HisCCMMTF(pucRGB24, Width , Height, stMTFAutoROI, _HisCCM_AlgID_MTF_hao_a, fMTFValue[i]);*/
			//************
			GetFreshframe(pucRGB24, itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight *3, _FrameType_RGB24, true);
			if(!ROPLOW::BlackStripesDetected(pucRGB24,itemshareData.pdafParameter->usCDAFmtfROIW,itemshareData.previewParameter->iWidth ,itemshareData.previewParameter->iHeight,stROI))
			{
				emit information("BlackStripesDetected failed, please check detected ROI size");
				HisReleaseMalloc(pucRGB24);
				itemshareData.itemparameterLock.unlock();
				return HisCCMError_QualcommPDAFStep2;
			}
			int iROiW= stROI.right-stROI.left, iROIH = stROI.bottom-stROI.top;
			emit information("Black stripes ROI L T R B: " % QString::number(stROI.left)%"," %QString::number(stROI.top)%","%QString::number(stROI.right)%","%QString::number(stROI.bottom));
			float* pflY	=	(float*)_aligned_malloc(iROiW *iROIH *sizeof(float), 64);
			ROPLOW::GetPartImageFromRGB24(pucRGB24, itemshareData.previewParameter->iWidth, itemshareData.previewParameter->iHeight, \
				_HisCCMAlg_ImageBuffer_Channel_Gr, stROI, pflY);	
			int isftcurvelen = iROiW + 1;
			double* pdflsfrvalue	=	new double[isftcurvelen];
			int iresult=classAlgorithm.HisCCMSFROne(pflY,iROiW, iROIH, ucMinCantrast, pdflsfrvalue, isftcurvelen, fMTFValue[i]);
			//emit information("SFR Value: " % QString::number(fMTFValue[i], 'f', 3)%",sfr return:"% QString::number(iresult));
			HisReleaseMalloc(pflY);
			HisReleaseNewB(pdflsfrvalue);
			//************
			_itemDraw stItem;
			stItem.uctype	=	HisDrawType_Block;
			stItem.strinfo.stblock	=stROI;
			stItem.stcolor	=	QColor::fromRgb(0,255,0);
			vectorDraw.push_back(stItem);
			stItem.uctype	=	HisDrawType_Text;
			stItem.idata[0]	=	stROI.right;
			stItem.idata[1]	=	stROI.bottom;
			stItem.stcolor	=	QColor::fromRgb(0,255,0);
			sprintf(stItem.strinfo.strtext, "%.3f", fMTFValue[i]);
			vectorDraw.push_back(stItem);
			_CODE_RJAFA_LP_ASIGNDRAW
				//*************
				emit information(QTextCodec::codecForName( "GBK")->toUnicode("CDAF对焦: Move Lens to:") % QString::number(iDACPos[i])%"Value:"% QString::number(fMTFValue[i], 'f', 5));
			if(iMaxMTFValue<fMTFValue[i] ) {iMaxMTFValue=fMTFValue[i];bPeakFind=true;iMaxLensPosIndex=i;}
			if(bPeakFind && (i>iMaxLensPosIndex))
			{
				iPeakDropArrary[i]=1;
				iPeakDropCnt++;
				if(itemshareData.pdafParameter->bPDAFVerifyMTFDropStop )
				{
					if((iPeakDropCnt>=4)&&(iPeakDropArrary[i-3]==1)&& (iPeakDropArrary[i-2]==1) && (iPeakDropArrary[i-1]==1) && (iPeakDropArrary[i]==1))
					{
						if( (fMTFValue[i]< fMTFValue[i-1]) && (fMTFValue[i-1]< fMTFValue[i-2])/*&& (fMTFValue[i-2]< fMTFValue[i-3])*/ )
						{
							//float DevMax=abs(fMTFValue[iMaxLensPosIndex]-fMTFValue[i-4]);
							//if((iMaxLensPosIndex!=(i-4))&& (DevMax<0.001)) iMaxLensPosIndex=i-4;
							int iDataSize=i;// First data skip
							float fMaxSommthMTF=0;
							CureSmooth(fMTFValue+1,fMTFSommth+1,iDataSize);
							FindCurePeak(fMTFSommth+1,iDataSize,fMaxSommthMTF,iMaxLensPosIndex);
							iCDAFTrueDAC=iDACPos[iMaxLensPosIndex+1];
							emit information(QTextCodec::codecForName( "GBK")->toUnicode("MTF Peak find and drop 3 counts in continues")%"Peak DAC:"% QString::number(iCDAFTrueDAC));
							break;
						}
					}
				}
			}
		}
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("CDAF found peak:")% QString::number(iCDAFTrueDAC)%"Dev to PDAF:"% QString::number(abs(iCDAFTrueDAC-iPDAFTrueDAC)));
		HisReleaseMalloc(pucRGB24);
		if(!iPeakDropCnt)  iCDAFTrueDAC=iDACPos[iMaxLensPosIndex];
		//Capture CDAF infocused image
		if(hisglobalparameter.bDebugMode)
		{	
			unsigned short* pusRaw10Verify	=	(unsigned short*)_aligned_malloc(itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight *sizeof(unsigned short), _HisCacheLine_Aligned);
			if(!pusRaw10Verify){
				itemshareData.itemparameterLock.unlock();
				return HisFX3Error_MallocBuffer;
			}
			iresult	=	GetFreshframe((unsigned char*)(pusRaw10Verify), itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight*2, _FrameType_Raw10, true);
			if(iresult){
				HisReleaseMalloc(pusRaw10Verify);
				itemshareData.itemparameterLock.unlock();
				return iresult;
			}
			iresult	=	setMotor(itemshareData.ccmhardwareParameter->motortype.toAscii().data(), \
				itemshareData.previewParameter->ucSlave, itemshareData.ccmhardwareParameter->projectname.toAscii().data(), \
				iPDAFTrueDAC, globalFunPointer.ReadHisFX3IIC, globalFunPointer.WriteHisFX3IIC, globalFunPointer.SetHisFX3IICSpeed, globalFunPointer.PullHisFX3RESET, globalFunPointer.PullHisFX3PWND, \
				globalFunPointer.PageWriteHisFX3IIC, globalFunPointer.PageReadHisFX3IIC, globalFunPointer.HisFX3PageWriteSPI, globalFunPointer.HisFX3PageReadSPI);
			if(iresult&&(!threadshareData.bOfflineMode))
			{
				emit information(QTextCodec::codecForName( "GBK")->toUnicode("设置马达位置失败"));
				itemshareData.itemparameterLock.unlock();
				return iresult;
			}
			Sleep(itemshareData.pdafParameter->uiMotorSleep);
			iresult	=	GetFreshframe((unsigned char*)(pusRaw10Verify), itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight*2, _FrameType_Raw10, true);
			if(iresult){
				HisReleaseMalloc(pusRaw10Verify);
				itemshareData.itemparameterLock.unlock();
				return iresult;
			}
			ROPLOW::saveRaw10(strIniPath, strSerialNumber % "_Qualcomm_Step2_CDAFIn-Focused"%(QDateTime::currentDateTime()).toString("yyyyMMdd_hhmmss"), itemshareData.previewParameter->ucDataFormat, \
				itemshareData.previewParameter->iWidth, itemshareData.previewParameter->iHeight, (void*)(pusRaw10Verify));
			HisReleaseMalloc(pusRaw10Verify);
		}
		if((abs(iCDAFTrueDAC-iPDAFTrueDAC))>itemshareData.pdafParameter->usQualcommkverifyoffest)
		{
			emit information(QTextCodec::codecForName( "GBK")->toUnicode("CDAF with PDAF in focused postion is over spec:") % QString::number(abs(iCDAFTrueDAC-iPDAFTrueDAC)));
			iresult=HisCCMError_QualcommPDAFStep2Verify;
		}
	}   

	//Save log

	strIniPath	=	QDir::currentPath() % "/QualcommPDAFLog";
	classDir.mkpath(strIniPath);
	QString strTime;
	if(itemshareData.pdafParameter->strQualcommGainMapStruct=="2D")
	{
		strIniPath	=	strIniPath % "/" % strSerialNumber % "_Qualcomm2D_PDAF_Step2_"%(QDateTime::currentDateTime()).toString("yyyyMMdd_hhmmss")%".csv";
	}
	else if(itemshareData.pdafParameter->strQualcommGainMapStruct=="1D")
	{
		strIniPath	=	strIniPath % "/" % strSerialNumber % "_Qualcomm1D_PDAF_Step2_"%(QDateTime::currentDateTime()).toString("yyyyMMdd_hhmmss")%".csv";
	}
	FILE* fileStep2	=	fopen(strIniPath.toAscii().data(),"wb");
	if(fileStep2 != NULL)
	{
		fprintf(fileStep2,"Note:[0]-20CM-Lens80%,[1]-20CM-Lens60%,[2]-50CM-Lens80%,[3]-50CM-Lens60%\r\n");
		fprintf(fileStep2,"     CCM Infinity:%d Macro:%d, Qualcomm K Calibration Lens Position  %d, %d, %d, %d\r\n",iInfiniteMotor,iMacroMotor,iLensPos[0],iLensPos[1],iLensPos[2],iLensPos[3]);
		fprintf(fileStep2,"==============================================================================\r\n");
		for(int i=0;i<4;i++)
		{
			fprintf(fileStep2,"[%d]_Phase Difference Conversion Coefficient = %d\r\n",i,stPDAFConfig.CalibrationKOutputValues[i].PDConversionCoef[0]);
			fprintf(fileStep2,"[%d]_FIRST IMAGE --> Phase Shift = %f Confidence Level = %d\r\n",i,stPDAFConfig.CalibrationKOutputValues[i].FirstImage_PDShiftValue[0],
				stPDAFConfig.CalibrationKOutputValues[i].FirstImage_CLValue[0]);
			fprintf(fileStep2,"[%d]_SECOND IMAGE --> Phase Shift = %f Confidence Level = %d\r\n",i,stPDAFConfig.CalibrationKOutputValues[i].SecondImage_PDShiftValue[0],
				stPDAFConfig.CalibrationKOutputValues[i].SecondImage_CLValue[0]);
		}
		fprintf(fileStep2,"KValue_Diff:%d\r\n",iKValueMax-iKValueMin);
		//fprintf(fileStep2,"KCalibraiton_Result:%s\r\n",(iKCalibrationRes)?("FAIL"):("PASS"));
		fprintf(fileStep2,"==============================================================================\r\n");
		if(itemshareData.pdafParameter->bQualcommpdafverify)
		{
			fprintf(fileStep2,"PDAF_infocusedDAC:%d,CDAF_infocusedDAC:%d, Dev(PDAF-CDAF):%d\r\n",iPDAFTrueDAC,iCDAFTrueDAC,iPDAFTrueDAC-iCDAFTrueDAC);
			for(int i=0;i<itemshareData.pdafParameter->usVerifyDACShiftCount;i++)
			{
				fprintf(fileStep2,"DAC[%d],",iDACPos[i]);
			}
			fprintf(fileStep2,"\r\n");
			for(int i=0;i<itemshareData.pdafParameter->usVerifyDACShiftCount;i++)
			{
				fprintf(fileStep2,"%f,",fMTFValue[i]);
			}
			fprintf(fileStep2,"\r\n");
			for(int i=0;i<itemshareData.pdafParameter->usVerifyDACShiftCount;i++)
			{
				fprintf(fileStep2,"%f,",fMTFSommth[i]);
			}
			fprintf(fileStep2,"\r\n");

		}
		fclose(fileStep2);
	}
	//Data to burn & result is pass
	if((!iresult) &&(!threadshareData.bOfflineMode))
	{
		stPDAFConfig.ucTpye=2;
		emit enableinfotimer(1);
		iresult	=	writeQualcommPDAF(*globalFunPointer.vectorHisCCMOTPInfoW, &stPDAFConfig, globalFunPointer.ReadHisFX3IIC, globalFunPointer.WriteHisFX3IIC, globalFunPointer.SetHisFX3IICSpeed, \
			globalFunPointer.SetHisFX3Voltage, globalFunPointer.GetHisFX3Voltage, SetHisFX3VFuseVolt, GetHisFX3VFuseVolt, GetFreshframe, \
			globalFunPointer.BatchWriteHisFX3IIC, globalFunPointer.BatchReadHisFX3IIC, SetHisFX3GPIO, GetHisFX3GPIO, globalFunPointer.PullHisFX3RESET, globalFunPointer.PullHisFX3PWND, \
			globalFunPointer.BatchReadHisFX3IICNoLimit, globalFunPointer.BatchWriteHisFX3IICNoLimit,globalFunPointer.HisFX3LogPush_back, globalFunPointer.PageWriteHisFX3IIC, globalFunPointer.PageReadHisFX3IIC, \
			globalFunPointer.HisFX3PageWriteSPI, globalFunPointer.HisFX3PageReadSPI);
		emit enableinfotimer(0);
		if(iresult)
		{
			emit information(QTextCodec::codecForName( "GBK")->toUnicode("写入PDAF Step2 数据失败"));
			itemshareData.itemparameterLock.unlock();
			return iresult;
		}
	}

	itemshareData.itemparameterLock.unlock();
	return iresult;
}

//#define QT_PDAF_LoadImage


int itemprocess::QualCommPDAFStep1()
{
#ifdef _WIN64
	emit information(QTextCodec::codecForName( "GBK")->toUnicode("Qualcomm PDAF 不支持64位软件") );
	return HisCCMError_NotSupportx64;
#endif

	itemshareData.itemparameterLock.lockForRead();

	QString strSerialNumber;
	classLog->getserialnumber(strSerialNumber);
	_HisCCMAFBurn_Config stAFConfig;
	stAFConfig.bDebug						=	hisglobalparameter.bDebugMode;
	stAFConfig.strDriverIC				=	(itemshareData.ccmhardwareParameter->motortype.toAscii()).data();
	stAFConfig.strproject					=	itemshareData.ccmhardwareParameter->projectname.toAscii().data();
	stAFConfig.strsensor					=	itemshareData.ccmhardwareParameter->sensortype.toAscii().data();
	stAFConfig.bNear						=	true;
	stAFConfig.bInfinite						=	true;
	stAFConfig.iwidth						=	itemshareData.previewParameter->iWidth;
	stAFConfig.iheight						=	itemshareData.previewParameter->iHeight;
	stAFConfig.strFunctionChoose	=	itemshareData.pdafParameter->strAFChoose.toAscii().data();
	stAFConfig.ucSlave					=	itemshareData.previewParameter->ucSlave;
	stAFConfig.uiDataFormat			=	itemshareData.previewParameter->ucDataFormat;
	stAFConfig.ucEESlave				=	itemshareData.ccmhardwareParameter->ucEESlave;
	stAFConfig.strSerialNumber		=	strSerialNumber.toAscii().data();

#if (defined _WIN64) && (defined _DEBUG)
	QString strLibPath	=	QDir::currentPath() % "/HisCCMOTP64D";
#elif (defined _WIN64) && !(defined _DEBUG)
	QString strLibPath	=	QDir::currentPath() % "/HisCCMOTP64";
#elif (defined _WIN32) && (defined _DEBUG)
	QString strLibPath	=	QDir::currentPath() % "/HisCCMOTP32D";
#else
	QString strLibPath	=	QDir::currentPath() % "/HisCCMOTP32";
#endif

	RolongoOTPAPIVersion getRolongoOTPAPIVersion = (RolongoOTPAPIVersion)(QLibrary::resolve(strLibPath, "getRolongoOTPAPIVersion"));
	Rolongocheckafmotor checkafmotor = (Rolongocheckafmotor)(QLibrary::resolve(strLibPath, "checkafmotor"));
	RolongowriteQualcommPDAF writeQualcommPDAF = (RolongowriteQualcommPDAF)(QLibrary::resolve(strLibPath, "writeQualcommPDAF"));

	if(!(getRolongoOTPAPIVersion && checkafmotor && writeQualcommPDAF)){
		emit information(tr("Resolve HisCCMOTP DLL Function Fail"));
		itemshareData.itemparameterLock.unlock();
		return HisCCMError_LoadDLLFuc;
	}

	int iresult=0;
	if(!threadshareData.bOfflineMode){
		emit enableinfotimer(1);
		iresult	=	checkafmotor(*globalFunPointer.vectorHisCCMOTPInfoW, &stAFConfig, globalFunPointer.ReadHisFX3IIC, globalFunPointer.WriteHisFX3IIC, globalFunPointer.SetHisFX3IICSpeed, globalFunPointer.SetHisFX3Voltage, \
			globalFunPointer.GetHisFX3Voltage, SetHisFX3VFuseVolt, GetHisFX3VFuseVolt, GetFreshframe, SetHisFX3GPIO, GetHisFX3GPIO, \
			globalFunPointer.PullHisFX3RESET, globalFunPointer.PullHisFX3PWND, globalFunPointer.BatchReadHisFX3IICNoLimit, globalFunPointer.BatchWriteHisFX3IICNoLimit, \
			globalFunPointer.HisFX3LogPush_back, globalFunPointer.PageWriteHisFX3IIC, globalFunPointer.PageReadHisFX3IIC, \
			globalFunPointer.HisFX3PageWriteSPI, globalFunPointer.HisFX3PageReadSPI);
		emit enableinfotimer(0);
		if(iresult){
			itemshareData.itemparameterLock.unlock();
			return iresult;
		}

		int iInfiniteMotor	=	stAFConfig.iInfinitMotor;
		int iMacroMotor	=	stAFConfig.iNearMotor;

		emit information(QTextCodec::codecForName( "GBK")->toUnicode("近焦位置：") % QString::number(iMacroMotor));
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("远焦位置：") % QString::number(iInfiniteMotor));

		if(itemshareData.pdafParameter->bWhiteMove2NearFocus){
			iresult	=	setMotor(itemshareData.ccmhardwareParameter->motortype.toAscii().data(), \
				itemshareData.previewParameter->ucSlave, itemshareData.ccmhardwareParameter->projectname.toAscii().data(), \
				iMacroMotor, globalFunPointer.ReadHisFX3IIC, globalFunPointer.WriteHisFX3IIC, globalFunPointer.SetHisFX3IICSpeed, globalFunPointer.PullHisFX3RESET, globalFunPointer.PullHisFX3PWND, \
				globalFunPointer.PageWriteHisFX3IIC, globalFunPointer.PageReadHisFX3IIC, globalFunPointer.HisFX3PageWriteSPI, globalFunPointer.HisFX3PageReadSPI);
			if(iresult){
				emit information(QTextCodec::codecForName( "GBK")->toUnicode("设置马达到近焦位置失败"));
				itemshareData.itemparameterLock.unlock();
				return iresult;
			}

			Sleep(itemshareData.pdafParameter->uiMotorSleep);
		}
	}

	strLibPath	=	QDir::currentPath() % "/pdaflib/qualcomm";
	strLibPath	=	strLibPath % "/x86/PDAFCalibrationTools_Rev" % itemshareData.pdafParameter->cVersion % "_Dll";
	typedef int (*qualcomm_PDAF_Cal_GainMap)(short *RAWDATA,int nWidth, int nHeight, PDAFPattern PDAFPatternValue, GainMap2DDataStruct *GainMapData2D, GainMap1DDataStruct *GainMapData1D, GainMapVerifyStruct &gmvs);
	typedef int (*qualcomm_PDAF_Cal_PDConversionCoef)(short *FirstImg,short *SecondImg,int nWidth, int nHeight,float FirstImg_LensPos, float SecondImg_LensPos, GainMapStruct GainMap,PDAFPattern PDAFPatternValue, bool MultipleRegions,CalibrationKOutputParams &CalibrationKOutput);
	typedef bool (*qualcomm_PDAF_Cal_Verification)(short *Distance50cmLensPosition9_Img,int nWidth, int nHeight,GainMapStruct GainMapData, PDAFPattern PDAFPatternValue,VerificationInputParams *VerificationValue,VerificationOutputParams &VerificationOutput);
	typedef unsigned short (*qualcomm_GM_Constraint)(GainMapVerifyStruct &gmvs, GainMap2DDataStruct *gm2d, GainMap1DDataStruct *gm1d);
	typedef int (*qualcomm_OTP_single_defect_1DGainmap)(GainMap1DDataStruct &gm1d, int GainDiff);
	typedef int (*qualcomm_OTP_single_defect_2DGainmap)(GainMap2DDataStruct &gm2d, int GainDiff);
	typedef void (*qualcomm_PDAF_Cal_get_lib_version)(char *s);
	typedef void (*qualcomm_PDAF_Cal_get_lib_features)(char *s);

	qualcomm_PDAF_Cal_GainMap PDAF_Cal_GainMap	=	(qualcomm_PDAF_Cal_GainMap)(QLibrary::resolve(strLibPath, "PDAF_Cal_GainMap"));
	qualcomm_PDAF_Cal_PDConversionCoef PDAF_Cal_PDConversionCoef	=	(qualcomm_PDAF_Cal_PDConversionCoef)(QLibrary::resolve(strLibPath, "PDAF_Cal_PDConversionCoef"));
	qualcomm_PDAF_Cal_Verification PDAF_Cal_Verification	=	(qualcomm_PDAF_Cal_Verification)(QLibrary::resolve(strLibPath, "PDAF_Cal_Verification"));
	qualcomm_GM_Constraint GM_Constraint	=	(qualcomm_GM_Constraint)(QLibrary::resolve(strLibPath, "GM_Constraint"));
	qualcomm_OTP_single_defect_1DGainmap OTP_single_defect_1DGainmap	=	(qualcomm_OTP_single_defect_1DGainmap)(QLibrary::resolve(strLibPath, "OTP_single_defect_1DGainmap"));
	qualcomm_OTP_single_defect_2DGainmap OTP_single_defect_2DGainmap	=	(qualcomm_OTP_single_defect_2DGainmap)(QLibrary::resolve(strLibPath, "OTP_single_defect_2DGainmap"));
	qualcomm_PDAF_Cal_get_lib_version PDAF_Cal_get_lib_version	=	(qualcomm_PDAF_Cal_get_lib_version)(QLibrary::resolve(strLibPath, "PDAF_Cal_get_lib_version"));
	qualcomm_PDAF_Cal_get_lib_features PDAF_Cal_get_lib_features	=	(qualcomm_PDAF_Cal_get_lib_features)(QLibrary::resolve(strLibPath, "PDAF_Cal_get_lib_features"));

	if(!(PDAF_Cal_GainMap && PDAF_Cal_PDConversionCoef && PDAF_Cal_Verification && GM_Constraint && \
		OTP_single_defect_1DGainmap && OTP_single_defect_2DGainmap && PDAF_Cal_get_lib_version && PDAF_Cal_get_lib_features)){
			emit information(tr("Resolve Qulacomm PDAF DLL Function Fail"));
			itemshareData.itemparameterLock.unlock();
			return HisCCMError_LoadDLLFuc;
	}

	//IMX258
	if(itemshareData.pdafParameter->bSONY258MTKCal)
	{
		iresult=ApplySONYIMX258SPC();
		if(iresult)
		{
			emit information(QTextCodec::codecForName( "GBK")->toUnicode("Apply SONY IMX258 SPC 失败"));
			itemshareData.itemparameterLock.unlock();
			return iresult;
		}
	}

	char strLibInfo[2048];
	PDAF_Cal_get_lib_version(strLibInfo);
	emit information(QString::fromAscii(strLibInfo));
	PDAF_Cal_get_lib_features(strLibInfo);
	emit information(QString::fromAscii(strLibInfo));

	GainMapVerifyStruct gmvs;
	//gmvs.MinPixelAvg  :for 10-bit data, Pixel average value shouldn't smaller than this
	//gmvs.MaxPixelAvg  : ... shouldn't bigger than this
	//gmvs.MinPDAvg     : PD Signal average shouldn't smaller than this
	//gmvs.MaxPDAvg     : PD Signal average shouldn't bigger than this
	//gmvs.MinGain      : PD Gainmap shouldn't smaller than this
	//gmvs.MaxGain      : PD Gainmap value shouldn't bigger than this
	//gmvs.MaxPixelThresh   : max signal of normal pixel should be higher than this
	/* indicator of bit-width error: 
	if max < 256, then could be too dark for a flat image of 10-bit.
	*/
	gmvs.MinPixelAvg = 64;
	gmvs.MaxPixelAvg = 1023;    // disabled
	gmvs.MinPDAvg = 64;         // 
	gmvs.MaxPDAvg = 1023;       // disabled
	gmvs.MinGain = 64;          // 0.25x gain
	gmvs.MaxGain = 1024;        // 4x gain
	gmvs.MaxPixelThresh = 256;  // 1/4 of max range (1023)
	gmvs.GainDiff = 256;

	unsigned short* pusRaw10	=	(unsigned short*)_aligned_malloc(itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight *sizeof(unsigned short), _HisCacheLine_Aligned);
	if(!pusRaw10){
		itemshareData.itemparameterLock.unlock();
		return HisFX3Error_MallocBuffer;
	}

	iresult	=	GetFreshframe((unsigned char*)(pusRaw10), itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight *2, _FrameType_Raw10, true);
	if(iresult){
		HisReleaseMalloc(pusRaw10);
		itemshareData.itemparameterLock.unlock();
		return iresult;
	}

	PDAFPattern PDAFPatternValue;
	QString strIniPath = "E:\\QtProject\\HisFX3CCMTest-80[Main]\\HisFX3CCMTest\\pdaftemplate\\Qualcomm\\hi1333\\Config.ini";
	//QString strIniPath = "./pdaftemplate/Qualcomm/" % itemshareData.ccmhardwareParameter->projectname % "/Config.ini";
	if(!QFile::exists(strIniPath)){
		HisReleaseMalloc(pusRaw10);
		emit information(tr("File not exist: ") % strIniPath);
		itemshareData.itemparameterLock.unlock();
		return HisCCMError_FilePath;
	}

	_HisQualcommPDAFBurn_Config stPDAFConfig;
	stPDAFConfig.bDebug					=		hisglobalparameter.bDebugMode;
	stPDAFConfig.ucSensorSlave		=		itemshareData.previewParameter->ucSlave;
	stPDAFConfig.strproject					=		itemshareData.ccmhardwareParameter->projectname.toAscii().data();
	stPDAFConfig.strsensor					=		itemshareData.ccmhardwareParameter->sensortype.toAscii().data();
	stPDAFConfig.strDriverIC				=		itemshareData.ccmhardwareParameter->motortype.toAscii().data();

	stPDAFConfig.strFunctionChoose	=	itemshareData.pdafParameter->strQualcommChoose.toAscii().data();
	stPDAFConfig.ucEESlave				=	itemshareData.ccmhardwareParameter->ucEESlave;

	QSettings classIniConfig(strIniPath, QSettings::IniFormat);
	QStringList childKeys = classIniConfig.allKeys();
	for(int x=0;	x<childKeys.size();	++x){
		if(childKeys.at(x) == "GlobalShift_x") PDAFPatternValue.GlobalShift_x =	classIniConfig.value(childKeys.at(x)).toInt();
		else if(childKeys.at(x) == "GlobalShift_y") PDAFPatternValue.GlobalShift_y =	classIniConfig.value(childKeys.at(x)).toInt();
		else if(childKeys.at(x) == "x_step") PDAFPatternValue.x_step =	classIniConfig.value(childKeys.at(x)).toInt();
		else if(childKeys.at(x) == "y_step") PDAFPatternValue.y_step =	classIniConfig.value(childKeys.at(x)).toInt();
		else if(childKeys.at(x) == "SensorGain") PDAFPatternValue.SensorGain =	classIniConfig.value(childKeys.at(x)).toInt();
		else if(childKeys.at(x) == "ImageBits") PDAFPatternValue.ImageBits =	classIniConfig.value(childKeys.at(x)).toInt();
		else if(childKeys.at(x) == "BlackLevel") PDAFPatternValue.BlackLevel =	classIniConfig.value(childKeys.at(x)).toInt();
		else if(childKeys.at(x) == "DSRatio") PDAFPatternValue.DSRatio =	classIniConfig.value(childKeys.at(x)).toInt();
		else if(childKeys.at(x) == "PDAFonG") PDAFPatternValue.PDAFonG =	(classIniConfig.value(childKeys.at(x)).toString() == "true");
		else if(childKeys.at(x) == "OTPFormat_Type"){

		}
	}

	strIniPath = "E:\\QtProject\\HisFX3CCMTest-80[Main]\\HisFX3CCMTest\\pdaftemplate\\Qualcomm\\hi1333\\PDAFPattern.txt";
	//strIniPath = "./pdaftemplate/Qualcomm/" % itemshareData.ccmhardwareParameter->projectname % "/PDAFPattern.txt";
	if(!QFile::exists(strIniPath)){

		emit information(tr("File not exist: ") % strIniPath);
		itemshareData.itemparameterLock.unlock();
		return HisCCMError_FilePath;
	}
	strcpy(PDAFPatternValue.PDAFPatternFilename, strIniPath.toAscii().data());
	// Qualcomm PDAF gain map call 
	int GainMapResult =0;
	if(itemshareData.pdafParameter->strQualcommGainMapStruct=="1D")
	{
		GainMapResult = PDAF_Cal_GainMap((short*)(pusRaw10), itemshareData.previewParameter->iWidth, itemshareData.previewParameter->iHeight, \
			PDAFPatternValue, NULL,&(stPDAFConfig.GainMapData1D), gmvs);

		stPDAFConfig.strGainMapDataStruct="1D";
		stPDAFConfig.GainMapData1D.VersionNum=0x01; // Set Qualcomm PDAF version to 0x01
		stPDAFConfig.usGainMapSize=stPDAFConfig.GainMapData1D.DSLength;
	}
	else if(itemshareData.pdafParameter->strQualcommGainMapStruct=="2D")
	{
		GainMapResult= PDAF_Cal_GainMap((short*)(pusRaw10), itemshareData.previewParameter->iWidth, itemshareData.previewParameter->iHeight, \
			PDAFPatternValue,&(stPDAFConfig.GainMapData2D), NULL, gmvs);

		stPDAFConfig.strGainMapDataStruct="2D";
		stPDAFConfig.GainMapData2D.VersionNum=0x02;  		// Set Qualcomm PDAF version to 0x02
		stPDAFConfig.usGainMapSize=stPDAFConfig.GainMapData2D.MapWidth*stPDAFConfig.GainMapData2D.MapHeight;
	}
	// Check result
	iresult= Display_GmCheckResult(GainMapResult);
	emit information(QTextCodec::codecForName( "GBK")->toUnicode("Display_GmCheckResult：") % QString::number(GainMapResult));
	if(iresult!=0)
	{ 
		printf("Some Error in Gain Map, Stop. \n");
		HisReleaseMalloc(pusRaw10);
		return iresult;
	}
	//Save image by selection
	QDir classDir;
	if(hisglobalparameter.bDebugMode)
	{	
		strIniPath	=	QDir::currentPath() % "/QualcommPDAFImage";
		classDir.mkpath(strIniPath);
		ROPLOW::saveRaw10(strIniPath, strSerialNumber % "_Qualcomm_Step1"%(QDateTime::currentDateTime()).toString("yyyyMMdd_hhmmss"), itemshareData.previewParameter->ucDataFormat, \
			itemshareData.previewParameter->iWidth, itemshareData.previewParameter->iHeight, (void*)(pusRaw10));
	}
	HisReleaseMalloc(pusRaw10);
	//Save log 
	strIniPath	=	QDir::currentPath() % "/QualcommPDAFLog";
	classDir.mkpath(strIniPath);
	if(itemshareData.pdafParameter->strQualcommGainMapStruct=="2D") 
	{
		strIniPath	=	strIniPath % "/" % strSerialNumber % "_Qualcomm2D_PDAF_Step1_"%(QDateTime::currentDateTime()).toString("yyyyMMdd_hhmmss")%".txt";
		FILE* fileStep1	=	fopen(strIniPath.toAscii().data(), "wb");
		if(fileStep1 != NULL)
		{
			fprintf(fileStep1,"%x\n",stPDAFConfig.GainMapData2D.VersionNum);
			fprintf(fileStep1,"%x\n",stPDAFConfig.GainMapData2D.OffsetX);
			fprintf(fileStep1,"%x\n",stPDAFConfig.GainMapData2D.OffsetY);
			fprintf(fileStep1,"%x\n",stPDAFConfig.GainMapData2D.RatioX);
			fprintf(fileStep1,"%x\n",stPDAFConfig.GainMapData2D.RatioY);
			fprintf(fileStep1,"%x\n",stPDAFConfig.GainMapData2D.MapWidth);
			fprintf(fileStep1,"%x\n",stPDAFConfig.GainMapData2D.MapHeight);
			for (unsigned int i = 0; i < stPDAFConfig.GainMapData2D.MapHeight*stPDAFConfig.GainMapData2D.MapWidth; i ++)
				fprintf(fileStep1,"%x\n",stPDAFConfig.GainMapData2D.Left_GainMap[i]);
			for (unsigned int i = 0; i < stPDAFConfig.GainMapData2D.MapHeight*stPDAFConfig.GainMapData2D.MapWidth; i ++)
				fprintf(fileStep1,"%x\n",stPDAFConfig.GainMapData2D.Right_GainMap[i]);
			fclose(fileStep1);
		}
	}
	else if(itemshareData.pdafParameter->strQualcommGainMapStruct=="1D")
	{
		strIniPath	=	strIniPath % "/" % strSerialNumber % "_Qualcomm1D_PDAF_Step1_"%(QDateTime::currentDateTime()).toString("yyyyMMdd_hhmmss")%".txt";
		FILE* fileStep1	=	fopen(strIniPath.toAscii().data(), "wb");
		if(fileStep1 != NULL)
		{
			fprintf(fileStep1,"%x\n",stPDAFConfig.GainMapData1D.VersionNum);
			fprintf(fileStep1,"%x\n",stPDAFConfig.GainMapData1D.DSRatio);
			fprintf(fileStep1,"%x\n",stPDAFConfig.GainMapData1D.ActualLength);
			fprintf(fileStep1,"%x\n",stPDAFConfig.GainMapData1D.DSLength);
			for (unsigned int i = 0; i < stPDAFConfig.GainMapData1D.DSLength; i ++)
				fprintf(fileStep1,"%x\n",stPDAFConfig.GainMapData1D.Left_GainMap[i]);
			for (unsigned int i = 0; i < stPDAFConfig.GainMapData1D.DSLength; i ++)
				fprintf(fileStep1,"%x\n",stPDAFConfig.GainMapData1D.Right_GainMap[i]);
			fclose(fileStep1);
		}
	}
	//Gainmap data to burn 
	emit enableinfotimer(1);
	stPDAFConfig.ucTpye	= 1;
	iresult	=	writeQualcommPDAF(*globalFunPointer.vectorHisCCMOTPInfoW, &stPDAFConfig, globalFunPointer.ReadHisFX3IIC, globalFunPointer.WriteHisFX3IIC, globalFunPointer.SetHisFX3IICSpeed, \
		globalFunPointer.SetHisFX3Voltage, globalFunPointer.GetHisFX3Voltage, SetHisFX3VFuseVolt, GetHisFX3VFuseVolt, GetFreshframe, \
		globalFunPointer.BatchWriteHisFX3IIC, globalFunPointer.BatchReadHisFX3IIC, SetHisFX3GPIO, GetHisFX3GPIO, globalFunPointer.PullHisFX3RESET, globalFunPointer.PullHisFX3PWND, \
		globalFunPointer.BatchReadHisFX3IICNoLimit, globalFunPointer.BatchWriteHisFX3IICNoLimit,globalFunPointer.HisFX3LogPush_back, globalFunPointer.PageWriteHisFX3IIC, globalFunPointer.PageReadHisFX3IIC, \
		globalFunPointer.HisFX3PageWriteSPI, globalFunPointer.HisFX3PageReadSPI);
	emit enableinfotimer(0);
	if(iresult&&(!threadshareData.bOfflineMode))
	{
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("写入PDAF Step1 数据失败"));
		itemshareData.itemparameterLock.unlock();
		return iresult;
	}
	itemshareData.itemparameterLock.unlock();
	return 0;
}

void itemprocess::RAW10CovertDualPDLeftandRightImage(unsigned short *img,_HisFX3_BaylorMode cfa,unsigned int iWidth, unsigned int iHeight,unsigned short *img_l, unsigned short *img_r )
{
	int k=0,l=0;
	switch(cfa)
	{
	case HisBaylor8_GRBG:
	case HisBaylor8_GBRG:
	case HisBaylor10_GRBG:
	case HisBaylor10_GBRG:
		{
			for (int i = 0; i < (iHeight>>2); i++)	
			{
				for (int j = 0; j < (iWidth>>2); j++) 
				{
					k = i<<2;
					l = j<<2;

					img_l[ i*(iWidth>>2) + j] = 
						( img[ (k+0)*iWidth + (l+0)] + 
						img[ (k+1)*iWidth + (l+2)] + 
						img[ (k+2)*iWidth + (l+0)] + 
						img[ (k+3)*iWidth + (l+2)] )>>2;

					img_r[i*(iWidth>>2) + j] =
						( img[ (k+0)*iWidth + (l+1)] + 
						img[ (k+1)*iWidth + (l+3)] + 
						img[ (k+2)*iWidth + (l+1)] + 
						img[ (k+3)*iWidth + (l+3)] )>>2;      
				}
			}
		}
		break;
	case HisBaylor8_BGGR:
	case HisBaylor8_RGGB:
	case HisBaylor10_BGGR:
	case HisBaylor10_RGGB:
		{
			for (int i = 0; i < (iHeight>>2); i++)	
			{
				for (int j = 0; j < (iWidth>>2); j++) 
				{
					k = i<<2;
					l = j<<2;

					img_l[ i*(iWidth>>2) + j] = 
						( img[ (k+0)*iWidth + (l+2)] + 
						img[ (k+1)*iWidth + (l+0)] + 
						img[ (k+2)*iWidth + (l+2)] + 
						img[ (k+3)*iWidth + (l+0)] )>>2;

					img_r[i*(iWidth>>2) + j] =
						( img[ (k+0)*iWidth + (l+3)] + 
						img[ (k+1)*iWidth + (l+1)] + 
						img[ (k+2)*iWidth + (l+3)] + 
						img[ (k+3)*iWidth + (l+1)] )>>2;      
				}
			}
		}
		break;
	}
}

int itemprocess::QualCommPDAF_LVersion_GainCalibration()
{
#ifdef _WIN64
	emit information(QTextCodec::codecForName( "GBK")->toUnicode("Qualcomm PDAF 不支持64位软件") );
	return HisCCMError_NotSupportx64;
#endif

	itemshareData.itemparameterLock.lockForRead();

	QString strSerialNumber;
	classLog->getserialnumber(strSerialNumber);
	_HisCCMAFBurn_Config stAFConfig;
	stAFConfig.bDebug						=	hisglobalparameter.bDebugMode;
	stAFConfig.strDriverIC				=	(itemshareData.ccmhardwareParameter->motortype.toAscii()).data();
	stAFConfig.strproject					=	itemshareData.ccmhardwareParameter->projectname.toAscii().data();
	stAFConfig.strsensor					=	itemshareData.ccmhardwareParameter->sensortype.toAscii().data();
	stAFConfig.bNear						=	true;
	stAFConfig.bInfinite						=	true;
	stAFConfig.iwidth						=	itemshareData.previewParameter->iWidth;
	stAFConfig.iheight						=	itemshareData.previewParameter->iHeight;
	stAFConfig.strFunctionChoose	=	itemshareData.pdafParameter->strAFChoose.toAscii().data();
	stAFConfig.ucSlave					=	itemshareData.previewParameter->ucSlave;
	stAFConfig.uiDataFormat			=	itemshareData.previewParameter->ucDataFormat;
	stAFConfig.ucEESlave				=	itemshareData.ccmhardwareParameter->ucEESlave;
	stAFConfig.strSerialNumber		=	strSerialNumber.toAscii().data();

#if (defined _WIN64) && (defined _DEBUG)
	QString strLibPath	=	QDir::currentPath() % "/HisCCMOTP64D";
#elif (defined _WIN64) && !(defined _DEBUG)
	QString strLibPath	=	QDir::currentPath() % "/HisCCMOTP64";
#elif (defined _WIN32) && (defined _DEBUG)
	QString strLibPath	=	QDir::currentPath() % "/HisCCMOTP32D";
#else
	QString strLibPath	=	QDir::currentPath() % "/HisCCMOTP32";
#endif

	RolongoOTPAPIVersion getRolongoOTPAPIVersion = (RolongoOTPAPIVersion)(QLibrary::resolve(strLibPath, "getRolongoOTPAPIVersion"));
	Rolongocheckafmotor checkafmotor = (Rolongocheckafmotor)(QLibrary::resolve(strLibPath, "checkafmotor"));
	RolongowriteQualcommPDAF writeQualcommPDAF = (RolongowriteQualcommPDAF)(QLibrary::resolve(strLibPath, "writeQualcommPDAF"));

	if(!(getRolongoOTPAPIVersion && checkafmotor && writeQualcommPDAF)){
		emit information(tr("Resolve HisCCMOTP DLL Function Fail"));
		itemshareData.itemparameterLock.unlock();
		return HisCCMError_LoadDLLFuc;
	}

	int iresult=0;
	if(!threadshareData.bOfflineMode)
	{
		emit enableinfotimer(1);
		iresult	=	checkafmotor(*globalFunPointer.vectorHisCCMOTPInfoW, &stAFConfig, globalFunPointer.ReadHisFX3IIC, globalFunPointer.WriteHisFX3IIC, globalFunPointer.SetHisFX3IICSpeed, globalFunPointer.SetHisFX3Voltage, \
			globalFunPointer.GetHisFX3Voltage, SetHisFX3VFuseVolt, GetHisFX3VFuseVolt, GetFreshframe, SetHisFX3GPIO, GetHisFX3GPIO, \
			globalFunPointer.PullHisFX3RESET, globalFunPointer.PullHisFX3PWND, globalFunPointer.BatchReadHisFX3IICNoLimit, globalFunPointer.BatchWriteHisFX3IICNoLimit, \
			globalFunPointer.HisFX3LogPush_back, globalFunPointer.PageWriteHisFX3IIC, globalFunPointer.PageReadHisFX3IIC, \
			globalFunPointer.HisFX3PageWriteSPI, globalFunPointer.HisFX3PageReadSPI);
		emit enableinfotimer(0);
		if(iresult){
			itemshareData.itemparameterLock.unlock();
			return iresult;
		}

		int iInfiniteMotor	=	stAFConfig.iInfinitMotor;
		int iMacroMotor	=	stAFConfig.iNearMotor;

		emit information(QTextCodec::codecForName( "GBK")->toUnicode("近焦位置：") % QString::number(iMacroMotor));
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("远焦位置：") % QString::number(iInfiniteMotor));

		int iMiddleMotor=iInfiniteMotor+(iMacroMotor-iInfiniteMotor)/2;
		iresult	=	setMotor(itemshareData.ccmhardwareParameter->motortype.toAscii().data(), \
			itemshareData.previewParameter->ucSlave, itemshareData.ccmhardwareParameter->projectname.toAscii().data(), \
			iMiddleMotor, globalFunPointer.ReadHisFX3IIC, globalFunPointer.WriteHisFX3IIC, globalFunPointer.SetHisFX3IICSpeed, globalFunPointer.PullHisFX3RESET, globalFunPointer.PullHisFX3PWND, \
			globalFunPointer.PageWriteHisFX3IIC, globalFunPointer.PageReadHisFX3IIC, globalFunPointer.HisFX3PageWriteSPI, globalFunPointer.HisFX3PageReadSPI);
		if(iresult){
			emit information(QTextCodec::codecForName( "GBK")->toUnicode("驱动马达到远近焦中间位置失败"));
			itemshareData.itemparameterLock.unlock();
			return iresult;
		}
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("驱动马达到远近焦中间位置：")%QString::number(iMiddleMotor));
		Sleep(itemshareData.pdafParameter->uiMotorSleep);
	}


	strLibPath	=	QDir::currentPath() % "/pdaflib/qualcomm";
	strLibPath	=	strLibPath % "/x86/PDAFCalibrationTools_Rev" % itemshareData.pdafParameter->cVersion % "_Dll";
	/* COMMON API FOR ALL PDAF SENSORS */
	typedef void* (*qualcomm_PDAF_Cal_create)( dll_config_t *dll_cfg );
	typedef int32_t (*qualcomm_PDAF_Cal_destroy)( void *p );
	typedef int32_t (*qualcomm_PDAF_Cal_validate_sensor_cfg)( uint16_t *img, uint16_t width, uint16_t height, sensor_config_t *sensor_cfg,uint16_t *img_l, uint16_t *img_r, uint16_t *out_width, uint16_t *out_height);

	typedef void (*qualcomm_PDAF_Cal_get_lib_version)(char *s);
	typedef void (*qualcomm_PDAF_Cal_get_lib_features)(char *s);
	typedef int32_t (*qualcomm_PDAF_Cal_get_dccmap)( void *p, dccmap_t *dcc_map, char* file_name);
	//typedef void PDAF_Cal_get_calibration_block( gainmap_t *gain_map, dccmap_t *dcc_map, pdaf_cal_t *pdaf_cal);
	//typedef int PDAF_Cal_read_calibration_block(gainmap_t *gain_map, dccmap_t *dcc_map, pdaf_cal_t *pdaf_cal);

	/* API FOR SPARSE AND 2X1 OCL PDAF SENSORS */
	typedef int32_t (*qualcomm_PDAF_Cal_get_gainmap)( void *p, uint16_t *img, sensor_config_t *sensor_cfg, gainmap_t *gain_map, gainmap_limits_t *gm_limits );
	typedef int32_t (*qualcomm_PDAF_Cal_add_raw)( void *p, int16_t stack_id, int16_t lens_pos, uint16_t *img, sensor_config_t *sensor_cfg, gainmap_t *gain_map);
	typedef int32_t (*qualcomm_PDAF_Cal_get_raw_pd)( void *p, 	uint16_t *img, sensor_config_t *sensor_cfg, gainmap_t *gain_map,pdmap_t* pdmap );

	/* API FOR DUAL PHOTODIODE PDAF SENSORS */
	typedef int32_t (*qualcomm_PDAF_Cal_get_gainmap_2pd)( void *p, uint16_t *img_l, uint16_t *img_r, uint16_t width, uint16_t height, uint16_t black_lvl, gainmap_t *gain_map, gainmap_limits_t *gm_limits, float sensor_gain);
	typedef int32_t(*qualcomm_PDAF_Cal_add_raw_2pd)( void *p, int16_t stack_id, int16_t lens_pos, uint16_t *img_l, uint16_t *img_r, uint16_t width, uint16_t height, uint16_t black_lvl, gainmap_t *gm,float sensor_gain);
	typedef int32_t (*qualcomm_PDAF_Cal_get_raw_pd_2pd)( void *p, uint16_t *img_l, uint16_t *img_r, uint16_t width, uint16_t height,uint16_t black_lvl, gainmap_t *gain_map, pdmap_t* pdmap );



	qualcomm_PDAF_Cal_create PDAF_Cal_create	=	(qualcomm_PDAF_Cal_create)(QLibrary::resolve(strLibPath, "PDAF_Cal_create"));
	qualcomm_PDAF_Cal_destroy PDAF_Cal_destroy	=	(qualcomm_PDAF_Cal_destroy)(QLibrary::resolve(strLibPath, "PDAF_Cal_destroy"));
	qualcomm_PDAF_Cal_get_lib_version PDAF_Cal_get_lib_version	=	(qualcomm_PDAF_Cal_get_lib_version)(QLibrary::resolve(strLibPath, "PDAF_Cal_get_lib_version"));
	qualcomm_PDAF_Cal_get_lib_features PDAF_Cal_get_lib_features	=	(qualcomm_PDAF_Cal_get_lib_features)(QLibrary::resolve(strLibPath, "PDAF_Cal_get_lib_features"));
	qualcomm_PDAF_Cal_get_dccmap PDAF_Cal_get_dccmap	=	(qualcomm_PDAF_Cal_get_dccmap)(QLibrary::resolve(strLibPath, "PDAF_Cal_get_dccmap"));
	qualcomm_PDAF_Cal_get_gainmap PDAF_Cal_get_gainmap	=	(qualcomm_PDAF_Cal_get_gainmap)(QLibrary::resolve(strLibPath, "PDAF_Cal_get_gainmap"));
	qualcomm_PDAF_Cal_add_raw PDAF_Cal_add_raw	=	(qualcomm_PDAF_Cal_add_raw)(QLibrary::resolve(strLibPath, "PDAF_Cal_add_raw"));
	qualcomm_PDAF_Cal_get_raw_pd PDAF_Cal_get_raw_pd	=	(qualcomm_PDAF_Cal_get_raw_pd)(QLibrary::resolve(strLibPath, "PDAF_Cal_get_raw_pd"));
	qualcomm_PDAF_Cal_get_gainmap_2pd PDAF_Cal_get_gainmap_2pd	=	(qualcomm_PDAF_Cal_get_gainmap_2pd)(QLibrary::resolve(strLibPath, "PDAF_Cal_get_gainmap_2pd"));
	qualcomm_PDAF_Cal_add_raw_2pd PDAF_Cal_add_raw_2pd	=	(qualcomm_PDAF_Cal_add_raw_2pd)(QLibrary::resolve(strLibPath, "PDAF_Cal_add_raw_2pd"));
	qualcomm_PDAF_Cal_get_raw_pd_2pd PDAF_Cal_get_raw_pd_2pd	=	(qualcomm_PDAF_Cal_get_raw_pd_2pd)(QLibrary::resolve(strLibPath, "PDAF_Cal_get_raw_pd_2pd"));

	if(!(PDAF_Cal_create && PDAF_Cal_destroy && PDAF_Cal_get_lib_version && \
		PDAF_Cal_get_lib_features && PDAF_Cal_get_dccmap && PDAF_Cal_get_gainmap && PDAF_Cal_add_raw&&PDAF_Cal_get_raw_pd&&PDAF_Cal_get_gainmap_2pd&&PDAF_Cal_add_raw_2pd&&PDAF_Cal_get_raw_pd_2pd)){
			emit information(tr("Resolve Qualcomm PDAF DLL Function Fail"));
			itemshareData.itemparameterLock.unlock();
			return HisCCMError_LoadDLLFuc;
	}


	_HisQualcommPDAFBurn_Config stPDAFConfig;
	stPDAFConfig.bDebug					=		hisglobalparameter.bDebugMode;
	stPDAFConfig.ucSensorSlave		=		itemshareData.previewParameter->ucSlave;
	stPDAFConfig.strproject					=		itemshareData.ccmhardwareParameter->projectname.toAscii().data();
	stPDAFConfig.strsensor					=		itemshareData.ccmhardwareParameter->sensortype.toAscii().data();
	stPDAFConfig.strDriverIC				=		itemshareData.ccmhardwareParameter->motortype.toAscii().data();
	stPDAFConfig.strFunctionChoose	=	itemshareData.pdafParameter->strQualcommChoose.toAscii().data();
	stPDAFConfig.ucEESlave				=	itemshareData.ccmhardwareParameter->ucEESlave;
	stPDAFConfig.strSerialNumber=	strSerialNumber.toAscii().data();
	stPDAFConfig.ucTpye=1; //gain cal


	gainmap_limits_t gm_limits;
	gm_limits.pd_max_limit   = 950;  //Max PD pixel value after LPF must be below 950
	gm_limits.pd_min_limit   = 100;  //Min PD pixel value after LPF must exceed 100
	gm_limits.gain_max_limit = (uint16_t) (7.999f * (1<<GAIN_MAP_Q_FMT));  // max gain of 8x
	// load dll config parameters
	dll_config_t     dll_cfg;
	float dcc_fir[]  = DCC_FIR;
	dll_cfg.cal_version         = CAL_VERSION;
	dll_cfg.chart_type          = LINECHART;
	dll_cfg.verify_type         = NORMALIZE;
	dll_cfg.gain_map_height     = GAIN_MAP_HEIGHT;
	dll_cfg.gain_map_width      = GAIN_MAP_WIDTH;
	dll_cfg.gain_map_q_fmt      = GAIN_MAP_Q_FMT;	
	dll_cfg.dcc_map_height      = DCC_MAP_HEIGHT;
	dll_cfg.dcc_map_width       = DCC_MAP_WIDTH;
	dll_cfg.dcc_map_q_fmt       = DCC_MAP_Q_FMT;
	memcpy(dll_cfg.dcc_fir, dcc_fir, sizeof(float)*DCC_FIR_SZ);
	dll_cfg.dcc_fir_sz          = DCC_FIR_SZ;
	dll_cfg.dcc_stack_sz        = DCC_STACK_SZ;
	dll_cfg.dcc_search_range    = DCC_SEARCH_RANGE;
	dll_cfg.dcc_fit_exclusion   = DCC_FIT_EXCLUSION;
	dll_cfg.dcc_min_pd_range    = DCC_MIN_PD_RANGE;
	dll_cfg.dcc_map_overlap     = DCC_MAP_OVERLAP;
	dll_cfg.dcc_linearity_level_theshold = DCC_LINEARITY_LEVEL_THRESHOLD;
	dll_cfg.dpd_pixel_unit      = DPD_PIXEL_UNIT;
	dll_cfg.dpd_min_sensor_gain = DPD_MIN_SENSOR_GAIN;
	dll_cfg.dpd_max_sensor_gain = DPD_MAX_SENSOR_GAIN;

	//INIT RUN ONLY ONCE 
	void *p = PDAF_Cal_create( &dll_cfg ); 
	if( p == NULL ) 
	{
		emit information(tr("dll memory allocation error"));
		itemshareData.itemparameterLock.unlock();
		return HisCCMError_LoadDLLFuc;
	}
	//calibration DLL for version number and version description
	char strLibInfo[2048];
	PDAF_Cal_get_lib_version(strLibInfo);
	emit information(QString::fromAscii(strLibInfo));
	PDAF_Cal_get_lib_features(strLibInfo);
	emit information(QString::fromAscii(strLibInfo));

	//Load Sensor Confiugure
	sensor_config_t  sensor_cfg;
	QString strIniPath;
	if(itemshareData.pdafParameter->ucpdafsensortype==0)
	{
		strIniPath = "pdaftemplate/Qualcomm/" % itemshareData.ccmhardwareParameter->projectname % "/Config.txt";
		if(!QFile::exists(strIniPath))
		{
			emit information(tr("File not exist: ") % strIniPath);
			itemshareData.itemparameterLock.unlock();
			return HisCCMError_FilePath;
		}
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("加载PDAF Sensor 配置文件")%strIniPath);
		QSettings classIniConfig(strIniPath, QSettings::IniFormat);
		QStringList childKeys = classIniConfig.allKeys();
		int index=childKeys.indexOf("pd_block_n_pd_pairs");
		sensor_cfg.pd_block_n_pd_pairs =classIniConfig.value(childKeys.at(index)).toUInt();
		for(int x=0;	x<childKeys.size();	++x)
		{
			if(childKeys.at(x) == "cfa")	
			{		
				if(classIniConfig.value(childKeys.at(x)).toString()=="BGGR") sensor_cfg.cfa=BGGR;
				else if(classIniConfig.value(childKeys.at(x)).toString()=="RGGB") sensor_cfg.cfa=RGGB;
				else if(classIniConfig.value(childKeys.at(x)).toString()=="GRBG") sensor_cfg.cfa=GRBG;
				else if(classIniConfig.value(childKeys.at(x)).toString()=="GBRG") sensor_cfg.cfa=GBRG;
			}
			else if(childKeys.at(x) == "image_width") sensor_cfg.image_width =	classIniConfig.value(childKeys.at(x)).toInt();
			else if(childKeys.at(x) == "image_height") sensor_cfg.image_height =	classIniConfig.value(childKeys.at(x)).toInt();
			else if(childKeys.at(x) == "bit_depth") sensor_cfg.bit_depth =	classIniConfig.value(childKeys.at(x)).toInt();
			else if(childKeys.at(x) == "black_lvl") sensor_cfg.black_lvl =	classIniConfig.value(childKeys.at(x)).toInt();
			else if(childKeys.at(x) == "fv_measure_channel") sensor_cfg.fv_measure_channel =	classIniConfig.value(childKeys.at(x)).toInt();
			else if(childKeys.at(x) == "pd_block_width") sensor_cfg.pd_block_width =	classIniConfig.value(childKeys.at(x)).toInt();
			else if(childKeys.at(x) == "pd_block_height") sensor_cfg.pd_block_height =	classIniConfig.value(childKeys.at(x)).toInt();
			else if(childKeys.at(x) == "pd_block_start_x") {sensor_cfg.pd_block_start_x=classIniConfig.value(childKeys.at(x)).toInt();}
			else if(childKeys.at(x) == "pd_block_start_y") {sensor_cfg.pd_block_start_y=classIniConfig.value(childKeys.at(x)).toInt();}
			else if(childKeys.at(x) == "pd_block_l_x") 
			{
				QString strvalue=classIniConfig.value(childKeys.at(x),"").toString();
				QStringList block_l_x_List = strvalue.split(","); 
				for(int i=0;i<sensor_cfg.pd_block_n_pd_pairs;i++)
				{
					sensor_cfg.pd_block_l_x[i]= block_l_x_List.at(i).toUInt();
				}
			}
			else if(childKeys.at(x) == "pd_block_l_y") 
			{
				QString strvalue=classIniConfig.value(childKeys.at(x),"").toString();
				QStringList block_l_y_List = strvalue.split(",");
				for(int i=0;i<sensor_cfg.pd_block_n_pd_pairs;i++)
				{
					sensor_cfg.pd_block_l_y[i]= block_l_y_List.at(i).toUInt();
				}
			}
			else if(childKeys.at(x) == "pd_block_r_x") 
			{
				QString strvalue=classIniConfig.value(childKeys.at(x),"").toString();
				QStringList block_r_x_List = strvalue.split(",");
				for(int i=0;i<sensor_cfg.pd_block_n_pd_pairs;i++)
				{
					sensor_cfg.pd_block_r_x[i]= block_r_x_List.at(i).toUInt();
				}
			}
			else if(childKeys.at(x) == "pd_block_r_y") 
			{
				QString strvalue=classIniConfig.value(childKeys.at(x),"").toString();
				QStringList block_r_y_List = strvalue.split(",");
				for(int i=0;i<sensor_cfg.pd_block_n_pd_pairs;i++)
				{
					sensor_cfg.pd_block_r_y[i]= block_r_y_List.at(i).toUInt();
				}
			}
		}
	}

	//
	unsigned short* pusRaw10	=	(unsigned short*)_aligned_malloc(itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight *sizeof(unsigned short), _HisCacheLine_Aligned);
	if(!pusRaw10){
		itemshareData.itemparameterLock.unlock();
		PDAF_Cal_destroy( p ); 
		return HisFX3Error_MallocBuffer;
	}

	iresult	=	GetFreshframe((unsigned char*)(pusRaw10), itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight *2, _FrameType_Raw10, true);
	if(iresult){
		HisReleaseMalloc(pusRaw10);
		PDAF_Cal_destroy( p ); 
		itemshareData.itemparameterLock.unlock();
		return iresult;
	}

	//gainmap_t    gain_map;
	if(itemshareData.pdafParameter->ucpdafsensortype==0)
	{
		memset(stPDAFConfig.GainMapDataLVer.gm_l,0,sizeof(stPDAFConfig.GainMapDataLVer.gm_l));
		memset(stPDAFConfig.GainMapDataLVer.gm_r,0,sizeof(stPDAFConfig.GainMapDataLVer.gm_r));
		iresult= PDAF_Cal_get_gainmap(p, pusRaw10, &sensor_cfg, &stPDAFConfig.GainMapDataLVer, &gm_limits );
	}
	else if(itemshareData.pdafParameter->ucpdafsensortype==1)
	{
		unsigned short* pRaw10_PDL	=	(unsigned short*)_aligned_malloc(itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight *sizeof(unsigned short), _HisCacheLine_Aligned);
		if(!pRaw10_PDL)
		{
			itemshareData.itemparameterLock.unlock();
			HisReleaseMalloc(pusRaw10);
			PDAF_Cal_destroy( p ); 
			return HisFX3Error_MallocBuffer;
		}
		unsigned short* pRaw10_PDR	=	(unsigned short*)_aligned_malloc(itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight *sizeof(unsigned short), _HisCacheLine_Aligned);
		if(!pRaw10_PDR)
		{
			itemshareData.itemparameterLock.unlock();
			HisReleaseMalloc(pusRaw10);
			HisReleaseMalloc(pRaw10_PDL);
			PDAF_Cal_destroy( p ); 
			return HisFX3Error_MallocBuffer;
		}
		unsigned short pd_width=itemshareData.previewParameter->iWidth>>2;
		unsigned short pd_height=itemshareData.previewParameter->iHeight>>2;
		float    sensor_gain=2.0f;
		RAW10CovertDualPDLeftandRightImage(pusRaw10,itemshareData.previewParameter->ucDataFormat,itemshareData.previewParameter->iWidth,itemshareData.previewParameter->iHeight,pRaw10_PDL,pRaw10_PDR);
		iresult = PDAF_Cal_get_gainmap_2pd(p, pRaw10_PDL, pRaw10_PDR, pd_width, pd_height,
			itemshareData.pdafParameter->usSensorBlackLevel, &stPDAFConfig.GainMapDataLVer, &gm_limits, sensor_gain);
		HisReleaseMalloc(pRaw10_PDL);
		HisReleaseMalloc(pRaw10_PDR);
	}
	HisReleaseMalloc(pusRaw10);
	iresult=print_return_code(iresult);
	if(iresult!=0)
	{
		itemshareData.itemparameterLock.unlock();
		PDAF_Cal_destroy( p ); 
		return iresult;
	}

	//Save image by selection
	if(hisglobalparameter.bDebugMode)
	{	
		QDir classDir;
		strIniPath	=	QDir::currentPath() % "/QualcommPDAFImage";
		classDir.mkpath(strIniPath);
		ROPLOW::saveRaw10(strIniPath, strSerialNumber % "_Qualcomm_Step1"%(QDateTime::currentDateTime()).toString("yyyyMMdd_hhmmss"), itemshareData.previewParameter->ucDataFormat, \
			itemshareData.previewParameter->iWidth, itemshareData.previewParameter->iHeight, (void*)(pusRaw10));
		//Save log 
		strIniPath	=	QDir::currentPath() % "/QualcommPDAFLog";
		classDir.mkpath(strIniPath);

		strIniPath	=	strIniPath % "/" % strSerialNumber % "_Qualcomm_PDAFL_GainmapCal_"%(QDateTime::currentDateTime()).toString("yyyyMMdd_hhmmss")%".txt";
		FILE* fileStep1	=	fopen(strIniPath.toAscii().data(), "a+");
		if(fileStep1 != NULL)
		{
			fprintf(fileStep1,"%x\n",stPDAFConfig.GainMapDataLVer.cal_version);
			fprintf(fileStep1,"%x\n",stPDAFConfig.GainMapDataLVer.width);
			fprintf(fileStep1,"%x\n",stPDAFConfig.GainMapDataLVer.height);
			for (unsigned int i = 0; i < stPDAFConfig.GainMapDataLVer.width*stPDAFConfig.GainMapDataLVer.height; i ++)
				fprintf(fileStep1,"%x\n",stPDAFConfig.GainMapDataLVer.gm_l[i]);
			for (unsigned int i = 0; i < stPDAFConfig.GainMapDataLVer.width*stPDAFConfig.GainMapDataLVer.height; i ++)
				fprintf(fileStep1,"%x\n",stPDAFConfig.GainMapDataLVer.gm_r[i]);
			fclose(fileStep1);
		}

	}

	PDAF_Cal_destroy( p ); 
	//Gainmap data to burn 
	if(!threadshareData.bOfflineMode)
	{
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("烧录 gain map"));
		emit enableinfotimer(1);
		stPDAFConfig.ucTpye	= 1;
		//iresult= PDAF_Cal_get_gainmap(p, pusRaw10, &sensor_cfg, &stPDAFConfig.GainMapDataLVer, &gm_limits );
		iresult	=	writeQualcommPDAF(*globalFunPointer.vectorHisCCMOTPInfoW, &stPDAFConfig, globalFunPointer.ReadHisFX3IIC, globalFunPointer.WriteHisFX3IIC, globalFunPointer.SetHisFX3IICSpeed, \
			globalFunPointer.SetHisFX3Voltage, globalFunPointer.GetHisFX3Voltage, SetHisFX3VFuseVolt, GetHisFX3VFuseVolt, GetFreshframe, \
			globalFunPointer.BatchWriteHisFX3IIC, globalFunPointer.BatchReadHisFX3IIC, SetHisFX3GPIO, GetHisFX3GPIO, globalFunPointer.PullHisFX3RESET, globalFunPointer.PullHisFX3PWND, \
			globalFunPointer.BatchReadHisFX3IICNoLimit, globalFunPointer.BatchWriteHisFX3IICNoLimit,globalFunPointer.HisFX3LogPush_back, globalFunPointer.PageWriteHisFX3IIC, globalFunPointer.PageReadHisFX3IIC, \
			globalFunPointer.HisFX3PageWriteSPI, globalFunPointer.HisFX3PageReadSPI);
		emit enableinfotimer(0);
		if(iresult)
		{
			emit information(QTextCodec::codecForName( "GBK")->toUnicode("写入Qualcomm PDAF Gain map 数据失败"));
			itemshareData.itemparameterLock.unlock();
			return iresult;
		}
	}
	itemshareData.itemparameterLock.unlock();
	return 0;
}

int itemprocess::QualCommPDAF_LVersion_DCCCalibration()
{
#ifdef _WIN64
	emit information(QTextCodec::codecForName( "GBK")->toUnicode("Qualcomm PDAF 不支持64位软件") );
	return HisCCMError_NotSupportx64;
#endif

	int iresult=0;

	itemshareData.itemparameterLock.lockForRead();

	QString strSerialNumber;
	classLog->getserialnumber(strSerialNumber);


#if (defined _WIN64) && (defined _DEBUG)
	QString strLibPath	=	QDir::currentPath() % "/HisCCMOTP64D";
#elif (defined _WIN64) && !(defined _DEBUG)
	QString strLibPath	=	QDir::currentPath() % "/HisCCMOTP64";
#elif (defined _WIN32) && (defined _DEBUG)
	QString strLibPath	=	QDir::currentPath() % "/HisCCMOTP32D";
#else
	QString strLibPath	=	QDir::currentPath() % "/HisCCMOTP32";
#endif

	RolongoOTPAPIVersion getRolongoOTPAPIVersion = (RolongoOTPAPIVersion)(QLibrary::resolve(strLibPath, "getRolongoOTPAPIVersion"));
	Rolongocheckafmotor checkafmotor = (Rolongocheckafmotor)(QLibrary::resolve(strLibPath, "checkafmotor"));
	RolongowriteQualcommPDAF writeQualcommPDAF = (RolongowriteQualcommPDAF)(QLibrary::resolve(strLibPath, "writeQualcommPDAF"));
	RolongocheckQualcommPDAF checkQualcommPDAF = (RolongocheckQualcommPDAF)(QLibrary::resolve(strLibPath, "checkQualcommPDAF"));

	if(!(getRolongoOTPAPIVersion && checkafmotor && writeQualcommPDAF&&checkQualcommPDAF)){
		emit information(tr("Resolve HisCCMOTP DLL Function Fail"));
		itemshareData.itemparameterLock.unlock();
		return HisCCMError_LoadDLLFuc;
	}

	emit information(QTextCodec::codecForName( "GBK")->toUnicode("从 EEPROM 读取Sensor Gain map数据"));
	_HisQualcommPDAFBurn_Config stPDAFConfig;
	stPDAFConfig.bDebug					=		hisglobalparameter.bDebugMode;
	stPDAFConfig.ucSensorSlave		=		itemshareData.previewParameter->ucSlave;
	stPDAFConfig.strproject					=		itemshareData.ccmhardwareParameter->projectname.toAscii().data();
	stPDAFConfig.strsensor					=		itemshareData.ccmhardwareParameter->sensortype.toAscii().data();
	stPDAFConfig.strDriverIC				=		itemshareData.ccmhardwareParameter->motortype.toAscii().data();
	stPDAFConfig.strFunctionChoose	=	itemshareData.pdafParameter->strQualcommChoose.toAscii().data();
	stPDAFConfig.ucEESlave				=	itemshareData.ccmhardwareParameter->ucEESlave;
	stPDAFConfig.usGainMapSize=itemshareData.pdafParameter->usQualcommGainMapSize;
	stPDAFConfig.strSerialNumber=	strSerialNumber.toAscii().data();
	stPDAFConfig.ucTpye=1;
	OutputDebugStringW(L"Read gain map data from eeprom ");
	emit enableinfotimer(1);
	iresult	=	checkQualcommPDAF(*globalFunPointer.vectorHisCCMOTPInfoW, &stPDAFConfig, globalFunPointer.ReadHisFX3IIC, globalFunPointer.WriteHisFX3IIC, globalFunPointer.SetHisFX3IICSpeed, \
		globalFunPointer.SetHisFX3Voltage, globalFunPointer.GetHisFX3Voltage, SetHisFX3VFuseVolt, GetHisFX3VFuseVolt, GetFreshframe, \
		globalFunPointer.BatchWriteHisFX3IIC, globalFunPointer.BatchReadHisFX3IIC, SetHisFX3GPIO, GetHisFX3GPIO, globalFunPointer.PullHisFX3RESET, globalFunPointer.PullHisFX3PWND, \
		globalFunPointer.BatchReadHisFX3IICNoLimit, globalFunPointer.BatchWriteHisFX3IICNoLimit,globalFunPointer.HisFX3LogPush_back, globalFunPointer.PageWriteHisFX3IIC, globalFunPointer.PageReadHisFX3IIC, \
		globalFunPointer.HisFX3PageWriteSPI, globalFunPointer.HisFX3PageReadSPI);
	emit enableinfotimer(0);
	if(iresult)
	{
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("读取PDAF Gain map 数据失败"));
		itemshareData.itemparameterLock.unlock();
		return iresult;
	}

	emit information(QTextCodec::codecForName( "GBK")->toUnicode("从 EEPROM 读取AF Calibration数据"));
	int iInfiniteMotor	=0,iMacroMotor=0;
	int16_t dcc_stack_lenspos[DCC_STACK_SZ] ={0};
	_HisCCMAFBurn_Config stAFConfig;
	stAFConfig.bDebug						=	hisglobalparameter.bDebugMode;
	stAFConfig.strDriverIC				=	(itemshareData.ccmhardwareParameter->motortype.toAscii()).data();
	stAFConfig.strproject					=	itemshareData.ccmhardwareParameter->projectname.toAscii().data();
	stAFConfig.strsensor					=	itemshareData.ccmhardwareParameter->sensortype.toAscii().data();
	stAFConfig.bNear						=	true;
	stAFConfig.bInfinite						=	true;
	stAFConfig.iwidth						=	itemshareData.previewParameter->iWidth;
	stAFConfig.iheight						=	itemshareData.previewParameter->iHeight;
	stAFConfig.strFunctionChoose	=	itemshareData.pdafParameter->strAFChoose.toAscii().data();
	stAFConfig.ucSlave					=	itemshareData.previewParameter->ucSlave;
	stAFConfig.uiDataFormat			=	itemshareData.previewParameter->ucDataFormat;
	stAFConfig.ucEESlave				=	itemshareData.ccmhardwareParameter->ucEESlave;
	stAFConfig.strSerialNumber		=	strSerialNumber.toAscii().data();
	if(!threadshareData.bOfflineMode)
	{
		emit enableinfotimer(1);
		iresult	=	checkafmotor(*globalFunPointer.vectorHisCCMOTPInfoW, &stAFConfig, globalFunPointer.ReadHisFX3IIC, globalFunPointer.WriteHisFX3IIC, globalFunPointer.SetHisFX3IICSpeed, globalFunPointer.SetHisFX3Voltage, \
			globalFunPointer.GetHisFX3Voltage, SetHisFX3VFuseVolt, GetHisFX3VFuseVolt, GetFreshframe, SetHisFX3GPIO, GetHisFX3GPIO, \
			globalFunPointer.PullHisFX3RESET, globalFunPointer.PullHisFX3PWND, globalFunPointer.BatchReadHisFX3IICNoLimit, globalFunPointer.BatchWriteHisFX3IICNoLimit, \
			globalFunPointer.HisFX3LogPush_back, globalFunPointer.PageWriteHisFX3IIC, globalFunPointer.PageReadHisFX3IIC, \
			globalFunPointer.HisFX3PageWriteSPI, globalFunPointer.HisFX3PageReadSPI);
		emit enableinfotimer(0);
		if(iresult){
			itemshareData.itemparameterLock.unlock();
			return iresult;
		}

		iInfiniteMotor=stAFConfig.iInfinitMotor;
		iMacroMotor	=	stAFConfig.iNearMotor;

		emit information(QTextCodec::codecForName( "GBK")->toUnicode("近焦位置：") % QString::number(iMacroMotor));
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("远焦位置：") % QString::number(iInfiniteMotor));

	}
	float DCC_LP_FAR_MARGIN=0.0f;
	float DCC_LP_NEAR_MARGIN=0.0f;
	unsigned int NEAR_LP_LIMIT=iMacroMotor+(iMacroMotor-iInfiniteMotor)*DCC_LP_NEAR_MARGIN;
	unsigned int FAR_LP_LIMIT=iInfiniteMotor-(iMacroMotor-iInfiniteMotor)*DCC_LP_FAR_MARGIN;
	unsigned int LP_Step_Size=(NEAR_LP_LIMIT-FAR_LP_LIMIT)/9;
	for(int i=0;i<DCC_STACK_SZ;i++)
	{
		dcc_stack_lenspos[i]=FAR_LP_LIMIT+LP_Step_Size*i;
	}


	strLibPath	=	QDir::currentPath() % "/pdaflib/qualcomm";
	strLibPath	=	strLibPath % "/x86/PDAFCalibrationTools_Rev" % itemshareData.pdafParameter->cVersion % "_Dll";
	/* COMMON API FOR ALL PDAF SENSORS */
	typedef void* (*qualcomm_PDAF_Cal_create)( dll_config_t *dll_cfg );
	typedef int32_t (*qualcomm_PDAF_Cal_destroy)( void *p );
	typedef void (*qualcomm_PDAF_Cal_get_lib_version)(char *s);
	typedef void (*qualcomm_PDAF_Cal_get_lib_features)(char *s);
	typedef int32_t (*qualcomm_PDAF_Cal_get_dccmap)( void *p, dccmap_t *dcc_map, char* file_name);
	//typedef void PDAF_Cal_get_calibration_block( gainmap_t *gain_map, dccmap_t *dcc_map, pdaf_cal_t *pdaf_cal);
	//typedef int PDAF_Cal_read_calibration_block(gainmap_t *gain_map, dccmap_t *dcc_map, pdaf_cal_t *pdaf_cal);

	/* API FOR SPARSE AND 2X1 OCL PDAF SENSORS */
	typedef int32_t (*qualcomm_PDAF_Cal_get_gainmap)( void *p, uint16_t *img, sensor_config_t *sensor_cfg, gainmap_t *gain_map, gainmap_limits_t *gm_limits );
	typedef int32_t (*qualcomm_PDAF_Cal_add_raw)( void *p, int16_t stack_id, int16_t lens_pos, uint16_t *img, sensor_config_t *sensor_cfg, gainmap_t *gain_map);
	typedef int32_t (*qualcomm_PDAF_Cal_get_raw_pd)( void *p, 	uint16_t *img, sensor_config_t *sensor_cfg, gainmap_t *gain_map,pdmap_t* pdmap );

	/* API FOR DUAL PHOTODIODE PDAF SENSORS */
	typedef int32_t (*qualcomm_PDAF_Cal_get_gainmap_2pd)( void *p, uint16_t *img_l, uint16_t *img_r, uint16_t width, uint16_t height, uint16_t black_lvl, gainmap_t *gain_map, gainmap_limits_t *gm_limits, float sensor_gain);
	typedef int32_t(*qualcomm_PDAF_Cal_add_raw_2pd)( void *p, int16_t stack_id, int16_t lens_pos, uint16_t *img_l, uint16_t *img_r, uint16_t width, uint16_t height, uint16_t black_lvl, gainmap_t *gm,float sensor_gain);
	typedef int32_t (*qualcomm_PDAF_Cal_get_raw_pd_2pd)( void *p, uint16_t *img_l, uint16_t *img_r, uint16_t width, uint16_t height,uint16_t black_lvl, gainmap_t *gain_map, pdmap_t* pdmap );



	qualcomm_PDAF_Cal_create PDAF_Cal_create	=	(qualcomm_PDAF_Cal_create)(QLibrary::resolve(strLibPath, "PDAF_Cal_create"));
	qualcomm_PDAF_Cal_destroy PDAF_Cal_destroy	=	(qualcomm_PDAF_Cal_destroy)(QLibrary::resolve(strLibPath, "PDAF_Cal_destroy"));
	qualcomm_PDAF_Cal_get_lib_version PDAF_Cal_get_lib_version	=	(qualcomm_PDAF_Cal_get_lib_version)(QLibrary::resolve(strLibPath, "PDAF_Cal_get_lib_version"));
	qualcomm_PDAF_Cal_get_lib_features PDAF_Cal_get_lib_features	=	(qualcomm_PDAF_Cal_get_lib_features)(QLibrary::resolve(strLibPath, "PDAF_Cal_get_lib_features"));
	qualcomm_PDAF_Cal_get_dccmap PDAF_Cal_get_dccmap	=	(qualcomm_PDAF_Cal_get_dccmap)(QLibrary::resolve(strLibPath, "PDAF_Cal_get_dccmap"));
	qualcomm_PDAF_Cal_get_gainmap PDAF_Cal_get_gainmap	=	(qualcomm_PDAF_Cal_get_gainmap)(QLibrary::resolve(strLibPath, "PDAF_Cal_get_gainmap"));
	qualcomm_PDAF_Cal_add_raw PDAF_Cal_add_raw	=	(qualcomm_PDAF_Cal_add_raw)(QLibrary::resolve(strLibPath, "PDAF_Cal_add_raw"));
	qualcomm_PDAF_Cal_get_raw_pd PDAF_Cal_get_raw_pd	=	(qualcomm_PDAF_Cal_get_raw_pd)(QLibrary::resolve(strLibPath, "PDAF_Cal_get_raw_pd"));
	qualcomm_PDAF_Cal_get_gainmap_2pd PDAF_Cal_get_gainmap_2pd	=	(qualcomm_PDAF_Cal_get_gainmap_2pd)(QLibrary::resolve(strLibPath, "PDAF_Cal_get_gainmap_2pd"));
	qualcomm_PDAF_Cal_add_raw_2pd PDAF_Cal_add_raw_2pd	=	(qualcomm_PDAF_Cal_add_raw_2pd)(QLibrary::resolve(strLibPath, "PDAF_Cal_add_raw_2pd"));
	qualcomm_PDAF_Cal_get_raw_pd_2pd PDAF_Cal_get_raw_pd_2pd	=	(qualcomm_PDAF_Cal_get_raw_pd_2pd)(QLibrary::resolve(strLibPath, "PDAF_Cal_get_raw_pd_2pd"));

	if(!(PDAF_Cal_create && PDAF_Cal_destroy && PDAF_Cal_get_lib_version && \
		PDAF_Cal_get_lib_features && PDAF_Cal_get_dccmap && PDAF_Cal_get_gainmap && PDAF_Cal_add_raw&&PDAF_Cal_get_raw_pd&&PDAF_Cal_get_gainmap_2pd&&PDAF_Cal_add_raw_2pd&&PDAF_Cal_get_raw_pd_2pd)){
			emit information(tr("Resolve Qualcomm PDAF DLL Function Fail"));
			itemshareData.itemparameterLock.unlock();
			return HisCCMError_LoadDLLFuc;
	}


	gainmap_limits_t gm_limits;
	gm_limits.pd_max_limit   = 950;  //Max PD pixel value after LPF must be below 950
	gm_limits.pd_min_limit   = 100;  //Min PD pixel value after LPF must exceed 100
	gm_limits.gain_max_limit = (uint16_t) (7.999f * (1<<GAIN_MAP_Q_FMT));  // max gain of 8x
	// load dll config parameters
	dll_config_t     dll_cfg;
	float dcc_fir[]  = DCC_FIR;
	dll_cfg.cal_version         = CAL_VERSION;
	dll_cfg.chart_type          = LINECHART;
	dll_cfg.verify_type         = NORMALIZE;
	dll_cfg.gain_map_height     = GAIN_MAP_HEIGHT;
	dll_cfg.gain_map_width      = GAIN_MAP_WIDTH;
	dll_cfg.gain_map_q_fmt      = GAIN_MAP_Q_FMT;	
	dll_cfg.dcc_map_height      = DCC_MAP_HEIGHT;
	dll_cfg.dcc_map_width       = DCC_MAP_WIDTH;
	dll_cfg.dcc_map_q_fmt       = DCC_MAP_Q_FMT;
	memcpy(dll_cfg.dcc_fir, dcc_fir, sizeof(float)*DCC_FIR_SZ);
	dll_cfg.dcc_fir_sz          = DCC_FIR_SZ;
	dll_cfg.dcc_stack_sz        = DCC_STACK_SZ;
	dll_cfg.dcc_search_range    = DCC_SEARCH_RANGE;
	dll_cfg.dcc_fit_exclusion   = DCC_FIT_EXCLUSION;
	dll_cfg.dcc_min_pd_range    = DCC_MIN_PD_RANGE;
	dll_cfg.dcc_map_overlap     = DCC_MAP_OVERLAP;
	dll_cfg.dcc_linearity_level_theshold = DCC_LINEARITY_LEVEL_THRESHOLD;
	dll_cfg.dpd_pixel_unit      = DPD_PIXEL_UNIT;
	dll_cfg.dpd_min_sensor_gain = DPD_MIN_SENSOR_GAIN;
	dll_cfg.dpd_max_sensor_gain = DPD_MAX_SENSOR_GAIN;
	dll_cfg.chart_type = LINECHART;
	float tolerance_table[48]={0};
	if(itemshareData.pdafParameter->ucpdafsensortype==0)   	//float tolerance_table[48]= DCC_VAL_TOL_SPARSE;
	{
		for(int i=0;i<48;i++){tolerance_table[i]=0.20f;}
	}
	else if(itemshareData.pdafParameter->ucpdafsensortype==1)  //float tolerance_table[48]= DCC_VAL_TOL_DPD;
	{
		for(int i=0;i<48;i++){tolerance_table[i]=0.10f;}
	}
	else
	{
		itemshareData.itemparameterLock.unlock();
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("Sensor PD Type未选择"));
		return HisFX3Error_Parameter;
	}

	memcpy(&dll_cfg.dcc_tolerance_table, tolerance_table, sizeof(tolerance_table));
	//INIT RUN ONLY ONCE 
	void *p = PDAF_Cal_create( &dll_cfg ); 
	if( p == NULL ) 
	{
		emit information(tr("dll memory allocation error"));
		itemshareData.itemparameterLock.unlock();
		return HisCCMError_LoadDLLFuc;
	}
	//calibration DLL for version number and version description
	char strLibInfo[2048];
	PDAF_Cal_get_lib_version(strLibInfo);
	emit information(QString::fromAscii(strLibInfo));
	PDAF_Cal_get_lib_features(strLibInfo);
	emit information(QString::fromAscii(strLibInfo));
	OutputDebugStringW(L"Load Sesor_cfg file ");
	//Load Sensor Confiugure
	float sensor_gain=2.0f;
	sensor_config_t  sensor_cfg;
	QString strIniPath;
	if(itemshareData.pdafParameter->ucpdafsensortype==0)
	{
		strIniPath = "./pdaftemplate/Qualcomm/" % itemshareData.ccmhardwareParameter->projectname % "/Config.txt";
		if(!QFile::exists(strIniPath))
		{
			emit information(tr("File not exist: ") % strIniPath);
			itemshareData.itemparameterLock.unlock();
			PDAF_Cal_destroy( p ); 
			return HisCCMError_FilePath;
		}

		QSettings classIniConfig(strIniPath, QSettings::IniFormat);
		QStringList childKeys = classIniConfig.allKeys();
		int index=childKeys.indexOf("pd_block_n_pd_pairs");
		sensor_cfg.pd_block_n_pd_pairs =classIniConfig.value(childKeys.at(index)).toUInt();
		for(int x=0;	x<childKeys.size();	++x)
		{
			if(childKeys.at(x) == "cfa")	
			{		
				if(classIniConfig.value(childKeys.at(x)).toString()=="BGGR") sensor_cfg.cfa=BGGR;
				else if(classIniConfig.value(childKeys.at(x)).toString()=="RGGB") sensor_cfg.cfa=RGGB;
				else if(classIniConfig.value(childKeys.at(x)).toString()=="GRBG") sensor_cfg.cfa=GRBG;
				else if(classIniConfig.value(childKeys.at(x)).toString()=="GBRG") sensor_cfg.cfa=GBRG;
			}
			else if(childKeys.at(x) == "image_width") sensor_cfg.image_width =	classIniConfig.value(childKeys.at(x)).toInt();
			else if(childKeys.at(x) == "image_height") sensor_cfg.image_height =	classIniConfig.value(childKeys.at(x)).toInt();
			else if(childKeys.at(x) == "bit_depth") sensor_cfg.bit_depth =	classIniConfig.value(childKeys.at(x)).toInt();
			else if(childKeys.at(x) == "black_lvl") sensor_cfg.black_lvl =	classIniConfig.value(childKeys.at(x)).toInt();
			else if(childKeys.at(x) == "fv_measure_channel") sensor_cfg.fv_measure_channel =	classIniConfig.value(childKeys.at(x)).toInt();
			else if(childKeys.at(x) == "pd_block_width") sensor_cfg.pd_block_width =	classIniConfig.value(childKeys.at(x)).toInt();
			else if(childKeys.at(x) == "pd_block_height") sensor_cfg.pd_block_height =	classIniConfig.value(childKeys.at(x)).toInt();
			else if(childKeys.at(x) == "pd_block_start_x") {sensor_cfg.pd_block_start_x=classIniConfig.value(childKeys.at(x)).toInt();}
			else if(childKeys.at(x) == "pd_block_start_y") {sensor_cfg.pd_block_start_y=classIniConfig.value(childKeys.at(x)).toInt();}
			else if(childKeys.at(x) == "pd_block_l_x") 
			{
				QString strvalue=classIniConfig.value(childKeys.at(x),"").toString();
				QStringList block_l_x_List = strvalue.split(","); 
				for(int i=0;i<sensor_cfg.pd_block_n_pd_pairs;i++)
				{
					sensor_cfg.pd_block_l_x[i]= block_l_x_List.at(i).toUInt();
				}
			}
			else if(childKeys.at(x) == "pd_block_l_y") 
			{
				QString strvalue=classIniConfig.value(childKeys.at(x),"").toString();
				QStringList block_l_y_List = strvalue.split(",");
				for(int i=0;i<sensor_cfg.pd_block_n_pd_pairs;i++)
				{
					sensor_cfg.pd_block_l_y[i]= block_l_y_List.at(i).toUInt();
				}
			}
			else if(childKeys.at(x) == "pd_block_r_x") 
			{
				QString strvalue=classIniConfig.value(childKeys.at(x),"").toString();
				QStringList block_r_x_List = strvalue.split(",");
				for(int i=0;i<sensor_cfg.pd_block_n_pd_pairs;i++)
				{
					sensor_cfg.pd_block_r_x[i]= block_r_x_List.at(i).toUInt();
				}
			}
			else if(childKeys.at(x) == "pd_block_r_y") 
			{
				QString strvalue=classIniConfig.value(childKeys.at(x),"").toString();
				QStringList block_r_y_List = strvalue.split(",");
				for(int i=0;i<sensor_cfg.pd_block_n_pd_pairs;i++)
				{
					sensor_cfg.pd_block_r_y[i]= block_r_y_List.at(i).toUInt();
				}
			}
		}
	}

	unsigned short* pusRaw10	=	(unsigned short*)_aligned_malloc(itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight *sizeof(unsigned short), _HisCacheLine_Aligned);
	if(!pusRaw10){
		itemshareData.itemparameterLock.unlock();
		PDAF_Cal_destroy( p ); 
		return HisFX3Error_MallocBuffer;
	}
	unsigned short *pRaw10_PDL=NULL,	*pRaw10_PDR=NULL;
	if(itemshareData.pdafParameter->ucpdafsensortype==2) //2pd sensor
	{
		pRaw10_PDL	=	(unsigned short*)_aligned_malloc((itemshareData.previewParameter->iWidth>>2) *(itemshareData.previewParameter->iHeight>>2)*sizeof(unsigned short), _HisCacheLine_Aligned);
		if(!pRaw10_PDL)
		{
			itemshareData.itemparameterLock.unlock();
			HisReleaseMalloc(pusRaw10);
			PDAF_Cal_destroy( p ); 
			return HisFX3Error_MallocBuffer;
		}
		pRaw10_PDR	=	(unsigned short*)_aligned_malloc((itemshareData.previewParameter->iWidth>>2)*(itemshareData.previewParameter->iHeight>>2) *sizeof(unsigned short), _HisCacheLine_Aligned);
		if(!pRaw10_PDR)
		{
			itemshareData.itemparameterLock.unlock();
			HisReleaseMalloc(pusRaw10);
			HisReleaseMalloc(pRaw10_PDL);
			PDAF_Cal_destroy( p ); 
			return HisFX3Error_MallocBuffer;
		}
	}
	OutputDebugStringW(L"Start DCC process ");
	emit information(tr("Start DCC process with 10 steps"));
	for( int stack_id=0; stack_id < DCC_STACK_SZ; stack_id++ ) 
	{
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("驱动马达[DAC]")%QString::number(dcc_stack_lenspos[stack_id]));
		iresult	=	setMotor(itemshareData.ccmhardwareParameter->motortype.toAscii().data(), \
			itemshareData.previewParameter->ucSlave, itemshareData.ccmhardwareParameter->projectname.toAscii().data(), \
			dcc_stack_lenspos[stack_id], globalFunPointer.ReadHisFX3IIC, globalFunPointer.WriteHisFX3IIC, globalFunPointer.SetHisFX3IICSpeed, globalFunPointer.PullHisFX3RESET, globalFunPointer.PullHisFX3PWND, \
			globalFunPointer.PageWriteHisFX3IIC, globalFunPointer.PageReadHisFX3IIC, globalFunPointer.HisFX3PageWriteSPI, globalFunPointer.HisFX3PageReadSPI);
		if(iresult)
		{
			emit information(QTextCodec::codecForName( "GBK")->toUnicode("驱动马达失败[DAC]")%QString::number(dcc_stack_lenspos[stack_id]));
			itemshareData.itemparameterLock.unlock();
			PDAF_Cal_destroy( p ); 
			HisReleaseMalloc(pusRaw10);
			return iresult;
		}
		Sleep(itemshareData.pdafParameter->uiMotorSleep);

		iresult	=	GetFreshframe((unsigned char*)(pusRaw10), itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight *2, _FrameType_Raw10, true);
		if(iresult)
		{
			HisReleaseMalloc(pusRaw10);
			PDAF_Cal_destroy( p ); 
			itemshareData.itemparameterLock.unlock();
			return iresult;
		}
		if(itemshareData.pdafParameter->ucpdafsensortype==0)
		{
			iresult=PDAF_Cal_add_raw(p, stack_id, dcc_stack_lenspos[stack_id],pusRaw10, &sensor_cfg, &stPDAFConfig.GainMapDataLVer);
		}
		else if(itemshareData.pdafParameter->ucpdafsensortype==1)
		{
			RAW10CovertDualPDLeftandRightImage(pusRaw10,itemshareData.previewParameter->ucDataFormat,itemshareData.previewParameter->iWidth,itemshareData.previewParameter->iHeight,pRaw10_PDL,pRaw10_PDR);
			iresult=PDAF_Cal_add_raw_2pd(p, stack_id, dcc_stack_lenspos[stack_id],
				pRaw10_PDL, pRaw10_PDR, itemshareData.previewParameter->iWidth>>2,itemshareData.previewParameter->iHeight>>2, itemshareData.pdafParameter->usSensorBlackLevel, &stPDAFConfig.GainMapDataLVer, sensor_gain);


		}
		iresult= print_return_code(iresult);
		if(iresult)
		{
			HisReleaseMalloc(pusRaw10);
			HisReleaseMalloc(pRaw10_PDL);
			HisReleaseMalloc(pRaw10_PDR);
			PDAF_Cal_destroy( p ); 
			itemshareData.itemparameterLock.unlock();
			return HisCCMError_QualcommPDAFStep2;
		}
		if(hisglobalparameter.bDebugMode)
		{
			QDir classDir;
			strIniPath	=	QDir::currentPath() % "/QualcommPDAFImage";
			classDir.mkpath(strIniPath);
			ROPLOW::saveRaw10(strIniPath, strSerialNumber % "_Qualcomm_Step2"%"_DAC["%QString::number(stack_id+1)%"]_"%QString::number(dcc_stack_lenspos[stack_id])%"_"%(QDateTime::currentDateTime()).toString("yyyyMMdd_hhmmss"), itemshareData.previewParameter->ucDataFormat, \
				itemshareData.previewParameter->iWidth, itemshareData.previewParameter->iHeight, (void*)(pusRaw10));
		}
	}
	strIniPath	=	QDir::currentPath() % "/QualcommPDAFLog";
	QDir classDir;
	classDir.mkpath(strIniPath);
	strIniPath	=	strIniPath % "/" % strSerialNumber % "_Qualcomm_PDAFL_DCCmapCal_"%(QDateTime::currentDateTime()).toString("yyyyMMdd_hhmmss")%".txt";
	//  get dcc map
	iresult=PDAF_Cal_get_dccmap(p, &stPDAFConfig.DccMapDatalVer,strIniPath.toLatin1().data());
	// end 
	iresult= print_return_code(iresult);
	if(iresult!=0) 
	{	
		HisReleaseMalloc(pusRaw10);	
		HisReleaseMalloc(pRaw10_PDL);
		HisReleaseMalloc(pRaw10_PDR);
		PDAF_Cal_destroy( p ); 
		itemshareData.itemparameterLock.unlock();
		return iresult;
	}

	//PDAF  Verify
	emit information(tr("Start PDAF verify process"));
	iresult	=	GetFreshframe((unsigned char*)(pusRaw10), itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight *2, _FrameType_Raw10, true);
	if(iresult)
	{
		HisReleaseMalloc(pusRaw10);
		HisReleaseMalloc(pRaw10_PDL);
		HisReleaseMalloc(pRaw10_PDR);
		PDAF_Cal_destroy( p ); 
		itemshareData.itemparameterLock.unlock();
		return iresult;
	}
	pdmap_t pdmap;
	if(itemshareData.pdafParameter->ucpdafsensortype==0)
	{
		iresult = PDAF_Cal_get_raw_pd(p, pusRaw10,  &sensor_cfg, &stPDAFConfig.GainMapDataLVer, &pdmap);
	}
	else if(itemshareData.pdafParameter->ucpdafsensortype==1)
	{
		RAW10CovertDualPDLeftandRightImage(pusRaw10,itemshareData.previewParameter->ucDataFormat,itemshareData.previewParameter->iWidth,itemshareData.previewParameter->iHeight,pRaw10_PDL,pRaw10_PDR);
		iresult =PDAF_Cal_get_raw_pd_2pd(p, pRaw10_PDL, pRaw10_PDR,itemshareData.previewParameter->iWidth>>2,itemshareData.previewParameter->iHeight>>2, itemshareData.pdafParameter->usSensorBlackLevel, &stPDAFConfig.GainMapDataLVer, &pdmap);
	}
	int iPD_FocusPos[100]={0};
	print_return_code(iresult);
	//save pd value in csv file
	FILE* fp	=	fopen(strIniPath.toAscii().data(), "a+");
	fprintf(fp,"DCC MAP:\n");
	for (int j=0; j<stPDAFConfig.DccMapDatalVer.height; j++) 
	{
		for (int i=0; i<stPDAFConfig.DccMapDatalVer.width; i++)
		{
			fprintf(fp, "%d,", stPDAFConfig.DccMapDatalVer.dm[j*stPDAFConfig.DccMapDatalVer.width+i]);
		}
		fprintf(fp,"\n");
	}
	fprintf(fp,"lens_Focus_DAC:\n");
	for (int j=0; j<pdmap.height; j++) 
	{
		for (int i=0; i<pdmap.width; i++)
		{
			float dcc = stPDAFConfig.DccMapDatalVer.dm[j*stPDAFConfig.DccMapDatalVer.width+i]/(float)(1<<stPDAFConfig.DccMapDatalVer.q_format);
			iPD_FocusPos[j*pdmap.width+i]=dcc_stack_lenspos[DCC_STACK_SZ-1] - (int)(pdmap.pd[j*pdmap.width+i]*dcc);
			fprintf(fp, "%d,", iPD_FocusPos[j*pdmap.width+i]);
		}
		fprintf(fp,"\n");
	}
	fclose(fp);
	//
	HisReleaseMalloc(pRaw10_PDL);
	HisReleaseMalloc(pRaw10_PDR);
	HisReleaseMalloc(pusRaw10);
	PDAF_Cal_destroy( p ); 
	//driver vcm
	emit information(QTextCodec::codecForName( "GBK")->toUnicode("驱动马达z至PDAF合焦的位置[DAC]")%QString::number(iPD_FocusPos[2*pdmap.width+4]));
	iresult	=	setMotor(itemshareData.ccmhardwareParameter->motortype.toAscii().data(), \
		itemshareData.previewParameter->ucSlave, itemshareData.ccmhardwareParameter->projectname.toAscii().data(), \
		iPD_FocusPos[2*pdmap.width+4], globalFunPointer.ReadHisFX3IIC, globalFunPointer.WriteHisFX3IIC, globalFunPointer.SetHisFX3IICSpeed, globalFunPointer.PullHisFX3RESET, globalFunPointer.PullHisFX3PWND, \
		globalFunPointer.PageWriteHisFX3IIC, globalFunPointer.PageReadHisFX3IIC, globalFunPointer.HisFX3PageWriteSPI, globalFunPointer.HisFX3PageReadSPI);
	if(iresult)
	{
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("驱动马达失败[DAC]")%QString::number(iPD_FocusPos[2*pdmap.width+4]));
		itemshareData.itemparameterLock.unlock();
		return iresult;
	}
	Sleep(itemshareData.pdafParameter->uiMotorSleep);

	if(itemshareData.pdafParameter->bQualcommpdafverify )
	{     
		int iCDAFDAC=0;
		iresult=PDAFSTEP2Verify(iPD_FocusPos[2*pdmap.width+4],iCDAFDAC, itemshareData.previewParameter->iWidth ,itemshareData.previewParameter->iHeight);
		if(iresult)
		{
			emit information(QTextCodec::codecForName( "GBK")->toUnicode("PDAF Verify fail"));
			itemshareData.itemparameterLock.unlock();
			return iresult;
		}
	}

	stPDAFConfig.ucTpye	= 2;
	//Gainmap data to burn 
	emit enableinfotimer(1);
	iresult	=	writeQualcommPDAF(*globalFunPointer.vectorHisCCMOTPInfoW, &stPDAFConfig, globalFunPointer.ReadHisFX3IIC, globalFunPointer.WriteHisFX3IIC, globalFunPointer.SetHisFX3IICSpeed, \
		globalFunPointer.SetHisFX3Voltage, globalFunPointer.GetHisFX3Voltage, SetHisFX3VFuseVolt, GetHisFX3VFuseVolt, GetFreshframe, \
		globalFunPointer.BatchWriteHisFX3IIC, globalFunPointer.BatchReadHisFX3IIC, SetHisFX3GPIO, GetHisFX3GPIO, globalFunPointer.PullHisFX3RESET, globalFunPointer.PullHisFX3PWND, \
		globalFunPointer.BatchReadHisFX3IICNoLimit, globalFunPointer.BatchWriteHisFX3IICNoLimit,globalFunPointer.HisFX3LogPush_back, globalFunPointer.PageWriteHisFX3IIC, globalFunPointer.PageReadHisFX3IIC, \
		globalFunPointer.HisFX3PageWriteSPI, globalFunPointer.HisFX3PageReadSPI);
	emit enableinfotimer(0);
	if(iresult&&(!threadshareData.bOfflineMode))
	{
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("写入Qualcomm PDAF DCC map 数据失败"));
		itemshareData.itemparameterLock.unlock();
		return iresult;
	}
	itemshareData.itemparameterLock.unlock();
	return 0;
}

int itemprocess::PDAFBurnCheck()
{
	if(!classPlatform.HisFX3isstart())	return HisFX3Error_IsNotPreview;

	int iresult;
	if(iresult	=	getccmhardwareParameter(false))	return iresult;
	if(iresult		=	getpdafParameter(false))	return iresult;

	itemshareData.itemparameterLock.lockForRead();

	if(itemshareData.previewParameter->ucDataFormat > HisBaylor10_GBRG){
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("图像格式错误：不是BAYLOR模式"));
		itemshareData.itemparameterLock.unlock();
		return iresult;
	}

	if(itemshareData.pdafParameter->bSONY258MTKCal )
	{
		if(itemshareData.pdafParameter->ucPlatform== 2)
		{
			emit information(QTextCodec::codecForName( "GBK")->toUnicode("设定参数不正确，IMX258模组不能选择SONY PDAF平台校正"));
			itemshareData.itemparameterLock.unlock();
			return iresult;
		}
		iresult=this->SONYPDAFCheck(1);
		if(iresult)
		{
			itemshareData.itemparameterLock.unlock();
			return iresult;
		}
	}
	if(itemshareData.pdafParameter->ucPlatform== 0) //MTK
	{
		iresult=this->MTKPDAFCheck();     
	}
	else if(itemshareData.pdafParameter->ucPlatform== 1)  //Qualcomm
	{
		iresult=this->QualcommPDAFCheck();    
	}
	else if(itemshareData.pdafParameter->ucPlatform== 2)
	{
		iresult=this->SONYPDAFCheck(3);
	}
	else if(itemshareData.pdafParameter->ucPlatform== 3)
	{
		iresult=HISIPDAFCheck();
	}

	return iresult;
}

int itemprocess::MTKPDAFCheck()
{	
	QString strMTKDir;
	QString strSerialNumber;
	classLog->getserialnumber(strSerialNumber);
	if(!strSerialNumber.isEmpty()){
		strMTKDir	=	QDir::currentPath() % "/mtk_approval_log/" % strSerialNumber;
		QDir classTempDir;
		if(!classTempDir.mkpath(strMTKDir)) strMTKDir.clear();
	}

	_HisCCMMTKPDAFBurn_Config stPDAFConfig;
	stPDAFConfig.bDebug					=		hisglobalparameter.bDebugMode;
	stPDAFConfig.ucSensorSlave		=		itemshareData.previewParameter->ucSlave;
	stPDAFConfig.strproject					=		itemshareData.ccmhardwareParameter->projectname.toAscii().data();
	stPDAFConfig.strsensor					=		itemshareData.ccmhardwareParameter->sensortype.toAscii().data();
	stPDAFConfig.strDriverIC				=		itemshareData.ccmhardwareParameter->motortype.toAscii().data();
	stPDAFConfig.strFunctionChoose	=	itemshareData.pdafParameter->strPDAFChoose.toAscii().data();
	stPDAFConfig.ucEESlave				=	itemshareData.ccmhardwareParameter->ucEESlave;
	stPDAFConfig.ucTpye					=	1;
	stPDAFConfig.uiDataSize				=	0;
	stPDAFConfig.Reserve1.u16value[3]	=	itemshareData.pdafParameter->usVersion[3];
	stPDAFConfig.Reserve1.u16value[2]	=	itemshareData.pdafParameter->usVersion[2];
	stPDAFConfig.Reserve1.u16value[1]	=	itemshareData.pdafParameter->usVersion[1];
	stPDAFConfig.Reserve1.u16value[0]	=	itemshareData.pdafParameter->usVersion[0];
	stPDAFConfig.uiStep1Size=itemshareData.pdafParameter->usMTKV2Step1dataSize;
	stPDAFConfig.uiStep2Size=itemshareData.pdafParameter->usMTKV2Step2dataSize;
	stPDAFConfig.strSerialNumber	=	strSerialNumber.toAscii().data();
	if(itemshareData.pdafParameter->bSONY258MTKCal)  {stPDAFConfig.bSONYIMX258Cal	=	true; }  // IMX258 MTK PDAF V2
	else {stPDAFConfig.bSONYIMX258Cal	=	false;}

#if (defined _WIN64) && (defined _DEBUG)
	QString strLibPath	=	QDir::currentPath() % "/HisCCMOTP64D";
#elif (defined _WIN64) && !(defined _DEBUG)
	QString strLibPath	=	QDir::currentPath() % "/HisCCMOTP64";
#elif (defined _WIN32) && (defined _DEBUG)
	QString strLibPath	=	QDir::currentPath() % "/HisCCMOTP32D";
#else
	QString strLibPath	=	QDir::currentPath() % "/HisCCMOTP32";
#endif

	RolongoOTPAPIVersion getRolongoOTPAPIVersion = (RolongoOTPAPIVersion)(QLibrary::resolve(strLibPath, "getRolongoOTPAPIVersion"));
	RolongocheckMTKPDAF checkMTKPDAF = (RolongocheckMTKPDAF)(QLibrary::resolve(strLibPath, "checkMTKPDAF"));

	if(!(getRolongoOTPAPIVersion && checkMTKPDAF)){
		emit information(tr("Resolve HisCCMOTP DLL Function Fail"));
		itemshareData.itemparameterLock.unlock();
		return HisCCMError_LoadDLLFuc;
	}

	emit enableinfotimer(1);
	int iresult	=	checkMTKPDAF(*globalFunPointer.vectorHisCCMOTPInfoW, &stPDAFConfig, globalFunPointer.ReadHisFX3IIC, globalFunPointer.WriteHisFX3IIC, globalFunPointer.SetHisFX3IICSpeed, \
		globalFunPointer.SetHisFX3Voltage, globalFunPointer.GetHisFX3Voltage, SetHisFX3VFuseVolt, GetHisFX3VFuseVolt, GetFreshframe, \
		globalFunPointer.BatchWriteHisFX3IIC, globalFunPointer.BatchReadHisFX3IIC, SetHisFX3GPIO, GetHisFX3GPIO, globalFunPointer.PullHisFX3RESET, globalFunPointer.PullHisFX3PWND, \
		globalFunPointer.BatchReadHisFX3IICNoLimit, globalFunPointer.BatchWriteHisFX3IICNoLimit, globalFunPointer.HisFX3LogPush_back, \
		globalFunPointer.PageWriteHisFX3IIC, globalFunPointer.PageReadHisFX3IIC, globalFunPointer.HisFX3PageWriteSPI, globalFunPointer.HisFX3PageReadSPI);
	emit enableinfotimer(0);

	if(iresult){
		itemshareData.itemparameterLock.unlock();
		return iresult;
	}

	if(hisglobalparameter.bDebugMode &&  stPDAFConfig.uiStep1Size != 0 && stPDAFConfig.uiStep2Size != 0){
		QDir classDir;
		QString strIniPath	=	QDir::currentPath() % "/mtkpdaflog";
		classDir.mkpath(strIniPath);
		ROPLOW::savebin(strIniPath, strSerialNumber % "_MTK_PDAF_Check_ALL", stPDAFConfig.ucData, \
			stPDAFConfig.uiStep1Size +stPDAFConfig.uiStep2Size +stPDAFConfig.uiStep3Size, 0, false);
		if(!strMTKDir.isEmpty())
			ROPLOW::savebin(strMTKDir, "all", stPDAFConfig.ucData, \
			stPDAFConfig.uiStep1Size +stPDAFConfig.uiStep2Size +stPDAFConfig.uiStep3Size, 0, false);
	}

	itemshareData.itemparameterLock.unlock();

	return iresult;
}

int itemprocess::HISIPDAFCheck()
{	
	QString strMTKDir;
	QString strSerialNumber;
	classLog->getserialnumber(strSerialNumber);

	_HisCCMMTKPDAFBurn_Config stPDAFConfig;
	stPDAFConfig.bDebug					=		hisglobalparameter.bDebugMode;
	stPDAFConfig.ucSensorSlave		=		itemshareData.previewParameter->ucSlave;
	stPDAFConfig.strproject					=		itemshareData.ccmhardwareParameter->projectname.toAscii().data();
	stPDAFConfig.strsensor					=		itemshareData.ccmhardwareParameter->sensortype.toAscii().data();
	stPDAFConfig.strDriverIC				=		itemshareData.ccmhardwareParameter->motortype.toAscii().data();
	stPDAFConfig.strFunctionChoose	=	itemshareData.pdafParameter->strHISIPDAFChoose.toAscii().data();
	stPDAFConfig.ucEESlave				=	itemshareData.ccmhardwareParameter->ucEESlave;
	stPDAFConfig.ucTpye					=	1;
	stPDAFConfig.uiDataSize				=	0;
	stPDAFConfig.Reserve1.u16value[3]	=	itemshareData.pdafParameter->usVersion[3];
	stPDAFConfig.Reserve1.u16value[2]	=	itemshareData.pdafParameter->usVersion[2];
	stPDAFConfig.Reserve1.u16value[1]	=	itemshareData.pdafParameter->usVersion[1];
	stPDAFConfig.Reserve1.u16value[0]	=	itemshareData.pdafParameter->usVersion[0];
	stPDAFConfig.uiStep1Size=itemshareData.pdafParameter->usMTKV2Step1dataSize;
	stPDAFConfig.uiStep2Size=itemshareData.pdafParameter->usMTKV2Step2dataSize;
	stPDAFConfig.strSerialNumber	=	strSerialNumber.toAscii().data();
	if(itemshareData.pdafParameter->bSONY258MTKCal)  {stPDAFConfig.bSONYIMX258Cal	=	true; }  // IMX258 MTK PDAF V2
	else {stPDAFConfig.bSONYIMX258Cal	=	false;}

#if (defined _WIN64) && (defined _DEBUG)
	QString strLibPath	=	QDir::currentPath() % "/HisCCMOTP64D";
#elif (defined _WIN64) && !(defined _DEBUG)
	QString strLibPath	=	QDir::currentPath() % "/HisCCMOTP64";
#elif (defined _WIN32) && (defined _DEBUG)
	QString strLibPath	=	QDir::currentPath() % "/HisCCMOTP32D";
#else
	QString strLibPath	=	QDir::currentPath() % "/HisCCMOTP32";
#endif

	RolongoOTPAPIVersion getRolongoOTPAPIVersion = (RolongoOTPAPIVersion)(QLibrary::resolve(strLibPath, "getRolongoOTPAPIVersion"));
	RolongocheckHISIPDAF checkHISIPDAF = (RolongocheckHISIPDAF)(QLibrary::resolve(strLibPath, "checkHISIPDAF"));

	if(!(getRolongoOTPAPIVersion && checkHISIPDAF)){
		emit information(tr("Resolve HisCCMOTP DLL Function Fail"));
		itemshareData.itemparameterLock.unlock();
		return HisCCMError_LoadDLLFuc;
	}

	emit enableinfotimer(1);
	int iresult	=	checkHISIPDAF(*globalFunPointer.vectorHisCCMOTPInfoW, &stPDAFConfig, globalFunPointer.ReadHisFX3IIC, globalFunPointer.WriteHisFX3IIC, globalFunPointer.SetHisFX3IICSpeed, \
		globalFunPointer.SetHisFX3Voltage, globalFunPointer.GetHisFX3Voltage, SetHisFX3VFuseVolt, GetHisFX3VFuseVolt, GetFreshframe, \
		globalFunPointer.BatchWriteHisFX3IIC, globalFunPointer.BatchReadHisFX3IIC, SetHisFX3GPIO, GetHisFX3GPIO, globalFunPointer.PullHisFX3RESET, globalFunPointer.PullHisFX3PWND, \
		globalFunPointer.BatchReadHisFX3IICNoLimit, globalFunPointer.BatchWriteHisFX3IICNoLimit, globalFunPointer.HisFX3LogPush_back, \
		globalFunPointer.PageWriteHisFX3IIC, globalFunPointer.PageReadHisFX3IIC, globalFunPointer.HisFX3PageWriteSPI, globalFunPointer.HisFX3PageReadSPI);
	emit enableinfotimer(0);

	if(iresult){
		itemshareData.itemparameterLock.unlock();
		return iresult;
	}

	itemshareData.itemparameterLock.unlock();

	return iresult;
}


int itemprocess::PDAFCalibrationSTEP2()
{
	if(!classPlatform.HisFX3isstart())	return HisFX3Error_IsNotPreview;

	unsigned char ucApplication	=	0x0;
	int iresult = classPlatform.HisFX3GetLInfo(NULL, &ucApplication, NULL, NULL, NULL, NULL);
	if(iresult) return iresult;
#if (defined PDAF_LICENSE_ONLY_AUTHORIZE)
	if(ucApplication != 0x2){
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("此主板没有操作PDAF的授权"));
		return HisFX3Error_License;
	}
#else
	// 	if(ucApplication != 0x2 && ucApplication != 0xff){
	// 		emit information(QTextCodec::codecForName( "GBK")->toUnicode("此主板没有操作PDAF的授权"));
	// 		return HisFX3Error_License;
	// 	}
#endif
	_CODE_CLEAR_IMAGEDRAW
		if(iresult	=	getccmhardwareParameter(false))	return iresult;
	if(iresult		=	getpdafParameter(false))	return iresult;

	itemshareData.itemparameterLock.lockForRead();

	if(itemshareData.previewParameter->ucDataFormat > HisBaylor10_GBRG){
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("图像格式错误：不是BAYLOR模式"));
		itemshareData.itemparameterLock.unlock();
		return iresult;
	}
	itemshareData.itemparameterLock.unlock();

	if(itemshareData.pdafParameter->ucPlatform== 0) //MTK
	{
		if(itemshareData.pdafParameter->usVersion[3]>=2)
		{   iresult=this->MTKPDAFSTEP2_20CM(); }
		else 
		{iresult=this->PDAFCalibration15CM();}
	}
	else if(itemshareData.pdafParameter->ucPlatform== 1) //Qualcomm
	{
		if(itemshareData.pdafParameter->cVersion=='L')
		{
			iresult=this->QualCommPDAF_LVersion_DCCCalibration();
		}
		else  iresult=this->QualCommPDAFStep2();    
	}
	else if(itemshareData.pdafParameter->ucPlatform== 2) //SONY
	{
		iresult=this->SONYPDAF_DCCCal();
	}
	else if(itemshareData.pdafParameter->ucPlatform== 3) //His
	{
		iresult=HISIPDAFSTEP2_20CM();
	}

	return iresult;
}

int itemprocess::PDAFCalibration50CM()
{
	if(!classPlatform.HisFX3isstart())	return HisFX3Error_IsNotPreview;

	unsigned char ucApplication	=	0x0;
	int iresult = classPlatform.HisFX3GetLInfo(NULL, &ucApplication, NULL, NULL, NULL, NULL);
	if(iresult) return iresult;
#if (defined PDAF_LICENSE_ONLY_AUTHORIZE)
	if(ucApplication != 0x2){
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("此主板没有操作PDAF的授权"));
		return HisFX3Error_License;
	}
#else
	// 	if(ucApplication != 0x2 && ucApplication != 0xff){
	// 		emit information(QTextCodec::codecForName( "GBK")->toUnicode("此主板没有操作PDAF的授权"));
	// 		return HisFX3Error_License;
	// 	}
#endif

	if(iresult	=	getccmhardwareParameter(false))	return iresult;
	if(iresult		=	getpdafParameter(false))	return iresult;

	itemshareData.itemparameterLock.lockForRead();

	if(itemshareData.previewParameter->ucDataFormat > HisBaylor10_GBRG){
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("图像格式错误：不是BAYLOR模式"));
		itemshareData.itemparameterLock.unlock();
		return iresult;
	}

	if(itemshareData.pdafParameter->usVersion[3] != 1){
		emit information(tr("The MTK PDAF lib version you chosen is not V1"));
		itemshareData.itemparameterLock.unlock();
		return HisFX3Error_Parameter;
	}

	QString strSerialNumber;
	classLog->getserialnumber(strSerialNumber);

	_HisCCMAFBurn_Config stAFConfig;
	stAFConfig.bDebug						=	hisglobalparameter.bDebugMode;
	stAFConfig.strDriverIC				=	(itemshareData.ccmhardwareParameter->motortype.toAscii()).data();
	stAFConfig.strproject					=	itemshareData.ccmhardwareParameter->projectname.toAscii().data();
	stAFConfig.strsensor					=	itemshareData.ccmhardwareParameter->sensortype.toAscii().data();
	stAFConfig.bNear						=	true;
	stAFConfig.bInfinite						=	true;
	stAFConfig.iwidth						=	itemshareData.previewParameter->iWidth;
	stAFConfig.iheight						=	itemshareData.previewParameter->iHeight;
	stAFConfig.strFunctionChoose	=	itemshareData.pdafParameter->strAFChoose.toAscii().data();
	stAFConfig.ucSlave					=	itemshareData.previewParameter->ucSlave;
	stAFConfig.uiDataFormat			=	itemshareData.previewParameter->ucDataFormat;
	stAFConfig.ucEESlave				=	itemshareData.ccmhardwareParameter->ucEESlave;
	stAFConfig.strSerialNumber		=	strSerialNumber.toAscii().data();

#if (defined _WIN64) && (defined _DEBUG)
	QString strLibPath	=	QDir::currentPath() % "/HisCCMOTP64D";
#elif (defined _WIN64) && !(defined _DEBUG)
	QString strLibPath	=	QDir::currentPath() % "/HisCCMOTP64";
#elif (defined _WIN32) && (defined _DEBUG)
	QString strLibPath	=	QDir::currentPath() % "/HisCCMOTP32D";
#else
	QString strLibPath	=	QDir::currentPath() % "/HisCCMOTP32";
#endif

	RolongoOTPAPIVersion getRolongoOTPAPIVersion = (RolongoOTPAPIVersion)(QLibrary::resolve(strLibPath, "getRolongoOTPAPIVersion"));
	Rolongocheckafmotor checkafmotor = (Rolongocheckafmotor)(QLibrary::resolve(strLibPath, "checkafmotor"));
	RolongowriteMTKPDAF writeMTKPDAF = (RolongowriteMTKPDAF)(QLibrary::resolve(strLibPath, "writeMTKPDAF"));

	if(!(getRolongoOTPAPIVersion && checkafmotor && writeMTKPDAF)){
		emit information(tr("Resolve HisCCMOTP DLL Function Fail"));
		itemshareData.itemparameterLock.unlock();
		return HisCCMError_LoadDLLFuc;
	}

	emit enableinfotimer(1);
	iresult	=	checkafmotor(*globalFunPointer.vectorHisCCMOTPInfoW, &stAFConfig, globalFunPointer.ReadHisFX3IIC, globalFunPointer.WriteHisFX3IIC, globalFunPointer.SetHisFX3IICSpeed, globalFunPointer.SetHisFX3Voltage, \
		globalFunPointer.GetHisFX3Voltage, SetHisFX3VFuseVolt, GetHisFX3VFuseVolt, GetFreshframe, SetHisFX3GPIO, GetHisFX3GPIO, \
		globalFunPointer.PullHisFX3RESET, globalFunPointer.PullHisFX3PWND, globalFunPointer.BatchReadHisFX3IICNoLimit, globalFunPointer.BatchWriteHisFX3IICNoLimit, \
		globalFunPointer.HisFX3LogPush_back, globalFunPointer.PageWriteHisFX3IIC, globalFunPointer.PageReadHisFX3IIC, \
		globalFunPointer.HisFX3PageWriteSPI, globalFunPointer.HisFX3PageReadSPI);
	emit enableinfotimer(0);
	if(iresult){
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("获取远近焦烧录数据失败"));
		itemshareData.itemparameterLock.unlock();
		return iresult;
	}

	int iInfiniteMotor	=	stAFConfig.iInfinitMotor;
	int iMacroMotor	=	stAFConfig.iNearMotor;

	emit information(QTextCodec::codecForName( "GBK")->toUnicode("近焦位置：") % QString::number(iMacroMotor));
	emit information(QTextCodec::codecForName( "GBK")->toUnicode("远焦位置：") % QString::number(iInfiniteMotor));

	// 	iresult	=	classSensor.setMotor(itemshareData.ccmhardwareParameter->motortype.toAscii().data(), \
	// 		itemshareData.previewParameter->ucSlave, itemshareData.ccmhardwareParameter->projectname.toAscii().data(), \
	// 		iMacroMotor, ReadHisFX3IIC, WriteHisFX3IIC, SetHisFX3IICSpeed);
	// 	if(iresult){
	// 		emit information(QTextCodec::codecForName( "GBK")->toUnicode("设置马达到近焦位置失败"));
	// 		itemshareData.itemparameterLock.unlock();
	// 		return iresult;
	// 	}

	strLibPath	=	QDir::currentPath() % "/pdaflib/mtk_" % QString::number(itemshareData.pdafParameter->usVersion[3]) % "." % \
		QString::number(itemshareData.pdafParameter->usVersion[2]) % "." % QString::number(itemshareData.pdafParameter->usVersion[1]) % \
		"." % QString::number(itemshareData.pdafParameter->usVersion[0]);
#ifdef _WIN64
	strLibPath	=	strLibPath % "/x64/pd_cali_dll";
#else
	strLibPath	=	strLibPath % "/x86/pd_cali_dll";
#endif

#ifdef _WIN64
	mtk_pd_cali_init pd_cali_init	=	(mtk_pd_cali_init)(QLibrary::resolve(strLibPath, "?pd_cali_init@@YA?AW4PD_ERR_CODE@@PEAD@Z"));
	mtk_pd_cali_get_max_output_size pd_cali_get_max_output_size	=	(mtk_pd_cali_get_max_output_size)(QLibrary::resolve(strLibPath, "?pd_cali_get_max_output_size@@YA?AW4PD_ERR_CODE@@AEAH@Z"));
	mtk_pd_cali_get_capture_num pd_cali_get_capture_num	=	(mtk_pd_cali_get_capture_num)(QLibrary::resolve(strLibPath, "?pd_cali_get_capture_num@@YA?AW4PD_ERR_CODE@@AEAH@Z"));
	mtk_pd_cali_get_raw_width_height pd_cali_get_raw_width_height	=	(mtk_pd_cali_get_raw_width_height)(QLibrary::resolve(strLibPath, "?pd_cali_get_raw_width_height@@YA?AW4PD_ERR_CODE@@AEAH0@Z"));
	mtk_pd_cali_proc1 pd_cali_proc1	=	(mtk_pd_cali_proc1)(QLibrary::resolve(strLibPath, "?pd_cali_proc1@@YA?AW4PD_ERR_CODE@@PEAGPEADHAEAH@Z"));
	mtk_pd_cali_proc2 pd_cali_proc2	=	(mtk_pd_cali_proc2)(QLibrary::resolve(strLibPath, "?pd_cali_proc2@@YA?AW4PD_ERR_CODE@@PEAPEADPEAHHPEADHAEAH@Z"));
	mtk_pd_cali_verify pd_cali_verify	=	(mtk_pd_cali_verify)(QLibrary::resolve(strLibPath, "?pd_cali_verify@@YA?AW4PD_ERR_CODE@@PEAE@Z"));
	mtk_pd_cali_verify_proc1 pd_cali_verify_proc1	=	(mtk_pd_cali_verify_proc1)(QLibrary::resolve(strLibPath, "?pd_cali_verify_proc1@@YA?AW4PD_ERR_CODE@@PEAE@Z"));
	mtk_pd_cali_verify_proc2 pd_cali_verify_proc2	=	(mtk_pd_cali_verify_proc2)(QLibrary::resolve(strLibPath, "?pd_cali_verify_proc2@@YA?AW4PD_ERR_CODE@@PEAE@Z"));
	mtk_pd_cali_get_DAC_proc2 pd_cali_get_DAC_proc2	=	(mtk_pd_cali_get_DAC_proc2)(QLibrary::resolve(strLibPath, "?pd_cali_get_DAC_proc2@@YA?AW4PD_ERR_CODE@@PEAEAEAH@Z"));
#else
	mtk_pd_cali_init pd_cali_init	=	(mtk_pd_cali_init)(QLibrary::resolve(strLibPath, "?pd_cali_init@@YA?AW4PD_ERR_CODE@@PAD@Z"));
	mtk_pd_cali_get_max_output_size pd_cali_get_max_output_size	=	(mtk_pd_cali_get_max_output_size)(QLibrary::resolve(strLibPath, "?pd_cali_get_max_output_size@@YA?AW4PD_ERR_CODE@@AAH@Z"));
	mtk_pd_cali_get_capture_num pd_cali_get_capture_num	=	(mtk_pd_cali_get_capture_num)(QLibrary::resolve(strLibPath, "?pd_cali_get_capture_num@@YA?AW4PD_ERR_CODE@@AAH@Z"));
	mtk_pd_cali_get_raw_width_height pd_cali_get_raw_width_height	=	(mtk_pd_cali_get_raw_width_height)(QLibrary::resolve(strLibPath, "?pd_cali_get_raw_width_height@@YA?AW4PD_ERR_CODE@@AAH0@Z"));
	mtk_pd_cali_proc1 pd_cali_proc1	=	(mtk_pd_cali_proc1)(QLibrary::resolve(strLibPath, "?pd_cali_proc1@@YA?AW4PD_ERR_CODE@@PAGPADHAAH@Z"));
	mtk_pd_cali_proc2 pd_cali_proc2	=	(mtk_pd_cali_proc2)(QLibrary::resolve(strLibPath, "?pd_cali_proc2@@YA?AW4PD_ERR_CODE@@PAPADPAHHPADHAAH@Z"));
	mtk_pd_cali_verify pd_cali_verify	=	(mtk_pd_cali_verify)(QLibrary::resolve(strLibPath, "?pd_cali_verify@@YA?AW4PD_ERR_CODE@@PAE@Z"));
	mtk_pd_cali_verify_proc1 pd_cali_verify_proc1	=	(mtk_pd_cali_verify_proc1)(QLibrary::resolve(strLibPath, "?pd_cali_verify_proc1@@YA?AW4PD_ERR_CODE@@PAE@Z"));
	mtk_pd_cali_verify_proc2 pd_cali_verify_proc2	=	(mtk_pd_cali_verify_proc2)(QLibrary::resolve(strLibPath, "?pd_cali_verify_proc2@@YA?AW4PD_ERR_CODE@@PAE@Z"));
	mtk_pd_cali_get_DAC_proc2 pd_cali_get_DAC_proc2	=	(mtk_pd_cali_get_DAC_proc2)(QLibrary::resolve(strLibPath, "?pd_cali_get_DAC_proc2@@YA?AW4PD_ERR_CODE@@PAEAAH@Z"));
#endif	
	if(!(pd_cali_init && pd_cali_get_max_output_size && pd_cali_get_capture_num && pd_cali_get_raw_width_height && \
		pd_cali_proc1 && pd_cali_proc2 && pd_cali_verify && pd_cali_verify_proc1 && pd_cali_verify_proc2 && pd_cali_get_DAC_proc2)){
			emit information(tr("Resolve MTK PDAF DLL Function Fail"));
			itemshareData.itemparameterLock.unlock();
			return HisCCMError_LoadDLLFuc;
	}

#ifdef _WIN64
	mtkv1_pd_cali_proc3 pd_cali_proc3	=	(mtkv1_pd_cali_proc3)(QLibrary::resolve(strLibPath, "?pd_cali_proc3@@YA?AW4PD_ERR_CODE@@PEAPEADPEAHHPEADHAEAH@Z"));
	mtkv1_pd_cali_verify_proc3 pd_cali_verify_proc3	=	(mtkv1_pd_cali_verify_proc3)(QLibrary::resolve(strLibPath, "?pd_cali_verify_proc3@@YA?AW4PD_ERR_CODE@@PEAEPEAHH@Z"));
	mtkv1_pd_cali_get_DAC_proc3 pd_cali_get_DAC_proc3	=	(mtkv1_pd_cali_get_DAC_proc3)(QLibrary::resolve(strLibPath, "?pd_cali_get_DAC_proc3@@YA?AW4PD_ERR_CODE@@PEAEAEAH@Z"));
#else
	mtkv1_pd_cali_proc3 pd_cali_proc3	=	(mtkv1_pd_cali_proc3)(QLibrary::resolve(strLibPath, "?pd_cali_proc3@@YA?AW4PD_ERR_CODE@@PAPADPAHHPADHAAH@Z"));
	mtkv1_pd_cali_verify_proc3 pd_cali_verify_proc3	=	(mtkv1_pd_cali_verify_proc3)(QLibrary::resolve(strLibPath, "?pd_cali_verify_proc3@@YA?AW4PD_ERR_CODE@@PAEPAHH@Z"));
	mtkv1_pd_cali_get_DAC_proc3 pd_cali_get_DAC_proc3	=	(mtkv1_pd_cali_get_DAC_proc3)(QLibrary::resolve(strLibPath, "?pd_cali_get_DAC_proc3@@YA?AW4PD_ERR_CODE@@PAEAAH@Z"));
#endif
	if(!(pd_cali_proc3 && pd_cali_verify_proc3 && pd_cali_get_DAC_proc3)){
		emit information(tr("Resolve MTK PDAF DLL Function Fail"));
		itemshareData.itemparameterLock.unlock();
		return HisCCMError_LoadDLLFuc;
	}

	QString strIniPath	=	QDir::currentPath() % "/pdaftemplate/MTK/" % itemshareData.ccmhardwareParameter->projectname % "/pd_pos_info.ini";

	PD_ERR_CODE mtkError	=	pd_cali_init(strIniPath.toAscii().data());
	iresult	=	MTkErrorcodeConvert(mtkError);
	if(iresult){
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("pd_cali_init调用失败"));
		itemshareData.itemparameterLock.unlock();
		return iresult;
	}

	int iMaxOutputSize;
	mtkError	=	pd_cali_get_max_output_size(iMaxOutputSize);
	int iCaptureNum;
	mtkError	=	pd_cali_get_capture_num(iCaptureNum);

	emit information(QTextCodec::codecForName( "GBK")->toUnicode("最大输出尺寸：") % QString::number(iMaxOutputSize));
	emit information(QTextCodec::codecForName( "GBK")->toUnicode("抓取帧数：") % QString::number(iCaptureNum));

	motorScaleto1023(itemshareData.ccmhardwareParameter->motortype.toAscii().data(), iInfiniteMotor, iInfiniteMotor);
	motorScaleto1023(itemshareData.ccmhardwareParameter->motortype.toAscii().data(), iMacroMotor, iMacroMotor);

	int* piMotorStep	=	new int[iCaptureNum];
	if(!piMotorStep){
		itemshareData.itemparameterLock.unlock();
		return HisFX3Error_MallocBuffer;
	}
	int iData	=	(iMacroMotor-iInfiniteMotor) /(iCaptureNum-1);
	if(iMacroMotor-iInfiniteMotor - iData *(iCaptureNum-1) >= 5) ++iData;
	piMotorStep[0]							=	iInfiniteMotor;
	piMotorStep[iCaptureNum-1]	=	iMacroMotor;
	for(int i=1;	i<iCaptureNum;	++i){
		piMotorStep[i]	=	piMotorStep[i-1] + iData;
	}

	unsigned short** ppusRaw10	=	new unsigned short*[iCaptureNum];
	if(!ppusRaw10){
		HisReleaseNewB(piMotorStep);
		itemshareData.itemparameterLock.unlock();
		return HisFX3Error_MallocBuffer;
	}
	for(int i=0;	i<iCaptureNum;	++i)
		ppusRaw10[i]	= 0;

	unsigned int uiPixel	=	itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight *2;


	int iMotorValue;
	motorScalefrom1023(itemshareData.ccmhardwareParameter->motortype.toAscii().data(), piMotorStep[0], iMotorValue);

	iresult =	setMotor((itemshareData.ccmhardwareParameter->motortype.toAscii()).data(), \
		itemshareData.previewParameter->ucSlave, \
		(itemshareData.ccmhardwareParameter->projectname.toAscii()).data(), iMotorValue, \
		globalFunPointer.ReadHisFX3IIC, globalFunPointer.WriteHisFX3IIC, globalFunPointer.SetHisFX3IICSpeed, globalFunPointer.PullHisFX3RESET, globalFunPointer.PullHisFX3PWND, \
		globalFunPointer.PageWriteHisFX3IIC, globalFunPointer.PageReadHisFX3IIC, globalFunPointer.HisFX3PageWriteSPI, globalFunPointer.HisFX3PageReadSPI);
	if(iresult){
		HisReleaseNewB(ppusRaw10);
		HisReleaseNewB(piMotorStep);
		itemshareData.itemparameterLock.unlock();
		return iresult;
	}
	DWORD dwend, dwstart	=	::GetTickCount();

	for(int i=1;	i<=iCaptureNum;	++i){
		ppusRaw10[i-1]	=	(unsigned short*)_aligned_malloc(uiPixel, _HisCacheLine_Aligned);
		if(!ppusRaw10[i-1]){
			for(int x=0;	x<iCaptureNum;	++x)
				HisReleaseMalloc(ppusRaw10[x]);
			HisReleaseNewB(ppusRaw10);
			HisReleaseNewB(piMotorStep);
			itemshareData.itemparameterLock.unlock();
			return iresult;
		}

		dwend	=	::GetTickCount();
		if(dwstart + itemshareData.pdafParameter->uiMotorSleep > dwend)
			::Sleep(dwstart + itemshareData.pdafParameter->uiMotorSleep - dwend);
		iresult	=	GetFreshframe((unsigned char*)(ppusRaw10[i-1]), uiPixel, _FrameType_Raw10, (i==1)?(true):(false));
		if(iresult){
			for(int x=0;	x<iCaptureNum;	++x)
				HisReleaseMalloc(ppusRaw10[x]);
			HisReleaseNewB(ppusRaw10);
			HisReleaseNewB(piMotorStep);
			itemshareData.itemparameterLock.unlock();
			return iresult;
		}

		if(i != iCaptureNum){
			motorScalefrom1023(itemshareData.ccmhardwareParameter->motortype.toAscii().data(), piMotorStep[i], iMotorValue);
			iresult =	setMotor((itemshareData.ccmhardwareParameter->motortype.toAscii()).data(), \
				itemshareData.previewParameter->ucSlave, \
				(itemshareData.ccmhardwareParameter->projectname.toAscii()).data(), iMotorValue, \
				globalFunPointer.ReadHisFX3IIC, globalFunPointer.WriteHisFX3IIC, globalFunPointer.SetHisFX3IICSpeed, globalFunPointer.PullHisFX3RESET, globalFunPointer.PullHisFX3PWND, \
				globalFunPointer.PageWriteHisFX3IIC, globalFunPointer.PageReadHisFX3IIC, globalFunPointer.HisFX3PageWriteSPI, globalFunPointer.HisFX3PageReadSPI);
			if(iresult){
				for(int x=0;	x<iCaptureNum;	++x)
					HisReleaseMalloc(ppusRaw10[x]);
				HisReleaseNewB(ppusRaw10);
				HisReleaseNewB(piMotorStep);
				itemshareData.itemparameterLock.unlock();
				return iresult;
			}
			dwstart	=	::GetTickCount();
		}

		if(hisglobalparameter.bDebugMode){
			QDir classDir;
			strIniPath	=	QDir::currentPath() % "/mtkpdaflog";
			classDir.mkpath(strIniPath);
			ROPLOW::saveRaw10(strIniPath, strSerialNumber % "_MTK_50CM_Motor_" % QString::number(i), itemshareData.previewParameter->ucDataFormat, \
				itemshareData.previewParameter->iWidth, itemshareData.previewParameter->iHeight, (void*)(ppusRaw10[i-1]));
		}
	}

	char* pstrOutput	=	new char[iMaxOutputSize];
	if(!pstrOutput){
		for(int x=0;	x<iCaptureNum;	++x)
			HisReleaseMalloc(ppusRaw10[x]);
		HisReleaseNewB(ppusRaw10);
		HisReleaseNewB(piMotorStep);
		itemshareData.itemparameterLock.unlock();
		return HisFX3Error_MallocBuffer;
	}

	int iOutputSize	=	0;
	mtkError	=	pd_cali_proc3((char**)(ppusRaw10), piMotorStep, iCaptureNum, pstrOutput, iMaxOutputSize, iOutputSize);
	for(int x=0;	x<iCaptureNum;	++x)
		HisReleaseMalloc(ppusRaw10[x]);
	HisReleaseNewB(ppusRaw10);

	iresult	=	MTkErrorcodeConvert(mtkError);
	if(iresult){
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("pd_cali_proc3调用失败"));
		HisReleaseNewB(pstrOutput);
		HisReleaseNewB(piMotorStep);
		itemshareData.itemparameterLock.unlock();
		return iresult;
	}

	emit information(QTextCodec::codecForName( "GBK")->toUnicode("step3 输出大小(BYTE)：") % QString::number(iOutputSize));

	mtkError	=	pd_cali_verify_proc3((unsigned char*)(pstrOutput), piMotorStep, iCaptureNum);
	HisReleaseNewB(piMotorStep);
	iresult		=	MTkErrorcodeConvert(mtkError);
	if(iresult){
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("pd_cali_verify_proc3调用失败"));
		HisReleaseNewB(pstrOutput);
		itemshareData.itemparameterLock.unlock();
		return iresult;
	}

	if(hisglobalparameter.bDebugMode){
		QDir classDir;
		strIniPath	=	QDir::currentPath() % "/mtkpdaflog";
		classDir.mkpath(strIniPath);
		strIniPath	=	strIniPath % "/" % strSerialNumber % "_MTK_PDAF_Step3_Write_F1.bin";
		FILE* fileStep1	=	fopen(strIniPath.toAscii().data(), "wb");
		if(fileStep1 != NULL){
			fwrite(pstrOutput, 1, iOutputSize, fileStep1);
			fclose(fileStep1);
		}
	}

	mtkError	=	pd_cali_get_DAC_proc3((unsigned char*)(pstrOutput), iMotorValue);
	iresult		=	MTkErrorcodeConvert(mtkError);
	if(iresult){
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("pd_cali_get_DAC_proc3调用失败"));
		HisReleaseNewB(pstrOutput);
		itemshareData.itemparameterLock.unlock();
		return iresult;
	}

	motorScalefrom1023(itemshareData.ccmhardwareParameter->motortype.toAscii().data(), iMotorValue, iMotorValue);
	emit information(QTextCodec::codecForName( "GBK")->toUnicode("50CM对焦清晰位置：") % QString::number(iMotorValue));
	iresult =	setMotor((itemshareData.ccmhardwareParameter->motortype.toAscii()).data(), \
		itemshareData.previewParameter->ucSlave, \
		(itemshareData.ccmhardwareParameter->projectname.toAscii()).data(), iMotorValue, \
		globalFunPointer.ReadHisFX3IIC, globalFunPointer.WriteHisFX3IIC, globalFunPointer.SetHisFX3IICSpeed, globalFunPointer.PullHisFX3RESET, globalFunPointer.PullHisFX3PWND, \
		globalFunPointer.PageWriteHisFX3IIC, globalFunPointer.PageReadHisFX3IIC, globalFunPointer.HisFX3PageWriteSPI, globalFunPointer.HisFX3PageReadSPI);
	if(iresult){
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("设置马达位置错误"));
		HisReleaseNewB(pstrOutput);
		itemshareData.itemparameterLock.unlock();
		return iresult;
	}

	_HisCCMMTKPDAFBurn_Config stPDAFConfig;
	stPDAFConfig.bDebug					=		hisglobalparameter.bDebugMode;
	stPDAFConfig.ucSensorSlave		=		itemshareData.previewParameter->ucSlave;
	stPDAFConfig.strproject					=		itemshareData.ccmhardwareParameter->projectname.toAscii().data();
	stPDAFConfig.strsensor					=		itemshareData.ccmhardwareParameter->sensortype.toAscii().data();
	stPDAFConfig.strDriverIC				=		itemshareData.ccmhardwareParameter->motortype.toAscii().data();
	stPDAFConfig.strFunctionChoose	=	itemshareData.pdafParameter->strPDAFChoose.toAscii().data();
	stPDAFConfig.ucEESlave				=	itemshareData.ccmhardwareParameter->ucEESlave;
	stPDAFConfig.ucTpye					=	3;
	stPDAFConfig.uiDataSize				=	iOutputSize;
	stPDAFConfig.Reserve1.u16value[3]	=	itemshareData.pdafParameter->usVersion[3];
	stPDAFConfig.Reserve1.u16value[2]	=	itemshareData.pdafParameter->usVersion[2];
	stPDAFConfig.Reserve1.u16value[1]	=	itemshareData.pdafParameter->usVersion[1];
	stPDAFConfig.Reserve1.u16value[0]	=	itemshareData.pdafParameter->usVersion[0];
	memcpy(stPDAFConfig.ucData, pstrOutput, stPDAFConfig.uiDataSize);

	emit enableinfotimer(1);
	iresult	=	writeMTKPDAF(*globalFunPointer.vectorHisCCMOTPInfoW, &stPDAFConfig, globalFunPointer.ReadHisFX3IIC, globalFunPointer.WriteHisFX3IIC, globalFunPointer.SetHisFX3IICSpeed, \
		globalFunPointer.SetHisFX3Voltage, globalFunPointer.GetHisFX3Voltage, SetHisFX3VFuseVolt, GetHisFX3VFuseVolt, GetFreshframe, \
		globalFunPointer.BatchWriteHisFX3IIC, globalFunPointer.BatchReadHisFX3IIC, SetHisFX3GPIO, GetHisFX3GPIO, globalFunPointer.PullHisFX3RESET, globalFunPointer.PullHisFX3PWND, \
		globalFunPointer.BatchReadHisFX3IICNoLimit, globalFunPointer.BatchWriteHisFX3IICNoLimit, globalFunPointer.HisFX3LogPush_back, \
		globalFunPointer.PageWriteHisFX3IIC, globalFunPointer.PageReadHisFX3IIC, globalFunPointer.HisFX3PageWriteSPI, globalFunPointer.HisFX3PageReadSPI);
	emit enableinfotimer(0);
	if(iresult){
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("写入PDAF Step2 数据失败"));
		HisReleaseNewB(pstrOutput);
		itemshareData.itemparameterLock.unlock();
		return iresult;
	}

	HisReleaseNewB(pstrOutput);
	itemshareData.itemparameterLock.unlock();
	return 0;
}

int itemprocess::PDAFCalibration15CM()
{
	itemshareData.itemparameterLock.lockForRead();
	int iresult;

	if(itemshareData.pdafParameter->usVersion[3] != 1){
		emit information(tr("The MTK PDAF lib version you chosen is not V1"));
		itemshareData.itemparameterLock.unlock();
		return HisFX3Error_Parameter;
	}

	QString strSerialNumber;
	classLog->getserialnumber(strSerialNumber);

	_HisCCMAFBurn_Config stAFConfig;
	stAFConfig.bDebug						=	hisglobalparameter.bDebugMode;
	stAFConfig.strDriverIC				=	(itemshareData.ccmhardwareParameter->motortype.toAscii()).data();
	stAFConfig.strproject					=	itemshareData.ccmhardwareParameter->projectname.toAscii().data();
	stAFConfig.strsensor					=	itemshareData.ccmhardwareParameter->sensortype.toAscii().data();
	stAFConfig.bNear						=	true;
	stAFConfig.bInfinite						=	true;
	stAFConfig.iwidth						=	itemshareData.previewParameter->iWidth;
	stAFConfig.iheight						=	itemshareData.previewParameter->iHeight;
	stAFConfig.strFunctionChoose	=	itemshareData.pdafParameter->strAFChoose.toAscii().data();
	stAFConfig.ucSlave					=	itemshareData.previewParameter->ucSlave;
	stAFConfig.uiDataFormat			=	itemshareData.previewParameter->ucDataFormat;
	stAFConfig.ucEESlave				=	itemshareData.ccmhardwareParameter->ucEESlave;
	stAFConfig.strSerialNumber	=	strSerialNumber.toAscii().data();

#if (defined _WIN64) && (defined _DEBUG)
	QString strLibPath	=	QDir::currentPath() % "/HisCCMOTP64D";
#elif (defined _WIN64) && !(defined _DEBUG)
	QString strLibPath	=	QDir::currentPath() % "/HisCCMOTP64";
#elif (defined _WIN32) && (defined _DEBUG)
	QString strLibPath	=	QDir::currentPath() % "/HisCCMOTP32D";
#else
	QString strLibPath	=	QDir::currentPath() % "/HisCCMOTP32";
#endif

	RolongoOTPAPIVersion getRolongoOTPAPIVersion = (RolongoOTPAPIVersion)(QLibrary::resolve(strLibPath, "getRolongoOTPAPIVersion"));
	Rolongocheckafmotor checkafmotor = (Rolongocheckafmotor)(QLibrary::resolve(strLibPath, "checkafmotor"));
	RolongowriteMTKPDAF writeMTKPDAF = (RolongowriteMTKPDAF)(QLibrary::resolve(strLibPath, "writeMTKPDAF"));

	if(!(getRolongoOTPAPIVersion && checkafmotor && writeMTKPDAF)){
		emit information(tr("Resolve HisCCMOTP DLL Function Fail"));
		itemshareData.itemparameterLock.unlock();
		return HisCCMError_LoadDLLFuc;
	}

	emit enableinfotimer(1);
	iresult	=	checkafmotor(*globalFunPointer.vectorHisCCMOTPInfoW, &stAFConfig, globalFunPointer.ReadHisFX3IIC, globalFunPointer.WriteHisFX3IIC, globalFunPointer.SetHisFX3IICSpeed, globalFunPointer.SetHisFX3Voltage, \
		globalFunPointer.GetHisFX3Voltage, SetHisFX3VFuseVolt, GetHisFX3VFuseVolt, GetFreshframe, SetHisFX3GPIO, GetHisFX3GPIO, \
		globalFunPointer.PullHisFX3RESET, globalFunPointer.PullHisFX3PWND, globalFunPointer.BatchReadHisFX3IICNoLimit, globalFunPointer.BatchWriteHisFX3IICNoLimit, \
		globalFunPointer.HisFX3LogPush_back, globalFunPointer.PageWriteHisFX3IIC, globalFunPointer.PageReadHisFX3IIC, \
		globalFunPointer.HisFX3PageWriteSPI, globalFunPointer.HisFX3PageReadSPI);
	emit enableinfotimer(0);
	if(iresult){
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("获取远近焦烧录数据失败"));
		itemshareData.itemparameterLock.unlock();
		return iresult;
	}

	int iInfiniteMotor	=	stAFConfig.iInfinitMotor;
	int iMacroMotor	=	stAFConfig.iNearMotor;

	emit information(QTextCodec::codecForName( "GBK")->toUnicode("近焦位置：") % QString::number(iMacroMotor));
	emit information(QTextCodec::codecForName( "GBK")->toUnicode("远焦位置：") % QString::number(iInfiniteMotor));

	// 	iresult	=	setMotor(itemshareData.ccmhardwareParameter->motortype.toAscii().data(), \
	// 		itemshareData.previewParameter->ucSlave, itemshareData.ccmhardwareParameter->projectname.toAscii().data(), \
	// 		iMacroMotor, ReadHisFX3IIC, WriteHisFX3IIC, SetHisFX3IICSpeed);
	// 	if(iresult){
	// 		emit information(QTextCodec::codecForName( "GBK")->toUnicode("设置马达到近焦位置失败"));
	// 		itemshareData.itemparameterLock.unlock();
	// 		return iresult;
	// 	}

	strLibPath	=	QDir::currentPath() % "/pdaflib/mtk_" % QString::number(itemshareData.pdafParameter->usVersion[3]) % "." % \
		QString::number(itemshareData.pdafParameter->usVersion[2]) % "." % QString::number(itemshareData.pdafParameter->usVersion[1]) % \
		"." % QString::number(itemshareData.pdafParameter->usVersion[0]);
#ifdef _WIN64
	strLibPath	=	strLibPath % "/x64/pd_cali_dll";
#else
	strLibPath	=	strLibPath % "/x86/pd_cali_dll";
#endif

#ifdef _WIN64
	mtk_pd_cali_init pd_cali_init	=	(mtk_pd_cali_init)(QLibrary::resolve(strLibPath, "?pd_cali_init@@YA?AW4PD_ERR_CODE@@PEAD@Z"));
	mtk_pd_cali_get_max_output_size pd_cali_get_max_output_size	=	(mtk_pd_cali_get_max_output_size)(QLibrary::resolve(strLibPath, "?pd_cali_get_max_output_size@@YA?AW4PD_ERR_CODE@@AEAH@Z"));
	mtk_pd_cali_get_capture_num pd_cali_get_capture_num	=	(mtk_pd_cali_get_capture_num)(QLibrary::resolve(strLibPath, "?pd_cali_get_capture_num@@YA?AW4PD_ERR_CODE@@AEAH@Z"));
	mtk_pd_cali_get_raw_width_height pd_cali_get_raw_width_height	=	(mtk_pd_cali_get_raw_width_height)(QLibrary::resolve(strLibPath, "?pd_cali_get_raw_width_height@@YA?AW4PD_ERR_CODE@@AEAH0@Z"));
	mtk_pd_cali_proc1 pd_cali_proc1	=	(mtk_pd_cali_proc1)(QLibrary::resolve(strLibPath, "?pd_cali_proc1@@YA?AW4PD_ERR_CODE@@PEAGPEADHAEAH@Z"));
	mtk_pd_cali_proc2 pd_cali_proc2	=	(mtk_pd_cali_proc2)(QLibrary::resolve(strLibPath, "?pd_cali_proc2@@YA?AW4PD_ERR_CODE@@PEAPEADPEAHHPEADHAEAH@Z"));
	mtk_pd_cali_verify pd_cali_verify	=	(mtk_pd_cali_verify)(QLibrary::resolve(strLibPath, "?pd_cali_verify@@YA?AW4PD_ERR_CODE@@PEAE@Z"));
	mtk_pd_cali_verify_proc1 pd_cali_verify_proc1	=	(mtk_pd_cali_verify_proc1)(QLibrary::resolve(strLibPath, "?pd_cali_verify_proc1@@YA?AW4PD_ERR_CODE@@PEAE@Z"));
	mtk_pd_cali_verify_proc2 pd_cali_verify_proc2	=	(mtk_pd_cali_verify_proc2)(QLibrary::resolve(strLibPath, "?pd_cali_verify_proc2@@YA?AW4PD_ERR_CODE@@PEAE@Z"));
	mtk_pd_cali_get_DAC_proc2 pd_cali_get_DAC_proc2	=	(mtk_pd_cali_get_DAC_proc2)(QLibrary::resolve(strLibPath, "?pd_cali_get_DAC_proc2@@YA?AW4PD_ERR_CODE@@PEAEAEAH@Z"));
#else
	mtk_pd_cali_init pd_cali_init	=	(mtk_pd_cali_init)(QLibrary::resolve(strLibPath, "?pd_cali_init@@YA?AW4PD_ERR_CODE@@PAD@Z"));
	mtk_pd_cali_get_max_output_size pd_cali_get_max_output_size	=	(mtk_pd_cali_get_max_output_size)(QLibrary::resolve(strLibPath, "?pd_cali_get_max_output_size@@YA?AW4PD_ERR_CODE@@AAH@Z"));
	mtk_pd_cali_get_capture_num pd_cali_get_capture_num	=	(mtk_pd_cali_get_capture_num)(QLibrary::resolve(strLibPath, "?pd_cali_get_capture_num@@YA?AW4PD_ERR_CODE@@AAH@Z"));
	mtk_pd_cali_get_raw_width_height pd_cali_get_raw_width_height	=	(mtk_pd_cali_get_raw_width_height)(QLibrary::resolve(strLibPath, "?pd_cali_get_raw_width_height@@YA?AW4PD_ERR_CODE@@AAH0@Z"));
	mtk_pd_cali_proc1 pd_cali_proc1	=	(mtk_pd_cali_proc1)(QLibrary::resolve(strLibPath, "?pd_cali_proc1@@YA?AW4PD_ERR_CODE@@PAGPADHAAH@Z"));
	mtk_pd_cali_proc2 pd_cali_proc2	=	(mtk_pd_cali_proc2)(QLibrary::resolve(strLibPath, "?pd_cali_proc2@@YA?AW4PD_ERR_CODE@@PAPADPAHHPADHAAH@Z"));
	mtk_pd_cali_verify pd_cali_verify	=	(mtk_pd_cali_verify)(QLibrary::resolve(strLibPath, "?pd_cali_verify@@YA?AW4PD_ERR_CODE@@PAE@Z"));
	mtk_pd_cali_verify_proc1 pd_cali_verify_proc1	=	(mtk_pd_cali_verify_proc1)(QLibrary::resolve(strLibPath, "?pd_cali_verify_proc1@@YA?AW4PD_ERR_CODE@@PAE@Z"));
	mtk_pd_cali_verify_proc2 pd_cali_verify_proc2	=	(mtk_pd_cali_verify_proc2)(QLibrary::resolve(strLibPath, "?pd_cali_verify_proc2@@YA?AW4PD_ERR_CODE@@PAE@Z"));
	mtk_pd_cali_get_DAC_proc2 pd_cali_get_DAC_proc2	=	(mtk_pd_cali_get_DAC_proc2)(QLibrary::resolve(strLibPath, "?pd_cali_get_DAC_proc2@@YA?AW4PD_ERR_CODE@@PAEAAH@Z"));
#endif	
	if(!(pd_cali_init && pd_cali_get_max_output_size && pd_cali_get_capture_num && pd_cali_get_raw_width_height && \
		pd_cali_proc1 && pd_cali_proc2 && pd_cali_verify && pd_cali_verify_proc1 && pd_cali_verify_proc2 && pd_cali_get_DAC_proc2)){
			emit information(tr("Resolve MTK PDAF DLL Function Fail"));
			itemshareData.itemparameterLock.unlock();
			return HisCCMError_LoadDLLFuc;
	}

#ifdef _WIN64
	mtkv1_pd_cali_proc3 pd_cali_proc3	=	(mtkv1_pd_cali_proc3)(QLibrary::resolve(strLibPath, "?pd_cali_proc3@@YA?AW4PD_ERR_CODE@@PEAPEADPEAHHPEADHAEAH@Z"));
	mtkv1_pd_cali_verify_proc3 pd_cali_verify_proc3	=	(mtkv1_pd_cali_verify_proc3)(QLibrary::resolve(strLibPath, "?pd_cali_verify_proc3@@YA?AW4PD_ERR_CODE@@PEAEPEAHH@Z"));
	mtkv1_pd_cali_get_DAC_proc3 pd_cali_get_DAC_proc3	=	(mtkv1_pd_cali_get_DAC_proc3)(QLibrary::resolve(strLibPath, "?pd_cali_get_DAC_proc3@@YA?AW4PD_ERR_CODE@@PEAEAEAH@Z"));
#else
	mtkv1_pd_cali_proc3 pd_cali_proc3	=	(mtkv1_pd_cali_proc3)(QLibrary::resolve(strLibPath, "?pd_cali_proc3@@YA?AW4PD_ERR_CODE@@PAPADPAHHPADHAAH@Z"));
	mtkv1_pd_cali_verify_proc3 pd_cali_verify_proc3	=	(mtkv1_pd_cali_verify_proc3)(QLibrary::resolve(strLibPath, "?pd_cali_verify_proc3@@YA?AW4PD_ERR_CODE@@PAEPAHH@Z"));
	mtkv1_pd_cali_get_DAC_proc3 pd_cali_get_DAC_proc3	=	(mtkv1_pd_cali_get_DAC_proc3)(QLibrary::resolve(strLibPath, "?pd_cali_get_DAC_proc3@@YA?AW4PD_ERR_CODE@@PAEAAH@Z"));
#endif
	if(!(pd_cali_proc3 && pd_cali_verify_proc3 && pd_cali_get_DAC_proc3)){
		emit information(tr("Resolve MTK PDAF DLL Function Fail"));
		itemshareData.itemparameterLock.unlock();
		return HisCCMError_LoadDLLFuc;
	}

	QString strIniPath	=	QDir::currentPath() % "/pdaftemplate/MTK/" % itemshareData.ccmhardwareParameter->projectname % "/pd_pos_info.ini";

	PD_ERR_CODE mtkError	=	pd_cali_init(strIniPath.toAscii().data());
	iresult	=	MTkErrorcodeConvert(mtkError);
	if(iresult){
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("pd_cali_init调用失败"));
		itemshareData.itemparameterLock.unlock();
		return iresult;
	}

	int iMaxOutputSize;
	mtkError	=	pd_cali_get_max_output_size(iMaxOutputSize);
	int iCaptureNum;
	mtkError	=	pd_cali_get_capture_num(iCaptureNum);

	emit information(QTextCodec::codecForName( "GBK")->toUnicode("最大输出尺寸：") % QString::number(iMaxOutputSize));
	emit information(QTextCodec::codecForName( "GBK")->toUnicode("抓取帧数：") % QString::number(iCaptureNum));

	motorScaleto1023(itemshareData.ccmhardwareParameter->motortype.toAscii().data(), iInfiniteMotor, iInfiniteMotor);
	motorScaleto1023(itemshareData.ccmhardwareParameter->motortype.toAscii().data(), iMacroMotor, iMacroMotor);

	int* piMotorStep	=	new int[iCaptureNum];
	if(!piMotorStep){
		itemshareData.itemparameterLock.unlock();
		return HisFX3Error_MallocBuffer;
	}
	int iData	=	(iMacroMotor-iInfiniteMotor) /(iCaptureNum-1);
	if(iMacroMotor-iInfiniteMotor - iData *(iCaptureNum-1) >= 5) ++iData;
	piMotorStep[0]						=	iInfiniteMotor;
	piMotorStep[iCaptureNum-1]	=	iMacroMotor;
	for(int i=1;	i<iCaptureNum;	++i){
		piMotorStep[i]	=	piMotorStep[i-1] + iData;
	}

	unsigned short** ppusRaw10	=	new unsigned short*[iCaptureNum];
	if(!ppusRaw10){
		HisReleaseNewB(piMotorStep);
		itemshareData.itemparameterLock.unlock();
		return HisFX3Error_MallocBuffer;
	}
	for(int i=0;	i<iCaptureNum;	++i)
		ppusRaw10[i]	= 0;

	unsigned int uiPixel	=	itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight *2;

	int iMotorValue;
	motorScalefrom1023(itemshareData.ccmhardwareParameter->motortype.toAscii().data(), piMotorStep[0], iMotorValue);

	iresult =	setMotor((itemshareData.ccmhardwareParameter->motortype.toAscii()).data(), \
		itemshareData.previewParameter->ucSlave, \
		(itemshareData.ccmhardwareParameter->projectname.toAscii()).data(), iMotorValue, \
		globalFunPointer.ReadHisFX3IIC, globalFunPointer.WriteHisFX3IIC, globalFunPointer.SetHisFX3IICSpeed, globalFunPointer.PullHisFX3RESET, globalFunPointer.PullHisFX3PWND, \
		globalFunPointer.PageWriteHisFX3IIC, globalFunPointer.PageReadHisFX3IIC, globalFunPointer.HisFX3PageWriteSPI, globalFunPointer.HisFX3PageReadSPI);
	emit information(QTextCodec::codecForName( "GBK")->toUnicode("第1步马达：") % QString::number(iMotorValue));
	if(iresult){
		HisReleaseNewB(ppusRaw10);
		HisReleaseNewB(piMotorStep);
		itemshareData.itemparameterLock.unlock();
		return iresult;
	}
	DWORD dwend, dwstart	=	::GetTickCount();

	for(int i=1;	i<=iCaptureNum;	++i){
		ppusRaw10[i-1]	=	(unsigned short*)_aligned_malloc(uiPixel, _HisCacheLine_Aligned);
		if(!ppusRaw10[i-1]){
			for(int x=0;	x<iCaptureNum;	++x)
				HisReleaseMalloc(ppusRaw10[x]);
			HisReleaseNewB(ppusRaw10);
			HisReleaseNewB(piMotorStep);
			itemshareData.itemparameterLock.unlock();
			return iresult;
		}

		dwend	=	::GetTickCount();
		if(dwstart + itemshareData.pdafParameter->uiMotorSleep > dwend)
			::Sleep(dwstart + itemshareData.pdafParameter->uiMotorSleep - dwend);
		iresult	=	GetFreshframe((unsigned char*)(ppusRaw10[i-1]), uiPixel, _FrameType_Raw10, (i==1)?(true):(false));
		if(iresult){
			for(int x=0;	x<iCaptureNum;	++x)
				HisReleaseMalloc(ppusRaw10[x]);
			HisReleaseNewB(ppusRaw10);
			HisReleaseNewB(piMotorStep);
			itemshareData.itemparameterLock.unlock();
			return iresult;
		}

		if(i != iCaptureNum){
			motorScalefrom1023(itemshareData.ccmhardwareParameter->motortype.toAscii().data(), piMotorStep[i], iMotorValue);
			iresult =	setMotor((itemshareData.ccmhardwareParameter->motortype.toAscii()).data(), \
				itemshareData.previewParameter->ucSlave, \
				(itemshareData.ccmhardwareParameter->projectname.toAscii()).data(), iMotorValue, \
				globalFunPointer.ReadHisFX3IIC, globalFunPointer.WriteHisFX3IIC, globalFunPointer.SetHisFX3IICSpeed, globalFunPointer.PullHisFX3RESET, globalFunPointer.PullHisFX3PWND, \
				globalFunPointer.PageWriteHisFX3IIC, globalFunPointer.PageReadHisFX3IIC, globalFunPointer.HisFX3PageWriteSPI, globalFunPointer.HisFX3PageReadSPI);
			emit information(QTextCodec::codecForName( "GBK")->toUnicode("第") % QString::number(i) % \
				QTextCodec::codecForName( "GBK")->toUnicode("步马达：") % QString::number(iMotorValue));
			if(iresult){
				for(int x=0;	x<iCaptureNum;	++x)
					HisReleaseMalloc(ppusRaw10[x]);
				HisReleaseNewB(ppusRaw10);
				HisReleaseNewB(piMotorStep);
				itemshareData.itemparameterLock.unlock();
				return iresult;
			}
			dwstart	=	::GetTickCount();
		}

		if(hisglobalparameter.bDebugMode){
			QDir classDir;
			strIniPath	=	QDir::currentPath() % "/mtkpdaflog";
			classDir.mkpath(strIniPath);
			ROPLOW::saveRaw10(strIniPath, strSerialNumber % "_MTK_15CM_Motor_" % QString::number(i), itemshareData.previewParameter->ucDataFormat, \
				itemshareData.previewParameter->iWidth, itemshareData.previewParameter->iHeight, (void*)(ppusRaw10[i-1]));
		}
	}

	char* pstrOutput	=	new char[iMaxOutputSize];
	if(!pstrOutput){
		for(int x=0;	x<iCaptureNum;	++x)
			HisReleaseMalloc(ppusRaw10[x]);
		HisReleaseNewB(ppusRaw10);
		HisReleaseNewB(piMotorStep);
		itemshareData.itemparameterLock.unlock();
		return HisFX3Error_MallocBuffer;
	}

	int iOutputSize	=	0;
	mtkError	=	pd_cali_proc2((char**)(ppusRaw10), piMotorStep, iCaptureNum, pstrOutput, iMaxOutputSize, iOutputSize);
	for(int x=0;	x<iCaptureNum;	++x)
		HisReleaseMalloc(ppusRaw10[x]);
	HisReleaseNewB(ppusRaw10);
	HisReleaseNewB(piMotorStep);

	iresult	=	MTkErrorcodeConvert(mtkError);
	if(iresult){
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("pd_cali_init调用失败"));
		HisReleaseNewB(pstrOutput);
		itemshareData.itemparameterLock.unlock();
		return iresult;
	}

	emit information(QTextCodec::codecForName( "GBK")->toUnicode("step2 输出大小(BYTE)：") % QString::number(iOutputSize));

	mtkError	=	pd_cali_verify_proc2((unsigned char*)(pstrOutput));
	iresult		=	MTkErrorcodeConvert(mtkError);
	if(iresult){
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("pd_cali_verify_proc2调用失败"));
		HisReleaseNewB(pstrOutput);
		itemshareData.itemparameterLock.unlock();
		return iresult;
	}

	if(hisglobalparameter.bDebugMode){
		QDir classDir;
		strIniPath	=	QDir::currentPath() % "/mtkpdaflog";
		classDir.mkpath(strIniPath);
		strIniPath	=	strIniPath % "/" % strSerialNumber % "_MTK_PDAF_Step2_Write_F1.bin";
		FILE* fileStep1	=	fopen(strIniPath.toAscii().data(), "wb");
		if(fileStep1 != NULL){
			fwrite(pstrOutput, 1, iOutputSize, fileStep1);
			fclose(fileStep1);
		}
	}

	mtkError	=	pd_cali_get_DAC_proc2((unsigned char*)(pstrOutput), iMotorValue);
	iresult		=	MTkErrorcodeConvert(mtkError);
	if(iresult){
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("pd_cali_get_DAC_proc2调用失败"));
		HisReleaseNewB(pstrOutput);
		itemshareData.itemparameterLock.unlock();
		return iresult;
	}

	motorScalefrom1023(itemshareData.ccmhardwareParameter->motortype.toAscii().data(), iMotorValue, iMotorValue);
	emit information(QTextCodec::codecForName( "GBK")->toUnicode("15CM对焦清晰位置：") % QString::number(iMotorValue));
	iresult =	setMotor((itemshareData.ccmhardwareParameter->motortype.toAscii()).data(), \
		itemshareData.previewParameter->ucSlave, \
		(itemshareData.ccmhardwareParameter->projectname.toAscii()).data(), iMotorValue, \
		globalFunPointer.ReadHisFX3IIC, globalFunPointer.WriteHisFX3IIC, globalFunPointer.SetHisFX3IICSpeed, globalFunPointer.PullHisFX3RESET, globalFunPointer.PullHisFX3PWND, \
		globalFunPointer.PageWriteHisFX3IIC, globalFunPointer.PageReadHisFX3IIC, globalFunPointer.HisFX3PageWriteSPI, globalFunPointer.HisFX3PageReadSPI);
	if(iresult){
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("设置马达位置错误"));
		HisReleaseNewB(pstrOutput);
		itemshareData.itemparameterLock.unlock();
		return iresult;
	}

	_HisCCMMTKPDAFBurn_Config stPDAFConfig;
	stPDAFConfig.bDebug					=		hisglobalparameter.bDebugMode;
	stPDAFConfig.ucSensorSlave		=		itemshareData.previewParameter->ucSlave;
	stPDAFConfig.strproject					=		itemshareData.ccmhardwareParameter->projectname.toAscii().data();
	stPDAFConfig.strsensor					=		itemshareData.ccmhardwareParameter->sensortype.toAscii().data();
	stPDAFConfig.strDriverIC				=		itemshareData.ccmhardwareParameter->motortype.toAscii().data();
	stPDAFConfig.strFunctionChoose	=	itemshareData.pdafParameter->strPDAFChoose.toAscii().data();
	stPDAFConfig.ucEESlave				=	itemshareData.ccmhardwareParameter->ucEESlave;
	stPDAFConfig.ucTpye					=	2;
	stPDAFConfig.uiDataSize				=	iOutputSize;
	stPDAFConfig.Reserve1.u16value[3]	=	itemshareData.pdafParameter->usVersion[3];
	stPDAFConfig.Reserve1.u16value[2]	=	itemshareData.pdafParameter->usVersion[2];
	stPDAFConfig.Reserve1.u16value[1]	=	itemshareData.pdafParameter->usVersion[1];
	stPDAFConfig.Reserve1.u16value[0]	=	itemshareData.pdafParameter->usVersion[0];
	memcpy(stPDAFConfig.ucData, pstrOutput, stPDAFConfig.uiDataSize);

	emit enableinfotimer(1);
	iresult	=	writeMTKPDAF(*globalFunPointer.vectorHisCCMOTPInfoW, &stPDAFConfig, globalFunPointer.ReadHisFX3IIC, globalFunPointer.WriteHisFX3IIC, globalFunPointer.SetHisFX3IICSpeed, \
		globalFunPointer.SetHisFX3Voltage, globalFunPointer.GetHisFX3Voltage, SetHisFX3VFuseVolt, GetHisFX3VFuseVolt, GetFreshframe, \
		globalFunPointer.BatchWriteHisFX3IIC, globalFunPointer.BatchReadHisFX3IIC, SetHisFX3GPIO, GetHisFX3GPIO, globalFunPointer.PullHisFX3RESET, globalFunPointer.PullHisFX3PWND, \
		globalFunPointer.BatchReadHisFX3IICNoLimit, globalFunPointer.BatchWriteHisFX3IICNoLimit, globalFunPointer.HisFX3LogPush_back, \
		globalFunPointer.PageWriteHisFX3IIC, globalFunPointer.PageReadHisFX3IIC, globalFunPointer.HisFX3PageWriteSPI, globalFunPointer.HisFX3PageReadSPI);
	emit enableinfotimer(0);
	if(iresult){
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("写入PDAF Step2 数据失败"));
		HisReleaseNewB(pstrOutput);
		itemshareData.itemparameterLock.unlock();
		return iresult;
	}

	HisReleaseNewB(pstrOutput);
	itemshareData.itemparameterLock.unlock();
	return 0;
}


#define SONY_PDWindow8_6  0
#define SONY_PDWindow16_12 1
#define SONY_PDWindowFlexible 2

int itemprocess::SONYPDAFCheck(unsigned char  CheckMode)
{
	int iresult=0;
	QString strSerialNumber;
	classLog->getserialnumber(strSerialNumber);
	_HisCCMSONYPDAFBurn_Config stPDAFSONYConfig;
	stPDAFSONYConfig.bDebug					=		hisglobalparameter.bDebugMode;
	stPDAFSONYConfig.ucSensorSlave		=		itemshareData.previewParameter->ucSlave;
	stPDAFSONYConfig.strSerialNumber  = strSerialNumber.toAscii().data();
	stPDAFSONYConfig.strproject					=		itemshareData.ccmhardwareParameter->projectname.toAscii().data();
	stPDAFSONYConfig.strsensor					=		itemshareData.ccmhardwareParameter->sensortype.toAscii().data();
	stPDAFSONYConfig.strDriverIC				=		itemshareData.ccmhardwareParameter->motortype.toAscii().data();
	stPDAFSONYConfig.strFunctionChoose	=	itemshareData.pdafParameter->strSONYPDAFChoose.toAscii().data();
	stPDAFSONYConfig.ucEESlave				=	itemshareData.ccmhardwareParameter->ucEESlave;
	stPDAFSONYConfig.ucTpye					=	CheckMode;
	stPDAFSONYConfig.uiSPCSize				=	itemshareData.pdafParameter->usSonySPCTableSize;
	if(itemshareData.pdafParameter->ucSonyDCCWindow==SONY_PDWindow8_6)
	{
		stPDAFSONYConfig.uiDCCSize=8*6*2;
	}
	else if(itemshareData.pdafParameter->ucSonyDCCWindow==SONY_PDWindow16_12)
	{
		stPDAFSONYConfig.uiDCCSize=16*12*2;
	}

#if (defined _WIN64) && (defined _DEBUG)
	QString strLibPath	=	QDir::currentPath() % "/HisCCMOTP64D";
#elif (defined _WIN64) && !(defined _DEBUG)
	QString strLibPath	=	QDir::currentPath() % "/HisCCMOTP64";
#elif (defined _WIN32) && (defined _DEBUG)
	QString strLibPath	=	QDir::currentPath() % "/HisCCMOTP32D";
#else
	QString strLibPath	=	QDir::currentPath() % "/HisCCMOTP32";
#endif

	RolongoOTPAPIVersion getRolongoOTPAPIVersion = (RolongoOTPAPIVersion)(QLibrary::resolve(strLibPath, "getRolongoOTPAPIVersion"));
	RolongocheckSONYPDAF checkSONYPDAF = (RolongocheckSONYPDAF)(QLibrary::resolve(strLibPath, "checkSONYPDAF"));

	if(!(getRolongoOTPAPIVersion&& checkSONYPDAF)){
		emit information(tr("Resolve HisCCMOTP DLL Function Fail"));
		itemshareData.itemparameterLock.unlock();
		return HisCCMError_LoadDLLFuc;
	}

	emit enableinfotimer(1);
	iresult	=	checkSONYPDAF(*globalFunPointer.vectorHisCCMOTPInfoW, &stPDAFSONYConfig, globalFunPointer.ReadHisFX3IIC, globalFunPointer.WriteHisFX3IIC, globalFunPointer.SetHisFX3IICSpeed, \
		globalFunPointer.SetHisFX3Voltage, globalFunPointer.GetHisFX3Voltage, SetHisFX3VFuseVolt, GetHisFX3VFuseVolt, GetFreshframe, \
		globalFunPointer.BatchWriteHisFX3IIC, globalFunPointer.BatchReadHisFX3IIC, SetHisFX3GPIO, GetHisFX3GPIO, globalFunPointer.PullHisFX3RESET, globalFunPointer.PullHisFX3PWND, \
		globalFunPointer.BatchReadHisFX3IICNoLimit, globalFunPointer.BatchWriteHisFX3IICNoLimit,globalFunPointer.HisFX3LogPush_back, globalFunPointer.PageWriteHisFX3IIC, globalFunPointer.PageReadHisFX3IIC, \
		globalFunPointer.HisFX3PageWriteSPI, globalFunPointer.HisFX3PageReadSPI);
	emit enableinfotimer(0);
	if(iresult)
	{
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("检查PDAF SONY SPC 数据失败"));
		return iresult;
	}
	return iresult;
}

bool itemprocess::PhaseDifferenceCovert_IMX230(unsigned int *pSensorData,int *PD16_12, int *Coef16_12,int *PD8_6, int *Coef8_6,int PDWindowMode)
{
	bool bRes=true;
	int StartAddr=0;
	int k=0;
	for(int i=0;i<192;i+=8)
	{		
		for(int j=0;j<8;j++)
		{
			int index=StartAddr+j*4;
			Coef16_12[i+j]=(((pSensorData[index+1]&0x03)<<6)) |(pSensorData[index+2]>>2);
			PD16_12[i+j]=(((pSensorData[index+2])&0x03)<<8) |(pSensorData[index+3]);
			if(PDWindowMode==SONY_PDWindow16_12)
			{ 
				if( Coef16_12[i+j] !=0xFF)  bRes=false;
			}
			if( StartAddr%64==0 && i<(8*6*2))
			{
				Coef8_6[k]=Coef16_12[i+j]; 
				PD8_6[k]=PD16_12[i+j];
				if(PDWindowMode==SONY_PDWindow8_6)
				{ 
					if(Coef8_6[k]!=0xFF) bRes=false; 
				}
				k++;
			}
		}
		StartAddr+=32;
	}
	return bRes;
}

bool itemprocess::PhaseDifferenceCovert_IMX386(unsigned int *pSensorData,int *PD16_12, int *Coef16_12,int *PD8_6, int *Coef8_6,int PDWindowMode)
{
	bool bRes=true;
	int StartAddr=0;
	int k=0;
	for(int i=0;i<192;i+=8)
	{		
		for(int j=0;j<8;j++)
		{
			int index=StartAddr+j*4;
			Coef16_12[i+j]=(((pSensorData[index+0])<<3)) |(pSensorData[index+1]>>5);
			PD16_12[i+j]=((pSensorData[index+1]<<6)&0x07FF) |((pSensorData[index+2]>>2)&0x3F);
			if(PDWindowMode==SONY_PDWindow16_12)
			{ 
				if( Coef16_12[i+j] !=0x7FF)  bRes=false;
			}
			if( StartAddr%64==0 && i<(8*6*2))
			{
				Coef8_6[k]=Coef16_12[i+j]; 
				PD8_6[k]=PD16_12[i+j];
				if(PDWindowMode==SONY_PDWindow8_6)
				{
					if(Coef8_6[k]!=0x7FF) bRes=false;
				}
				k++;
			}
		}
		StartAddr+=32;
	}
	return bRes;
}

void   itemprocess::DCCVerify_PhaseDiffPixelCovert_IMX230(unsigned int *pSensorData,int PD_WindowIndex,  int PD_WindowMode, float &PDPixel)
{

	if(PD_WindowMode==SONY_PDWindow16_12)  //(0~~191) 
	{
		int index=PD_WindowIndex*4;
		//unsigned char Coef16_12=(((pSensorData[index+1]&0x03)<<6)) |(pSensorData[index+2]>>2);
		short PD16_12=(((pSensorData[index+2])&0x03)<<8) |(pSensorData[index+3]);
		if(PD16_12&0x0200)   PDPixel=abs((PD16_12-1024) / 16.0f);
		else   PDPixel=PD16_12/16.0f;
	}
	else if(PD_WindowMode==SONY_PDWindow8_6) // (0~~47)
	{
		int Divider=PD_WindowIndex/8;
		int index=Divider*64+PD_WindowIndex%8*4;
		short PD16_12=(((pSensorData[index+2])&0x03)<<8) |(pSensorData[index+3]);
		if(PD16_12&0x0200)   PDPixel=abs((PD16_12-1024) / 16.0f);
		else   PDPixel=PD16_12/16.0f;
	}
}

void   itemprocess::DCCVerify_PhaseDiffPixelCovert_IMX386(unsigned int *pSensorData,int PD_WindowIndex,  int PD_WindowMode, float &PDPixel)
{
	if(PD_WindowMode==SONY_PDWindow16_12)  //(0~~191) 
	{
		int index=PD_WindowIndex*4;
		//unsigned char Coef16_12=(((pSensorData[index+1]&0x03)<<6)) |(pSensorData[index+2]>>2);
		short PD16_12=((pSensorData[index+1]<<6)&0x07FF) |((pSensorData[index+2]>>2)&0x3F);
		if(PD16_12&0x0400)   PDPixel=abs((PD16_12-2048) / 16.0f);
		else   PDPixel=PD16_12/16.0f;
	}
	else if(PD_WindowMode==SONY_PDWindow8_6) // (0~~47)
	{
		int Divider=PD_WindowIndex/8;
		int index=Divider*64+PD_WindowIndex%8*4;
		short PD16_12=((pSensorData[index+1]<<6)&0x07FF) |((pSensorData[index+2]>>2)&0x3F);
		if(PD16_12&0x0400)   PDPixel=abs((PD16_12-2048) / 16.0f);
		else   PDPixel=PD16_12/16.0f;
	}
}

void  itemprocess::SavePDReadData(unsigned int iPDStartAddr,unsigned int *RegisterData, int *PDData_16_12,int *Coef_16_12,int *PDData_8_6, int *Coef_8_6, int iAFDAC,int PDMODE)
{
	QDir classDir;
	QString strSerialNumber;
	int  PDMemory=192;
	classLog->getserialnumber(strSerialNumber);
	QString strIniPath	=	QDir::currentPath() % "/SONYPDAFLog";
	classDir.mkpath(strIniPath);
	char _temp[128];
	strIniPath	=	strIniPath % "/" % strSerialNumber % "_SONY_PDAF_DCCCal_"%(QDateTime::currentDateTime()).toString("yyyyMMdd_hhmmss")%".txt";
	FILE* fileStep1	=	fopen(strIniPath.toAscii().data(), "wb");
	if(fileStep1 != NULL)
	{
		fprintf(fileStep1,"SetAFDAC:%d\r\n",iAFDAC);
		fprintf(fileStep1,"Phase difference value from sensor register read 0x8500 ~~0x87FF\r\n");
		int k=0;
		int StartAddr=iPDStartAddr;
		for(int i=0;i<PDMemory;i++)
		{
			int index=k;
			sprintf_s(_temp,128,"0x%04X,0x%02X,0x%02X,0x%02X,0x%02X",StartAddr,RegisterData[index+0],RegisterData[index+1],RegisterData[index+2],RegisterData[index+3]);
			fprintf(fileStep1,"%s\r\n",_temp);
			StartAddr+=4;
			k+=4;
		}

		if(PDMODE==SONY_PDWindow16_12)
		{
			fprintf(fileStep1,"Phase difference value & Confidence level of 16_12 PD window  mask from sensor register data transfer\r\n Confidence level\r\n" );
			for(int i=0;i<12;i++)
			{
				for(int j=0;j<16;j++)
				{
					sprintf_s(_temp,128,"%d,",Coef_16_12[i*16+j]);
					fprintf(fileStep1,"%s",_temp);
				}
				fprintf(fileStep1,"\r\n");
			}

			fprintf(fileStep1,"Phase difference value\r\n");
			for(int i=0;i<12;i++)
			{
				for(int j=0;j<16;j++)
				{
					sprintf_s(_temp,128,"%d,",PDData_16_12[i*16+j]);
					fprintf(fileStep1,"%s",_temp);
				}
				fprintf(fileStep1,"\r\n");
			}
		}
		if(PDMODE==SONY_PDWindow8_6)
		{
			fprintf(fileStep1,"Phase difference value & Confidence level of 8_6  PD window  mask from sensor register data transfer\r\nConfidence level\r\n" );
			for(int i=0;i<6;i++)
			{
				for(int j=0;j<8;j++)
				{
					sprintf_s(_temp,128,"%d,",Coef_8_6[i*8+j]);
					fprintf(fileStep1,"%s",_temp);
				}
				fprintf(fileStep1,"\r\n");
			}

			fprintf(fileStep1,"Phase difference value\r\n");
			for(int i=0;i<6;i++)
			{
				for(int j=0;j<8;j++)
				{
					sprintf_s(_temp,128,"%d,",PDData_8_6[i*8+j]);
					fprintf(fileStep1,"%s",_temp);
				}
				fprintf(fileStep1,"\r\n");
			}
		}
		fclose(fileStep1);
	}

}

int  itemprocess::SONYPDAF_DCCCal()
{
#ifdef _WIN64
	emit information(QTextCodec::codecForName( "GBK")->toUnicode("SONY PDAF 不支持64位软件") );
	return HisCCMError_NotSupportx64;
#endif

	int iresult=0;
	itemshareData.itemparameterLock.lockForRead();
	QString strSerialNumber;
	classLog->getserialnumber(strSerialNumber);
	QString strLibPath	=	QDir::currentPath() % "/pdaflib/sony";
#ifdef _WIN64
	emit information(tr("SONY PDAF DLL without x64 bit interface"));
	itemshareData.itemparameterLock.unlock();
	return HisCCMError_LoadDLLFuc;
#else
	strLibPath	=	strLibPath % "/Sony_IMX_PDAF";
#endif

	IMX230_PDAF_Window_DCC Sony_IMX230_PDAF_Window_DCC	=	(IMX230_PDAF_Window_DCC)(QLibrary::resolve(strLibPath, "Sony_IMX230_PDAF_Window_DCC"));
	IMX230_PDAF_Window_DCC_verify Sony_IMX230_PDAF_Window_DCC_verify	=	(IMX230_PDAF_Window_DCC_verify)(QLibrary::resolve(strLibPath, "Sony_IMX230_PDAF_Window_DCC_verify"));
	IMX298_PDAF_Window_DCC Sony_IMX298_PDAF_Window_DCC	=	(IMX298_PDAF_Window_DCC)(QLibrary::resolve(strLibPath, "Sony_IMX298_PDAF_Window_DCC"));
	IMX298_PDAF_Window_DCC_verify Sony_IMX298_PDAF_Window_DCC_verify	=	(IMX298_PDAF_Window_DCC_verify)(QLibrary::resolve(strLibPath, "Sony_IMX298_PDAF_Window_DCC_verify"));
	IMX386_PDAF_Window_DCC Sony_IMX386_PDAF_Window_DCC	=	(IMX386_PDAF_Window_DCC)(QLibrary::resolve(strLibPath, "Sony_IMX386_PDAF_Window_DCC"));
	IMX386_PDAF_Window_DCC_verify Sony_IMX386_PDAF_Window_DCC_verify	=	(IMX386_PDAF_Window_DCC_verify)(QLibrary::resolve(strLibPath, "Sony_IMX386_PDAF_Window_DCC_verify"));
	if(!(Sony_IMX230_PDAF_Window_DCC && Sony_IMX230_PDAF_Window_DCC_verify&&Sony_IMX298_PDAF_Window_DCC&&Sony_IMX298_PDAF_Window_DCC_verify&&Sony_IMX386_PDAF_Window_DCC&&Sony_IMX386_PDAF_Window_DCC_verify))
	{
		emit information(tr("Resolve SONY PDAF DLL Function Fail"));
		itemshareData.itemparameterLock.unlock();
		return HisCCMError_LoadDLLFuc;
	}

#if (defined _WIN64) && (defined _DEBUG)
	strLibPath	=	QDir::currentPath() % "/HisCCMOTP64D";
#elif (defined _WIN64) && !(defined _DEBUG)
	strLibPath	=	QDir::currentPath() % "/HisCCMOTP64";
#elif (defined _WIN32) && (defined _DEBUG)
	strLibPath	=	QDir::currentPath() % "/HisCCMOTP32D";
#else
	strLibPath	=	QDir::currentPath() % "/HisCCMOTP32";
#endif

	RolongoOTPAPIVersion getRolongoOTPAPIVersion = (RolongoOTPAPIVersion)(QLibrary::resolve(strLibPath, "getRolongoOTPAPIVersion"));
	Rolongocheckafmotor checkafmotor = (Rolongocheckafmotor)(QLibrary::resolve(strLibPath, "checkafmotor"));
	RolongocheckSONYPDAF checkSONYPDAF = (RolongocheckSONYPDAF)(QLibrary::resolve(strLibPath, "checkSONYPDAF"));
	RolongowriteSONYPDAF writeSONYPDAF = (RolongowriteSONYPDAF)(QLibrary::resolve(strLibPath, "writeSONYPDAF"));

	if(!(getRolongoOTPAPIVersion&&checkafmotor&& checkSONYPDAF&&writeSONYPDAF)){
		emit information(tr("Resolve HisCCMOTP DLL Function Fail"));
		itemshareData.itemparameterLock.unlock();
		return HisCCMError_LoadDLLFuc;
	}

	//Step1 Read EEPROM get AF Infinity & Macro DAC
	_HisCCMAFBurn_Config stAFConfig;
	stAFConfig.bDebug						=	hisglobalparameter.bDebugMode;
	stAFConfig.strDriverIC				=	(itemshareData.ccmhardwareParameter->motortype.toAscii()).data();
	stAFConfig.strproject					=	itemshareData.ccmhardwareParameter->projectname.toAscii().data();
	stAFConfig.strsensor					=	itemshareData.ccmhardwareParameter->sensortype.toAscii().data();
	stAFConfig.bNear						=	true;
	stAFConfig.bInfinite						=	true;
	stAFConfig.iwidth						=	itemshareData.previewParameter->iWidth;
	stAFConfig.iheight						=	itemshareData.previewParameter->iHeight;
	stAFConfig.strFunctionChoose	=	itemshareData.pdafParameter->strAFChoose.toAscii().data();
	stAFConfig.ucSlave					=	itemshareData.previewParameter->ucSlave;
	stAFConfig.uiDataFormat			=	itemshareData.previewParameter->ucDataFormat;
	stAFConfig.ucEESlave				=	itemshareData.ccmhardwareParameter->ucEESlave;
	stAFConfig.strSerialNumber		=	strSerialNumber.toAscii().data();

	int iInfiniteMotor=0,iMacroMotor=0;
	//iInfiniteMotor=495;
	//iMacroMotor=720;
	if(!threadshareData.bOfflineMode)
	{
		emit enableinfotimer(1);
		iresult	=	checkafmotor(*globalFunPointer.vectorHisCCMOTPInfoW, &stAFConfig, globalFunPointer.ReadHisFX3IIC, globalFunPointer.WriteHisFX3IIC, globalFunPointer.SetHisFX3IICSpeed, globalFunPointer.SetHisFX3Voltage, \
			globalFunPointer.GetHisFX3Voltage, SetHisFX3VFuseVolt, GetHisFX3VFuseVolt, GetFreshframe, SetHisFX3GPIO, GetHisFX3GPIO, \
			globalFunPointer.PullHisFX3RESET, globalFunPointer.PullHisFX3PWND, globalFunPointer.BatchReadHisFX3IICNoLimit, globalFunPointer.BatchWriteHisFX3IICNoLimit, \
			globalFunPointer.HisFX3LogPush_back, globalFunPointer.PageWriteHisFX3IIC, globalFunPointer.PageReadHisFX3IIC, \
			globalFunPointer.HisFX3PageWriteSPI, globalFunPointer.HisFX3PageReadSPI);
		emit enableinfotimer(0);
		if(iresult){
			itemshareData.itemparameterLock.unlock();
			return iresult;
		}

		iInfiniteMotor	=	stAFConfig.iInfinitMotor;
		iMacroMotor	=	stAFConfig.iNearMotor;

		emit information(QTextCodec::codecForName( "GBK")->toUnicode("近焦位置：") % QString::number(iMacroMotor));
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("远焦位置：") % QString::number(iInfiniteMotor));

		if(iInfiniteMotor==0xFFF || iInfiniteMotor==0x00 || iMacroMotor==0xFFF || iMacroMotor==0x00)
		{
			emit information(QTextCodec::codecForName( "GBK")->toUnicode("远/近焦不正确，不能为0XFFFF或者0x0000"));
			return HisCCMError_OtpFucExec;
		}
	}

	//2.Read  eeprom get SPC data
	_HisCCMSONYPDAFBurn_Config stPDAFSONYConfig;
	stPDAFSONYConfig.bDebug					=		hisglobalparameter.bDebugMode;
	stPDAFSONYConfig.ucSensorSlave		=		itemshareData.previewParameter->ucSlave;
	stPDAFSONYConfig.strSerialNumber  = strSerialNumber.toAscii().data();
	stPDAFSONYConfig.strproject					=		itemshareData.ccmhardwareParameter->projectname.toAscii().data();
	stPDAFSONYConfig.strsensor					=		itemshareData.ccmhardwareParameter->sensortype.toAscii().data();
	stPDAFSONYConfig.strDriverIC				=		itemshareData.ccmhardwareParameter->motortype.toAscii().data();
	stPDAFSONYConfig.strFunctionChoose	=	itemshareData.pdafParameter->strSONYPDAFChoose.toAscii().data();
	stPDAFSONYConfig.ucEESlave				=	itemshareData.ccmhardwareParameter->ucEESlave;
	stPDAFSONYConfig.ucTpye					=	1;
	stPDAFSONYConfig.uiSPCSize				=	itemshareData.pdafParameter->usSonySPCTableSize;

	emit enableinfotimer(1);
	iresult	=	checkSONYPDAF(*globalFunPointer.vectorHisCCMOTPInfoW, &stPDAFSONYConfig, globalFunPointer.ReadHisFX3IIC, globalFunPointer.WriteHisFX3IIC, globalFunPointer.SetHisFX3IICSpeed, \
		globalFunPointer.SetHisFX3Voltage, globalFunPointer.GetHisFX3Voltage, SetHisFX3VFuseVolt, GetHisFX3VFuseVolt, GetFreshframe, \
		globalFunPointer.BatchWriteHisFX3IIC, globalFunPointer.BatchReadHisFX3IIC, SetHisFX3GPIO, GetHisFX3GPIO, globalFunPointer.PullHisFX3RESET, globalFunPointer.PullHisFX3PWND, \
		globalFunPointer.BatchReadHisFX3IICNoLimit, globalFunPointer.BatchWriteHisFX3IICNoLimit,globalFunPointer.HisFX3LogPush_back, globalFunPointer.PageWriteHisFX3IIC, globalFunPointer.PageReadHisFX3IIC, \
		globalFunPointer.HisFX3PageWriteSPI, globalFunPointer.HisFX3PageReadSPI);
	emit enableinfotimer(0);
	if(iresult)
	{
		itemshareData.itemparameterLock.unlock();
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("读取PDAF SONY SPC 数据失败或者没有烧录"));
		return iresult;
	}

	//3. write spc gain to sensor register
	unsigned int uRegAddr[1024]={0};
	unsigned int uPDRegAddr[1024]={0};
	unsigned int uRegData[1024]={0};
	unsigned int uPDRegData[1024]={0};
	unsigned short uRegType[1024]={0};
	unsigned short uI2CDelay=500;
	unsigned char uSlave[1024]={0};
	int I2Count=0;
	int iReadPDI2Count=0;
	memset(uSlave,itemshareData.previewParameter->ucSlave,sizeof(unsigned char)*1024);
	for(int i=0;i<1024;i++)  {uRegType[i]=0x1608;}
	unsigned short uSPCSize=itemshareData.pdafParameter->usSonySPCTableSize;  //imx258 
	QString strPDAFSettingPath;
	if(itemshareData.pdafParameter->ucSonySensorMode==0) //IMX230
	{
		strPDAFSettingPath =	QDir::currentPath() % "/pdaftemplate/sony/" % itemshareData.ccmhardwareParameter->projectname % "/PDAFSetting_IMX230.dll";
		for(int i=0;i<uSPCSize;i++)  
		{
			uRegAddr[i]=0x7C00+i;
			uRegData[i]=stPDAFSONYConfig.uSPC[i];
		}
		iReadPDI2Count=0x87FF-0x8500+1;
		for(int i=0;i<iReadPDI2Count;i++)
		{
			uPDRegAddr[i]=0x8500+i;
		}
	}
	else if(itemshareData.pdafParameter->ucSonySensorMode==1) //IMX298
	{
		strPDAFSettingPath =	QDir::currentPath() % "/pdaftemplate/sony/" % itemshareData.ccmhardwareParameter->projectname % "/PDAFSetting_IMX298.dll";
	}
	else if(itemshareData.pdafParameter->ucSonySensorMode==3) //IMX386
	{
		strPDAFSettingPath =	QDir::currentPath() % "/pdaftemplate/sony/" % itemshareData.ccmhardwareParameter->projectname % "/PDAFSetting_IMX386.dll";
		uRegAddr[0]=0x7d4C;
		uRegData[0]=stPDAFSONYConfig.uSPC[0];
		int GainKontSize=8*6;
		for(int i=1;i<uSPCSize;i++)  
		{
			if(i==GainKontSize) { uRegAddr[i]=0x7d80;}
			else {uRegAddr[i]=uRegAddr[i-1]+1;}
			uRegData[i]=stPDAFSONYConfig.uSPC[i];
		}
		iReadPDI2Count=0x86FF-0x8400+1;
		for(int i=0;i<iReadPDI2Count;i++)
		{
			uPDRegAddr[i]=0x8400+i;
		}

	}
	iresult	=	globalFunPointer.SetHisFX3IICSpeed(400);
	if(iresult) return iresult;

	iresult=globalFunPointer.BatchWriteHisFX3IICNoLimit(uSPCSize,uSlave,uRegAddr,uRegData,uRegType,uI2CDelay);  
	if(iresult&& (!threadshareData.bOfflineMode))
	{
		itemshareData.itemparameterLock.unlock();
		emit information("Write SONY SPC gain to  sensor by  i2c command fail");   
		return iresult;
	}
	//4. Write PD Widnow & Setting 3 Rgeister to Sensor
	wchar_t wSettingName[512]={0};
	if(itemshareData.pdafParameter->ucSonyDCCWindow==SONY_PDWindow16_12) {wcscpy_s(wSettingName,512,L"PDAF_Setting3_Window16_12");}
	else if(itemshareData.pdafParameter->ucSonyDCCWindow==SONY_PDWindow8_6) {wcscpy_s(wSettingName,512,L"PDAF_Setting3_Window8_6");}
	else if(itemshareData.pdafParameter->ucSonyDCCWindow==SONY_PDWindowFlexible) {wcscpy_s(wSettingName,512,L"PDAF_Setting3_WindowFlexible");}
	iresult=ROPLOW::ParseINIFile(strPDAFSettingPath,wSettingName,uRegAddr,uRegData,I2Count);
	if(iresult) 
	{
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("无法打开文件:")%strPDAFSettingPath);   
		itemshareData.itemparameterLock.unlock();
		return iresult;
	}
	iresult=globalFunPointer.BatchWriteHisFX3IICNoLimit(I2Count,uSlave,uRegAddr,uRegData,uRegType,uI2CDelay);
	if(iresult&& (!threadshareData.bOfflineMode))
	{
		emit information("Write SONY SPC <setting 3> sensor i2c command fail");   
		itemshareData.itemparameterLock.unlock();
		return iresult;
	}
	emit information("Write SONY SPC  <setting 3>  ok");   
	//5. Write DAC from far to middle 80%  and get pahse diffrence
	SONY_PDAF_PDInfo sInfinityPDInfo, sMacroPDInfo;
	memset(&sInfinityPDInfo,0,sizeof(SONY_PDAF_PDInfo));
	memset(&sMacroPDInfo,0,sizeof(SONY_PDAF_PDInfo));
	int iLensPosINF20Percentage=iInfiniteMotor+((iMacroMotor-iInfiniteMotor)/2*0.2);
	int iLensPosMAC20Percentage=iMacroMotor-((iMacroMotor-iInfiniteMotor)/2*0.2);
	//Infinity Position
	emit information(QTextCodec::codecForName( "GBK")->toUnicode("Move Lens to from far to middle 80%:") % QString::number(iLensPosINF20Percentage));
	iresult	=	setMotor(itemshareData.ccmhardwareParameter->motortype.toAscii().data(), \
		itemshareData.previewParameter->ucSlave, itemshareData.ccmhardwareParameter->projectname.toAscii().data(), \
		iLensPosINF20Percentage, globalFunPointer.ReadHisFX3IIC, globalFunPointer.WriteHisFX3IIC, globalFunPointer.SetHisFX3IICSpeed, globalFunPointer.PullHisFX3RESET, globalFunPointer.PullHisFX3PWND, \
		globalFunPointer.PageWriteHisFX3IIC, globalFunPointer.PageReadHisFX3IIC, globalFunPointer.HisFX3PageWriteSPI, globalFunPointer.HisFX3PageReadSPI);
	Sleep(itemshareData.pdafParameter->uiMotorSleep);
	//Read PD data
	iresult=globalFunPointer.BatchReadHisFX3IICNoLimit(iReadPDI2Count,uSlave,uPDRegAddr,uPDRegData,uRegType,uI2CDelay);
	bool bresult=false;
	if(iresult)
	{
		emit information("read SONY PD phase Value by i2c command fail at from far to middle 80%");   
		itemshareData.itemparameterLock.unlock();
		return iresult;
	}
	if(itemshareData.pdafParameter->ucSonySensorMode==0) //imx230
	{
		bresult=PhaseDifferenceCovert_IMX230(uPDRegData,sInfinityPDInfo.Phase_diff_16_12,sInfinityPDInfo.Coef_16_12,sInfinityPDInfo.Phase_diff_8_6,sInfinityPDInfo.Coef_8_6,SONY_PDWindow8_6);
	}
	else if(itemshareData.pdafParameter->ucSonySensorMode==1) //imx298
	{

	}
	else if(itemshareData.pdafParameter->ucSonySensorMode==3) //imx386
	{
		bresult=PhaseDifferenceCovert_IMX386(uPDRegData,sInfinityPDInfo.Phase_diff_16_12,sInfinityPDInfo.Coef_16_12,sInfinityPDInfo.Phase_diff_8_6,sInfinityPDInfo.Coef_8_6,SONY_PDWindow8_6);
	}
	SavePDReadData(uPDRegAddr[0],uPDRegData,sInfinityPDInfo.Phase_diff_16_12,sInfinityPDInfo.Coef_16_12,sInfinityPDInfo.Phase_diff_8_6,sInfinityPDInfo.Coef_8_6,iLensPosINF20Percentage,SONY_PDWindow8_6);
	if(!bresult)
	{
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("PDAF Coef 不足."));
		itemshareData.itemparameterLock.unlock();
		return HisCCMError_SONYPDAF_DCC_COEF;
	}
	//6. Write DAC from mear to middle 80%  and get pahse diffrence
	emit information(QTextCodec::codecForName( "GBK")->toUnicode("Move Lens to from near to middle 80%:") % QString::number(iLensPosMAC20Percentage));
	iresult	=	setMotor(itemshareData.ccmhardwareParameter->motortype.toAscii().data(), \
		itemshareData.previewParameter->ucSlave, itemshareData.ccmhardwareParameter->projectname.toAscii().data(), \
		iLensPosMAC20Percentage, globalFunPointer.ReadHisFX3IIC, globalFunPointer.WriteHisFX3IIC, globalFunPointer.SetHisFX3IICSpeed, globalFunPointer.PullHisFX3RESET, globalFunPointer.PullHisFX3PWND, \
		globalFunPointer.PageWriteHisFX3IIC, globalFunPointer.PageReadHisFX3IIC, globalFunPointer.HisFX3PageWriteSPI, globalFunPointer.HisFX3PageReadSPI);
	Sleep(itemshareData.pdafParameter->uiMotorSleep);
	iresult=globalFunPointer.BatchReadHisFX3IICNoLimit(iReadPDI2Count,uSlave,uPDRegAddr,uPDRegData,uRegType,uI2CDelay);
	if(iresult)
	{
		emit information("read SONY PD phase Value by i2c command fail at from near to middle 80%");   
		itemshareData.itemparameterLock.unlock();
		return iresult;
	}
	if(itemshareData.pdafParameter->ucSonySensorMode==0) //imx230
	{
		bresult=PhaseDifferenceCovert_IMX230(uPDRegData,sMacroPDInfo.Phase_diff_16_12,sMacroPDInfo.Coef_16_12,sMacroPDInfo.Phase_diff_8_6,sMacroPDInfo.Coef_8_6,SONY_PDWindow8_6);		
	}
	else if(itemshareData.pdafParameter->ucSonySensorMode==1) //imx298
	{

	}
	else if(itemshareData.pdafParameter->ucSonySensorMode==3) //imx386
	{
		bresult=PhaseDifferenceCovert_IMX386(uPDRegData,sMacroPDInfo.Phase_diff_16_12,sMacroPDInfo.Coef_16_12,sMacroPDInfo.Phase_diff_8_6,sMacroPDInfo.Coef_8_6,SONY_PDWindow8_6);		
	}
	SavePDReadData(uPDRegAddr[0],uPDRegData,sMacroPDInfo.Phase_diff_16_12,sMacroPDInfo.Coef_16_12,sMacroPDInfo.Phase_diff_8_6,sMacroPDInfo.Coef_8_6,iLensPosMAC20Percentage,SONY_PDWindow8_6);
	if(!bresult)
	{
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("PDAF Coef 不足."));
		itemshareData.itemparameterLock.unlock();
		return HisCCMError_SONYPDAF_DCC_COEF;
	}
	//7.Calculate DCC
	SONY_PDAF_DCCRes  sDCCRes;
	memset(&sDCCRes,0,sizeof(SONY_PDAF_DCCRes));
	if(itemshareData.pdafParameter->ucSonyDCCWindow==SONY_PDWindow8_6 )
	{
		if(itemshareData.pdafParameter->ucSonySensorMode==0)
		{
			Sony_IMX230_PDAF_Window_DCC(iLensPosINF20Percentage,iLensPosMAC20Percentage,sInfinityPDInfo.Phase_diff_8_6,sMacroPDInfo.Phase_diff_8_6,8,6,sDCCRes.DCC_8_6);
			//8.Verify DCC Value;  Current VCM at 80% Macro Position
			Sony_IMX230_PDAF_Window_DCC_verify(sDCCRes.DCC_8_6,sMacroPDInfo.Phase_diff_8_6,8,6,sDCCRes.DACOut_8_6,&sDCCRes.DACCenterOut_8_6);
			stPDAFSONYConfig.uiDCCSize=8*6*2;
			for(int i=0,j=0;i<48;i++,j+=2)
			{
				stPDAFSONYConfig.uDCC[j]=(sDCCRes.DCC_8_6[i]>>8)&0x00FF;
				stPDAFSONYConfig.uDCC[j+1]=(sDCCRes.DCC_8_6[i])&0x00FF;
			}
		}
		else if(itemshareData.pdafParameter->ucSonySensorMode==3) //IMX386
		{
			Sony_IMX386_PDAF_Window_DCC(iLensPosINF20Percentage,iLensPosMAC20Percentage,sInfinityPDInfo.Phase_diff_8_6,sMacroPDInfo.Phase_diff_8_6,8,6,sDCCRes.DCC_8_6);
			//8.Verify DCC Value;  Current VCM at 80% Macro Position
			Sony_IMX386_PDAF_Window_DCC_verify(sDCCRes.DCC_8_6,sMacroPDInfo.Phase_diff_8_6,8,6,sDCCRes.DACOut_8_6,&sDCCRes.DACCenterOut_8_6);
			stPDAFSONYConfig.uiDCCSize=8*6*2;
			for(int i=0,j=0;i<48;i++,j+=2)
			{
				stPDAFSONYConfig.uDCC[j]=(sDCCRes.DCC_8_6[i]>>8)&0x00FF;
				stPDAFSONYConfig.uDCC[j+1]=(sDCCRes.DCC_8_6[i])&0x00FF;
			}
		}

	}
	else if(itemshareData.pdafParameter->ucSonyDCCWindow==SONY_PDWindow16_12 )
	{
		if( itemshareData.pdafParameter->ucSonySensorMode==0)
		{

		}
		else if(itemshareData.pdafParameter->ucSonySensorMode==1) //IMX298
		{

		}
	}
	DCCVerify sDCCVerify;
	memset(&sDCCVerify,0,sizeof(DCCVerify)); 
	//Assign DCC PD Window Index
	int iDCCVerifyWindowCnt=5;
	sDCCVerify.PDWindowIndex_16_12[0]=34;sDCCVerify.PDWindowIndex_16_12[1]=45;sDCCVerify.PDWindowIndex_16_12[2]=103;
	sDCCVerify.PDWindowIndex_16_12[3]=146;sDCCVerify.PDWindowIndex_16_12[4]=157;
	sDCCVerify.PDWindowIndex_8_6[0]=9;sDCCVerify.PDWindowIndex_8_6[1]=14;sDCCVerify.PDWindowIndex_8_6[2]=27;
	sDCCVerify.PDWindowIndex_8_6[3]=33;sDCCVerify.PDWindowIndex_8_6[4]=38;
	if(itemshareData.pdafParameter->ucSonyDCCWindow==SONY_PDWindow8_6 )
	{
		for(int i=0; i<iDCCVerifyWindowCnt;i++)
		{
			int FocusedDAC=iLensPosMAC20Percentage-sDCCRes.DACOut_8_6[sDCCVerify.PDWindowIndex_8_6[i]];
			emit information(QTextCodec::codecForName( "GBK")->toUnicode("Move lens for DCC Check set DAC:") % QString::number(FocusedDAC)%("DCC DAC Out:")%
				QString::number(sDCCRes.DACOut_8_6[sDCCVerify.PDWindowIndex_8_6[i]])%("PD Window Index:")%QString::number(sDCCVerify.PDWindowIndex_8_6[i]));
			iresult	=	setMotor(itemshareData.ccmhardwareParameter->motortype.toAscii().data(), \
				itemshareData.previewParameter->ucSlave, itemshareData.ccmhardwareParameter->projectname.toAscii().data(), \
				FocusedDAC, globalFunPointer.ReadHisFX3IIC, globalFunPointer.WriteHisFX3IIC, globalFunPointer.SetHisFX3IICSpeed, globalFunPointer.PullHisFX3RESET, globalFunPointer.PullHisFX3PWND, \
				globalFunPointer.PageWriteHisFX3IIC, globalFunPointer.PageReadHisFX3IIC, globalFunPointer.HisFX3PageWriteSPI, globalFunPointer.HisFX3PageReadSPI);
			Sleep(itemshareData.pdafParameter->uiMotorSleep);
			iresult=globalFunPointer.BatchReadHisFX3IICNoLimit(iReadPDI2Count,uSlave,uPDRegAddr,uPDRegData,uRegType,uI2CDelay);
			if(iresult)
			{
				emit information("read SONY PD phase Value by i2c command fail for DCC check step");   
				itemshareData.itemparameterLock.unlock();
				return iresult;
			}
			if(itemshareData.pdafParameter->ucSonySensorMode==0) //IMX230
			{
				DCCVerify_PhaseDiffPixelCovert_IMX230(uPDRegData,sDCCVerify.PDWindowIndex_8_6[i],SONY_PDWindow8_6,sDCCRes.InfocusdPDPixel_8_6[i]);
			}
			else if(itemshareData.pdafParameter->ucSonySensorMode==1)//IMX298
			{
				sDCCRes.InfocusdPDPixel_8_6[i]=65535.0f;
			}
			else if(itemshareData.pdafParameter->ucSonySensorMode==3)//IMX386
			{
				DCCVerify_PhaseDiffPixelCovert_IMX386(uPDRegData,sDCCVerify.PDWindowIndex_8_6[i],SONY_PDWindow8_6,sDCCRes.InfocusdPDPixel_8_6[i]);
				if(hisglobalparameter.bDebugMode)
				{
					PhaseDifferenceCovert_IMX386(uPDRegData,sMacroPDInfo.Phase_diff_16_12,sMacroPDInfo.Coef_16_12,sMacroPDInfo.Phase_diff_8_6,sMacroPDInfo.Coef_8_6,SONY_PDWindow8_6);		
					SavePDReadData(uPDRegAddr[0],uPDRegData,sMacroPDInfo.Phase_diff_16_12,sMacroPDInfo.Coef_16_12,sMacroPDInfo.Phase_diff_8_6,sMacroPDInfo.Coef_8_6,FocusedDAC,SONY_PDWindow8_6);
				}		
			}
			emit information(QTextCodec::codecForName( "GBK")->toUnicode("DCC Verify,PD Cover to Pixel:")%(QString::number(sDCCRes.InfocusdPDPixel_8_6[i],'f',3))%("PDWindow_Index:")%(QString::number(sDCCVerify.PDWindowIndex_8_6[i])));
			if(sDCCRes.InfocusdPDPixel_8_6[i]>itemshareData.pdafParameter->dDCCVerifySpec)
			{
				emit information(QTextCodec::codecForName( "GBK")->toUnicode("DCC Verify,PD Cover to Pixel over Spec:")%(QString::number(itemshareData.pdafParameter->dDCCVerifySpec,'f',3)));
				itemshareData.itemparameterLock.unlock();
				return HisCCMError_SONYPDAF_DCC_VERIFY;
			}
		}
	}
	else if(itemshareData.pdafParameter->ucSonyDCCWindow==SONY_PDWindow16_12 )
	{

	}


	stPDAFSONYConfig.bDebug					=		hisglobalparameter.bDebugMode;
	stPDAFSONYConfig.ucSensorSlave		=		itemshareData.previewParameter->ucSlave;
	stPDAFSONYConfig.strSerialNumber  = strSerialNumber.toAscii().data();
	stPDAFSONYConfig.strproject					=		itemshareData.ccmhardwareParameter->projectname.toAscii().data();
	stPDAFSONYConfig.strsensor					=		itemshareData.ccmhardwareParameter->sensortype.toAscii().data();
	stPDAFSONYConfig.strDriverIC				=		itemshareData.ccmhardwareParameter->motortype.toAscii().data();
	stPDAFSONYConfig.strFunctionChoose	=	itemshareData.pdafParameter->strSONYPDAFChoose.toAscii().data();
	stPDAFSONYConfig.ucEESlave				=	itemshareData.ccmhardwareParameter->ucEESlave;
	stPDAFSONYConfig.ucTpye					=	2;
	emit enableinfotimer(1);
	iresult	=	writeSONYPDAF(*globalFunPointer.vectorHisCCMOTPInfoW, &stPDAFSONYConfig, globalFunPointer.ReadHisFX3IIC, globalFunPointer.WriteHisFX3IIC, globalFunPointer.SetHisFX3IICSpeed, \
		globalFunPointer.SetHisFX3Voltage, globalFunPointer.GetHisFX3Voltage, SetHisFX3VFuseVolt, GetHisFX3VFuseVolt, GetFreshframe, \
		globalFunPointer.BatchWriteHisFX3IIC, globalFunPointer.BatchReadHisFX3IIC, SetHisFX3GPIO, GetHisFX3GPIO, globalFunPointer.PullHisFX3RESET, globalFunPointer.PullHisFX3PWND, \
		globalFunPointer.BatchReadHisFX3IICNoLimit, globalFunPointer.BatchWriteHisFX3IICNoLimit,globalFunPointer.HisFX3LogPush_back, globalFunPointer.PageWriteHisFX3IIC, globalFunPointer.PageReadHisFX3IIC, \
		globalFunPointer.HisFX3PageWriteSPI, globalFunPointer.HisFX3PageReadSPI);
	emit enableinfotimer(0);
	if(iresult){
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("写入SONY PDAF DCC  数据失败"));
		itemshareData.itemparameterLock.unlock();
		return iresult;
	}

	stLogItem.itemtype		=	classLog->getmaxtypeindex(_HISLOG_CLASSIFY_PDAFBURN);
	stLogItem.itemkey		=	"SONYDCC_Result";
	stLogItem.itemvalue	=	(iresult)?("NG"):("OK");
	classLog->push_back(stLogItem);
	for(int i=0;i<5;i++)
	{
		QString sFieldName="DCC_Verify_PDPixel_WindowIndex_"%QString::number(sDCCVerify.PDWindowIndex_8_6[i]);
		_CODE_LOG_PUSHBACK(sFieldName, sDCCRes.InfocusdPDPixel_8_6[i]);
	}

	itemshareData.itemparameterLock.unlock();
	return iresult;
}

int itemprocess::SONYPDAF_SPCCal()
{
#ifdef _WIN64
	emit information(QTextCodec::codecForName( "GBK")->toUnicode("SONY PDAF 不支持64位软件") );
	return HisCCMError_NotSupportx64;
#endif

	int  iresult=0;
	itemshareData.itemparameterLock.lockForRead();

	if(itemshareData.previewParameter->ucDataFormat > HisBaylor10_GBRG){
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("图像格式错误：不是BAYLOR模式"));
		itemshareData.itemparameterLock.unlock();
		return iresult;
	}

	_HisCCMSONYPDAFBurn_Config stPDAFConfig;
	QString strSerialNumber;
	classLog->getserialnumber(strSerialNumber);
	QString strLibPath	=	QDir::currentPath() % "/pdaflib/sony";
#ifdef _WIN64
	emit information(tr("SONY PDAF DLL without x64 bit interface"));
	itemshareData.itemparameterLock.unlock();
	return HisCCMError_LoadDLLFuc;
#else
	strLibPath	=	strLibPath % "/Sony_IMX_PDAF";
#endif

	IMX230_PDAF_SPC_INI Sony_IMX230_PDAF_SPC_INI	=	(IMX230_PDAF_SPC_INI)(QLibrary::resolve(strLibPath, "Sony_IMX230_PDAF_SPC_INI"));
	IMX230_PDAF_SPC_Judge_INI Sony_IMX230_PDAF_SPC_Judge_INI	=	(IMX230_PDAF_SPC_Judge_INI)(QLibrary::resolve(strLibPath, "Sony_IMX230_PDAF_SPC_Judge_INI"));
	IMX298_PDAF_SPC_INI Sony_IMX298_PDAF_SPC_INI	=	(IMX298_PDAF_SPC_INI)(QLibrary::resolve(strLibPath, "Sony_IMX298_PDAF_SPC_INI"));
	IMX298_PDAF_SPC_Judge_INI Sony_IMX298_PDAF_SPC_Judge_INI	=	(IMX298_PDAF_SPC_Judge_INI)(QLibrary::resolve(strLibPath, "Sony_IMX298_PDAF_SPC_Judge_INI"));
	IMX386_PDAF_SPC_INI Sony_IMX386_PDAF_SPC_INI	=	(IMX386_PDAF_SPC_INI)(QLibrary::resolve(strLibPath, "Sony_IMX386_PDAF_SPC_INI"));
	IMX386_PDAF_SPC_Judge_INI Sony_IMX386_PDAF_SPC_Judge_INI	=	(IMX386_PDAF_SPC_Judge_INI)(QLibrary::resolve(strLibPath, "Sony_IMX386_PDAF_SPC_Judge_INI"));
	if(!(Sony_IMX230_PDAF_SPC_INI&&Sony_IMX230_PDAF_SPC_Judge_INI&&Sony_IMX298_PDAF_SPC_INI&&Sony_IMX298_PDAF_SPC_Judge_INI&&Sony_IMX386_PDAF_SPC_INI&&Sony_IMX386_PDAF_SPC_Judge_INI))
	{
		emit information(tr("Resolve SONY PDAF DLL Function Fail"));
		itemshareData.itemparameterLock.unlock();
		return HisCCMError_LoadDLLFuc;
	}

#if (defined _WIN64) && (defined _DEBUG)
	strLibPath	=	QDir::currentPath() % "/HisCCMOTP64D";
#elif (defined _WIN64) && !(defined _DEBUG)
	strLibPath	=	QDir::currentPath() % "/HisCCMOTP64";
#elif (defined _WIN32) && (defined _DEBUG)
	strLibPath	=	QDir::currentPath() % "/HisCCMOTP32D";
#else
	strLibPath	=	QDir::currentPath() % "/HisCCMOTP32";
#endif

	RolongoOTPAPIVersion getRolongoOTPAPIVersion = (RolongoOTPAPIVersion)(QLibrary::resolve(strLibPath, "getRolongoOTPAPIVersion"));
	Rolongocheckafmotor checkafmotor = (Rolongocheckafmotor)(QLibrary::resolve(strLibPath, "checkafmotor"));
	RolongocheckSONYPDAF checkSONYPDAF = (RolongocheckSONYPDAF)(QLibrary::resolve(strLibPath, "checkSONYPDAF"));
	RolongowriteSONYPDAF writeSONYPDAF = (RolongowriteSONYPDAF)(QLibrary::resolve(strLibPath, "writeSONYPDAF"));

	if(!(getRolongoOTPAPIVersion&&checkafmotor&& checkSONYPDAF&&writeSONYPDAF)){
		emit information(tr("Resolve HisCCMOTP DLL Function Fail"));
		itemshareData.itemparameterLock.unlock();
		return HisCCMError_LoadDLLFuc;
	}

	unsigned int uRegAddr[1024]={0};
	unsigned int uRegData[1024]={0};
	unsigned short uRegType[1024]={0};
	unsigned short uI2CDelay=5000;
	unsigned char uSlave[1024]={0};
	int iI2CCount=0;
	memset(uSlave,itemshareData.previewParameter->ucSlave,sizeof(unsigned char)*1024);
	memset(uRegType,0x1608,sizeof(unsigned short)*1024);
	for(int i=0;i<1024;i++)
	{uRegType[i]=0x1608;}
	iresult	=	globalFunPointer.SetHisFX3IICSpeed(400);
	if(iresult) return iresult;
	QString strIniPath;
	QString strPDAFSettingPath;
	if(itemshareData.pdafParameter->ucSonySensorMode==0)
	{	
		strIniPath =	QDir::currentPath() % "/pdaftemplate/sony/" % itemshareData.ccmhardwareParameter->projectname % "/imx230_pdaf.ini";
		strPDAFSettingPath =	QDir::currentPath() % "/pdaftemplate/sony/" % itemshareData.ccmhardwareParameter->projectname % "/PDAFSetting_IMX230.dll";
	}
	else if(itemshareData.pdafParameter->ucSonySensorMode==1)
	{ 	
		strIniPath =	QDir::currentPath() % "/pdaftemplate/sony/" % itemshareData.ccmhardwareParameter->projectname % "/imx298_pdaf.ini";
		strPDAFSettingPath =	QDir::currentPath() % "/pdaftemplate/sony/" % itemshareData.ccmhardwareParameter->projectname % "/PDAFSetting_IMX298.dll";
	}
	else if(itemshareData.pdafParameter->ucSonySensorMode==3)
	{ 	
		strIniPath =	QDir::currentPath() % "/pdaftemplate/sony/" % itemshareData.ccmhardwareParameter->projectname % "/imx386_pdaf.ini";
		strPDAFSettingPath =	QDir::currentPath() % "/pdaftemplate/sony/" % itemshareData.ccmhardwareParameter->projectname % "/PDAFSetting_IMX386.dll";
	}

	emit information(tr("sony spc gain calibration ini file: ") % strIniPath);
	if(!QFile::exists(strIniPath))
	{
		emit information(tr("File not exist: ") % strIniPath);
		itemshareData.itemparameterLock.unlock();
		return HisCCMError_FilePath;
	}
	if( !QFile::exists(strPDAFSettingPath))
	{
		emit information(tr("File not exist: ") % strPDAFSettingPath);
		itemshareData.itemparameterLock.unlock();
		return HisCCMError_FilePath;
	}
	//1. Write SPC Cal "setting 1" to sensor
	iresult=ROPLOW::ParseINIFile(strPDAFSettingPath,L"[PDAF_Setting1]",uRegAddr,uRegData,iI2CCount);
	if(iresult) 
	{
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("无法打开文件:")%strPDAFSettingPath);   
		itemshareData.itemparameterLock.unlock();
		return iresult;
	}
	iresult=globalFunPointer.BatchWriteHisFX3IICNoLimit(iI2CCount,uSlave,uRegAddr,uRegData,uRegType,uI2CDelay);
	Sleep(itemshareData.pdafParameter->uiMotorSleep);
	if(iresult&& (!threadshareData.bOfflineMode))
	{
		emit information("Write SONY SPC <setting 1> sensor i2c command fail");   
		itemshareData.itemparameterLock.unlock();
		return iresult;
	}
	emit information("Write SONY SPC  <setting 1>  ok");   
	//3. Capture RAW10
	unsigned int uiPixel	=	itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight *2;
	unsigned short* pusRaw10	=	(unsigned short*)_aligned_malloc(uiPixel, _HisCacheLine_Aligned);
	if(!pusRaw10 ){
		HisReleaseMalloc(pusRaw10);
		itemshareData.itemparameterLock.unlock();
		return HisFX3Error_MallocBuffer;
	}
	iresult	=	GetFreshframe((unsigned char*)(pusRaw10), uiPixel, _FrameType_Raw10, true);
	if(iresult){
		HisReleaseMalloc(pusRaw10);
		itemshareData.itemparameterLock.unlock();
		return iresult;
	}
	QDir classDir;
	if(hisglobalparameter.bDebugMode)
	{	
		QString strImagePath	=	QDir::currentPath() % "/SONYSPCImage";
		classDir.mkpath(strImagePath);
		ROPLOW::saveRaw10(strImagePath, strSerialNumber % "_SONY_"%itemshareData.ccmhardwareParameter->projectname%"_SPCCal_"%(QDateTime::currentDateTime()).toString("yyyyMMdd_hhmmss"), itemshareData.previewParameter->ucDataFormat, \
			itemshareData.previewParameter->iWidth, itemshareData.previewParameter->iHeight, (void*)(pusRaw10));
	}
	// 4. SPC call
	short pSPCData[512]={0};
	if(itemshareData.pdafParameter->ucSonySensorMode==0) //imx230
	{
		iresult=Sony_IMX230_PDAF_SPC_INI(strIniPath.toLatin1().data(),(short*)pusRaw10,pSPCData);
	}
	else if(itemshareData.pdafParameter->ucSonySensorMode==1) //imx298
	{
		iresult=Sony_IMX298_PDAF_SPC_INI(strIniPath.toLatin1().data(),(short*)pusRaw10,pSPCData);
	}
	else if(itemshareData.pdafParameter->ucSonySensorMode==3) //imx386
	{
		iresult=Sony_IMX386_PDAF_SPC_INI(strIniPath.toLatin1().data(),(short*)pusRaw10,pSPCData);
	}
	if(iresult!=TRUE)
	{
		HisReleaseMalloc(pusRaw10);
		itemshareData.itemparameterLock.unlock();
		return HisCCMError_SONYPDAF_SPC;
	}
	// SPC verify 
	//5.   write spc gain to sensor by I2C 
	unsigned short uSPCSizefromAPI=11*8*2;  
	uRegType[0]=0x1608;
	if(itemshareData.pdafParameter->ucSonySensorMode==0)  //IMX230
	{
		//     IMX230 SPC gain API output format pSPCData[0]=0x0969; pSPCData[1]=0x07db
		//    sensor.register(0x7c00, 0, 8) = 0x09
		//	sensor.register(0x7c01, 0, 8) = 0x69
		//	sensor.register(0x7c02, 0, 8) = 0x07
		//	sensor.register(0x7c03, 0, 8) = 0xdb
		uSPCSizefromAPI=11*8*2;  //imx230
		stPDAFConfig.uiSPCSize=	uSPCSizefromAPI*2;  //
		for(int i=0,j=0;i<uSPCSizefromAPI;i++,j+=2)  
		{
			uRegAddr[j]=0x7C00+j;
			uRegAddr[j+1]=0x7C00+j+1;
			stPDAFConfig.uSPC[j]=uRegData[j]=(pSPCData[i]>>8)&0x00FF;
			stPDAFConfig.uSPC[j+1]=uRegData[j+1]=(pSPCData[i])&0x00FF;
			uRegType[j]=0x1608;uRegType[j+1]=0x1608;
		}
	}
	else if(itemshareData.pdafParameter->ucSonySensorMode==1)   //IMX298
	{
		uSPCSizefromAPI=9*7*2; 
		uRegAddr[0]=0x7e00;  
	}
	else if(itemshareData.pdafParameter->ucSonySensorMode==3)   //IMX386
	{
		uSPCSizefromAPI=8*6*2;  //Imx386
		int GainKontSize=8*6;
		stPDAFConfig.uiSPCSize=	uSPCSizefromAPI;  
		uRegAddr[0]=0x7d4C;
		stPDAFConfig.uSPC[0]=uRegData[0]=(pSPCData[0])&0x00FF;
		for(int i=1;i<uSPCSizefromAPI;i++)  
		{
			if(i==GainKontSize) { uRegAddr[i]=0x7d80;}
			else {uRegAddr[i]=uRegAddr[i-1]+1;}
			stPDAFConfig.uSPC[i]=uRegData[i]=(pSPCData[i])&0x00FF;
		}
	}
	iresult=globalFunPointer.BatchWriteHisFX3IICNoLimit(stPDAFConfig.uiSPCSize,uSlave,uRegAddr,uRegData,uRegType,500);
	if(iresult&& (!threadshareData.bOfflineMode))
	{
		emit information("Write SONY SPC gain to  sensor by  i2c command fail");   
		HisReleaseMalloc(pusRaw10);
		itemshareData.itemparameterLock.unlock();
		return iresult;
	}
	//6.   write spc verify  "setting2" to sensor by I2C 
	iresult=ROPLOW::ParseINIFile(strPDAFSettingPath,L"[PDAF_Setting2]",uRegAddr,uRegData,iI2CCount);
	if(iresult) 
	{
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("无法打开文件:")%strPDAFSettingPath);  
		itemshareData.itemparameterLock.unlock();
		HisReleaseMalloc(pusRaw10);
		return iresult;
	}
	iresult=globalFunPointer.BatchWriteHisFX3IICNoLimit(iI2CCount,uSlave,uRegAddr,uRegData,uRegType,uI2CDelay);
	if(iresult&& (!threadshareData.bOfflineMode))
	{
		emit information("Write SONY SPC <setting 2> sensor i2c command fail");   
		itemshareData.itemparameterLock.unlock();
		HisReleaseMalloc(pusRaw10);
		return iresult;
	}
	emit information("Write SONY SPC  <setting 2>  ok");  
	Sleep(itemshareData.pdafParameter->uiMotorSleep);
	//7.   Capture RAW10
	iresult	=	GetFreshframe((unsigned char*)(pusRaw10), uiPixel, _FrameType_Raw10, true);
	if(iresult){
		HisReleaseMalloc(pusRaw10);
		itemshareData.itemparameterLock.unlock();
		return iresult;
	}
	if(hisglobalparameter.bDebugMode)
	{	
		QString strImagePath	=	QDir::currentPath() % "/SONYSPCImage";
		classDir.mkpath(strImagePath);
		ROPLOW::saveRaw10(strImagePath, strSerialNumber % "_SONY_" %itemshareData.ccmhardwareParameter->projectname%"_SPCVerify_" %(QDateTime::currentDateTime()).toString("yyyyMMdd_hhmmss"), itemshareData.previewParameter->ucDataFormat, \
			itemshareData.previewParameter->iWidth, itemshareData.previewParameter->iHeight, (void*)(pusRaw10));
	}
	//8.   Call SONY SPC verify tool
	int pSPCVerifyData[512]={0};
	if(itemshareData.pdafParameter->ucSonySensorMode==0)
	{
		iresult	=Sony_IMX230_PDAF_SPC_Judge_INI(strIniPath.toLatin1().data(),(short*)pusRaw10,pSPCVerifyData);
	}
	else if(itemshareData.pdafParameter->ucSonySensorMode==1)
	{
		iresult	=Sony_IMX298_PDAF_SPC_Judge_INI(strIniPath.toLatin1().data(),(short*)pusRaw10,pSPCVerifyData);
	}
	else if(itemshareData.pdafParameter->ucSonySensorMode==3)
	{
		iresult	=Sony_IMX386_PDAF_SPC_Judge_INI(strIniPath.toLatin1().data(),(short*)pusRaw10,pSPCVerifyData);
	}

	if( (!iresult)|| (!pSPCVerifyData[0]) || (!pSPCVerifyData[1]))  
	{
		HisReleaseMalloc(pusRaw10);
		itemshareData.itemparameterLock.unlock();
		return HisCCMError_SONYPDAF_SPC;
	}
	HisReleaseMalloc(pusRaw10);
	//9.  write to eeprom
	if(threadshareData.bOfflineMode) { itemshareData.itemparameterLock.unlock();	return 0;  }


	stPDAFConfig.bDebug					=		hisglobalparameter.bDebugMode;
	stPDAFConfig.ucSensorSlave		=		itemshareData.previewParameter->ucSlave;
	stPDAFConfig.strSerialNumber  = strSerialNumber.toAscii().data();
	stPDAFConfig.strproject					=		itemshareData.ccmhardwareParameter->projectname.toAscii().data();
	stPDAFConfig.strsensor					=		itemshareData.ccmhardwareParameter->sensortype.toAscii().data();
	stPDAFConfig.strDriverIC				=		itemshareData.ccmhardwareParameter->motortype.toAscii().data();
	stPDAFConfig.strFunctionChoose	=	itemshareData.pdafParameter->strSONYPDAFChoose.toAscii().data();
	stPDAFConfig.ucEESlave				=	itemshareData.ccmhardwareParameter->ucEESlave;
	stPDAFConfig.ucTpye					=	1;


	emit enableinfotimer(1);
	iresult	=	writeSONYPDAF(*globalFunPointer.vectorHisCCMOTPInfoW, &stPDAFConfig, globalFunPointer.ReadHisFX3IIC, globalFunPointer.WriteHisFX3IIC, globalFunPointer.SetHisFX3IICSpeed, \
		globalFunPointer.SetHisFX3Voltage, globalFunPointer.GetHisFX3Voltage, SetHisFX3VFuseVolt, GetHisFX3VFuseVolt, GetFreshframe, \
		globalFunPointer.BatchWriteHisFX3IIC, globalFunPointer.BatchReadHisFX3IIC, SetHisFX3GPIO, GetHisFX3GPIO, globalFunPointer.PullHisFX3RESET, globalFunPointer.PullHisFX3PWND, \
		globalFunPointer.BatchReadHisFX3IICNoLimit, globalFunPointer.BatchWriteHisFX3IICNoLimit,globalFunPointer.HisFX3LogPush_back, globalFunPointer.PageWriteHisFX3IIC, globalFunPointer.PageReadHisFX3IIC, \
		globalFunPointer.HisFX3PageWriteSPI, globalFunPointer.HisFX3PageReadSPI);
	emit enableinfotimer(0);
	if(iresult){
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("写入SONY PDAF SPC 数据失败"));
		itemshareData.itemparameterLock.unlock();
		return iresult;
	}
	itemshareData.itemparameterLock.unlock();
	return iresult;
}

int itemprocess::SONYIMX258PDAF_SPCCal()
{
	if(!classPlatform.HisFX3isstart()) return HisFX3Error_IsNotPreview;
	unsigned char ucApplication	=	0x0;
	int iresult =0;
	iresult= classPlatform.HisFX3GetLInfo(NULL, &ucApplication, NULL, NULL, NULL, NULL);
	if(iresult) return iresult;
#if (defined PDAF_LICENSE_ONLY_AUTHORIZE)
	if(ucApplication != 0x2){
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("此主板没有操作PDAF的授权"));
		return HisFX3Error_License;
	}
#endif

	if(iresult	=	getccmhardwareParameter(false))	return iresult;
	if(iresult		=	getpdafParameter(false))	return iresult;

	itemshareData.itemparameterLock.lockForRead();
	if(itemshareData.previewParameter->ucDataFormat > HisBaylor10_GBRG){
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("图像格式错误：不是BAYLOR模式"));
		itemshareData.itemparameterLock.unlock();
		return iresult;
	}

	_HisCCMSONYPDAFBurn_Config stPDAFConfig;
	QString strSerialNumber;
	classLog->getserialnumber(strSerialNumber);
	QString strLibPath	=	QDir::currentPath() % "/pdaflib/sony";
#ifdef _WIN64
	emit information(tr("SONY PDAF DLL without x64 bit interface"));
	itemshareData.itemparameterLock.unlock();
	return HisCCMError_LoadDLLFuc;
#else
	strLibPath	=	strLibPath % "/Sony_IMX_PDAF";
#endif

	IMX258_PDAF_SPC_INI Sony_IMX258_PDAF_SPC_INI	=	(IMX258_PDAF_SPC_INI)(QLibrary::resolve(strLibPath, "Sony_IMX258_PDAF_SPC_INI"));
	IMX258_PDAF_SPC_Judge_INI Sony_IMX258_PDAF_SPC_Judge_INI	=	(IMX258_PDAF_SPC_Judge_INI)(QLibrary::resolve(strLibPath, "Sony_IMX258_PDAF_SPC_Judge_INI"));

	if(!(Sony_IMX258_PDAF_SPC_INI && Sony_IMX258_PDAF_SPC_Judge_INI )){
		emit information(tr("Resolve SONY PDAF DLL Function Fail"));
		itemshareData.itemparameterLock.unlock();
		return HisCCMError_LoadDLLFuc;
	}

#if (defined _WIN64) && (defined _DEBUG)
	strLibPath	=	QDir::currentPath() % "/HisCCMOTP64D";
#elif (defined _WIN64) && !(defined _DEBUG)
	strLibPath	=	QDir::currentPath() % "/HisCCMOTP64";
#elif (defined _WIN32) && (defined _DEBUG)
	strLibPath	=	QDir::currentPath() % "/HisCCMOTP32D";
#else
	strLibPath	=	QDir::currentPath() % "/HisCCMOTP32";
#endif

	RolongoOTPAPIVersion getRolongoOTPAPIVersion = (RolongoOTPAPIVersion)(QLibrary::resolve(strLibPath, "getRolongoOTPAPIVersion"));
	RolongowriteSONYPDAF writeSONYPDAF = (RolongowriteSONYPDAF)(QLibrary::resolve(strLibPath, "writeSONYPDAF"));

	if(!(getRolongoOTPAPIVersion&&writeSONYPDAF)){
		emit information(tr("Resolve HisCCMOTP DLL Function Fail"));
		itemshareData.itemparameterLock.unlock();
		return HisCCMError_LoadDLLFuc;
	}

	unsigned int uRegAddr[1024]={0};
	unsigned int uRegData[1024]={0};
	unsigned short uRegType[1024]={0};
	unsigned short uI2CDelay=5000;
	unsigned char uSlave[1024]={0};
	int iI2CCount=0;
	memset(uSlave,itemshareData.previewParameter->ucSlave,sizeof(unsigned char)*1024);
	iresult	=	globalFunPointer.SetHisFX3IICSpeed(400);
	if(iresult) return iresult;
	//1.get sensor spec  version from OTP and select calibration file for SPC
	emit information(QTextCodec::codecForName( "GBK")->toUnicode("读取 <Sensor SPEC version> expresses about shield pixel assignment") );
	uRegAddr[0]=0x0A02; uRegData[0]=0x0F; uRegType[0]=0x1608;
	uRegAddr[1]=0x0A00; uRegData[1]=0x01; uRegType[1]=0x1608;
	uRegAddr[2]=0x0A01; uRegData[2]=0x00; uRegType[2]=0x1608;
	uRegAddr[3]=0x0A2E; uRegData[3]=0xFF; uRegType[3]=0x1608;
	iresult=globalFunPointer.BatchWriteHisFX3IICNoLimit(1,uSlave,uRegAddr,uRegData,uRegType,uI2CDelay);
	iresult=globalFunPointer.BatchWriteHisFX3IICNoLimit(1,uSlave,uRegAddr+1,uRegData+1,uRegType,uI2CDelay);
	if(iresult && (!threadshareData.bOfflineMode))
	{
		emit information("Write I2C sensor command fail");   
		itemshareData.itemparameterLock.unlock();
		return iresult;
	}
	int icheckcounts=0;
	do 
	{
		icheckcounts++;
		iresult=globalFunPointer.BatchReadHisFX3IICNoLimit(2,uSlave,uRegAddr+2,uRegData+2,uRegType+2,uI2CDelay);
		if(iresult)
		{
			if(!threadshareData.bOfflineMode)
			{ emit information("read I2C sensor command fail");    itemshareData.itemparameterLock.unlock(); return iresult;}
			else {uRegData[2]=0x01;uRegData[3]=0x00;}
		}
		Sleep(50);
		if(icheckcounts==20) {emit information("read otp fail and already try 50 counts");    itemshareData.itemparameterLock.unlock();  return HisCCMError_readIIC;}
	} while(uRegData[2]==0x00);
	QString strIniPath;
	if(uRegData[3]==0x00)
	{	strIniPath =	QDir::currentPath() % "/pdaftemplate/sony/" % itemshareData.ccmhardwareParameter->projectname % "/spc_gain_258_NML.ini";}
	else if(uRegData[3]==0x10)
	{ 	strIniPath =	QDir::currentPath() % "/pdaftemplate/sony/" % itemshareData.ccmhardwareParameter->projectname % "/spc_gain_258_FD.ini";}
	else if(uRegData[3]==0x40)
	{ strIniPath =	QDir::currentPath() % "/pdaftemplate/sony/" % itemshareData.ccmhardwareParameter->projectname % "/spc_gain_258_HDD.ini";}
	else 
	{
		emit information(tr("sensor spec version is error , readout data:0x")%QString::number(uRegData[3],16)%tr(",readout data must be 0x00/0x10/0x40"));
		itemshareData.itemparameterLock.unlock();
		return HisCCMError_readIIC;
	}
	emit information(tr("sony spc gain calibration ini file: ") % strIniPath);
	if(!QFile::exists(strIniPath)){
		emit information(tr("File not exist: ") % strIniPath);
		itemshareData.itemparameterLock.unlock();
		return HisCCMError_FilePath;
	}
	//2. Write SPC Cal "setting 1" to sensor
	uRegAddr[0]=0x0B00; uRegData[0]=0x00; uRegType[0]=0x1608;
	uRegAddr[1]=0x3051; uRegData[1]=0x00; uRegType[1]=0x1608;
	uRegAddr[2]=0x3052 ; uRegData[2]=0x00; uRegType[2]=0x1608;
	uRegAddr[3]=0x7BCA; uRegData[3]=0x00; uRegType[3]=0x1608;
	uRegAddr[4]=0x7BCB; uRegData[4]=0x00; uRegType[4]=0x1608;
	uRegAddr[5]=0x7BC8; uRegData[5]=0x00; uRegType[5]=0x1608;
	iresult=globalFunPointer.BatchWriteHisFX3IICNoLimit(6,uSlave,uRegAddr,uRegData,uRegType,uI2CDelay);
	// iresult=BatchWriteHisFX3IICNoLimit(1,uSlave,uRegAddr+1,uRegData+1,uRegType+1,uI2CDelay);
	//iresult=BatchWriteHisFX3IICNoLimit(1,uSlave,uRegAddr+2,uRegData+2,uRegType+2,uI2CDelay);
	//iresult=BatchWriteHisFX3IICNoLimit(1,uSlave,uRegAddr+3,uRegData+3,uRegType+3,uI2CDelay);
	// iresult=BatchWriteHisFX3IICNoLimit(1,uSlave,uRegAddr+4,uRegData+4,uRegType+4,uI2CDelay);
	//iresult=BatchWriteHisFX3IICNoLimit(1,uSlave,uRegAddr+5,uRegData+5,uRegType+5,uI2CDelay);
	if(iresult&& (!threadshareData.bOfflineMode))
	{
		emit information("Write SONY SPC <setting 1> sensor i2c command fail");   
		itemshareData.itemparameterLock.unlock();
		return iresult;
	}
	emit information("Write SONY SPC  <setting 1>  ok");   
	//3. Capture RAW10
	unsigned int uiPixel	=	itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight *2;
	unsigned short* pusRaw10	=	(unsigned short*)_aligned_malloc(uiPixel, _HisCacheLine_Aligned);
	if(!pusRaw10 ){
		HisReleaseMalloc(pusRaw10);
		itemshareData.itemparameterLock.unlock();
		return HisFX3Error_MallocBuffer;
	}
	Sleep(1000);
	iresult	=	GetFreshframe((unsigned char*)(pusRaw10), uiPixel, _FrameType_Raw10, true);
	if(iresult){
		HisReleaseMalloc(pusRaw10);
		itemshareData.itemparameterLock.unlock();
		return iresult;
	}
	QDir classDir;
	if(hisglobalparameter.bDebugMode)
	{	
		QString strImagePath	=	QDir::currentPath() % "/SONYSPCImage";
		classDir.mkpath(strImagePath);
		ROPLOW::saveRaw10(strImagePath, strSerialNumber % "_SONY_"%itemshareData.ccmhardwareParameter->projectname%"_SPCCal_"%(QDateTime::currentDateTime()).toString("yyyyMMdd_hhmmss"), itemshareData.previewParameter->ucDataFormat, \
			itemshareData.previewParameter->iWidth, itemshareData.previewParameter->iHeight, (void*)(pusRaw10));
	}
	// 4. SPC call
	short pSPCData[512]={0};
	iresult=Sony_IMX258_PDAF_SPC_INI(strIniPath.toLatin1().data(),(short*)pusRaw10,pSPCData);
	if(iresult!=TRUE)
	{
		HisReleaseMalloc(pusRaw10);
		itemshareData.itemparameterLock.unlock();
		return HisCCMError_SONYPDAF_SPC;
	}
	// SPC verify 
	//5.   write spc gain to sensor by I2C 
	unsigned short uSPCSize=9*7*2;  //imx258 
	unsigned short uLeftGainSize=9*7;
	uRegAddr[0]=0xd04c;
	stPDAFConfig.uSPC[0]= uRegData[0]=pSPCData[0];
	uRegType[0]=0x1608;
	for(int i=1;i<uSPCSize;i++)  // Left  & Right gain
	{
		uRegAddr[i]=uRegAddr[i-1]+1;
		if(i==uLeftGainSize)  uRegAddr[i]+=1;
		stPDAFConfig.uSPC[i]=uRegData[i]=pSPCData[i];
		uRegType[i]=0x1608;
	}
	iresult=globalFunPointer.BatchWriteHisFX3IICNoLimit(uSPCSize,uSlave,uRegAddr,uRegData,uRegType,uI2CDelay);
	if(iresult&& (!threadshareData.bOfflineMode))
	{
		emit information("Write SONY SPC gain to  sensor by  i2c command fail");   
		HisReleaseMalloc(pusRaw10);
		itemshareData.itemparameterLock.unlock();
		return iresult;
	}
	//6.   write spc verify  "setting2" to sensor by I2C 
	uRegAddr[0]=0x0B00; uRegData[0]=0x00; uRegType[0]=0x1608;
	uRegAddr[1]=0x3051; uRegData[1]=0x00; uRegType[1]=0x1608;
	uRegAddr[2]=0x3052 ; uRegData[2]=0x00; uRegType[2]=0x1608;
	uRegAddr[3]=0x7BCA; uRegData[3]=0x00; uRegType[3]=0x1608;
	uRegAddr[4]=0x7BCB; uRegData[4]=0x00; uRegType[4]=0x1608;
	uRegAddr[5]=0x7BC8; uRegData[5]=0x01; uRegType[5]=0x1608;
	iresult=globalFunPointer.BatchWriteHisFX3IICNoLimit(6,uSlave,uRegAddr,uRegData,uRegType,uI2CDelay);
	// iresult=BatchWriteHisFX3IICNoLimit(1,uSlave,uRegAddr+1,uRegData+1,uRegType,uI2CDelay);
	// iresult=BatchWriteHisFX3IICNoLimit(1,uSlave,uRegAddr+2,uRegData+2,uRegType,uI2CDelay);
	//iresult=BatchWriteHisFX3IICNoLimit(1,uSlave,uRegAddr+3,uRegData+3,uRegType,uI2CDelay);
	// iresult=BatchWriteHisFX3IICNoLimit(1,uSlave,uRegAddr+4,uRegData+4,uRegType,uI2CDelay);
	// iresult=BatchWriteHisFX3IICNoLimit(1,uSlave,uRegAddr+5,uRegData+5,uRegType,uI2CDelay);
	if(iresult&& (!threadshareData.bOfflineMode))
	{
		emit information("Write SONY SPC <setting 2> sensor i2c command fail");   
		itemshareData.itemparameterLock.unlock();
		return iresult;
	}
	emit information("Write SONY SPC  <setting 2>  ok");  
	Sleep(1000);
	//7.   Capture RAW10
	iresult	=	GetFreshframe((unsigned char*)(pusRaw10), uiPixel, _FrameType_Raw10, true);
	if(iresult){
		HisReleaseMalloc(pusRaw10);
		itemshareData.itemparameterLock.unlock();
		return iresult;
	}
	if(hisglobalparameter.bDebugMode)
	{	
		QString strImagePath	=	QDir::currentPath() % "/SONYSPCImage";
		classDir.mkpath(strImagePath);
		ROPLOW::saveRaw10(strImagePath, strSerialNumber % "_SONY_" %itemshareData.ccmhardwareParameter->projectname%"_SPCVerify_" %(QDateTime::currentDateTime()).toString("yyyyMMdd_hhmmss"), itemshareData.previewParameter->ucDataFormat, \
			itemshareData.previewParameter->iWidth, itemshareData.previewParameter->iHeight, (void*)(pusRaw10));
	}
	//8.   Call SONY SPC verify tool
	int pSPCVerifyData[512]={0};
	iresult	=Sony_IMX258_PDAF_SPC_Judge_INI(strIniPath.toLatin1().data(),(short*)pusRaw10,pSPCVerifyData);
	if( (!iresult)|| (!pSPCVerifyData[0]) || (!pSPCVerifyData[1]))  //imx258
	{
		HisReleaseMalloc(pusRaw10);
		itemshareData.itemparameterLock.unlock();
		return HisCCMError_SONYPDAF_SPC;
	}
	HisReleaseMalloc(pusRaw10);
	//9.  write to eeprom
	if(threadshareData.bOfflineMode) { itemshareData.itemparameterLock.unlock();	return 0;  }


	stPDAFConfig.bDebug					=		hisglobalparameter.bDebugMode;
	stPDAFConfig.ucSensorSlave		=		itemshareData.previewParameter->ucSlave;
	stPDAFConfig.strSerialNumber  = strSerialNumber.toAscii().data();
	stPDAFConfig.strproject					=		itemshareData.ccmhardwareParameter->projectname.toAscii().data();
	stPDAFConfig.strsensor					=		itemshareData.ccmhardwareParameter->sensortype.toAscii().data();
	stPDAFConfig.strDriverIC				=		itemshareData.ccmhardwareParameter->motortype.toAscii().data();
	stPDAFConfig.strFunctionChoose	=	itemshareData.pdafParameter->strSONYPDAFChoose.toAscii().data();
	stPDAFConfig.ucEESlave				=	itemshareData.ccmhardwareParameter->ucEESlave;
	stPDAFConfig.ucTpye					=	1;
	stPDAFConfig.uiSPCSize				=	uSPCSize;

	emit enableinfotimer(1);
	iresult	=	writeSONYPDAF(*globalFunPointer.vectorHisCCMOTPInfoW, &stPDAFConfig, globalFunPointer.ReadHisFX3IIC, globalFunPointer.WriteHisFX3IIC, globalFunPointer.SetHisFX3IICSpeed, \
		globalFunPointer.SetHisFX3Voltage, globalFunPointer.GetHisFX3Voltage, SetHisFX3VFuseVolt, GetHisFX3VFuseVolt, GetFreshframe, \
		globalFunPointer.BatchWriteHisFX3IIC, globalFunPointer.BatchReadHisFX3IIC, SetHisFX3GPIO, GetHisFX3GPIO, globalFunPointer.PullHisFX3RESET, globalFunPointer.PullHisFX3PWND, \
		globalFunPointer.BatchReadHisFX3IICNoLimit, globalFunPointer.BatchWriteHisFX3IICNoLimit,globalFunPointer.HisFX3LogPush_back, globalFunPointer.PageWriteHisFX3IIC, globalFunPointer.PageReadHisFX3IIC, \
		globalFunPointer.HisFX3PageWriteSPI, globalFunPointer.HisFX3PageReadSPI);
	emit enableinfotimer(0);
	if(iresult){
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("写入SONY PDAF SPC 数据失败"));
		itemshareData.itemparameterLock.unlock();
		return iresult;
	}
	return iresult;
}

int itemprocess::ApplySONYIMX258SPC()
{
	int iresult=0;
	QString strSerialNumber;
	classLog->getserialnumber(strSerialNumber);

#if (defined _WIN64) && (defined _DEBUG)
	QString strLibPath	=	QDir::currentPath() % "/HisCCMOTP64D";
#elif (defined _WIN64) && !(defined _DEBUG)
	QString strLibPath	=	QDir::currentPath() % "/HisCCMOTP64";
#elif (defined _WIN32) && (defined _DEBUG)
	QString strLibPath	=	QDir::currentPath() % "/HisCCMOTP32D";
#else
	QString strLibPath	=	QDir::currentPath() % "/HisCCMOTP32";
#endif

	RolongoOTPAPIVersion getRolongoOTPAPIVersion = (RolongoOTPAPIVersion)(QLibrary::resolve(strLibPath, "getRolongoOTPAPIVersion"));
	RolongocheckSONYPDAF checkSONYPDAF = (RolongocheckSONYPDAF)(QLibrary::resolve(strLibPath, "checkSONYPDAF"));
	RolongowriteSONYPDAF writeSONYPDAF = (RolongowriteSONYPDAF)(QLibrary::resolve(strLibPath, "writeSONYPDAF"));

	if(!(getRolongoOTPAPIVersion&& checkSONYPDAF&&writeSONYPDAF)){
		emit information(tr("Resolve HisCCMOTP DLL Function Fail"));
		itemshareData.itemparameterLock.unlock();
		return HisCCMError_LoadDLLFuc;
	}

	//1.Readout spc gain from eeprom
	_HisCCMSONYPDAFBurn_Config stPDAFSONYConfig;
	stPDAFSONYConfig.bDebug					=		hisglobalparameter.bDebugMode;
	stPDAFSONYConfig.ucSensorSlave		=		itemshareData.previewParameter->ucSlave;
	stPDAFSONYConfig.strSerialNumber  = strSerialNumber.toAscii().data();
	stPDAFSONYConfig.strproject					=		itemshareData.ccmhardwareParameter->projectname.toAscii().data();
	stPDAFSONYConfig.strsensor					=		itemshareData.ccmhardwareParameter->sensortype.toAscii().data();
	stPDAFSONYConfig.strDriverIC				=		itemshareData.ccmhardwareParameter->motortype.toAscii().data();
	stPDAFSONYConfig.strFunctionChoose	=	itemshareData.pdafParameter->strSONYPDAFChoose.toAscii().data();
	stPDAFSONYConfig.ucEESlave				=	itemshareData.ccmhardwareParameter->ucEESlave;
	stPDAFSONYConfig.ucTpye					=	1;
	stPDAFSONYConfig.uiSPCSize				=	9*7*2;
	emit enableinfotimer(1);
	iresult	=	checkSONYPDAF(*globalFunPointer.vectorHisCCMOTPInfoW, &stPDAFSONYConfig, globalFunPointer.ReadHisFX3IIC, globalFunPointer.WriteHisFX3IIC, globalFunPointer.SetHisFX3IICSpeed, \
		globalFunPointer.SetHisFX3Voltage, globalFunPointer.GetHisFX3Voltage, SetHisFX3VFuseVolt, GetHisFX3VFuseVolt, GetFreshframe, \
		globalFunPointer.BatchWriteHisFX3IIC, globalFunPointer.BatchReadHisFX3IIC, SetHisFX3GPIO, GetHisFX3GPIO, globalFunPointer.PullHisFX3RESET, globalFunPointer.PullHisFX3PWND, \
		globalFunPointer.BatchReadHisFX3IICNoLimit, globalFunPointer.BatchWriteHisFX3IICNoLimit,globalFunPointer.HisFX3LogPush_back, globalFunPointer.PageWriteHisFX3IIC, globalFunPointer.PageReadHisFX3IIC, \
		globalFunPointer.HisFX3PageWriteSPI, globalFunPointer.HisFX3PageReadSPI);
	emit enableinfotimer(0);
	if(iresult)
	{
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("读取PDAF SONY SPC 数据失败或者没有烧录"));
		return iresult;
	}
	//2. write spc gain to sensor register
	unsigned int uRegAddr[1024]={0};
	unsigned int uRegData[1024]={0};
	unsigned short uRegType[1024]={0};
	unsigned short uI2CDelay=5000;
	unsigned char uSlave[1024]={0};
	memset(uSlave,itemshareData.previewParameter->ucSlave,sizeof(unsigned char)*1024);
	unsigned short uSPCSize=stPDAFSONYConfig.uiSPCSize;  //imx258 
	unsigned short uLeftGainSize=9*7;
	uRegAddr[0]=0xd04c;
	uRegData[0]=stPDAFSONYConfig.uSPC[0];
	uRegType[0]=0x1608;
	for(int i=1;i<uSPCSize;i++)  // Left  & Right gain
	{
		uRegAddr[i]=uRegAddr[i-1]+1;
		if(i==uLeftGainSize)  uRegAddr[i]+=1;
		uRegData[i]=stPDAFSONYConfig.uSPC[i];
		uRegType[i]=0x1608;
	}
	iresult	=	globalFunPointer.SetHisFX3IICSpeed(400);
	if(iresult) return iresult;
	iresult=globalFunPointer.BatchWriteHisFX3IICNoLimit(uSPCSize,uSlave,uRegAddr,uRegData,uRegType,uI2CDelay);
	if(iresult&& (!threadshareData.bOfflineMode))
	{
		emit information("Write SONY SPC gain to  sensor by  i2c command fail");   
		return iresult;
	}
	//6.   write spc on  "setting4" to sensor by I2C 
	uRegAddr[0]=0x0B00; uRegData[0]=0x00; uRegType[0]=0x1608;
	uRegAddr[1]=0x3051; uRegData[1]=0x00; uRegType[1]=0x1608;
	uRegAddr[2]=0x3052 ; uRegData[2]=0x00; uRegType[2]=0x1608;
	uRegAddr[3]=0x7BCA; uRegData[3]=0x01; uRegType[3]=0x1608;
	uRegAddr[4]=0x7BCB; uRegData[4]=0x00; uRegType[4]=0x1608;
	uRegAddr[5]=0x7BC8; uRegData[5]=0x01; uRegType[5]=0x1608;
	iresult=globalFunPointer.BatchWriteHisFX3IICNoLimit(6,uSlave,uRegAddr,uRegData,uRegType,uI2CDelay);
	if(iresult&& (!threadshareData.bOfflineMode))
	{
		emit information("Write SONY SPC <setting 4> sensor i2c command fail");   
		return iresult;
	}
	emit information("Write SONY SPC  <setting 4>  ok");   
	return iresult;
}

int itemprocess::PDAFSTEP2Verify(int iPDAFDAC, int &iCDAFDAC,int  Width,int Height)
{
	_CODE_CLEAR_IMAGEDRAW
		QString strSerialNumber;
	classLog->getserialnumber(strSerialNumber);
	float fMTFValue[128]={0};
	float fMTFSommth[128]={0};
	int   iDACPos[128]={0};
	iCDAFDAC=0;
	int   iresult=0;
	QDir classDir;
	// Assign DAC 
	iDACPos[0]=iPDAFDAC-(itemshareData.pdafParameter->usVerifyDACShiftCount/2)*itemshareData.pdafParameter->usDACMoveStep;
	if(iDACPos[0]<0) iDACPos[0]=0;
	for(int i=1;i<itemshareData.pdafParameter->usVerifyDACShiftCount;i++)
	{
		iDACPos[i]=iDACPos[i-1]+itemshareData.pdafParameter->usDACMoveStep;
		if( iDACPos[i]>1023) iDACPos[i]=1023; 
	}
	//
	RECT stMTFAutoROI;
	stMTFAutoROI.left=(Width>>1)-(itemshareData.pdafParameter->usCDAFmtfROIW>>1);stMTFAutoROI.top=(Height>>1)-(itemshareData.pdafParameter->usCDAFmtfROIH>>1);
	stMTFAutoROI.right=(Width>>1)+(itemshareData.pdafParameter->usCDAFmtfROIW>>1);stMTFAutoROI.bottom=(Height>>1)+(itemshareData.pdafParameter->usCDAFmtfROIH>>1);
	unsigned char *pucRGB24		=	(unsigned char*)_aligned_malloc(Width* Height *3, _HisCacheLine_Aligned);
	if(!pucRGB24) {HisReleaseMalloc(pucRGB24);return HisFX3Error_MallocBuffer;}
	float iMaxMTFValue=0.0f;
	int   iMaxLensPosIndex=0,iPeakDropCnt=0;
	bool  bPeakFind=false;
	int   iPeakDropArrary[128]={0};
	unsigned char ucMinCantrast = 20;
	std::vector<_itemDraw> vectorDraw;
	vectorDraw.reserve(100);
	RECT stROI;
	iresult	=	setMotor(itemshareData.ccmhardwareParameter->motortype.toAscii().data(), \
		itemshareData.previewParameter->ucSlave, itemshareData.ccmhardwareParameter->projectname.toAscii().data(), \
		iDACPos[0], globalFunPointer.ReadHisFX3IIC, globalFunPointer.WriteHisFX3IIC, globalFunPointer.SetHisFX3IICSpeed, globalFunPointer.PullHisFX3RESET, globalFunPointer.PullHisFX3PWND, \
		globalFunPointer.PageWriteHisFX3IIC, globalFunPointer.PageReadHisFX3IIC, globalFunPointer.HisFX3PageWriteSPI, globalFunPointer.HisFX3PageReadSPI);
	Sleep(itemshareData.pdafParameter->uiMotorSleep);
	for(int i=0;i<itemshareData.pdafParameter->usVerifyDACShiftCount;i++)
	{
		vectorDraw.clear();
		iresult	=	setMotor(itemshareData.ccmhardwareParameter->motortype.toAscii().data(), \
			itemshareData.previewParameter->ucSlave, itemshareData.ccmhardwareParameter->projectname.toAscii().data(), \
			iDACPos[i], globalFunPointer.ReadHisFX3IIC, globalFunPointer.WriteHisFX3IIC, globalFunPointer.SetHisFX3IICSpeed, globalFunPointer.PullHisFX3RESET, globalFunPointer.PullHisFX3PWND, \
			globalFunPointer.PageWriteHisFX3IIC, globalFunPointer.PageReadHisFX3IIC, globalFunPointer.HisFX3PageWriteSPI, globalFunPointer.HisFX3PageReadSPI);
		Sleep(itemshareData.pdafParameter->uiMotorSleep);

		GetFreshframe(pucRGB24, Width *Height *3, _FrameType_RGB24, true);
		if(!ROPLOW::BlackStripesDetected(pucRGB24,itemshareData.pdafParameter->usCDAFmtfROIW,Width ,Height,stROI))
		{
			emit information("BlackStripesDetected failed, please check detected ROI size");
			HisReleaseMalloc(pucRGB24);
			return HisCCMError_PDAF_VERIFY;
		}
		int iROiW= stROI.right-stROI.left, iROIH = stROI.bottom-stROI.top;
		//emit information("Black stripes ROI L T R B: " % QString::number(stROI.left)%"," %QString::number(stROI.top)%","%QString::number(stROI.right)%","%QString::number(stROI.bottom));
		float* pflY	=	(float*)_aligned_malloc(iROiW *iROIH *sizeof(float), 64);
		ROPLOW::GetPartImageFromRGB24(pucRGB24, Width, Height, _HisCCMAlg_ImageBuffer_Channel_Y, stROI, pflY);	
		int isftcurvelen = iROiW + 1;
		double* pdflsfrvalue	=	new double[isftcurvelen];
		int iresult=classAlgorithm.HisCCMSFROne(pflY,iROiW, iROIH, ucMinCantrast, pdflsfrvalue, isftcurvelen, fMTFValue[i]);
		//emit information("SFR Value: " % QString::number(fMTFValue[i], 'f', 3)%",sfr return:"% QString::number(iresult));
		HisReleaseMalloc(pflY);
		HisReleaseNewB(pdflsfrvalue);
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("CDAF对焦: Move Lens to:") % QString::number(iDACPos[i])%"SFR Value:"% QString::number(fMTFValue[i], 'f', 5)%",sfr return:"% QString::number(iresult));
		if(iMaxMTFValue<fMTFValue[i] ) {iMaxMTFValue=fMTFValue[i];bPeakFind=true;iMaxLensPosIndex=i;}
		if(bPeakFind && (i>iMaxLensPosIndex))
		{
			iPeakDropArrary[i]=1;
			iPeakDropCnt++;
			if(itemshareData.pdafParameter->bPDAFVerifyMTFDropStop )
			{
				if((iPeakDropCnt>=4)&&(iPeakDropArrary[i-3]==1)&& (iPeakDropArrary[i-2]==1) && (iPeakDropArrary[i-1]==1) && (iPeakDropArrary[i]==1))
				{
					if( (fMTFValue[i]< fMTFValue[i-1]) && (fMTFValue[i-1]< fMTFValue[i-2])/*&& (fMTFValue[i-2]< fMTFValue[i-3])*/ )
					{
						int iDataSize=i;// First data skip
						float fMaxSommthMTF=0;
						CureSmooth(fMTFValue+1,fMTFSommth+1,iDataSize);
						FindCurePeak(fMTFSommth+1,iDataSize,fMaxSommthMTF,iMaxLensPosIndex);
						iCDAFDAC=iDACPos[iMaxLensPosIndex+1];
						emit information(QTextCodec::codecForName( "GBK")->toUnicode("MTF Peak find and drop 3 counts in continues")%"Peak DAC:"% QString::number(iCDAFDAC));
						break;
					}
				}
			}
		}
		//draw result
		_itemDraw stItem;
		stItem.uctype	=	HisDrawType_Block;
		stItem.strinfo.stblock	=stROI;
		stItem.stcolor	=	QColor::fromRgb(0,255,0);
		vectorDraw.push_back(stItem);
		stItem.uctype	=	HisDrawType_Text;
		stItem.idata[0]	=	stROI.right;
		stItem.idata[1]	=	stROI.bottom;
		stItem.stcolor	=	QColor::fromRgb(0,255,0);
		sprintf(stItem.strinfo.strtext, "%.3f", fMTFValue[i]);
		vectorDraw.push_back(stItem);
		_CODE_RJAFA_LP_ASIGNDRAW
	}
	HisReleaseMalloc(pucRGB24);
	if(!iPeakDropCnt)  iCDAFDAC=iDACPos[iMaxLensPosIndex];
	emit information(QTextCodec::codecForName( "GBK")->toUnicode("CDAF found peak:")% QString::number(iCDAFDAC)%"Dev to PDAF:"% QString::number(abs(iCDAFDAC-iPDAFDAC)));
	if((abs(iCDAFDAC-iPDAFDAC))>itemshareData.pdafParameter->usQualcommkverifyoffest)
	{
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("CDAF with PDAF in focused postion is over spec:") % QString::number(abs(iCDAFDAC-iPDAFDAC)));
		iresult=HisCCMError_PDAF_VERIFY;
	}
	//save log
	QString strLogPath;
	if(itemshareData.pdafParameter->ucPlatform==0)
	{
		strLogPath	=	QDir::currentPath() % "/mtkpdaflog";
		classDir.mkpath(strLogPath);
		strLogPath	=strLogPath% "/MTK_PDAF_Step2Verify_"%(QDate::currentDate()).toString("yyyyMMdd")%".csv";
	}
	else if(itemshareData.pdafParameter->ucPlatform==1) 
	{
		strLogPath	=	QDir::currentPath() % "/QualcommPDAFLog";
		classDir.mkpath(strLogPath);
		strLogPath	=strLogPath% "/Qualcomm_PDAF_Step2Verify_"%(QDate::currentDate()).toString("yyyyMMdd")%".csv";
	}
	else if(itemshareData.pdafParameter->ucPlatform==2)
	{
		strLogPath	=	QDir::currentPath() % "/SONYPDAFLog";
		classDir.mkpath(strLogPath);
		strLogPath	=strLogPath% "/SONY_PDAF_Step2Verify_"%(QDate::currentDate()).toString("yyyyMMdd")%".csv";
	}
	else if(itemshareData.pdafParameter->ucPlatform==3){

	}
	ROPLOW::saveCDAFVerifyCure(itemshareData.pdafParameter->usVerifyDACShiftCount,iDACPos,fMTFValue,fMTFSommth,strLogPath,strSerialNumber);
	return iresult;
}

int itemprocess::IOBitOut(unsigned int uiCardNum, unsigned int uiPort, unsigned int uiBitNum, unsigned int uiValue)
{
	int iresult = 0;
#if (defined USE_EQUIPMENT_JSL_RRT_V1) || (defined USE_EQUIPMENT_GB_PDAF) || (defined USE_EQUIPMENT_GB_AFBURN)
	if(iresult = classMotion.IOWriteOutBit(uiCardNum, uiPort, uiBitNum, uiValue)){
		emit information(classMotion.GetLastError());
	}

	unsigned int uiRead;
	if(iresult = classMotion.IOReadOutBit(uiCardNum, uiPort, uiBitNum, &uiRead)){
		emit information("IOReadOutBit: " % classMotion.GetLastError());
	}
	else{
		emit information("IOReadOutBit Read: " % QString::number(uiRead));
	}
#endif
	return iresult;
}

int itemprocess::MotorMove(unsigned int CardNo,unsigned int axis, double Dist, bool bAbs)
{
	int iresult = 0;

#if (defined USE_EQUIPMENT_JSL_RRT_V1)
	if(bAbs)
	{
		if(iresult = classMotion.MoveAbs(CardNo, axis, Dist, true))
			emit information(classMotion.GetLastError());
	}
	else
	{
		if(iresult = classMotion.MoveRelative(CardNo, axis, Dist, true))
			emit information(classMotion.GetLastError());
	}
#endif

	return iresult;
}

int itemprocess::ChartAlign(unsigned char ucChartType, unsigned char ucAngle, unsigned char ucTimes, unsigned short usMarkMin, unsigned short usMarkMax, \
	unsigned short usPosDiff, unsigned short usTarget, float flFOV, float flScaleX, float flScaleY, unsigned short usFrameSleep)
{
	int iresult = 0;
	//判断图像是否点亮中
	if(!threadshareData.GetHisPreviewflag())	return HisCCMError_NotPreivew;

	itemshareData.clearDrawList();

	QColor stNowColor		=	QColor::fromRgb(255, 255, 0);
	QColor stDesColor		=	QColor::fromRgb(0x1E, 0x90, 0xFF);
	QHReadWriteLockManage classitemparameterLock(&(itemshareData.itemparameterLock));
	int ciLineLen	=	50;

#if (defined USE_EQUIPMENT_JSL_RRT_V1)
	if(ucChartType == 0 || ucChartType == 1)
	{
		unsigned int uiPixelSize	=	itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight;
		unsigned char* pucRGB24	=	(unsigned char*)HisAlignedMalloc(uiPixelSize *3);
		if(!pucRGB24) return HisFX3Error_MallocBuffer;
		QHisFX3MallocAlignedManage classpucRGB24(pucRGB24);
		int iDCenterX = (itemshareData.previewParameter->iWidth >>1), iDCenterY = (itemshareData.previewParameter->iHeight >>1);
		std::vector<_SFRBlackItem> vecPos;
		vecPos.reserve(100);

		bool bSuccess	=	false;
		POINT stP1, stP2, stP3, stP4, stCenter;
		int iLastDiff_X = 0x00FFFFFF, iLastDiff_Y = 0x00FFFFFF;
		for(unsigned int w=0;	w<ucTimes;	++w)
		{
			if(iresult	=	GetFreshframe(pucRGB24, uiPixelSize *3, _FrameType_RGB24, !w))
				return iresult;

			unsigned char* pucSrc = pucRGB24 + 1, *pucDes = pucRGB24;
			for(unsigned int x=0;	x<uiPixelSize;	++x)
			{
				*pucDes++	=	*pucSrc;
				pucSrc	+=	3;
			}

			if(iresult = classAlgorithm.decodeSFRChartTAHA(pucRGB24, itemshareData.previewParameter->iWidth, itemshareData.previewParameter->iHeight, \
				usMarkMin, usMarkMax, vecPos))
			{
				emit information(QTextCodec::codecForName( "GBK")->toUnicode("无法提取出CHART轮廓信息"));
				return HisCCMError_Result;
			}

			if(vecPos.size() < 4)
			{
				emit information(QTextCodec::codecForName( "GBK")->toUnicode("无法提取出CHART轮廓信息"));
				return HisCCMError_Result;
			}

			if(iresult = classAlgorithm.getChartAlignMarkCenter(vecPos, itemshareData.previewParameter->iWidth, itemshareData.previewParameter->iHeight, \
				flFOV, ucAngle, usPosDiff, stP1, stP2, stP3, stP4, stCenter))
			{
				emit information(QTextCodec::codecForName( "GBK")->toUnicode("无法找到4个对称MARK点"));
				return HisCCMError_Result;
			}

			itemshareData.drawLock.lockForWrite();
			itemshareData.itemdrawList.resize(12);
			for(unsigned int x=0;	x<12;	++x)
			{
				itemshareData.itemdrawList[x].usitem	=	chartalignlitem;
				itemshareData.itemdrawList[x].uctype	=	HisDrawType_Line;
				if(x < 2) itemshareData.itemdrawList[x].stcolor	=	stDesColor;
				else	itemshareData.itemdrawList[x].stcolor	=	stNowColor;
			}

			itemshareData.itemdrawList[0].strinfo.stblock.left			= 0;
			itemshareData.itemdrawList[0].strinfo.stblock.top			= iDCenterY;
			itemshareData.itemdrawList[0].strinfo.stblock.right		= itemshareData.previewParameter->iWidth-1;
			itemshareData.itemdrawList[0].strinfo.stblock.bottom	= iDCenterY;

			itemshareData.itemdrawList[1].strinfo.stblock.left			= iDCenterX;
			itemshareData.itemdrawList[1].strinfo.stblock.top			= 0;
			itemshareData.itemdrawList[1].strinfo.stblock.right		= iDCenterX;
			itemshareData.itemdrawList[1].strinfo.stblock.bottom	= itemshareData.previewParameter->iHeight-1;

			POINT* pstDraw;
			for(unsigned int x=2;	x<12;	++x)
			{
				switch (((x-2) >>1))
				{
				case 0:	pstDraw = &stP1;	break;
				case 1:	pstDraw = &stP2;	break;
				case 2:	pstDraw = &stP3;	break;
				case 3:	pstDraw = &stP4;	break;
				default:		pstDraw = &stCenter;	break;
				}

				itemshareData.itemdrawList[x].strinfo.stblock.left			= pstDraw->x - ciLineLen;
				itemshareData.itemdrawList[x].strinfo.stblock.top			= pstDraw->y;
				itemshareData.itemdrawList[x].strinfo.stblock.right		= pstDraw->x + ciLineLen;
				itemshareData.itemdrawList[x].strinfo.stblock.bottom	= pstDraw->y;
				++x;

				itemshareData.itemdrawList[x].strinfo.stblock.left			= pstDraw->x;
				itemshareData.itemdrawList[x].strinfo.stblock.top			= pstDraw->y - ciLineLen;
				itemshareData.itemdrawList[x].strinfo.stblock.right		= pstDraw->x;
				itemshareData.itemdrawList[x].strinfo.stblock.bottom	= pstDraw->y + ciLineLen;
			}
			itemshareData.drawLock.unlock();

			int iDiffX	=	stCenter.x - iDCenterX, iDiffY = stCenter.y - iDCenterY;
			emit information(QString::number(w) %  "    Diff X: " % QString::number(iDiffX) % " Diff Y: " % QString::number(iDiffY));
			if(abs(iDiffX) < usTarget && abs(iDiffY) < usTarget) { bSuccess = true; break; }

			if(w == 0) 
			{
				if(abs(iDiffX) >= usTarget)		iLastDiff_X = iDiffX; 
				if(abs(iDiffY) >= usTarget)		iLastDiff_Y = iDiffY; 
			}
			else if(w == 1)
			{
				if(iLastDiff_X != 0x00FFFFFF)
				{
					if((iDiffX < 0 && iLastDiff_X < 0 && iDiffX < iLastDiff_X) || \
						(iDiffX > 0 && iLastDiff_X > 0 && iDiffX > iLastDiff_X)) 
						emit information("Warning: The X direction is wrong.");
					else
					{
						double dflReal;
						if(iLastDiff_X *iDiffX < 0) dflReal  = (double)(abs(iLastDiff_X)) / (abs(iLastDiff_X) + abs(iDiffX));
						else dflReal	=	(double)(abs(iLastDiff_X)) / (abs(iLastDiff_X - iDiffX));
						dflReal *=	flScaleX;
						emit information("Axis X Best Scale: " % QString::number(dflReal, 'f', 2));
					}
				}

				if(iLastDiff_Y != 0x00FFFFFF)
				{
					if((iDiffY < 0 && iLastDiff_Y < 0 && iDiffY < iLastDiff_Y) || \
						(iDiffY > 0 && iLastDiff_Y > 0 && iDiffY > iLastDiff_Y)) 
						emit information("Warning: The Y direction is wrong.");
					else
					{
						double dflReal;
						if(iLastDiff_Y *iDiffY < 0) dflReal  = (double)(abs(iLastDiff_Y)) / (abs(iLastDiff_Y) + abs(iDiffY));
						else dflReal	=	(double)(abs(iLastDiff_Y)) / (abs(iLastDiff_Y - iDiffY));
						dflReal *=	flScaleY;
						emit information("Axis Y Best Scale: " % QString::number(dflReal, 'f', 2));
					}
				}
			}



#if (defined USE_EQUIPMENT_JSL_RRT_V1)
			unsigned int uiAxisX = 1, uiAxisY = 0;
			if(ucChartType == 1)
			{
				uiAxisX		= 3;
				uiAxisY		=	2;
			}

			double dflMoveX = iDiffX *flScaleX, dflMoveY = iDiffY *flScaleY;
			if(abs(iDiffX) >= usTarget && (iresult = classMotion.MoveRelative(0, uiAxisX, dflMoveX, false)))
			{
				emit information("Axis X Move Fail");
				return iresult;
			}

			if(abs(iDiffY) >= usTarget && (iresult = classMotion.MoveRelative(0, uiAxisY, dflMoveY, false)))
			{
				emit information("Axis X Move Fail");
				return iresult;
			}

			Sleep(100);
			if(abs(iDiffX) >= usTarget && (iresult = classMotion.CheckAxisStoped(0, uiAxisX)))
			{
				emit information("Check Axis X Stop Fail");
				return iresult;
			}

			if(abs(iDiffY) >= usTarget && (iresult = classMotion.CheckAxisStoped(0, uiAxisY)))
			{
				emit information("Check Axis X Stop Fail");
				return iresult;
			}
#endif

			if(usFrameSleep) Sleep(usFrameSleep);
		}

		if(!bSuccess) iresult = HisFX3Error_Timeout;
	}
#endif

	return iresult;
}

int itemprocess::RRTCheck(unsigned int uiChart)
{
	int iresult = 0;

	//判断图像是否点亮中
	if(!threadshareData.GetHisPreviewflag())	return HisCCMError_NotPreivew;

	itemshareData.clearDrawList();

	QHReadWriteLockManage classitemparameterLock(&(itemshareData.itemparameterLock));

	if(uiChart == 0) //Macro
	{
		QString strDllPath = QDir::currentPath() % "/SRITDLL/RRT_DLL";
		typedef int (*RRT_RRT_Run_Target2nd)(unsigned char *);
		typedef int (*RRT_RRT_Set_ConfigurationPath)(char *);

#ifdef _WIN64
		RRT_RRT_Run_Target2nd  RRT_Run_Target2nd = (RRT_RRT_Run_Target2nd)(QLibrary::resolve(strDllPath, "?RRT_Run_Target2nd@@YAHPEAE@Z"));
		RRT_RRT_Set_ConfigurationPath  RRT_Set_ConfigurationPath = (RRT_RRT_Set_ConfigurationPath)(QLibrary::resolve(strDllPath, "?RRT_Set_ConfigurationPath@@YAHPEAD@Z"));
#else
		RRT_RRT_Run_Target2nd  RRT_Run_Target2nd = (RRT_RRT_Run_Target2nd)(QLibrary::resolve(strDllPath, "?RRT_Run_Target2nd@@YAHPAE@Z"));
		RRT_RRT_Set_ConfigurationPath  RRT_Set_ConfigurationPath = (RRT_RRT_Set_ConfigurationPath)(QLibrary::resolve(strDllPath, "?RRT_Set_ConfigurationPath@@YAHPAD@Z"));
#endif
		if(!RRT_Run_Target2nd || !RRT_Set_ConfigurationPath){
			emit information(strDllPath % " load RRT_Run fail");
			return HisCCMError_LoadDLLFuc;
		}

		stLogItem.itemtype		=	classLog->getmaxtypeindex(_HISLOG_CLASSIFY_RRTMacro);
		stLogItem.itemkey		=	"RRT_Macro_Result";
		stLogItem.itemvalue	=	"OK";
		QHDefaultLogManage classstLogItem(classLog, &stLogItem, "NG");

		unsigned short* pusBaylor	=	(unsigned short*)HisAlignedMalloc(itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight *2);
		if(!pusBaylor) return HisFX3Error_MallocBuffer;
		QHisFX3MallocAlignedManage classpusBaylor(pusBaylor);

		//取得raw图像数据
		if(iresult	=	GetFreshframe((unsigned char*)pusBaylor, itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight *2, _FrameType_Raw10, true))
			return iresult;

		QString strWorkDir = QDir::currentPath() % "/SRITDLL/";
		emit information(strWorkDir);
		if(iresult = RRT_Set_ConfigurationPath(strWorkDir.toAscii().data()))
		{
			emit information("RRT_Set_ConfigurationPath return(error): " % QString::number(iresult));
			return HisCCMError_OtpFucExec;
		}

		QString strRawPath = QDir::currentPath() % "/RRT_Chart40.raw";

		QFile classFile(strRawPath);
		iresult	=	0;
		if(classFile.open(QIODevice::WriteOnly | QIODevice::Truncate))
		{
			if(classFile.write((char*)(pusBaylor), itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight *2) == -1)	iresult	=	HisCCMError_WriteFile;
			classFile.close();
		}
		else iresult	=	HisCCMError_WriteFile;

		if(iresult) { emit information(strRawPath % " write fail"); return iresult; }

		QString strLogPath = QDir::currentPath() % "/RRT_OUT/RRTOutTxt2nd.txt";
		if(QFile::exists(strLogPath))
			QFile::remove(strLogPath);

		QString strSerialNumber;
		classLog->getserialnumber(strSerialNumber);
		if(iresult = RRT_Run_Target2nd(NULL))
		{
			emit information("RRT_Run_Target2nd return(error): " % QString::number(iresult));
			return HisCCMError_OtpFucExec;
		}

		iresult = HisCCMError_Result;
		if(QFile::exists(strLogPath))
		{
			QFile classFile(strLogPath);
			if(classFile.open(QFile::ReadOnly))
			{
				iresult	=	0;
				char buf[1024];
				qint64 lineLength = classFile.readLine(buf, 1023);
				while(lineLength > 1)
				{
					buf[lineLength] = '\0';
					QString strLine	=	QString::fromAscii(buf);
					strLine	=	strLine.trimmed();
					if(strLine.size() < 6) break;
					strLine	=	strLine.right(1);
					if(strLine != "O") { iresult = HisCCMError_Result; break; }
					lineLength = classFile.readLine(buf, 1023);
				}
				classFile.close();
			}
		}

		if(iresult) stLogItem.itemvalue = "NG";
		classstLogItem.SubRef();
		classLog->push_back(stLogItem);
	}
	else if(uiChart == 1) //Far
	{
		QString strDllPath = QDir::currentPath() % "/SRITDLL/RRT_DLL";
		typedef int (*RRT_RRT_Run)(unsigned char *);
		typedef int (*RRT_RRT_Set_ConfigurationPath)(char *);

#ifdef _WIN64
		RRT_RRT_Run  RRT_Run = (RRT_RRT_Run)(QLibrary::resolve(strDllPath, "?RRT_Run@@YAHPEAE@Z"));
		RRT_RRT_Set_ConfigurationPath  RRT_Set_ConfigurationPath = (RRT_RRT_Set_ConfigurationPath)(QLibrary::resolve(strDllPath, "?RRT_Set_ConfigurationPath@@YAHPEAD@Z"));
#else
		RRT_RRT_Run  RRT_Run = (RRT_RRT_Run)(QLibrary::resolve(strDllPath, "?RRT_Run@@YAHPAE@Z"));
		RRT_RRT_Set_ConfigurationPath  RRT_Set_ConfigurationPath = (RRT_RRT_Set_ConfigurationPath)(QLibrary::resolve(strDllPath, "?RRT_Set_ConfigurationPath@@YAHPAD@Z"));
#endif
		if(!RRT_Run || !RRT_Set_ConfigurationPath){
			emit information(strDllPath % " load RRT_Run fail");
			return HisCCMError_LoadDLLFuc;
		}

		stLogItem.itemtype		=	classLog->getmaxtypeindex(_HISLOG_CLASSIFY_RRTFar);
		stLogItem.itemkey		=	"RRT_Far_Result";
		stLogItem.itemvalue	=	"OK";
		QHDefaultLogManage classstLogItem(classLog, &stLogItem, "NG");

		unsigned short* pusBaylor	=	(unsigned short*)HisAlignedMalloc(itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight *2);
		if(!pusBaylor) return HisFX3Error_MallocBuffer;
		QHisFX3MallocAlignedManage classpusBaylor(pusBaylor);

		//取得raw图像数据
		if(iresult	=	GetFreshframe((unsigned char*)pusBaylor, itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight *2, _FrameType_Raw10, true))
			return iresult;

		QString strWorkDir = QDir::currentPath() % "/SRITDLL/";
		emit information(strWorkDir);
		if(iresult = RRT_Set_ConfigurationPath(strWorkDir.toAscii().data()))
		{
			emit information("RRT_Set_ConfigurationPath return(error): " % QString::number(iresult));
			return HisCCMError_OtpFucExec;
		}

		QString strRawPath = QDir::currentPath() % "/RRT_Chart16.raw";

		QFile classFile(strRawPath);
		iresult	=	0;
		if(classFile.open(QIODevice::WriteOnly | QIODevice::Truncate))
		{
			if(classFile.write((char*)(pusBaylor), itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight *2) == -1)	iresult	=	HisCCMError_WriteFile;
			classFile.close();
		}
		else iresult	=	HisCCMError_WriteFile;

		if(iresult) { emit information(strRawPath % " write fail"); return iresult; }

		QString strLogPath = QDir::currentPath() % "/RRT_OUT/RRTOutTxt.txt";
		if(QFile::exists(strLogPath))
			QFile::remove(strLogPath);

		QString strSerialNumber;
		classLog->getserialnumber(strSerialNumber);
		if(iresult = RRT_Run(NULL))
		{
			emit information("RRT_Run return(error): " % QString::number(iresult));
			return HisCCMError_OtpFucExec;
		}

		iresult = HisCCMError_Result;
		if(QFile::exists(strLogPath))
		{
			QFile classFile(strLogPath);
			if(classFile.open(QFile::ReadOnly))
			{
				iresult	=	0;
				char buf[1024];
				qint64 lineLength = classFile.readLine(buf, 1023);
				while(lineLength > 1)
				{
					buf[lineLength] = '\0';
					QString strLine	=	QString::fromAscii(buf);
					strLine	=	strLine.trimmed();
					if(strLine.size() < 6) break;
					strLine	=	strLine.right(1);
					if(strLine != "O") { iresult = HisCCMError_Result; break; }
					lineLength = classFile.readLine(buf, 1023);
				}
				classFile.close();
			}
		}

		if(iresult) stLogItem.itemvalue = "NG";
		classstLogItem.SubRef();
		classLog->push_back(stLogItem);
	}

	return iresult;
}

int itemprocess::toPosWhitePanel()
{
	emit information(tr("Move To White Panel Position"));
	int iresult = 0;

#if (defined USE_EQUIPMENT_JSL_RRT_V1)
	unsigned int uiBitValue = 0;

	if(iresult = classMotion.IOReadOutBit(0, 0, 0, &uiBitValue)){
		emit information(classMotion.GetLastError());
		return iresult;
	}	
	if(uiBitValue != 0){
		if(iresult = classMotion.IOWriteOutBit(0, 0, 0, 0)){
			emit information(classMotion.GetLastError());
			return iresult;
		}
		Sleep(20);
	}

	if(iresult = classMotion.IOReadOutBit(0, 0, 1, &uiBitValue)){
		emit information(classMotion.GetLastError());
		return iresult;
	}	
	if(uiBitValue != 1){
		if(iresult = classMotion.IOWriteOutBit(0, 0, 1, 1)){
			emit information(classMotion.GetLastError());
			return iresult;
		}
		Sleep(20);
	}

	if(iresult = classMotion.IOReadOutBit(0, 0, 3, &uiBitValue)){
		emit information(classMotion.GetLastError());
		return iresult;
	}	
	if(uiBitValue != 0){
		if(iresult = classMotion.IOWriteOutBit(0, 0, 3, 0)){
			emit information(classMotion.GetLastError());
			return iresult;
		}
		Sleep(20);
	}

	if(iresult = classMotion.IOReadOutBit(0, 0, 4, &uiBitValue)){
		emit information(classMotion.GetLastError());
		return iresult;
	}	
	if(uiBitValue != 1){
		if(iresult = classMotion.IOWriteOutBit(0, 0, 4, 1)){
			emit information(classMotion.GetLastError());
			return iresult;
		}
		Sleep(20);
	}

	if(iresult = classMotion.IOReadOutBit(0, 0, 5, &uiBitValue)){
		emit information(classMotion.GetLastError());
		return iresult;
	}	
	if(uiBitValue != 1){
		if(iresult = classMotion.IOWriteOutBit(0, 0, 5, 1)){
			emit information(classMotion.GetLastError());
			return iresult;
		}
		Sleep(20);
	}

	if(iresult = classMotion.IOReadOutBit(0, 0, 6, &uiBitValue)){
		emit information(classMotion.GetLastError());
		return iresult;
	}	
	if(uiBitValue != 1){
		if(iresult = classMotion.IOWriteOutBit(0, 0, 6, 1)){
			emit information(classMotion.GetLastError());
			return iresult;
		}
		Sleep(20);
	}



#endif

	return iresult;
}

int itemprocess::toPosBlackPanel()
{
	emit information(tr("Move To Black Panel Position"));
	int iresult = 0;

#if (defined USE_EQUIPMENT_JSL_RRT_V1)
	unsigned int uiBitValue = 0;

	if(iresult = classMotion.IOReadOutBit(0, 0, 0, &uiBitValue)){
		emit information(classMotion.GetLastError());
		return iresult;
	}	
	if(uiBitValue != 1){
		if(iresult = classMotion.IOWriteOutBit(0, 0, 0, 1)){
			emit information(classMotion.GetLastError());
			return iresult;
		}
		Sleep(20);
	}

	if(iresult = classMotion.IOReadOutBit(0, 0, 1, &uiBitValue)){
		emit information(classMotion.GetLastError());
		return iresult;
	}	
	if(uiBitValue != 0){
		if(iresult = classMotion.IOWriteOutBit(0, 0, 1, 0)){
			emit information(classMotion.GetLastError());
			return iresult;
		}
		Sleep(20);
	}

	if(iresult = classMotion.IOReadOutBit(0, 0, 3, &uiBitValue)){
		emit information(classMotion.GetLastError());
		return iresult;
	}	
	if(uiBitValue != 0){
		if(iresult = classMotion.IOWriteOutBit(0, 0, 3, 0)){
			emit information(classMotion.GetLastError());
			return iresult;
		}
		Sleep(20);
	}

	if(iresult = classMotion.IOReadOutBit(0, 0, 4, &uiBitValue)){
		emit information(classMotion.GetLastError());
		return iresult;
	}	
	if(uiBitValue != 1){
		if(iresult = classMotion.IOWriteOutBit(0, 0, 4, 1)){
			emit information(classMotion.GetLastError());
			return iresult;
		}
		Sleep(20);
	}

	if(iresult = classMotion.IOReadOutBit(0, 0, 5, &uiBitValue)){
		emit information(classMotion.GetLastError());
		return iresult;
	}	
	if(uiBitValue != 1){
		if(iresult = classMotion.IOWriteOutBit(0, 0, 5, 1)){
			emit information(classMotion.GetLastError());
			return iresult;
		}
		Sleep(20);
	}

	if(iresult = classMotion.IOReadOutBit(0, 0, 6, &uiBitValue)){
		emit information(classMotion.GetLastError());
		return iresult;
	}	
	if(uiBitValue != 1){
		if(iresult = classMotion.IOWriteOutBit(0, 0, 6, 1)){
			emit information(classMotion.GetLastError());
			return iresult;
		}
		Sleep(20);
	}



#endif

	return iresult;
}

int itemprocess::toPosNearFocus()
{
	emit information(tr("Move To Near Focus Position"));
	int iresult = 0;

#if (defined USE_EQUIPMENT_JSL_RRT_V1)
	unsigned int uiBitValue = 0;

	if(iresult = classMotion.IOReadOutBit(0, 0, 5, &uiBitValue)){
		emit information(classMotion.GetLastError());
		return iresult;
	}	
	if(uiBitValue != 0){
		if(iresult = classMotion.IOWriteOutBit(0, 0, 5, 0)){
			emit information(classMotion.GetLastError());
			return iresult;
		}
		Sleep(20);
	}

	if(iresult = classMotion.IOReadOutBit(0, 0, 0, &uiBitValue)){
		emit information(classMotion.GetLastError());
		return iresult;
	}
	if(uiBitValue != 1){
		if(iresult = classMotion.IOWriteOutBit(0, 0, 0, 1)){
			emit information(classMotion.GetLastError());
			return iresult;
		}
		Sleep(20);
	}

	if(iresult = classMotion.IOReadOutBit(0, 0, 1, &uiBitValue)){
		emit information(classMotion.GetLastError());
		return iresult;
	}
	if(uiBitValue != 1){
		if(iresult = classMotion.IOWriteOutBit(0, 0, 1, 1)){
			emit information(classMotion.GetLastError());
			return iresult;
		}
		Sleep(20);
	}

	if(iresult = classMotion.IOReadOutBit(0, 0, 3, &uiBitValue)){
		emit information(classMotion.GetLastError());
		return iresult;
	}
	if(uiBitValue != 1){
		if(iresult = classMotion.IOWriteOutBit(0, 0, 3, 1)){
			emit information(classMotion.GetLastError());
			return iresult;
		}
		Sleep(20);
	}

	if(iresult = classMotion.IOReadOutBit(0, 0, 4, &uiBitValue)){
		emit information(classMotion.GetLastError());
		return iresult;
	}
	if(uiBitValue != 1){
		if(iresult = classMotion.IOWriteOutBit(0, 0, 4, 1)){
			emit information(classMotion.GetLastError());
			return iresult;
		}
		Sleep(20);
	}

	if(iresult = classMotion.IOReadOutBit(0, 0, 6, &uiBitValue)){
		emit information(classMotion.GetLastError());
		return iresult;
	}
	if(uiBitValue != 1){
		if(iresult = classMotion.IOWriteOutBit(0, 0, 6, 1)){
			emit information(classMotion.GetLastError());
			return iresult;
		}
		Sleep(20);
	}
#endif

	return iresult;
}

int itemprocess::toPosFarFocus()
{
	emit information(tr("Move To Far Panel Position"));
	int iresult = 0;

#if (defined USE_EQUIPMENT_JSL_RRT_V1)
	unsigned int uiBitValue = 0;

	if(iresult = classMotion.IOReadOutBit(0, 0, 0, &uiBitValue)){
		emit information(classMotion.GetLastError());
		return iresult;
	}	
	if(uiBitValue != 1){
		if(iresult = classMotion.IOWriteOutBit(0, 0, 0, 1)){
			emit information(classMotion.GetLastError());
			return iresult;
		}
		Sleep(20);
	}

	if(iresult = classMotion.IOReadOutBit(0, 0, 1, &uiBitValue)){
		emit information(classMotion.GetLastError());
		return iresult;
	}	
	if(uiBitValue != 1){
		if(iresult = classMotion.IOWriteOutBit(0, 0, 1, 1)){
			emit information(classMotion.GetLastError());
			return iresult;
		}
		Sleep(20);
	}

	if(iresult = classMotion.IOReadOutBit(0, 0, 3, &uiBitValue)){
		emit information(classMotion.GetLastError());
		return iresult;
	}	
	if(uiBitValue != 1){
		if(iresult = classMotion.IOWriteOutBit(0, 0, 3, 1)){
			emit information(classMotion.GetLastError());
			return iresult;
		}
		Sleep(20);
	}

	if(iresult = classMotion.IOReadOutBit(0, 0, 4, &uiBitValue)){
		emit information(classMotion.GetLastError());
		return iresult;
	}	
	if(uiBitValue != 0){
		if(iresult = classMotion.IOWriteOutBit(0, 0, 4, 0)){
			emit information(classMotion.GetLastError());
			return iresult;
		}
		Sleep(20);
	}

	if(iresult = classMotion.IOReadOutBit(0, 0, 5, &uiBitValue)){
		emit information(classMotion.GetLastError());
		return iresult;
	}	
	if(uiBitValue != 1){
		if(iresult = classMotion.IOWriteOutBit(0, 0, 5, 1)){
			emit information(classMotion.GetLastError());
			return iresult;
		}
		Sleep(20);
	}

	if(iresult = classMotion.IOReadOutBit(0, 0, 6, &uiBitValue)){
		emit information(classMotion.GetLastError());
		return iresult;
	}	
	if(uiBitValue != 1){
		if(iresult = classMotion.IOWriteOutBit(0, 0, 6, 1)){
			emit information(classMotion.GetLastError());
			return iresult;
		}
		Sleep(20);
	}
#endif

	return iresult;
}

int itemprocess::getGereralAFAParameter(bool bupdate, bool bcheck)
{
	itemshareData.itemparameterLock.lockForRead();
	if(!bupdate && itemshareData.afaBasicStacticsParameter){ itemshareData.itemparameterLock.unlock(); return 0; }

	QMutexLocker locker(&hisglobalparameter.mutexDatabase);

	itemshareData.itemparameterLock.unlock();
	itemshareData.itemparameterLock.lockForWrite();
	if(!itemshareData.afaBasicStacticsParameter)	itemshareData.afaBasicStacticsParameter		=	new _HisAutoFA_BASIC_STACTICS;
	if(!itemshareData.afaBasicStacticsParameter){
		itemshareData.itemparameterLock.unlock();
		return HisFX3Error_MallocBuffer;
	}

	bool bparsesuccess	=	true, bItemExist = false;

	//读取，解析config
	for(int  w=0;	w<1;	++w){ //此处是有意义的,不要删除
		QSqlDatabase customdb = QSqlDatabase::addDatabase("QSQLITE", "querycustom");
		customdb.setDatabaseName(QDir::currentPath() % "/HisFX3Custom");
		if (!customdb.open()){
			bparsesuccess	=	false;
			break;
		}

		QString strData, strdata2;
		QStringList strname, strvalue;
		QSqlQuery query(customdb);
		query.prepare("SELECT itemsuffix2,key,value,reserve,note FROM " % itemshareData.currentTableName % \
			" WHERE classfy='equipment' AND item='afarolongo' ORDER BY id ASC" );
		query.exec();

		//(tactics:0)(direction:0)(chart:10)(valuechoose:0)(valuetype:0)(undermethod:0)(underangle:30)(underlaser:0.5)(bestoffset:0.0)(sfrmarkblock:5)
		//(database:true)(dboffset:0.0)(evyup:true)(evyupdis:3.0)(retrytime:3)(retryangle:3.0)(lastup:true)(lastupdis:3.0)(lastunderangle:0)(underdevmin:0.3)(underdevmax:0.6)
		//(laser:true)(vision:true)(mark:true)(lensangle:60)(ringangle:50)(lenspitch:0.25)(lensnum:3)(ringnum:3)
		//(maxstep:20)(stepdelay:650)(curvevalid:0.3)(curvefall:0.05)(maxccw:120)(maxcw:120)(minlaser:0.0)(maxlaser:0.0)(minmark:0.0)(maxmark:0.0)
		//(nodenum:4)(n1value:0.1)(n1angle:0.1)(n2value:0.1)(n2angle:0.1)(n3value:0.1)(n3angle:0.1)(n4value:0.1)(n4angle:0.1)(n5value:0.1)(n5angle:0.1)(n6value:0.1)(n6angle:0.1)(n7value:0.1)(n7angle:0.1)(n8value:0.1)(n8angle:0.1)(n9value:0.1)(n9angle:0.1)

		while (query.next()){
			bItemExist = true;
			for(int y=0;	y<5;	++y){
				strData	=	query.value(y).toString();
				ROPLOW::patchconfigstring(strData, strname, strvalue);
				for(int x=0;	x<strname.size();	++x){
					if(strname.at(x) == "tactics")	itemshareData.afaBasicStacticsParameter->ucTactics	=	strvalue.at(x).toInt();
					else if(strname.at(x) == "direction")	itemshareData.afaBasicStacticsParameter->ucDirection	=	strvalue.at(x).toInt();
					else if(strname.at(x) == "chart")	itemshareData.afaBasicStacticsParameter->ucChartType	=	strvalue.at(x).toInt();
					else if(strname.at(x) == "valuechoose")	itemshareData.afaBasicStacticsParameter->ucValueChoose	=	strvalue.at(x).toInt();
					else if(strname.at(x) == "valuetype")	itemshareData.afaBasicStacticsParameter->ucValueTypeChoose	=	strvalue.at(x).toInt();
					else if(strname.at(x) == "undermethod")	itemshareData.afaBasicStacticsParameter->uc1stCWMode	=	strvalue.at(x).toInt();
					else if(strname.at(x) == "underangle")	itemshareData.afaBasicStacticsParameter->fl1stCWAngle	=	strvalue.at(x).toInt();
					else if(strname.at(x) == "underlaser")	itemshareData.afaBasicStacticsParameter->fl1stCWLaser	=	strvalue.at(x).toDouble();
					else if(strname.at(x) == "bestoffset")	itemshareData.afaBasicStacticsParameter->fltoBestAngOffset	=	strvalue.at(x).toDouble();
					else if(strname.at(x) == "sfrmarkblock") 	itemshareData.afaBasicStacticsParameter->ucSFRAMarkBlockCount	=	strvalue.at(x).toUInt();
#ifdef USE_AFC_Fitting
					else if(strname.at(x) == "sfrmarkminarea")	itemshareData.afaBasicStacticsParameter->dflMarkMinArea	=	strvalue.at(x).toDouble();
					else if(strname.at(x) == "sfrmarkmaxarea") 	itemshareData.afaBasicStacticsParameter->dflMarkMaxArea	=	strvalue.at(x).toDouble();
					else if(strname.at(x) == "sfrmarkminlength") 	itemshareData.afaBasicStacticsParameter->dflMarkMinLength	=	strvalue.at(x).toDouble();
					else if(strname.at(x) == "sfrmarkmaxlength") 	itemshareData.afaBasicStacticsParameter->dflMarkMaxLength	=	strvalue.at(x).toDouble();
					else if(strname.at(x) == "sfrmarktargetdist") 	itemshareData.afaBasicStacticsParameter->dflMarkTargetDistance	=	strvalue.at(x).toDouble();
					else if(strname.at(x) == "sfrmarkstepdist") 	itemshareData.afaBasicStacticsParameter->dflMarkStepDistance	=	strvalue.at(x).toDouble();
#endif
					else if(strname.at(x) == "database")	itemshareData.afaBasicStacticsParameter->bDataBase	=	(strvalue.at(x) == "true");
					else if(strname.at(x) == "dboffset")	itemshareData.afaBasicStacticsParameter->flDBAngleOffset	=	strvalue.at(x).toDouble();
					else if(strname.at(x) == "evyup")	itemshareData.afaBasicStacticsParameter->bUpCheckEveryStep	=	(strvalue.at(x) == "true");
					else if(strname.at(x) == "evyupdis")	itemshareData.afaBasicStacticsParameter->flEveryUpDis	=	strvalue.at(x).toDouble();
					else if(strname.at(x) == "retrytime")	itemshareData.afaBasicStacticsParameter->ucLastRetryTime	=	strvalue.at(x).toInt();
					else if(strname.at(x) == "retryangle")	itemshareData.afaBasicStacticsParameter->flLastRetryAngle	=	strvalue.at(x).toDouble();
					else if(strname.at(x) == "lastup")	itemshareData.afaBasicStacticsParameter->bUpCheck	=	(strvalue.at(x) == "true");
					else if(strname.at(x) == "xyreversal")	itemshareData.afaBasicStacticsParameter->bXYReversal	=	(strvalue.at(x) == "true");
					else if(strname.at(x) == "mtfbmarkx")	itemshareData.afaBasicStacticsParameter->flMTFBMarkRangeX	=	strvalue.at(x).toDouble();
					else if(strname.at(x) == "mtfbmarky")	itemshareData.afaBasicStacticsParameter->flMTFBMarkRangeY	=	strvalue.at(x).toDouble();
					else if(strname.at(x) == "mtfbmarkymax")	itemshareData.afaBasicStacticsParameter->flMTFBMarkRangeYMax	=	strvalue.at(x).toDouble();
					else if(strname.at(x) == "lastunderangle")	itemshareData.afaBasicStacticsParameter->uiUnderSpinAngle	=	strvalue.at(x).toInt();
					else if(strname.at(x) == "underdevmin")	itemshareData.afaBasicStacticsParameter->flUnderSpinDValueMin	=	strvalue.at(x).toDouble();
					else if(strname.at(x) == "underdevmax")	itemshareData.afaBasicStacticsParameter->flUnderSpinDValueMax	=	strvalue.at(x).toDouble();
					else if(strname.at(x) == "laser")	itemshareData.afaBasicStacticsParameter->bUseLaser	=	(strvalue.at(x) == "true");
					else if(strname.at(x) == "vision")	itemshareData.afaBasicStacticsParameter->bVision	=	(strvalue.at(x) == "true");
					else if(strname.at(x) == "mark")	itemshareData.afaBasicStacticsParameter->bUseMark	=	(strvalue.at(x) == "true");
					else if(strname.at(x) == "lensangle")	itemshareData.afaBasicStacticsParameter->dfllensIncludedAngle	=	strvalue.at(x).toDouble();
					else if(strname.at(x) == "ringangle")	itemshareData.afaBasicStacticsParameter->dflringIncludedAngle	=	strvalue.at(x).toDouble();
					else if(strname.at(x) == "lenspitch")	itemshareData.afaBasicStacticsParameter->dfllenspitch	=	strvalue.at(x).toDouble();
					else if(strname.at(x) == "lensnum")	itemshareData.afaBasicStacticsParameter->uclensleafs	=	strvalue.at(x).toInt();
					else if(strname.at(x) == "ringnum")	itemshareData.afaBasicStacticsParameter->ucclaw	=	strvalue.at(x).toInt();
					else if(strname.at(x) == "maxstep")	itemshareData.afaBasicStacticsParameter->ussteplimit	=	strvalue.at(x).toInt();
					else if(strname.at(x) == "stepdelay")	itemshareData.afaBasicStacticsParameter->usoperatedelay	=	strvalue.at(x).toInt();
					else if(strname.at(x) == "curvevalid")	itemshareData.afaBasicStacticsParameter->flConstPeakDefValue	=	strvalue.at(x).toDouble();
					else if(strname.at(x) == "curvefall")	itemshareData.afaBasicStacticsParameter->flConstPeakDefFall	=	strvalue.at(x).toDouble();
					else if(strname.at(x) == "maxccw")	itemshareData.afaBasicStacticsParameter->flConstMaxAngleCCW	=	strvalue.at(x).toDouble();
					else if(strname.at(x) == "maxcw")	itemshareData.afaBasicStacticsParameter->flConstMaxAngleCW	=	strvalue.at(x).toDouble();
					else if(strname.at(x) == "minlaser")	itemshareData.afaBasicStacticsParameter->flConstLaserMin	=	strvalue.at(x).toDouble();
					else if(strname.at(x) == "maxlaser")	itemshareData.afaBasicStacticsParameter->flConstLaserMax	=	strvalue.at(x).toDouble();
					else if(strname.at(x) == "minmark")	itemshareData.afaBasicStacticsParameter->flConstMarkDisMin	=	strvalue.at(x).toDouble();
					else if(strname.at(x) == "maxmark")	itemshareData.afaBasicStacticsParameter->flConstMarkDisMax	=	strvalue.at(x).toDouble();
					else if(strname.at(x) == "tcptimeoutlimit")	itemshareData.iSocketReceiveTimeOut	=	strvalue.at(x).toInt();
					else if(strname.at(x) == "nodenum")	{
						itemshareData.afaBasicStacticsParameter->bConfigValid = true;
						itemshareData.afaBasicStacticsParameter->ucVNodeNum	=	strvalue.at(x).toInt();
					}
					else if(strname.at(x) == "n1value")	itemshareData.afaBasicStacticsParameter->flVNode[0]	=	strvalue.at(x).toDouble();
					else if(strname.at(x) == "n1angle")	itemshareData.afaBasicStacticsParameter->flVAngle[0]	=	strvalue.at(x).toDouble();
					else if(strname.at(x) == "n2value")	itemshareData.afaBasicStacticsParameter->flVNode[1]	=	strvalue.at(x).toDouble();
					else if(strname.at(x) == "n2angle")	itemshareData.afaBasicStacticsParameter->flVAngle[1]	=	strvalue.at(x).toDouble();
					else if(strname.at(x) == "n3value")	itemshareData.afaBasicStacticsParameter->flVNode[2]	=	strvalue.at(x).toDouble();
					else if(strname.at(x) == "n3angle")	itemshareData.afaBasicStacticsParameter->flVAngle[2]	=	strvalue.at(x).toDouble();
					else if(strname.at(x) == "n4value")	itemshareData.afaBasicStacticsParameter->flVNode[3]	=	strvalue.at(x).toDouble();
					else if(strname.at(x) == "n4angle")	itemshareData.afaBasicStacticsParameter->flVAngle[3]	=	strvalue.at(x).toDouble();
					else if(strname.at(x) == "n5value")	itemshareData.afaBasicStacticsParameter->flVNode[4]	=	strvalue.at(x).toDouble();
					else if(strname.at(x) == "n5angle")	itemshareData.afaBasicStacticsParameter->flVAngle[4]	=	strvalue.at(x).toDouble();
					else if(strname.at(x) == "n6value")	itemshareData.afaBasicStacticsParameter->flVNode[5]	=	strvalue.at(x).toDouble();
					else if(strname.at(x) == "n6angle")	itemshareData.afaBasicStacticsParameter->flVAngle[5]	=	strvalue.at(x).toDouble();
					else if(strname.at(x) == "n7value")	itemshareData.afaBasicStacticsParameter->flVNode[6]	=	strvalue.at(x).toDouble();
					else if(strname.at(x) == "n7angle")	itemshareData.afaBasicStacticsParameter->flVAngle[6]	=	strvalue.at(x).toDouble();
					else if(strname.at(x) == "n8value")	itemshareData.afaBasicStacticsParameter->flVNode[7]	=	strvalue.at(x).toDouble();
					else if(strname.at(x) == "n8angle")	itemshareData.afaBasicStacticsParameter->flVAngle[7]	=	strvalue.at(x).toDouble();
					else if(strname.at(x) == "n9value")	itemshareData.afaBasicStacticsParameter->flVNode[8]	=	strvalue.at(x).toDouble();
					else if(strname.at(x) == "n9angle")	itemshareData.afaBasicStacticsParameter->flVAngle[8]	=	strvalue.at(x).toDouble();
				}
			}
		}

		customdb.close();
	}

	QSqlDatabase::removeDatabase("querycustom");
	if(!bparsesuccess || !bItemExist)
	{
		HisReleaseNewO(itemshareData.afaBasicStacticsParameter);
		itemshareData.itemparameterLock.unlock();
		return HisFX3Error_Parameter;
	}

	if(!bcheck) {itemshareData.itemparameterLock.unlock(); return 0; }

	if(!itemshareData.afaBasicStacticsParameter->bConfigValid){
		HisReleaseNewO(itemshareData.afaBasicStacticsParameter);
		itemshareData.itemparameterLock.unlock();
		return HisFX3Error_Parameter;
	}

	if(itemshareData.afaBasicStacticsParameter->bUpCheckEveryStep) itemshareData.afaBasicStacticsParameter->bUpCheck = false;
	if(itemshareData.afaBasicStacticsParameter->ucChartType == _HisCCMAlg_Rolongo_Chart_MTF_A) itemshareData.afaBasicStacticsParameter->bUseMark = false;

	itemshareData.itemparameterLock.unlock();
	return 0;
}

#if (defined USE_EQUIPMENT_AFM_JSL_V1)
void itemprocess::DrawAFAMTFBarChart(_HisAutoFA_Rolongo_DataItem& stItemData)
{
	QImage imageGreen(":/Resources/bar_green.png", "PNG");
	QImage imageRed(":/Resources/bar_red.png", "PNG");
	QImage imageBlue(":/Resources/bar_blue.png", "PNG");

	QImage imageBackgound(770, 220, QImage::Format_RGB888);
	imageBackgound.fill(QColor::fromRgb(240, 240, 240));

	const int ciTotalWidth		=	imageBackgound.width();
	const int ciTotalHeight		=	imageBackgound.height();
	const int ciInitBarWidth	=	imageGreen.width();
	const int ciIntiBarHeight	=	imageGreen.height();
	const int ciTextRectHeight		=	20;
	const float cflY1	=	ciTotalHeight - ciTextRectHeight;

	int iGroupCount		=	stItemData.vectorMTFFOV.size();
	int iBlockCount		=	2;
	for(unsigned int x=0;	x<stItemData.vectorMTFFOV.size(); ++x){
		if(stItemData.vectorMTFFOV.at(x).ucBlockCount == 2) iBlockCount += 2;
		else iBlockCount+= 4;
	}

	int iBarWidth	=	ciTotalWidth / (iBlockCount + iGroupCount +iGroupCount /2 +1);
	iBarWidth		=	min(iBarWidth, ciInitBarWidth);

	if(iBarWidth != ciInitBarWidth){
		imageGreen	=	imageGreen.scaled(iBarWidth, ciIntiBarHeight, Qt::IgnoreAspectRatio, Qt::FastTransformation);
		imageRed		=	imageRed.scaled(iBarWidth, ciIntiBarHeight, Qt::IgnoreAspectRatio, Qt::FastTransformation);
		imageBlue		=	imageBlue.scaled(iBarWidth, ciIntiBarHeight, Qt::IgnoreAspectRatio, Qt::FastTransformation);
	}

	QPainter painer(&imageBackgound);

	QPen	thePen	=	painer.pen();
	thePen.setStyle(Qt::DotLine);
	thePen.setWidth(4);
	thePen.setColor(QColor::fromRgb(0,0,0));
	painer.setPen(thePen);

	QFont theFont	=	painer.font();
	theFont.setFamily("arial");
	theFont.setPixelSize(iBarWidth *0.4);
	painer.setFont(theFont);

	QRect rectImage;
	rectImage.setLeft(0);
	rectImage.setTop(0);
	rectImage.setBottom(ciTotalHeight -1);
	rectImage.setRight(iBarWidth -1);

	QRect rectText;
	rectText.setLeft(0);
	rectText.setTop(0);
	rectText.setWidth(iBarWidth);
	rectText.setHeight(ciTextRectHeight);

	QLine lineSpec;
	QRect rectSpec;

	QImage* ptheImage;
	int idata;
	QString strText;

	for(int i=0;	i<iGroupCount;	++i){
		for(int x=0;	x<stItemData.vectorMTFFOV.at(i).ucBlockCount;	++x){
			ptheImage	=	(stItemData.vectorMTFFOV.at(i).flValue[x] < stItemData.vectorMTFFOV.at(i).flSpec)?(&imageRed):(&imageGreen);
			idata	=	rectImage.bottom() - cflY1 *stItemData.vectorMTFFOV.at(i).flValue[x] -1;
			rectImage.setTop(idata);
			painer.drawImage(rectImage,  *ptheImage);

			rectText.moveTo(rectImage.left(), rectImage.top() - ciTextRectHeight);
			painer.drawText(rectText, Qt::AlignHCenter|Qt::AlignVCenter|Qt::TextSingleLine|Qt::TextDontClip, QString::number(stItemData.vectorMTFFOV.at(i).flValue[x], 'f', 3));

			idata	=	rectImage.bottom() - cflY1 *stItemData.vectorMTFFOV.at(i).flSpec -1;
			lineSpec.setLine(rectImage.left(), idata, rectImage.right(), idata);

			painer.drawLine(lineSpec);

			rectImage.moveLeft(rectImage.left() + iBarWidth);
		}

		ptheImage	=	(stItemData.vectorMTFFOV.at(i).flUniformValue > stItemData.vectorMTFFOV.at(i).flSpecUniform)?(&imageRed):(&imageGreen);
		idata	=	rectImage.bottom() - cflY1 *(1.0f - stItemData.vectorMTFFOV.at(i).flUniformValue) -1;
		rectImage.setTop(idata);
		painer.drawImage(rectImage,  *ptheImage);

		rectText.moveTo(rectImage.left(), rectImage.top() - ciTextRectHeight);
		painer.drawText(rectText, Qt::AlignHCenter|Qt::AlignVCenter|Qt::TextSingleLine|Qt::TextDontClip, QString::number(stItemData.vectorMTFFOV.at(i).flUniformValue, 'f', 3));

		idata	=	rectImage.bottom() - cflY1 *(1.0f - stItemData.vectorMTFFOV.at(i).flSpecUniform) -1;
		lineSpec.setLine(rectImage.left(), idata, rectImage.right(), idata);
		painer.drawLine(lineSpec);

		rectImage.moveLeft(rectImage.left() + iBarWidth);
		rectImage.moveLeft(rectImage.left() + iBarWidth /2);
	}

	ptheImage	=	(stItemData.flMTFCenterValue < stItemData.flMTFCenterSpec)?(&imageRed):(&imageGreen);
	idata	=	rectImage.bottom() - cflY1 *stItemData.flMTFCenterValue -1;
	rectImage.setTop(idata);
	painer.drawImage(rectImage,  *ptheImage);

	rectText.moveTo(rectImage.left(), rectImage.top() - ciTextRectHeight);
	painer.drawText(rectText, Qt::AlignHCenter|Qt::AlignVCenter|Qt::TextSingleLine|Qt::TextDontClip, QString::number(stItemData.flMTFCenterValue, 'f', 3));

	idata	=	rectImage.bottom() - cflY1 *stItemData.flMTFCenterSpec -1;
	lineSpec.setLine(rectImage.left(), idata, rectImage.right(), idata);
	painer.drawLine(lineSpec);

	rectImage.moveLeft(rectImage.left() + iBarWidth);
	// 	ptheImage	=	&imageBlue;
	// 	idata	=	rectImage.bottom() - cflY1 *stMaxItem.flWeightValue -1;
	// 	rectImage.setTop(idata);
	// 	painer.drawImage(rectImage,  *ptheImage);
	ptheImage	=	(stItemData.ucStatus == 0x0)?(&imageRed):(&imageGreen);
	idata	=	rectImage.bottom() - cflY1 *stItemData.flWeightValue -1;
	rectImage.setTop(idata);
	painer.drawImage(rectImage,  *ptheImage);
	rectText.moveTo(rectImage.left(), rectImage.top() - ciTextRectHeight);
	painer.drawText(rectText, Qt::AlignHCenter|Qt::AlignVCenter|Qt::TextSingleLine|Qt::TextDontClip, QString::number(stItemData.flWeightValue, 'f', 3));

	itemshareData.plotLock.lockForWrite();
	itemshareData.plotimage	=	imageBackgound;
	itemshareData.plotLock.unlock();
	emit plotpainter(0);
}

void itemprocess::DrawAFASFRBarChart(_HisCCMAlg_SFRPlusHABasic_Info* pstBasic, _HisAutoFA_Rolongo_DataItem& stItemData)
{
	QImage imageGreen(":/Resources/bar_green.png", "PNG");
	QImage imageRed(":/Resources/bar_red.png", "PNG");
	QImage imageBlue(":/Resources/bar_blue.png", "PNG");

	QImage imageBackgound(770, 220, QImage::Format_RGB888);
	imageBackgound.fill(QColor::fromRgb(240, 240, 240));

	const int ciTotalWidth		=	imageBackgound.width();
	const int ciTotalHeight		=	imageBackgound.height();
	const int ciInitBarWidth	=	imageGreen.width();
	const int ciIntiBarHeight	=	imageGreen.height();
	const int ciTextRectHeight		=	20;
	int iTotalHeight1 = ciTotalHeight /2;
	int iTotalHeight2	=	iTotalHeight1;
	int iTotalBottom1	=	0;
	int iTotalBottom2	=	iTotalHeight1;
	const float cflY1	=	iTotalHeight1 - ciTextRectHeight;
	const float cflWY1	=	ciTotalHeight - ciTextRectHeight;

	int iGroupCount		=	stItemData.vectorSFRFOV.size();
	int iBlockCount		=	iGroupCount *4 +1;
	if(pstBasic->ucMethod == _His_SFR_Method_2Freq && pstBasic->b2ndFreq){
		iBlockCount = iBlockCount *2 +iGroupCount;
	}

	int iBarWidth	=	ciTotalWidth / (iBlockCount + iGroupCount +iGroupCount /2 +1);
	iBarWidth		=	min(iBarWidth, ciInitBarWidth);

	if(iBarWidth != ciInitBarWidth){
		imageGreen	=	imageGreen.scaled(iBarWidth, ciIntiBarHeight, Qt::IgnoreAspectRatio, Qt::FastTransformation);
		imageRed		=	imageRed.scaled(iBarWidth, ciIntiBarHeight, Qt::IgnoreAspectRatio, Qt::FastTransformation);
		imageBlue		=	imageBlue.scaled(iBarWidth, ciIntiBarHeight, Qt::IgnoreAspectRatio, Qt::FastTransformation);
	}

	QPainter painer(&imageBackgound);

	QPen	thePen	=	painer.pen();
	thePen.setStyle(Qt::DotLine);
	thePen.setWidth(4);
	thePen.setColor(QColor::fromRgb(0,0,0));
	painer.setPen(thePen);

	QFont theFont	=	painer.font();
	theFont.setFamily("arial");
	theFont.setPixelSize(iBarWidth *0.4);
	painer.setFont(theFont);

	QRect rectImageH;
	rectImageH.setLeft(0);
	rectImageH.setTop(0);
	rectImageH.setBottom(iTotalHeight1 -1);
	rectImageH.setRight(iBarWidth -1);

	QRect rectTextH;
	rectTextH.setLeft(0);
	rectTextH.setTop(0);
	rectTextH.setWidth(iBarWidth);
	rectTextH.setHeight(ciTextRectHeight);

	QRect rectImageV;
	rectImageV.setLeft(0);
	rectImageV.setTop(iTotalHeight1);
	rectImageV.setBottom(ciTotalHeight -1);
	rectImageV.setRight(iBarWidth -1);

	QRect rectTextV;
	rectTextV.setLeft(0);
	rectTextV.setTop(iTotalHeight1);
	rectTextV.setWidth(iBarWidth);
	rectTextV.setHeight(ciTextRectHeight);

	QLine lineSpec;
	QRect rectSpec;

	QImage* ptheImage;
	int idata;
	QString strText;
	float flData;

	if(pstBasic->ucMethod == _His_SFR_Method_2Freq){
		for(int i=0;	i<iGroupCount;	++i){
			for(int x=0;	x<4;	++x){
				flData	=	min(stItemData.vectorSFRFOV.at(i).stSFRFreq1[x].flValueH_L, stItemData.vectorSFRFOV.at(i).stSFRFreq1[x].flValueH_R);
				ptheImage	=	(flData < stItemData.vectorSFRFOV.at(i).fl1stFreqSpecH)?(&imageRed):(&imageGreen);
				idata	=	rectImageH.bottom() - cflY1 *flData -1;
				rectImageH.setTop(idata);
				painer.drawImage(rectImageH,  *ptheImage);

				rectTextH.moveTo(rectImageH.left(), rectImageH.top() - ciTextRectHeight);
				painer.drawText(rectTextH, Qt::AlignHCenter|Qt::AlignVCenter|Qt::TextSingleLine|Qt::TextDontClip, QString::number(flData, 'f', 3));

				idata	=	rectImageH.bottom() - cflY1 *stItemData.vectorSFRFOV.at(i).fl1stFreqSpecH -1;
				lineSpec.setLine(rectImageH.left(), idata, rectImageH.right(), idata);
				painer.drawLine(lineSpec);

				rectImageH.moveLeft(rectImageH.left() + iBarWidth);

				//V
				flData	=	min(stItemData.vectorSFRFOV.at(i).stSFRFreq1[x].flValueV_T, stItemData.vectorSFRFOV.at(i).stSFRFreq1[x].flValueV_B);
				ptheImage	=	(flData < stItemData.vectorSFRFOV.at(i).fl1stFreqSpecV)?(&imageRed):(&imageGreen);
				idata	=	rectImageV.bottom() - cflY1 *flData -1;
				rectImageV.setTop(idata);
				painer.drawImage(rectImageV,  *ptheImage);

				rectTextV.moveTo(rectImageV.left(), rectImageV.top() - ciTextRectHeight);
				painer.drawText(rectTextV, Qt::AlignHCenter|Qt::AlignVCenter|Qt::TextSingleLine|Qt::TextDontClip, QString::number(flData, 'f', 3));

				idata	=	rectImageV.bottom() - cflY1 *stItemData.vectorSFRFOV.at(i).fl1stFreqSpecV -1;
				lineSpec.setLine(rectImageV.left(), idata, rectImageV.right(), idata);
				painer.drawLine(lineSpec);

				rectImageV.moveLeft(rectImageV.left() + iBarWidth);
			}

			//H
			flData	=	stItemData.vectorSFRFOV.at(i).flFreq1UnifH;
			ptheImage	=	(flData > stItemData.vectorSFRFOV.at(i).fl1stFreqSpecUnifH)?(&imageRed):(&imageGreen);
			idata	=	rectImageH.bottom() - cflY1 *(1.0f - flData) -1;
			rectImageH.setTop(idata);
			painer.drawImage(rectImageH,  *ptheImage);

			rectTextH.moveTo(rectImageH.left(), rectImageH.top() - ciTextRectHeight);
			painer.drawText(rectTextH, Qt::AlignHCenter|Qt::AlignVCenter|Qt::TextSingleLine|Qt::TextDontClip, QString::number(flData, 'f', 3));

			idata	=	rectImageH.bottom() - cflY1 *(1.0f - stItemData.vectorSFRFOV.at(i).fl1stFreqSpecUnifH) -1;
			lineSpec.setLine(rectImageH.left(), idata, rectImageH.right(), idata);
			painer.drawLine(lineSpec);

			rectImageH.moveLeft(rectImageH.left() + iBarWidth);

			//V
			flData	=	stItemData.vectorSFRFOV.at(i).flFreq1UnifV;
			ptheImage	=	(flData > stItemData.vectorSFRFOV.at(i).fl1stFreqSpecUnifV)?(&imageRed):(&imageGreen);
			idata	=	rectImageV.bottom() - cflY1 *(1.0f - flData) -1;
			rectImageV.setTop(idata);
			painer.drawImage(rectImageV,  *ptheImage);

			rectTextV.moveTo(rectImageV.left(), rectImageV.top() - ciTextRectHeight);
			painer.drawText(rectTextV, Qt::AlignHCenter|Qt::AlignVCenter|Qt::TextSingleLine|Qt::TextDontClip, QString::number(flData, 'f', 3));

			idata	=	rectImageV.bottom() - cflY1 *(1.0f - stItemData.vectorSFRFOV.at(i).fl1stFreqSpecUnifV) -1;
			lineSpec.setLine(rectImageV.left(), idata, rectImageV.right(), idata);
			painer.drawLine(lineSpec);

			rectImageV.moveLeft(rectImageV.left() + iBarWidth);

			if(pstBasic->b2ndFreq){
				for(int x=0;	x<4;	++x){
					flData	=	min(stItemData.vectorSFRFOV.at(i).stSFRFreq2[x].flValueH_L, stItemData.vectorSFRFOV.at(i).stSFRFreq2[x].flValueH_R);
					ptheImage	=	(flData < stItemData.vectorSFRFOV.at(i).fl2ndFreqSpecH)?(&imageRed):(&imageGreen);
					idata	=	rectImageH.bottom() - cflY1 *flData -1;
					rectImageH.setTop(idata);
					painer.drawImage(rectImageH,  *ptheImage);

					rectTextH.moveTo(rectImageH.left(), rectImageH.top() - ciTextRectHeight);
					painer.drawText(rectTextH, Qt::AlignHCenter|Qt::AlignVCenter|Qt::TextSingleLine|Qt::TextDontClip, QString::number(flData, 'f', 3));

					idata	=	rectImageH.bottom() - cflY1 *stItemData.vectorSFRFOV.at(i).fl2ndFreqSpecH -1;
					lineSpec.setLine(rectImageH.left(), idata, rectImageH.right(), idata);
					painer.drawLine(lineSpec);

					rectImageH.moveLeft(rectImageH.left() + iBarWidth);

					//V
					flData	=	min(stItemData.vectorSFRFOV.at(i).stSFRFreq2[x].flValueV_T, stItemData.vectorSFRFOV.at(i).stSFRFreq2[x].flValueV_B);
					ptheImage	=	(flData < stItemData.vectorSFRFOV.at(i).fl2ndFreqSpecV)?(&imageRed):(&imageGreen);
					idata	=	rectImageV.bottom() - cflY1 *flData -1;
					rectImageV.setTop(idata);
					painer.drawImage(rectImageV,  *ptheImage);

					rectTextV.moveTo(rectImageV.left(), rectImageV.top() - ciTextRectHeight);
					painer.drawText(rectTextV, Qt::AlignHCenter|Qt::AlignVCenter|Qt::TextSingleLine|Qt::TextDontClip, QString::number(flData, 'f', 3));

					idata	=	rectImageV.bottom() - cflY1 *stItemData.vectorSFRFOV.at(i).fl2ndFreqSpecV -1;
					lineSpec.setLine(rectImageV.left(), idata, rectImageV.right(), idata);
					painer.drawLine(lineSpec);

					rectImageV.moveLeft(rectImageV.left() + iBarWidth);
				}

				//H
				flData	=	stItemData.vectorSFRFOV.at(i).flFreq2UnifH;
				ptheImage	=	(flData > stItemData.vectorSFRFOV.at(i).fl2ndFreqSpecUnifH)?(&imageRed):(&imageGreen);
				idata	=	rectImageH.bottom() - cflY1 *(1.0f - flData) -1;
				rectImageH.setTop(idata);
				painer.drawImage(rectImageH,  *ptheImage);

				rectTextH.moveTo(rectImageH.left(), rectImageH.top() - ciTextRectHeight);
				painer.drawText(rectTextH, Qt::AlignHCenter|Qt::AlignVCenter|Qt::TextSingleLine|Qt::TextDontClip, QString::number(flData, 'f', 3));

				idata	=	rectImageH.bottom() - cflY1 *(1.0f - stItemData.vectorSFRFOV.at(i).fl2ndFreqSpecUnifH) -1;
				lineSpec.setLine(rectImageH.left(), idata, rectImageH.right(), idata);
				painer.drawLine(lineSpec);

				rectImageH.moveLeft(rectImageH.left() + iBarWidth);

				//V
				flData	=	stItemData.vectorSFRFOV.at(i).flFreq2UnifV;
				ptheImage	=	(flData > stItemData.vectorSFRFOV.at(i).fl2ndFreqSpecUnifV)?(&imageRed):(&imageGreen);
				idata	=	rectImageV.bottom() - cflY1 *(1.0f - flData) -1;
				rectImageV.setTop(idata);
				painer.drawImage(rectImageV,  *ptheImage);

				rectTextV.moveTo(rectImageV.left(), rectImageV.top() - ciTextRectHeight);
				painer.drawText(rectTextV, Qt::AlignHCenter|Qt::AlignVCenter|Qt::TextSingleLine|Qt::TextDontClip, QString::number(flData, 'f', 3));

				idata	=	rectImageV.bottom() - cflY1 *(1.0f - stItemData.vectorSFRFOV.at(i).fl2ndFreqSpecUnifV) -1;
				lineSpec.setLine(rectImageV.left(), idata, rectImageV.right(), idata);
				painer.drawLine(lineSpec);

				rectImageV.moveLeft(rectImageV.left() + iBarWidth);
			}

			rectImageH.moveLeft(rectImageH.left() + iBarWidth /2);
			rectImageV.moveLeft(rectImageV.left() + iBarWidth /2);
		}

		//H
		flData	=	min(stItemData.stSFRCenterFreq1.flValueH_L, stItemData.stSFRCenterFreq1.flValueH_R);
		ptheImage	=	(flData < stItemData.flSFRCenter1stFreqSpecH)?(&imageRed):(&imageGreen);
		idata	=	rectImageH.bottom() - cflY1 *flData -1;
		rectImageH.setTop(idata);
		painer.drawImage(rectImageH,  *ptheImage);

		rectTextH.moveTo(rectImageH.left(), rectImageH.top() - ciTextRectHeight);
		painer.drawText(rectTextH, Qt::AlignHCenter|Qt::AlignVCenter|Qt::TextSingleLine|Qt::TextDontClip, QString::number(flData, 'f', 3));

		idata	=	rectImageH.bottom() - cflY1 *stItemData.flSFRCenter1stFreqSpecH -1;
		lineSpec.setLine(rectImageH.left(), idata, rectImageH.right(), idata);
		painer.drawLine(lineSpec);

		//V
		flData	=	min(stItemData.stSFRCenterFreq1.flValueV_T, stItemData.stSFRCenterFreq1.flValueV_B);
		ptheImage	=	(flData < stItemData.flSFRCenter1stFreqSpecV)?(&imageRed):(&imageGreen);
		idata	=	rectImageV.bottom() - cflY1 *flData -1;
		rectImageV.setTop(idata);
		painer.drawImage(rectImageV,  *ptheImage);

		rectTextV.moveTo(rectImageV.left(), rectImageV.top() - ciTextRectHeight);
		painer.drawText(rectTextV, Qt::AlignHCenter|Qt::AlignVCenter|Qt::TextSingleLine|Qt::TextDontClip, QString::number(flData, 'f', 3));

		idata	=	rectImageV.bottom() - cflY1 *stItemData.flSFRCenter1stFreqSpecV -1;
		lineSpec.setLine(rectImageV.left(), idata, rectImageV.right(), idata);
		painer.drawLine(lineSpec);

		if(pstBasic->b2ndFreq){
			rectImageH.moveLeft(rectImageH.left() + iBarWidth);
			rectImageV.moveLeft(rectImageV.left() + iBarWidth);

			//H
			flData	=	min(stItemData.stSFRCenterFreq2.flValueH_L, stItemData.stSFRCenterFreq2.flValueH_R);
			ptheImage	=	(flData < stItemData.flSFRCenter2ndFreqSpecH)?(&imageRed):(&imageGreen);
			idata	=	rectImageH.bottom() - cflY1 *flData -1;
			rectImageH.setTop(idata);
			painer.drawImage(rectImageH,  *ptheImage);

			rectTextH.moveTo(rectImageH.left(), rectImageH.top() - ciTextRectHeight);
			painer.drawText(rectTextH, Qt::AlignHCenter|Qt::AlignVCenter|Qt::TextSingleLine|Qt::TextDontClip, QString::number(flData, 'f', 3));

			idata	=	rectImageH.bottom() - cflY1 *stItemData.flSFRCenter2ndFreqSpecH -1;
			lineSpec.setLine(rectImageH.left(), idata, rectImageH.right(), idata);
			painer.drawLine(lineSpec);

			//V
			flData	=	min(stItemData.stSFRCenterFreq2.flValueV_T, stItemData.stSFRCenterFreq2.flValueV_B);
			ptheImage	=	(flData < stItemData.flSFRCenter2ndFreqSpecV)?(&imageRed):(&imageGreen);
			idata	=	rectImageV.bottom() - cflY1 *flData -1;
			rectImageV.setTop(idata);
			painer.drawImage(rectImageV,  *ptheImage);

			rectTextV.moveTo(rectImageV.left(), rectImageV.top() - ciTextRectHeight);
			painer.drawText(rectTextV, Qt::AlignHCenter|Qt::AlignVCenter|Qt::TextSingleLine|Qt::TextDontClip, QString::number(flData, 'f', 3));

			idata	=	rectImageV.bottom() - cflY1 *stItemData.flSFRCenter2ndFreqSpecV -1;
			lineSpec.setLine(rectImageV.left(), idata, rectImageV.right(), idata);
			painer.drawLine(lineSpec);
		}

		//weight
		rectImageV.moveLeft(rectImageV.left() + iBarWidth);
		// 		ptheImage	=	&imageBlue;
		// 		idata	=	rectImageV.bottom() - cflWY1 *stMaxItem.flWeightValue -1;
		// 		rectImageV.setTop(idata);
		// 		painer.drawImage(rectImageV,  *ptheImage);
		ptheImage	=	(stItemData.ucStatus == 0x0)?(&imageRed):(&imageGreen);
		idata	=	rectImageV.bottom() - cflWY1 *stItemData.flWeightValue -1;
		rectImageV.setTop(idata);
		painer.drawImage(rectImageV,  *ptheImage);
		rectTextV.moveTo(rectImageV.left(), rectImageV.top() - ciTextRectHeight);
		painer.drawText(rectTextV, Qt::AlignHCenter|Qt::AlignVCenter|Qt::TextSingleLine|Qt::TextDontClip, QString::number(stItemData.flWeightValue, 'f', 3));		
	}
	else{ //MTF50
		for(int i=0;	i<iGroupCount;	++i){
			for(int x=0;	x<4;	++x){
				flData	=	min(stItemData.vectorSFRFOV.at(i).stSFRMTF50[x].flValueH_L, stItemData.vectorSFRFOV.at(i).stSFRMTF50[x].flValueH_R);
				ptheImage	=	(flData < stItemData.vectorSFRFOV.at(i).flMTF50SpecH)?(&imageRed):(&imageGreen);
				idata	=	rectImageH.bottom() - cflY1 *flData -1;
				rectImageH.setTop(idata);
				painer.drawImage(rectImageH,  *ptheImage);

				rectTextH.moveTo(rectImageH.left(), rectImageH.top() - ciTextRectHeight);
				painer.drawText(rectTextH, Qt::AlignHCenter|Qt::AlignVCenter|Qt::TextSingleLine|Qt::TextDontClip, QString::number(flData, 'f', 3));

				idata	=	rectImageH.bottom() - cflY1 *stItemData.vectorSFRFOV.at(i).flMTF50SpecH -1;
				lineSpec.setLine(rectImageH.left(), idata, rectImageH.right(), idata);
				painer.drawLine(lineSpec);

				rectImageH.moveLeft(rectImageH.left() + iBarWidth);
				//V
				flData	=	min(stItemData.vectorSFRFOV.at(i).stSFRMTF50[x].flValueV_T, stItemData.vectorSFRFOV.at(i).stSFRMTF50[x].flValueV_B);
				ptheImage	=	(flData < stItemData.vectorSFRFOV.at(i).flMTF50SpecV)?(&imageRed):(&imageGreen);
				idata	=	rectImageV.bottom() - cflY1 *flData -1;
				rectImageV.setTop(idata);
				painer.drawImage(rectImageV,  *ptheImage);

				rectTextV.moveTo(rectImageV.left(), rectImageV.top() - ciTextRectHeight);
				painer.drawText(rectTextV, Qt::AlignHCenter|Qt::AlignVCenter|Qt::TextSingleLine|Qt::TextDontClip, QString::number(flData, 'f', 3));

				idata	=	rectImageV.bottom() - cflY1 *stItemData.vectorSFRFOV.at(i).flMTF50SpecV -1;
				lineSpec.setLine(rectImageV.left(), idata, rectImageV.right(), idata);
				painer.drawLine(lineSpec);

				rectImageV.moveLeft(rectImageV.left() + iBarWidth);
			}

			//H
			flData	=	stItemData.vectorSFRFOV.at(i).flMTF50UnifH;
			ptheImage	=	(flData > stItemData.vectorSFRFOV.at(i).flMTF50SpecUnifH)?(&imageRed):(&imageGreen);
			idata	=	rectImageH.bottom() - cflY1 *(1.0f - flData) -1;
			rectImageH.setTop(idata);
			painer.drawImage(rectImageH,  *ptheImage);

			rectTextH.moveTo(rectImageH.left(), rectImageH.top() - ciTextRectHeight);
			painer.drawText(rectTextH, Qt::AlignHCenter|Qt::AlignVCenter|Qt::TextSingleLine|Qt::TextDontClip, QString::number(flData, 'f', 3));

			idata	=	rectImageH.bottom() - cflY1 *(1.0f - stItemData.vectorSFRFOV.at(i).flMTF50SpecUnifH) -1;
			lineSpec.setLine(rectImageH.left(), idata, rectImageH.right(), idata);
			painer.drawLine(lineSpec);

			rectImageH.moveLeft(rectImageH.left() + iBarWidth);
			rectImageH.moveLeft(rectImageH.left() + iBarWidth /2);

			//V
			flData	=	stItemData.vectorSFRFOV.at(i).flMTF50UnifV;
			ptheImage	=	(flData > stItemData.vectorSFRFOV.at(i).flMTF50SpecUnifH)?(&imageRed):(&imageGreen);
			idata	=	rectImageV.bottom() - cflY1 *(1.0f - flData) -1;
			rectImageV.setTop(idata);
			painer.drawImage(rectImageV,  *ptheImage);

			rectTextV.moveTo(rectImageV.left(), rectImageV.top() - ciTextRectHeight);
			painer.drawText(rectTextV, Qt::AlignHCenter|Qt::AlignVCenter|Qt::TextSingleLine|Qt::TextDontClip, QString::number(flData, 'f', 3));

			idata	=	rectImageV.bottom() - cflY1 *(1.0f - stItemData.vectorSFRFOV.at(i).flMTF50SpecUnifH) -1;
			lineSpec.setLine(rectImageV.left(), idata, rectImageV.right(), idata);
			painer.drawLine(lineSpec);

			rectImageV.moveLeft(rectImageV.left() + iBarWidth);
			rectImageV.moveLeft(rectImageV.left() + iBarWidth /2);
		}

		//H
		flData	=	min(stItemData.stSFRCenterMTF50.flValueH_L, stItemData.stSFRCenterMTF50.flValueH_R);
		ptheImage	=	(flData < stItemData.flSFRCenterMTF50SpecH)?(&imageRed):(&imageGreen);
		idata	=	rectImageH.bottom() - cflY1 *flData -1;
		rectImageH.setTop(idata);
		painer.drawImage(rectImageH,  *ptheImage);

		rectTextH.moveTo(rectImageH.left(), rectImageH.top() - ciTextRectHeight);
		painer.drawText(rectTextH, Qt::AlignHCenter|Qt::AlignVCenter|Qt::TextSingleLine|Qt::TextDontClip, QString::number(flData, 'f', 3));

		idata	=	rectImageH.bottom() - cflY1 *stItemData.flSFRCenterMTF50SpecH -1;
		lineSpec.setLine(rectImageH.left(), idata, rectImageH.right(), idata);
		painer.drawLine(lineSpec);

		//V
		flData	=	min(stItemData.stSFRCenterMTF50.flValueV_T, stItemData.stSFRCenterMTF50.flValueV_B);
		ptheImage	=	(flData < stItemData.flSFRCenterMTF50SpecV)?(&imageRed):(&imageGreen);
		idata	=	rectImageV.bottom() - cflY1 *flData -1;
		rectImageV.setTop(idata);
		painer.drawImage(rectImageV,  *ptheImage);

		rectTextV.moveTo(rectImageV.left(), rectImageV.top() - ciTextRectHeight);
		painer.drawText(rectTextV, Qt::AlignHCenter|Qt::AlignVCenter|Qt::TextSingleLine|Qt::TextDontClip, QString::number(flData, 'f', 3));

		idata	=	rectImageV.bottom() - cflY1 *stItemData.flSFRCenterMTF50SpecV -1;
		lineSpec.setLine(rectImageV.left(), idata, rectImageV.right(), idata);
		painer.drawLine(lineSpec);

		//weight
		rectImageV.moveLeft(rectImageV.left() + iBarWidth);
		// 		ptheImage	=	&imageBlue;
		// 		idata	=	rectImageV.bottom() - cflWY1 *stMaxItem.flWeightValue -1;
		// 		rectImageV.setTop(idata);
		// 		painer.drawImage(rectImageV,  *ptheImage);
		ptheImage	=	(stItemData.ucStatus == 0x0)?(&imageRed):(&imageGreen);
		idata	=	rectImageV.bottom() - cflWY1 *stItemData.flWeightValue -1;
		rectImageV.setTop(idata);
		painer.drawImage(rectImageV,  *ptheImage);
		rectTextV.moveTo(rectImageV.left(), rectImageV.top() - ciTextRectHeight);
		painer.drawText(rectTextV, Qt::AlignHCenter|Qt::AlignVCenter|Qt::TextSingleLine|Qt::TextDontClip, QString::number(stItemData.flWeightValue, 'f', 3));
	}

	itemshareData.plotLock.lockForWrite();
	itemshareData.plotimage	=	imageBackgound;
	itemshareData.plotLock.unlock();
	emit plotpainter(0);
}

void itemprocess::DrawAFALpBarChart(_lpMFAParameter* pstParameter, _HisAutoFA_Rolongo_DataItem& stItemData)
{
	QImage imageGreen(":/Resources/bar_green.png", "PNG");                                                                                                                      
	QImage imageRed(":/Resources/bar_red.png", "PNG");                                                                                                                        
	QImage imageBlue(":/Resources/bar_blue.png", "PNG");                                                                                                                      

	QImage imageBackgound(770, 220, QImage::Format_RGB888);                                                                                                                   
	imageBackgound.fill(QColor::fromRgb(240, 240, 240));                                                                                                                      

	const int ciTotalWidth		=	imageBackgound.width();                                                                                                                       
	const int ciTotalHeight		=	imageBackgound.height();                                                                                                                      
	const int ciInitBarWidth	=	imageGreen.width();                                                                                                                           
	const int ciIntiBarHeight	=	imageGreen.height();                                                                                                                          
	const int ciTextRectHeight		=	20; 

	float flConstLineMax = -9999.0f, flConstLineMin = 9999999.0f;
	for(unsigned int x=0;	x<pstParameter->vectorLpItem.size(); ++x){
		flConstLineMax	=	max(flConstLineMax, pstParameter->vectorLpItem.at(x).usLPMax);
		flConstLineMin		=	min(flConstLineMin, pstParameter->vectorLpItem.at(x).usLPMin);
	}

	const float cflY1	=	(ciTotalHeight - ciTextRectHeight) / flConstLineMax;                                                                                                                     

	int iGroupCount		=	stItemData.vectorLPFOV.size();                                                                                                                       
	int iBlockCount		=	stItemData.vectorLPFOV.size() *4;                                                                                                                                                    

	int iBarWidth	=	ciTotalWidth / (iBlockCount + iGroupCount +iGroupCount /2 +1);                                                                                            
	iBarWidth		=	min(iBarWidth, ciInitBarWidth);                                                                                                                             

	if(iBarWidth != ciInitBarWidth){                                                                                                                                          
		imageGreen	=	imageGreen.scaled(iBarWidth, ciIntiBarHeight, Qt::IgnoreAspectRatio, Qt::FastTransformation);                                                             
		imageRed		=	imageRed.scaled(iBarWidth, ciIntiBarHeight, Qt::IgnoreAspectRatio, Qt::FastTransformation);                                                               
		imageBlue		=	imageBlue.scaled(iBarWidth, ciIntiBarHeight, Qt::IgnoreAspectRatio, Qt::FastTransformation);                                                              
	}                                                                                                                                                                         

	QPainter painer(&imageBackgound);                                                                                                                                         

	QPen	thePen	=	painer.pen();                                                                                                                                             
	thePen.setStyle(Qt::DotLine);                                                                                                                                             
	thePen.setWidth(4);                                                                                                                                         
	thePen.setColor(QColor::fromRgb(0,0,0));                                                                                                                                  
	painer.setPen(thePen);                                                                                                                                                    

	QFont theFont	=	painer.font();                                                                                                                                            
	theFont.setFamily("arial");                                                                                                                                               
	theFont.setPixelSize(iBarWidth *0.4);                                                                                                                                     
	painer.setFont(theFont);                                                                                                                                                  

	QRect rectImage;                                                                                                                                                          
	rectImage.setLeft(0);                                                                                                                                                     
	rectImage.setTop(0);                                                                                                                                                      
	rectImage.setBottom(ciTotalHeight -1);                                                                                                                                    
	rectImage.setRight(iBarWidth -1);                                                                                                                                         

	QRect rectText;                                                                                                                                                           
	rectText.setLeft(0);                                                                                                                                                      
	rectText.setTop(0);                                                                                                                                                       
	rectText.setWidth(iBarWidth);                                                                                                                                             
	rectText.setHeight(ciTextRectHeight);                                                                                                                                     

	QLine lineSpec;                                                                                                                                                           
	QRect rectSpec;                                                                                                                                                           

	QImage* ptheImage;                                                                                                                                                        
	int idata;                                                                                                                                                                
	QString strText;                                                                                                                                                          

	for(int i=0;	i<iGroupCount;	++i){                                                                                                                                       
		for(int x=0;	x<4;	++x){     
			if(stItemData.vectorLPFOV.at(i).stLpValue[x].ucOrientation == 0)
				ptheImage	=	(stItemData.vectorLPFOV.at(i).stLpValue[x].flValue < stItemData.vectorLPFOV.at(i).flSpecHor)?(&imageRed):(&imageGreen);            
			else
				ptheImage	=	(stItemData.vectorLPFOV.at(i).stLpValue[x].flValue < stItemData.vectorLPFOV.at(i).flSpecVec)?(&imageRed):(&imageGreen); 
			idata	=	rectImage.bottom() - cflY1 *stItemData.vectorLPFOV.at(i).stLpValue[x].flValue -1;                                                                                      
			rectImage.setTop(idata);                                                                                                                                              
			painer.drawImage(rectImage,  *ptheImage);                                                                                                                             

			rectText.moveTo(rectImage.left(), rectImage.top() - ciTextRectHeight);                                                                                                
			painer.drawText(rectText, Qt::AlignHCenter|Qt::AlignVCenter|Qt::TextSingleLine|Qt::TextDontClip, QString::number(stItemData.vectorLPFOV.at(i).stLpValue[x].flValue, 'f', 3));  

			if(stItemData.vectorLPFOV.at(i).stLpValue[x].ucOrientation == 0)
				idata	=	rectImage.bottom() - cflY1 *stItemData.vectorLPFOV.at(i).flSpecHor -1;         
			else
				idata	=	rectImage.bottom() - cflY1 *stItemData.vectorLPFOV.at(i).flSpecVec -1; 
			lineSpec.setLine(rectImage.left(), idata, rectImage.right(), idata);                                                                                                  

			painer.drawLine(lineSpec);                                                                                                                                            

			rectImage.moveLeft(rectImage.left() + iBarWidth);                                                                                                                     
		}                                                                                                                                                                       

		ptheImage	=	(stItemData.vectorLPFOV.at(i).flUniformValue > stItemData.vectorLPFOV.at(i).flSpecUniform)?(&imageRed):(&imageGreen);                                     
		idata	=	rectImage.bottom() - cflY1 *(flConstLineMax - stItemData.vectorLPFOV.at(i).flUniformValue) -1;                                                                           
		rectImage.setTop(idata);                                                                                                                                                
		painer.drawImage(rectImage,  *ptheImage);                                                                                                                               

		rectText.moveTo(rectImage.left(), rectImage.top() - ciTextRectHeight);                                                                                                  
		painer.drawText(rectText, Qt::AlignHCenter|Qt::AlignVCenter|Qt::TextSingleLine|Qt::TextDontClip, QString::number(stItemData.vectorLPFOV.at(i).flUniformValue, 'f', 3));

		idata	=	rectImage.bottom() - cflY1 *(flConstLineMax - stItemData.vectorLPFOV.at(i).flSpecUniform) -1;                                                                            
		lineSpec.setLine(rectImage.left(), idata, rectImage.right(), idata);                                                                                                    
		painer.drawLine(lineSpec);                                                                                                                                              

		rectImage.moveLeft(rectImage.left() + iBarWidth);                                                                                                                       
		rectImage.moveLeft(rectImage.left() + iBarWidth /2);                                                                                                                    
	}                                                                                                                                                                         

	// 	ptheImage	=	&imageBlue;                                                                                                                                                 
	// 	idata	=	rectImage.bottom() - cflY1 *stMaxItem.flWeightValue -1;                                                                                                         
	// 	rectImage.setTop(idata);                                                                                                                                                
	// 	painer.drawImage(rectImage,  *ptheImage);                                                                                                                               
	ptheImage	=	(stItemData.ucStatus == 0x0)?(&imageRed):(&imageGreen);                                                                                                       
	idata	=	rectImage.bottom() - cflY1 *stItemData.flWeightValue -1;                                                                                                          
	rectImage.setTop(idata);                                                                                                                                                  
	painer.drawImage(rectImage,  *ptheImage);                                                                                                                                 
	rectText.moveTo(rectImage.left(), rectImage.top() - ciTextRectHeight);                                                                                                    
	painer.drawText(rectText, Qt::AlignHCenter|Qt::AlignVCenter|Qt::TextSingleLine|Qt::TextDontClip, QString::number(stItemData.flWeightValue, 'f', 3));                      

	itemshareData.plotLock.lockForWrite();                                                                                                                                    
	itemshareData.plotimage	=	imageBackgound;                                                                                                                                 
	itemshareData.plotLock.unlock();                                                                                                                                          
	emit plotpainter(0);    
}

int itemprocess::gereralAutoFA()
{

	_CODE_CLEAR_IMAGEDRAW
		if(!threadshareData.GetHisPreviewflag())
		{ return HisFX3Error_IsNotPreview;
	}

	//***************** 2018.04.28 feng Add ************* 
#ifdef _DEBUG
		getMarkDistance_RGB24 fnGetMarkDistance=(getMarkDistance_RGB24)QLibrary::resolve("fqqImageToold.dll","getMarkDistance_RGB24");
		polyfit fnPolyfit=(polyfit)QLibrary::resolve("fqqImageToold.dll","polyfit");
		polyval fnPolyval=(polyval)QLibrary::resolve("fqqImageToold.dll","polyval");
#else
	getMarkDistance_RGB24 fnGetMarkDistance=(getMarkDistance_RGB24)QLibrary::resolve("fqqImageTool.dll","getMarkDistance_RGB24");
	polyfit fnPolyfit=(polyfit)QLibrary::resolve("fqqImageTool.dll","polyfit");
	polyval fnPolyval=(polyval)QLibrary::resolve("fqqImageTool.dll","polyval");
#endif
	if(!fnGetMarkDistance){
		emit information(QString::fromLocal8Bit("!载入fqqImageTool.dll失败，请检查是否存在"));
		return -1;
	}
//********************************************************
	/*返回数据库结果*/
#if 1
	bool bGetDB	=	false;
	if(itemshareData.afaBasicStacticsParameter == NULL) bGetDB = true;

	int iresult;
	if(iresult = getGereralAFAParameter(false)) return iresult;

	if(itemshareData.afaBasicStacticsParameter->ucChartType == _HisCCMAlg_Rolongo_Chart_MTF_A || \
		itemshareData.afaBasicStacticsParameter->ucChartType == _HisCCMAlg_Rolongo_Chart_MTF_B){
			if(itemshareData.mtffaParameter == NULL) bGetDB = true;
			if(iresult = getmtffaParameter(false)) return iresult;
			itemshareData.afaBasicStacticsParameter->flOK2Percent	=	itemshareData.mtffaParameter->stMTFBasic.flGradeMultiple;
			// 			itemshareData.mtffaParameter->stMTFBasic.flGradeMultiple	=	1.0f;
	}
	else if(itemshareData.afaBasicStacticsParameter->ucChartType == _HisCCMAlg_Rolongo_Chart_SFR_A){
		if(itemshareData.sfrfacaParameter == NULL) bGetDB = true;
		if(iresult = getSFRMFACAParameter(false)) return iresult;
		itemshareData.afaBasicStacticsParameter->flOK2Percent	=	itemshareData.sfrfacaParameter->stSFRBasic.flGradeMultiple;
		// 		itemshareData.sfrfacaParameter->stSFRBasic.flGradeMultiple	=	1.0f;
	}
	else{
		if(itemshareData.lpmfaParameter == NULL) bGetDB = true;
		if(iresult = getlpFAParameter(false)) return iresult;
		itemshareData.afaBasicStacticsParameter->flOK2Percent	=	itemshareData.lpmfaParameter->stLpBasic.flGradeMultiple;
		// 		itemshareData.lpmfaParameter->stLpBasic.flGradeMultiple		=	1.0f;
	}

	void* pclassControl = NULL;


	if(bGetDB && itemshareData.afaBasicStacticsParameter->bDataBase){
		if(iresult = ROPLOW::AFARolongoFromDB(itemshareData.mtffaParameter, itemshareData.sfrfacaParameter, \
			itemshareData.lpmfaParameter, itemshareData.afaBasicStacticsParameter, &stAFARolongoDB)) return iresult;
		emit information("DB item count: " % QString::number(stAFARolongoDB.vectorDataItem.size()));
	}
#endif

	/*定义参数*/
#if 1
	unsigned char* pucBufRaw = NULL,*pucBufRaw10=NULL, *pucBufY = NULL;
	RECT* pstBlock	=	NULL, *pstTemp = NULL;
	float* pflSFRBlock	=	NULL;
	double* pdflsfrvalue	=	NULL;

	itemshareData.itemparameterLock.lockForRead();

	// Image parameter
	_HisFX3_BaylorMode emDataFormat =	itemshareData.previewParameter->ucDataFormat;
	int iImgWidth =	itemshareData.previewParameter->iWidth, iImgHeight =	itemshareData.previewParameter->iHeight;
	unsigned int uiRawImgSize		=	itemshareData.previewParameter->iWidth * itemshareData.previewParameter->iHeight *3;
	unsigned char ucFrameType		=	_FrameType_RGB24;

	unsigned int uiRawImgSize_Raw10		=	itemshareData.previewParameter->iWidth * itemshareData.previewParameter->iHeight *2;
	unsigned char ucFrameType_Raw10		=	_FrameType_Raw10;

	unsigned int uiPixelSize	=	iImgWidth *iImgHeight;
	bool bNext;

	//mtf
	_HisAutoFA_Rolongo_DataItem_EX stDataItem_EX;
	float flvalue, flmax, flmin,flHvalue,flVvalue;
	RECT stMTFAutoROI;

	//SFR
	int isftcurvelen;
	float flmtf50;
	std::vector<_SFRBlackItem> vecPos;	
	std::vector<_SFRBlackROI4> vecFOVROI;
	std::vector<_SFRBlackROI4>::iterator iteratorFOVROI;
	unsigned char ucSFRDirect[41];
	memset(ucSFRDirect, 2, sizeof(unsigned char) *41);
	const float cflSFRDirectPercent = 0.8f;
	float flSFRDirectThreshold[11];
	for(unsigned int x=0;	x<11; ++x) flSFRDirectThreshold[x] = 0.007f;
	bool bUseYUV_Y, bAllValueMeetDirect;

	//lp
	_HisCCMAlg_RECT_FOV4 stRectFOV4;
	std::vector<_HisCCMAlg_RECT_FOV4> vectorRectFov4;
	std::vector<RECT> vectorBlock;
	std::vector<RECT> vectorMark;
	RECT stValueLine, stMinLine, stMaxLine;
	int iCenterX, iCenterY;
	double dflAngle, dflDistance, dflValue;
	float flChartLpValueMax	=	1.0f;
#endif

	/*选取ROI框*/
#if 1
	if(itemshareData.afaBasicStacticsParameter->ucChartType == _HisCCMAlg_Rolongo_Chart_MTF_A || \
		itemshareData.afaBasicStacticsParameter->ucChartType == _HisCCMAlg_Rolongo_Chart_MTF_B){
			if(iresult = ROPLOW::GetMTFCABlock(iImgWidth, iImgHeight, \
				itemshareData.mtffaParameter->stMTFBasic, itemshareData.mtffaParameter->vectorMTFItem, &pstBlock)){
					if(iresult == HisFX3Error_Parameter)
						emit information(QTextCodec::codecForName( "GBK")->toUnicode("选取的MTF ROI超出了图像区域"));
					_CODE_AFA_ALL_EXIT1
			}
	}
	else if(itemshareData.afaBasicStacticsParameter->ucChartType == _HisCCMAlg_Rolongo_Chart_SFR_A){
		switch (itemshareData.previewParameter->ucDataFormat){
		case HisBaylor10_BGGR:
		case HisBaylor12_BGGR:
		case HisBaylor8_BGGR:	emDataFormat	=	HisBaylor8_BGGR;	break;
		case HisBaylor10_RGGB:
		case HisBaylor12_RGGB:
		case HisBaylor8_RGGB:	emDataFormat	=	HisBaylor8_RGGB;	break;
		case HisBaylor10_GRBG:
		case HisBaylor12_GRBG:
		case HisBaylor8_GRBG:	emDataFormat	=	HisBaylor8_GRBG;	break;
		case HisBaylor10_GBRG:
		case HisBaylor12_GBRG:
		case HisBaylor8_GBRG:	emDataFormat	=	HisBaylor8_GBRG;	break;
		case HisBaylor10_MONO:
		case HisBaylor12_MONO:
		case HisBaylor8_MONO:	emDataFormat	=	HisBaylor8_MONO;	break;
		case HisRGB_RGB24:		break;
		default:
			uiRawImgSize		=	itemshareData.previewParameter->iWidth * itemshareData.previewParameter->iHeight *2;
			ucFrameType		=	_FrameType_Raw;
			break;
		}

		bUseYUV_Y	=	(emDataFormat>=HisYUV8_422_YUYV && emDataFormat<=HisYUV8_422_VYUY && itemshareData.sfrfacaParameter->stSFRBasic.ucChannel==_HisCCMAlg_ImageBuffer_Channel_Y)?(true):(false);
		isftcurvelen	=	itemshareData.sfrfacaParameter->stSFRBasic.iROIWidth +1;
		pucBufY			=	(unsigned char*)_aligned_malloc(uiPixelSize, _HisCacheLine_Aligned);
		pflSFRBlock	=	(float*)_aligned_malloc(itemshareData.sfrfacaParameter->stSFRBasic.iROIWidth *itemshareData.sfrfacaParameter->stSFRBasic.iROIHeght *sizeof(float), _HisCacheLine_Aligned);
		pdflsfrvalue		=	(double*)_aligned_malloc(isftcurvelen *sizeof(double), _HisCacheLine_Aligned);
		if(!(pucBufY && pflSFRBlock && pdflsfrvalue)){
			iresult	=	HisFX3Error_MallocBuffer;
			_CODE_AFA_ALL_EXIT1
		}

		vecPos.reserve(400);
		vecFOVROI.reserve(13);
		vectorMark.reserve(4);
		//获取锁定黑块的最小值
		if(itemshareData.sfrfacaParameter->stSFRBasic.ucMethod == _His_SFR_Method_2Freq){
			flSFRDirectThreshold[0]	=	max(flSFRDirectThreshold[0], min(itemshareData.sfrfacaParameter->stSFRBasic.flCenter1stFreqSpecH, itemshareData.sfrfacaParameter->stSFRBasic.flCenter1stFreqSpecV) *cflSFRDirectPercent);
			for(unsigned int w=0;	w<itemshareData.sfrfacaParameter->vectorSFRItem.size(); ++w){
				flSFRDirectThreshold[w+1]	=	max(flSFRDirectThreshold[w+1], min(itemshareData.sfrfacaParameter->vectorSFRItem.at(w).fl1stFreqSpecH, itemshareData.sfrfacaParameter->vectorSFRItem.at(w).fl1stFreqSpecV) *cflSFRDirectPercent);
			}
		}
		else{
			flSFRDirectThreshold[0]	=	max(flSFRDirectThreshold[0], min(itemshareData.sfrfacaParameter->stSFRBasic.flCenterMTF50SpecH, itemshareData.sfrfacaParameter->stSFRBasic.flCenterMTF50SpecV) *cflSFRDirectPercent);
			for(unsigned int w=0;	w<itemshareData.sfrfacaParameter->vectorSFRItem.size(); ++w){
				flSFRDirectThreshold[w+1]	=	max(flSFRDirectThreshold[w+1], min(itemshareData.sfrfacaParameter->vectorSFRItem.at(w).flMTF50SpecH, itemshareData.sfrfacaParameter->vectorSFRItem.at(w).flMTF50SpecV) *cflSFRDirectPercent);
			}
		}		
	}
	else{
		switch (itemshareData.previewParameter->ucDataFormat){
		case HisBaylor10_BGGR:
		case HisBaylor12_BGGR:
		case HisBaylor8_BGGR:	emDataFormat	=	HisBaylor8_BGGR;	break;
		case HisBaylor10_RGGB:
		case HisBaylor12_RGGB:
		case HisBaylor8_RGGB:	emDataFormat	=	HisBaylor8_RGGB;	break;
		case HisBaylor10_GRBG:
		case HisBaylor12_GRBG:
		case HisBaylor8_GRBG:	emDataFormat	=	HisBaylor8_GRBG;	break;
		case HisBaylor10_GBRG:
		case HisBaylor12_GBRG:
		case HisBaylor8_GBRG:	emDataFormat	=	HisBaylor8_GBRG;	break;
		case HisBaylor10_MONO:
		case HisBaylor12_MONO:
		case HisBaylor8_MONO:	emDataFormat	=	HisBaylor8_MONO;	break;
		case HisRGB_RGB24:		break;
		default:
			uiRawImgSize		=	itemshareData.previewParameter->iWidth * itemshareData.previewParameter->iHeight *2;
			ucFrameType		=	_FrameType_Raw;
			break;
		}

		pucBufY			=	(unsigned char*)_aligned_malloc(iImgWidth *iImgHeight, _HisCacheLine_Aligned);
		if(!pucBufY){
			iresult	=	HisFX3Error_MallocBuffer;
			_CODE_AFA_ALL_EXIT1
		}

		vectorRectFov4.resize(itemshareData.lpmfaParameter->vectorLpItem.size());
		vectorBlock.reserve(32);
		vectorMark.reserve(4);

		for(unsigned int x=0;	x<itemshareData.lpmfaParameter->vectorLpItem.size();	++x){
			flChartLpValueMax	=	max(flChartLpValueMax, itemshareData.lpmfaParameter->vectorLpItem.at(x).usLPMax);
		}
	}


	pucBufRaw		=	(unsigned char*)_aligned_malloc(uiRawImgSize, _HisCacheLine_Aligned);
	pucBufRaw10		=	(unsigned char*)_aligned_malloc(uiRawImgSize_Raw10, _HisCacheLine_Aligned);
	if(!pucBufRaw){
		iresult	=	HisFX3Error_MallocBuffer;
		_CODE_AFA_ALL_EXIT1
	}

	_HisCCMAlg_ImageBuffer stImgBuffer;
	stImgBuffer.pvImgBuf			=	(void*)(pucBufY);
	stImgBuffer.iImgWidth		=	iImgWidth;
	stImgBuffer.iImgHeight		=	iImgHeight;
	stImgBuffer.enumFormat	=	_HisCCMAlg_ImageBuffer_Type_Y_U8;
	stImgBuffer.enumChannel	=	_HisCCMAlg_ImageBuffer_Channel_Y; 
#endif

	/*第一步旋转策略*/
#if 1
	double dflAbsAngle	=	0.0;
	bool bCW=true;
	if(itemshareData.afaBasicStacticsParameter->uc1stCWMode == 1 && itemshareData.afaBasicStacticsParameter->fl1stCWAngle > 0.0f)
	{

		//if(iresult = RAUTOMATION::AutoFARingRotate(itemshareData.afaBasicStacticsParameter->fl1stCWAngle *-1.0, false, pclassControl))  _CODE_AFA_ALL_EXIT1
		emit information(QString("angle:%1").arg(itemshareData.afaBasicStacticsParameter->fl1stCWAngle *-1.0));

			if(itemshareData.afaBasicStacticsParameter->bUpCheckEveryStep)
			{

				if(iresult = RAUTOMATION::AutoFAAxisZMoveR(itemshareData.afaBasicStacticsParameter->flEveryUpDis *-1.0, pclassControl)) _CODE_AFA_ALL_EXIT1

			}
			::Sleep(itemshareData.afaBasicStacticsParameter->usoperatedelay);

	}
	else if(itemshareData.afaBasicStacticsParameter->uc1stCWMode == 2)
	{

		if(itemshareData.afaBasicStacticsParameter->bUpCheckEveryStep)
		{

			if(iresult = RAUTOMATION::AutoFAAxisZMoveR(itemshareData.afaBasicStacticsParameter->flEveryUpDis *-1.0, pclassControl)) _CODE_AFA_ALL_EXIT1

		}
		::Sleep(itemshareData.afaBasicStacticsParameter->usoperatedelay);

	}
	else if(itemshareData.afaBasicStacticsParameter->bUpCheckEveryStep){
		if(iresult = RAUTOMATION::AutoFAAxisZMoveR(itemshareData.afaBasicStacticsParameter->flEveryUpDis *-1.0, pclassControl)) _CODE_AFA_ALL_EXIT1
	}
#endif

#if 1
	std::vector<_itemDraw> vectorDraw;
	vectorDraw.reserve(300);
	std::vector<_itemDraw>::iterator iteratorDraw;
	std::vector<_HisAutoFA_Rolongo_DataItem> vectorItemData;
	std::vector<_HisAutoFA_Rolongo_DataItem>::iterator iteratorItemData;

	unsigned char ucRetry1CCW = 0, ucRetry1CW = 0, ucRetry2CCW = 0, ucRetry2CW = 0, ucDirect = 0xFF, ucType = 0x0;
	unsigned int uiProcess = 0; //0-CCW 1-CW 2-retry1 3-upcheck 4-retry2 5-upcheck2 6-underspin
	int iCCWStatus = -1, iCWStatus = -1;
	double dflUpDistance = 0.0, dflRetry1AbsAngle = 0.0, dflRetry2AbsAngle = 0.0;
	double dflUnderSpinBest = 0.0;
	float* pflValue1, *pflValue2, *pflValue3;
	float flRetry1CCWWeight = 0.0f, flRetry1CWWeight = 0.0f, flRetry2CCWWeight = 0.0f, flRetry2CWWeight = 0.0f;
	_itemStatus itemstatus;
	itemstatus.ucstatus	=	_His_ItemStatus_NG;
	itemstatus.usitem		=	autofageneralitem;
#endif

	// 获取Mark点距离，移动到具体位置
#ifdef USE_AFC_Fitting 

	/*定义参数*/


	//捉一张RGB24图像
	//
	if(iresult	=	GetFreshframe(pucBufRaw, uiRawImgSize, ucFrameType, true)) { _CODE_AFA_ALL_EXIT1}
	double dflDist[5]={0};
	double dflAngle1=0;
	double dflAngOffset=itemshareData.afaBasicStacticsParameter->fltoBestAngOffset;
	iresult=fnGetMarkDistance(pucBufRaw,NULL,dflDist,iImgWidth,iImgHeight,15,itemshareData.afaBasicStacticsParameter->dflMarkMinArea,\
		itemshareData.afaBasicStacticsParameter->dflMarkMaxArea,itemshareData.afaBasicStacticsParameter->dflMarkMinLength,itemshareData.afaBasicStacticsParameter->dflMarkMaxLength,\
		hisglobalparameter.bDebugMode);

	if(iresult){
		emit information(QString::fromLocal8Bit("无法找到Mark点!"));
		QImage image(pucBufRaw,iImgWidth,iImgHeight,QImage::Format_RGB888);
		image.save("D:\\mark.bmp");

		WCHAR wstr[1024]={0};
		QString str1=QString("MinArea:%1,MaxArea:%2,MinLen:%3,MaxLen:%4").arg(itemshareData.afaBasicStacticsParameter->dflMarkMinArea).arg(itemshareData.afaBasicStacticsParameter->dflMarkMaxArea)\
			.arg(itemshareData.afaBasicStacticsParameter->dflMarkMinLength).arg(itemshareData.afaBasicStacticsParameter->dflMarkMaxLength);
		emit information(str1);
		_CODE_AFA_ALL_EXIT1
	}
	dflAngle1=(itemshareData.afaBasicStacticsParameter->dflMarkTargetDistance-dflDist[0])/itemshareData.afaBasicStacticsParameter->dflMarkStepDistance;
	if(bCW&&dflAngle1>0){
		dflAngle1+=dflAngOffset;
		bCW=true;
	}else if((!bCW)&&dflAngle1<0){
		dflAngle1-=dflAngOffset;
		bCW=false;
	}
	
	if(iresult = RAUTOMATION::AutoFARingRotate(dflAngle1, false, pclassControl))  _CODE_AFA_ALL_EXIT1
	emit information(QString::fromLocal8Bit("Move Angle:%1").arg(dflAngle1));
	
	//   Fitting Move 
	if(!bCW){
		if(iresult = RAUTOMATION::AutoFARingRotate(dflAngOffset*-1, false, pclassControl))  _CODE_AFA_ALL_EXIT1
		
	}

	//  调焦循环
	double dflPolyX[10]={0,8,16,24,32,40,48,56,64,72};
	double dflPolyY[10]={0};
	double dflPeak[9]={0};
	

	for (int i=0;i<10;i++)
	{
		if(i!=0){
			if(iresult = RAUTOMATION::AutoFARingRotate(-8, false, pclassControl))  _CODE_AFA_ALL_EXIT1
		}
		Sleep(200);
		if(iresult	=	GetFreshframe(pucBufRaw, uiRawImgSize, ucFrameType, true)) { _CODE_AFA_ALL_EXIT1}// 捉图

		if(emDataFormat >= HisYUV8_422_YUYV && emDataFormat <= HisYUV8_422_VYUY)
			classAlgorithm.extactYfromYUV422U8(pucBufRaw, pucBufY, iImgWidth*iImgHeight, emDataFormat); //抽取Y通道
		else{ //抽取G通道作为Y通道
			unsigned char* pucSrc = pucBufRaw + 1, *pucDes = pucBufY;
			for(unsigned int x=0;	x<uiPixelSize;	++x){
				*pucDes	=	*pucSrc;
				++pucDes;
				pucSrc	+=	3;
			}
		}

		ROPLOW::AFARolongoItemDataInitial(vectorItemData, itemshareData.afaBasicStacticsParameter, itemshareData.mtffaParameter, \
			itemshareData.sfrfacaParameter, itemshareData.lpmfaParameter, dflAbsAngle, itemshareData.afaBasicStacticsParameter->uclensleafs, \
			itemshareData.afaBasicStacticsParameter->dfllenspitch, ucDirect, ucType,  NULL);

		iteratorItemData	=	vectorItemData.end() - 1;

		pstTemp	=	pstBlock;
		stMTFAutoROI	=	*pstTemp;
		if(itemshareData.mtffaParameter->stMTFBasic.bAutoSeartchROI)
			classRolongoTest.CRolongoBlockAutomaticSearching(stMTFAutoROI, pucBufRaw, iImgWidth, iImgHeight, itemshareData.mtffaParameter->stMTFBasic.iblockwith *4, stMTFAutoROI);
		stMTFAutoROI.left+=global_ioc_x;stMTFAutoROI.right+=global_ioc_x;// 加OC偏移
		stMTFAutoROI.top+=global_ioc_y;stMTFAutoROI.bottom+=global_ioc_y;// 加OC偏移


		if(itemshareData.mtffaParameter->stMTFBasic.algswitch <= 4){
			if(iresult	=	classAlgorithm.HisCCMMTF(pucBufRaw, iImgWidth, iImgHeight, stMTFAutoROI, itemshareData.mtffaParameter->stMTFBasic.algswitch, flvalue)) break;
		}else if(itemshareData.mtffaParameter->stMTFBasic.algswitch == 7){
			if(iresult	=	classRolongoTest.HisCCMMTF(pucBufRaw, iImgWidth, iImgHeight, stMTFAutoROI, itemshareData.mtffaParameter->stMTFBasic.algswitch, flHvalue,flVvalue)) break;
		}
		else{
			if(iresult	=	classRolongoTest.HisCCMMTF(pucBufRaw, iImgWidth, iImgHeight, stMTFAutoROI, itemshareData.mtffaParameter->stMTFBasic.algswitch, flvalue)) break;
		}

		stDataItem_EX.vectorMTFFOV.resize(itemshareData.mtffaParameter->vectorMTFItem.size());
		stDataItem_EX.stMTFCenterBlock =	stMTFAutoROI;
		iteratorItemData->stMTFCenterBlock		=	stMTFAutoROI;

		if(itemshareData.mtffaParameter->stMTFBasic.algswitch != 7){
			iteratorItemData->flMTFCenterValue		=	flvalue;
		}else{
			iteratorItemData->flMTFCenterValue		=	(flHvalue+flVvalue)/2;
			stDataItem_EX.flMTFCenterValue		=	(flHvalue+flVvalue)/2;
			stDataItem_EX.flMTFCenterValue_H		=	flHvalue;
			stDataItem_EX.flMTFCenterValue_V		=	flVvalue;
		}
		dflPolyY[i]=iteratorItemData->flMTFCenterValue;

		pstTemp++;
		for(unsigned int y=0;	y<itemshareData.mtffaParameter->vectorMTFItem.size(); ++y){
				flmax	=	-99999.0f; flmin	=	99999.0f;
				for(unsigned int x=0;	x<itemshareData.mtffaParameter->vectorMTFItem.at(y).ucBlockCount; ++x){
					stMTFAutoROI	=	*pstTemp;
					if(itemshareData.mtffaParameter->stMTFBasic.bAutoSeartchROI)
						classRolongoTest.CRolongoBlockAutomaticSearching(stMTFAutoROI, pucBufRaw, iImgWidth, iImgHeight, itemshareData.mtffaParameter->stMTFBasic.iblockwith *4, stMTFAutoROI);
					stMTFAutoROI.left+=global_ioc_x;stMTFAutoROI.right+=global_ioc_x;// 加OC偏移
					stMTFAutoROI.top+=global_ioc_y;stMTFAutoROI.bottom+=global_ioc_y;// 加OC偏移

					if(itemshareData.mtffaParameter->stMTFBasic.algswitch <= 4){
						if(iresult	=	classAlgorithm.HisCCMMTF(pucBufRaw, iImgWidth, iImgHeight, stMTFAutoROI, itemshareData.mtffaParameter->stMTFBasic.algswitch, flvalue)) break;
					}else if(itemshareData.mtffaParameter->stMTFBasic.algswitch == 7){
						if(iresult	=	classRolongoTest.HisCCMMTF(pucBufRaw, iImgWidth, iImgHeight, stMTFAutoROI, itemshareData.mtffaParameter->stMTFBasic.algswitch, flHvalue,flVvalue)) break;
					}
					else{
						if(iresult	=	classRolongoTest.HisCCMMTF(pucBufRaw, iImgWidth, iImgHeight, stMTFAutoROI, itemshareData.mtffaParameter->stMTFBasic.algswitch, flvalue)) break;
					}

					if(itemshareData.mtffaParameter->stMTFBasic.algswitch != 7){
						iteratorItemData->vectorMTFFOV.at(y).flValue[x]	=	flvalue;
					}else{
						iteratorItemData->vectorMTFFOV.at(y).flValue[x]	=	(flHvalue+flVvalue)/2;
						stDataItem_EX.vectorMTFFOV.at(y).flValue[x]	=	(flHvalue+flVvalue)/2;
						stDataItem_EX.vectorMTFFOV.at(y).flHValue[x]=flHvalue;
						stDataItem_EX.vectorMTFFOV.at(y).flVValue[x]=flVvalue;
					}

					iteratorItemData->vectorMTFFOV.at(y).stBlock[x]	=	stMTFAutoROI;
					stDataItem_EX.vectorMTFFOV.at(y).stBlock[x]	=	stMTFAutoROI;
					pstTemp++;
					flmax	=	max(flmax, flvalue);
					flmin		=	min(flmin, flvalue);
				}
				if(iresult) break;
				iteratorItemData->vectorMTFFOV.at(y).flUniformValue	=	flmax - flmin;
			}

			if(iresult) break;

			
			if(itemshareData.mtffaParameter->stMTFBasic.algswitch != 7)
				ROPLOW::AddDrawMTFHA(*iteratorItemData, iImgWidth, iImgHeight, vectorDraw);
			else
				ROPLOW::AddDrawMTFHE(stDataItem_EX, iImgWidth, iImgHeight, vectorDraw,*itemshareData.mtffaParameter);

			_CODE_RJAFA_LP_ASIGNDRAW
	}

	fnPolyfit(dflPolyX,dflPolyY,10,9,dflPeak);
	
	double dflNewPolyY[73]={0};
	double dflNewPolyX[73]={0};
	fnPolyval(dflNewPolyX,dflNewPolyY,73,dflPeak,9);
	int maxIdx=0,maxVal=0;
	for (int i=0;i<73;i++)
	{
		if(dflNewPolyY[i]>maxVal){
			maxIdx=i;
			maxVal=dflNewPolyY[i];
		}
	}

	if(iresult = RAUTOMATION::AutoFARingRotate(dflAngOffset+72-maxIdx, false, pclassControl))  _CODE_AFA_ALL_EXIT1
	emit information(QString::fromLocal8Bit("Move To Peak:%1").arg(72-maxIdx));

#else



	/*调焦主循环*/
	for(unsigned short uistepcount = 0; uistepcount < itemshareData.afaBasicStacticsParameter->ussteplimit && threadshareData.GetHisPreviewflag(); ++uistepcount)
	{
		/*捉图并转成Y通道*/
#if 1
		vectorDraw.clear();
		vecFOVROI.clear();
		bNext	=	true;
		//捉一张RGB24图像
		if(iresult	=	GetFreshframe(pucBufRaw, uiRawImgSize, ucFrameType, !uistepcount)) { _CODE_AFA_ALL_EXIT1}
		

		if(itemshareData.afaBasicStacticsParameter->ucChartType != _HisCCMAlg_Rolongo_Chart_MTF_A && \
			itemshareData.afaBasicStacticsParameter->ucChartType != _HisCCMAlg_Rolongo_Chart_MTF_B){
				if(emDataFormat >= HisYUV8_422_YUYV && emDataFormat <= HisYUV8_422_VYUY)
					classAlgorithm.extactYfromYUV422U8(pucBufRaw, pucBufY, iImgWidth*iImgHeight, emDataFormat); //抽取Y通道
				else{ //抽取G通道作为Y通道
					unsigned char* pucSrc = pucBufRaw + 1, *pucDes = pucBufY;
					for(unsigned int x=0;	x<uiPixelSize;	++x){
						*pucDes	=	*pucSrc;
						++pucDes;
						pucSrc	+=	3;
					}
				}
		}
#endif
		/*初始化MTF规格参数*/
#if 1
		ROPLOW::AFARolongoItemDataInitial(vectorItemData, itemshareData.afaBasicStacticsParameter, itemshareData.mtffaParameter, \
			itemshareData.sfrfacaParameter, itemshareData.lpmfaParameter, dflAbsAngle, itemshareData.afaBasicStacticsParameter->uclensleafs, \
			itemshareData.afaBasicStacticsParameter->dfllenspitch, ucDirect, ucType,  NULL);


		iteratorItemData	=	vectorItemData.end() - 1;
#endif
		/*MTF 计算*/
#if 1
		if(itemshareData.afaBasicStacticsParameter->ucChartType == _HisCCMAlg_Rolongo_Chart_MTF_A || \
			itemshareData.afaBasicStacticsParameter->ucChartType == _HisCCMAlg_Rolongo_Chart_MTF_B)
		{
			pstTemp	=	pstBlock;
			stMTFAutoROI	=	*pstTemp;
			if(itemshareData.mtffaParameter->stMTFBasic.bAutoSeartchROI)
				classRolongoTest.CRolongoBlockAutomaticSearching(stMTFAutoROI, pucBufRaw, iImgWidth, iImgHeight, itemshareData.mtffaParameter->stMTFBasic.iblockwith *4, stMTFAutoROI);
			stMTFAutoROI.left+=global_ioc_x;stMTFAutoROI.right+=global_ioc_x;// 加OC偏移
			stMTFAutoROI.top+=global_ioc_y;stMTFAutoROI.bottom+=global_ioc_y;// 加OC偏移


			if(itemshareData.mtffaParameter->stMTFBasic.algswitch <= 4){
				if(iresult	=	classAlgorithm.HisCCMMTF(pucBufRaw, iImgWidth, iImgHeight, stMTFAutoROI, itemshareData.mtffaParameter->stMTFBasic.algswitch, flvalue)) break;
			}else if(itemshareData.mtffaParameter->stMTFBasic.algswitch == 7){
				if(iresult	=	classRolongoTest.HisCCMMTF(pucBufRaw, iImgWidth, iImgHeight, stMTFAutoROI, itemshareData.mtffaParameter->stMTFBasic.algswitch, flHvalue,flVvalue)) break;
			}
			else{
				if(iresult	=	classRolongoTest.HisCCMMTF(pucBufRaw, iImgWidth, iImgHeight, stMTFAutoROI, itemshareData.mtffaParameter->stMTFBasic.algswitch, flvalue)) break;
			}

			stDataItem_EX.vectorMTFFOV.resize(itemshareData.mtffaParameter->vectorMTFItem.size());
			stDataItem_EX.stMTFCenterBlock =	stMTFAutoROI;
			iteratorItemData->stMTFCenterBlock		=	stMTFAutoROI;

			if(itemshareData.mtffaParameter->stMTFBasic.algswitch != 7){
				iteratorItemData->flMTFCenterValue		=	flvalue;
			}else{
				iteratorItemData->flMTFCenterValue		=	(flHvalue+flVvalue)/2;
				stDataItem_EX.flMTFCenterValue		=	(flHvalue+flVvalue)/2;
				stDataItem_EX.flMTFCenterValue_H		=	flHvalue;
				stDataItem_EX.flMTFCenterValue_V		=	flVvalue;
			}


			pstTemp++;

			for(unsigned int y=0;	y<itemshareData.mtffaParameter->vectorMTFItem.size(); ++y){
				flmax	=	-99999.0f; flmin	=	99999.0f;
				for(unsigned int x=0;	x<itemshareData.mtffaParameter->vectorMTFItem.at(y).ucBlockCount; ++x){
					stMTFAutoROI	=	*pstTemp;
					if(itemshareData.mtffaParameter->stMTFBasic.bAutoSeartchROI)
						classRolongoTest.CRolongoBlockAutomaticSearching(stMTFAutoROI, pucBufRaw, iImgWidth, iImgHeight, itemshareData.mtffaParameter->stMTFBasic.iblockwith *4, stMTFAutoROI);
					stMTFAutoROI.left+=global_ioc_x;stMTFAutoROI.right+=global_ioc_x;// 加OC偏移
					stMTFAutoROI.top+=global_ioc_y;stMTFAutoROI.bottom+=global_ioc_y;// 加OC偏移

					if(itemshareData.mtffaParameter->stMTFBasic.algswitch <= 4){
						if(iresult	=	classAlgorithm.HisCCMMTF(pucBufRaw, iImgWidth, iImgHeight, stMTFAutoROI, itemshareData.mtffaParameter->stMTFBasic.algswitch, flvalue)) break;
					}else if(itemshareData.mtffaParameter->stMTFBasic.algswitch == 7){
						if(iresult	=	classRolongoTest.HisCCMMTF(pucBufRaw, iImgWidth, iImgHeight, stMTFAutoROI, itemshareData.mtffaParameter->stMTFBasic.algswitch, flHvalue,flVvalue)) break;
						/*if(iteratorItemData->vectorMTFFOV.at(y).flFOV==0.7f){
							if(iresult	=	fnMTF(ImgInfo,stMTFAutoROI,flHvalue,flVvalue,true));
						}else{
							if(iresult	=	fnMTF(ImgInfo,stMTFAutoROI,flHvalue,flVvalue,FALSE));
						}*/
					}
					else{
						if(iresult	=	classRolongoTest.HisCCMMTF(pucBufRaw, iImgWidth, iImgHeight, stMTFAutoROI, itemshareData.mtffaParameter->stMTFBasic.algswitch, flvalue)) break;
					}

					if(itemshareData.mtffaParameter->stMTFBasic.algswitch != 7){
						iteratorItemData->vectorMTFFOV.at(y).flValue[x]	=	flvalue;
					}else{
						iteratorItemData->vectorMTFFOV.at(y).flValue[x]	=	(flHvalue+flVvalue)/2;
						stDataItem_EX.vectorMTFFOV.at(y).flValue[x]	=	(flHvalue+flVvalue)/2;
						stDataItem_EX.vectorMTFFOV.at(y).flHValue[x]=flHvalue;
						stDataItem_EX.vectorMTFFOV.at(y).flVValue[x]=flVvalue;
					}

					iteratorItemData->vectorMTFFOV.at(y).stBlock[x]	=	stMTFAutoROI;
					stDataItem_EX.vectorMTFFOV.at(y).stBlock[x]	=	stMTFAutoROI;
					pstTemp++;
					flmax	=	max(flmax, flvalue);
					flmin		=	min(flmin, flvalue);
				}
				if(iresult) break;
				iteratorItemData->vectorMTFFOV.at(y).flUniformValue	=	flmax - flmin;
			}

			if(iresult) break;

			if(itemshareData.mtffaParameter->stMTFBasic.algswitch != 7)
				ROPLOW::AddDrawMTFHA(*iteratorItemData, iImgWidth, iImgHeight, vectorDraw);
			else
				ROPLOW::AddDrawMTFHE(stDataItem_EX, iImgWidth, iImgHeight, vectorDraw,*itemshareData.mtffaParameter);

			float flMTFPt1X, flMTFPt1Y, flMTFPt2X, flMTFPt2Y;
			RECT stMTKMark1, stMTKMark2;
			if(itemshareData.afaBasicStacticsParameter->ucChartType == _HisCCMAlg_Rolongo_Chart_MTF_B && \
				itemshareData.afaBasicStacticsParameter->bUseMark){
					ROPLOW::AddDrawMark4(stMTKMark1, stMTKMark2, vectorDraw);
					if(!classRolongoTest.cvRolongoMTFChartMarkDetect(pucBufRaw, iImgWidth, iImgHeight, itemshareData.afaBasicStacticsParameter->flMTFBMarkRangeX, \
						itemshareData.afaBasicStacticsParameter->flMTFBMarkRangeY, itemshareData.afaBasicStacticsParameter->flMTFBMarkRangeYMax, \
						flMTFPt1X, flMTFPt1Y, flMTFPt2X, flMTFPt2Y, stMTKMark1, stMTKMark2, itemshareData.afaBasicStacticsParameter->bXYReversal)){
							iteratorItemData->dflMarkDistance	=	sqrt((flMTFPt1X-flMTFPt2X)*(flMTFPt1X-flMTFPt2X) + (flMTFPt1Y-flMTFPt2Y)*(flMTFPt1Y-flMTFPt2Y));
							ROPLOW::AddDrawMark3(flMTFPt1X, flMTFPt1Y, flMTFPt2X, flMTFPt2Y,  vectorDraw);
					}
			}		
		}
#endif
		/*SFR 计算*/
#if 1
		else if(itemshareData.afaBasicStacticsParameter->ucChartType == _HisCCMAlg_Rolongo_Chart_SFR_A)
		{
			if(iresult = classAlgorithm.decodeSFRChartTAHA(pucBufY, iImgWidth, iImgHeight, itemshareData.sfrfacaParameter->stSFRBasic.usMarkSideMin, \
				itemshareData.sfrfacaParameter->stSFRBasic.usMarkSideMax, vecPos)){
					emit information(QTextCodec::codecForName( "GBK")->toUnicode("无法提取出CHART轮廓信息"));
					bNext	=	false;
			}

			if(vecPos.size() < 1){
				emit information(QTextCodec::codecForName( "GBK")->toUnicode("无法提取出CHART轮廓信息"));
				bNext	=	false;
			}

			if(bNext){
				//center
				vecFOVROI.clear();
				iresult = classAlgorithm.getSFRFOVPos(vecPos, iImgWidth, iImgHeight, 0.0f, 0.0f, itemshareData.sfrfacaParameter->stSFRBasic.iROIWidth, \
					itemshareData.sfrfacaParameter->stSFRBasic.iROIHeght, itemshareData.sfrfacaParameter->stSFRBasic.usFOVOffset, vecFOVROI, 4, ucSFRDirect);
				if(iresult){
					emit information(QTextCodec::codecForName( "GBK")->toUnicode("无法提取中心位置信息"));
					bNext	=	false;
				}
				else{
					bAllValueMeetDirect	=	true;
					iteratorFOVROI	=	vecFOVROI.begin();
					iteratorItemData->stSFRCenterBlock	=	*iteratorFOVROI;
					for(unsigned int x=0;	x<4;	++x){
						switch (x){
						case 0: pstTemp = &(iteratorFOVROI->stLeft); pflValue1 = &(iteratorItemData->stSFRCenterMTF50.flValueH_L); \
									pflValue2 = &(iteratorItemData->stSFRCenterFreq1.flValueH_L); pflValue3 = &(iteratorItemData->stSFRCenterFreq2.flValueH_L); break;
						case 1: pstTemp = &(iteratorFOVROI->stRight); pflValue1 = &(iteratorItemData->stSFRCenterMTF50.flValueH_R); \
									pflValue2 = &(iteratorItemData->stSFRCenterFreq1.flValueH_R); pflValue3 = &(iteratorItemData->stSFRCenterFreq2.flValueH_R); break;
						case 2: pstTemp = &(iteratorFOVROI->stTop); pflValue1 = &(iteratorItemData->stSFRCenterMTF50.flValueV_T); \
									pflValue2 = &(iteratorItemData->stSFRCenterFreq1.flValueV_T); pflValue3 = &(iteratorItemData->stSFRCenterFreq2.flValueV_T); break;
						default: pstTemp = &(iteratorFOVROI->stBottom); pflValue1 = &(iteratorItemData->stSFRCenterMTF50.flValueV_B); \
									 pflValue2 = &(iteratorItemData->stSFRCenterFreq1.flValueV_B); pflValue3 = &(iteratorItemData->stSFRCenterFreq2.flValueV_B); break;
						}
						// 					emit information("left: " % QString::number(pstBlock->left) % "right: " % QString::number(pstBlock->right) % \
						//  						"top: " % QString::number(pstBlock->top) % "bottom: " % QString::number(pstBlock->bottom));

						if(bUseYUV_Y)	ROPLOW::GetPartYFromY(pucBufY, iImgWidth, iImgHeight, *pstTemp, pflSFRBlock);
						else ROPLOW::GetPartImageFromRGB24(pucBufRaw, iImgWidth, iImgHeight, itemshareData.sfrfacaParameter->stSFRBasic.ucChannel, *pstTemp, pflSFRBlock);
						classAlgorithm.HisCCMSFROne(pflSFRBlock, itemshareData.sfrfacaParameter->stSFRBasic.iROIWidth, itemshareData.sfrfacaParameter->stSFRBasic.iROIHeght, \
							itemshareData.sfrfacaParameter->stSFRBasic.ucMinCantrast, pdflsfrvalue, isftcurvelen, flmtf50);
						if(itemshareData.sfrfacaParameter->stSFRBasic.ucMethod == _His_SFR_Method_2Freq){
							if(isftcurvelen){
								*pflValue2	= ROPLOW::GetSFRFreqValue(pdflsfrvalue, isftcurvelen, itemshareData.sfrfacaParameter->stSFRBasic.uc1stFreq);
								if(*pflValue2 < flSFRDirectThreshold[0]) bAllValueMeetDirect = false;
								if(itemshareData.sfrfacaParameter->stSFRBasic.b2ndFreq)
									*pflValue3	= ROPLOW::GetSFRFreqValue(pdflsfrvalue, isftcurvelen, itemshareData.sfrfacaParameter->stSFRBasic.uc2ndFreq);
							}
							else bAllValueMeetDirect = false;
						}
						else{
							*pflValue1	=	flmtf50;
							if(*pflValue1 < flSFRDirectThreshold[0]) bAllValueMeetDirect = false;
						}
					}

					if(bAllValueMeetDirect && ucSFRDirect[0] == 2) ucSFRDirect[0] = (fabsf(iteratorItemData->stSFRCenterBlock.flAngle) <45.0f)?(0):(1);

					ROPLOW::AddDrawSFRHAMFA(*iteratorFOVROI, iteratorItemData->stSFRCenterMTF50, iteratorItemData->stSFRCenterFreq1, \
						iteratorItemData->stSFRCenterFreq2, itemshareData.sfrfacaParameter, 0xFFFFFFFF, vectorDraw, itemshareData.sfrfacaParameter->stSFRBasic.flGradeMultiple);
				}

				//FOV
				for(unsigned int w=0;	w<itemshareData.sfrfacaParameter->vectorSFRItem.size();	++w){
					vecFOVROI.clear();
					if(iresult = classAlgorithm.getSFRFOVPos(vecPos, iImgWidth, iImgHeight, itemshareData.sfrfacaParameter->vectorSFRItem.at(w).flFOV, \
						itemshareData.sfrfacaParameter->vectorSFRItem.at(w).flAngle, itemshareData.sfrfacaParameter->stSFRBasic.iROIWidth, itemshareData.sfrfacaParameter->stSFRBasic.iROIHeght, \
						itemshareData.sfrfacaParameter->stSFRBasic.usFOVOffset, vecFOVROI, 	itemshareData.sfrfacaParameter->vectorSFRItem.at(w).ucBlockCount, &ucSFRDirect[w*4+1])){
							emit information(QTextCodec::codecForName( "GBK")->toUnicode("无法提取") % \
								QString::number(itemshareData.sfrfacaParameter->vectorSFRItem.at(w).flFOV, 'f', 2) % \
								QTextCodec::codecForName( "GBK")->toUnicode("FOV位置信息"));
							bNext	=	false;
					}
					else{
						iteratorFOVROI	=	vecFOVROI.begin();				
						for(unsigned int y=0;	y<itemshareData.sfrfacaParameter->vectorSFRItem.at(w).ucBlockCount;	++y)
						{	
							bAllValueMeetDirect	=	true;
							for(unsigned int x=0;	x<4;	++x){
								switch (x){
								case 0: pstTemp = &(iteratorFOVROI->stLeft); pflValue1 = &(iteratorItemData->vectorSFRFOV.at(w).stSFRMTF50[y].flValueH_L); \
											pflValue2 = &(iteratorItemData->vectorSFRFOV.at(w).stSFRFreq1[y].flValueH_L); pflValue3 = &(iteratorItemData->vectorSFRFOV.at(w).stSFRFreq2[y].flValueH_L); break;
								case 1: pstTemp = &(iteratorFOVROI->stRight); pflValue1 = &(iteratorItemData->vectorSFRFOV.at(w).stSFRMTF50[y].flValueH_R); \
											pflValue2 = &(iteratorItemData->vectorSFRFOV.at(w).stSFRFreq1[y].flValueH_R); pflValue3 = &(iteratorItemData->vectorSFRFOV.at(w).stSFRFreq2[y].flValueH_R); break;
								case 2: pstTemp = &(iteratorFOVROI->stTop); pflValue1 = &(iteratorItemData->vectorSFRFOV.at(w).stSFRMTF50[y].flValueV_T); \
											pflValue2 = &(iteratorItemData->vectorSFRFOV.at(w).stSFRFreq1[y].flValueV_T); pflValue3 = &(iteratorItemData->vectorSFRFOV.at(w).stSFRFreq2[y].flValueV_T); break;
								default: pstTemp = &(iteratorFOVROI->stBottom); pflValue1 = &(iteratorItemData->vectorSFRFOV.at(w).stSFRMTF50[y].flValueV_B); \
											 pflValue2 = &(iteratorItemData->vectorSFRFOV.at(w).stSFRFreq1[y].flValueV_B); pflValue3 = &(iteratorItemData->vectorSFRFOV.at(w).stSFRFreq2[y].flValueV_B); break;
								}

								if(bUseYUV_Y)	ROPLOW::GetPartYFromY(pucBufY, iImgWidth, iImgHeight, *pstTemp, pflSFRBlock);
								else ROPLOW::GetPartImageFromRGB24(pucBufRaw, iImgWidth, iImgHeight, itemshareData.sfrfacaParameter->stSFRBasic.ucChannel, *pstTemp, pflSFRBlock);
								classAlgorithm.HisCCMSFROne(pflSFRBlock, itemshareData.sfrfacaParameter->stSFRBasic.iROIWidth, itemshareData.sfrfacaParameter->stSFRBasic.iROIHeght, \
									itemshareData.sfrfacaParameter->stSFRBasic.ucMinCantrast, pdflsfrvalue, isftcurvelen, flmtf50);
								if(itemshareData.sfrfacaParameter->stSFRBasic.ucMethod == _His_SFR_Method_2Freq){
									if(isftcurvelen){
										*pflValue2	= ROPLOW::GetSFRFreqValue(pdflsfrvalue, isftcurvelen, itemshareData.sfrfacaParameter->stSFRBasic.uc1stFreq);
										if(*pflValue2 < flSFRDirectThreshold[w+1]) bAllValueMeetDirect = false;
										if(itemshareData.sfrfacaParameter->stSFRBasic.b2ndFreq)
											*pflValue3	= ROPLOW::GetSFRFreqValue(pdflsfrvalue, isftcurvelen, itemshareData.sfrfacaParameter->stSFRBasic.uc2ndFreq);
									}
									else bAllValueMeetDirect = false;
								}
								else{
									*pflValue1	=	flmtf50;
									if(*pflValue1 < flSFRDirectThreshold[w+1]) bAllValueMeetDirect = false;
								}
							}

							if(bAllValueMeetDirect && ucSFRDirect[w*4+1+y] == 2) ucSFRDirect[w*4+1+y] = (fabsf(iteratorFOVROI->flAngle) < 45.0f)?(0):(1);

							ROPLOW::AddDrawSFRHAMFA(*iteratorFOVROI, iteratorItemData->vectorSFRFOV.at(w).stSFRMTF50[y], iteratorItemData->vectorSFRFOV.at(w).stSFRFreq1[y], \
								iteratorItemData->vectorSFRFOV.at(w).stSFRFreq2[y], itemshareData.sfrfacaParameter, w, vectorDraw, itemshareData.sfrfacaParameter->stSFRBasic.flGradeMultiple);
							iteratorItemData->vectorSFRFOV.at(w).stBlock[y]	=	*iteratorFOVROI;
							iteratorFOVROI++;
						}
					}
				}

				if(bNext){
					if(!classAlgorithm.getSFRAMarkDistance(vecPos, itemshareData.previewParameter->iWidth, itemshareData.previewParameter->iHeight, \
						itemshareData.sfrfacaParameter->stSFRBasic.usFOVOffset, itemshareData.afaBasicStacticsParameter->ucSFRAMarkBlockCount, \
						dflDistance, vectorMark)){
							iteratorItemData->dflMarkDistance		=	dflDistance;
							ROPLOW::AddDrawMark2(vectorMark, vectorDraw);
					}				
				}
			}
		}
#endif
		/*TV Line计算*/
#if 1
		else
		{ //TV Line
			ROPLOW::AddDrawEllipse((iImgWidth>>1), (iImgHeight >>1), iImgWidth, iImgHeight, itemshareData.lpmfaParameter->stLpBasic.dflConstMarkFMin, 1, vectorDraw);
			ROPLOW::AddDrawEllipse((iImgWidth>>1), (iImgHeight >>1), iImgWidth, iImgHeight, itemshareData.lpmfaParameter->stLpBasic.dflConstMarkFMax, 1, vectorDraw);

			bNext	=	true;
			if(iresult = classAlgorithm.HisCCMlinePairDetectHA((char*)(pucBufY), iImgWidth, iImgHeight, itemshareData.lpmfaParameter->stLpBasic.usConstLPWMin, \
				itemshareData.lpmfaParameter->stLpBasic.usConstLPWMax,itemshareData.lpmfaParameter->stLpBasic.usConstLPHMin, itemshareData.lpmfaParameter->stLpBasic.usConstLPHMax,\
				itemshareData.lpmfaParameter->stLpBasic.usConstMarkPMin, itemshareData.lpmfaParameter->stLpBasic.usConstMarkPMax, itemshareData.lpmfaParameter->stLpBasic.dflConstMarkFMin, \
				itemshareData.lpmfaParameter->stLpBasic.dflConstMarkFMax,itemshareData.lpmfaParameter->stLpBasic.dflConstMarkAngle,  \
				itemshareData.lpmfaParameter->stLpBasic.usConstExpandW, itemshareData.lpmfaParameter->stLpBasic.usConstExpandH, \
				iCenterX, iCenterY, dflAngle, dflDistance, vectorBlock, vectorMark)){
					emit information(QTextCodec::codecForName( "GBK")->toUnicode("无法提取出MARK点的位置信息"));
					bNext	=	false;
			}

			if(bNext){
				iteratorItemData->dflMarkDistance		=	dflDistance;
				for(unsigned int x=0;	x<itemshareData.lpmfaParameter->vectorLpItem.size(); ++x)
					ROPLOW::AddDesiredFOV4Cross(dflDistance*itemshareData.lpmfaParameter->vectorLpItem.at(x).flFOV, itemshareData.lpmfaParameter->vectorLpItem.at(x).flAngle, iCenterX, iCenterY, vectorDraw);
				ROPLOW::AddDrawMark(vectorMark, 1, vectorDraw);

				for(unsigned int x=0;	x<itemshareData.lpmfaParameter->vectorLpItem.size(); ++x){
					iresult	=	classAlgorithm.HisCCMExtractLPDetectHBFOV4(vectorBlock, iImgWidth, iImgHeight, iCenterX, iCenterY, \
						itemshareData.lpmfaParameter->vectorLpItem.at(x).flFOV*dflDistance, itemshareData.lpmfaParameter->vectorLpItem.at(x).flAngle, \
						itemshareData.lpmfaParameter->stLpBasic.usFOVDisDev, stRectFOV4);
					if(iresult)	{
						emit information(QTextCodec::codecForName( "GBK")->toUnicode("无法提取线对位置信息 FOV: ") % QString::number(itemshareData.lpmfaParameter->vectorLpItem.at(x).flFOV));
						bNext	=	false;
						continue;
					}

					ROPLOW::AddDrawFOV4(stRectFOV4, 1, vectorDraw);
					vectorRectFov4.at(x)	=	stRectFOV4;
					for(unsigned int i=0;	i<4; ++i){
						iresult	=	classAlgorithm.HisCCMLinePairValueHA(stImgBuffer,  vectorRectFov4.at(x).stBlocks[i], itemshareData.lpmfaParameter->vectorLpItem.at(x).ucConstLPNum, \
							itemshareData.lpmfaParameter->vectorLpItem.at(x).ucConstThresholdB8, itemshareData.lpmfaParameter->vectorLpItem.at(x).usLPMin, \
							itemshareData.lpmfaParameter->vectorLpItem.at(x).usLPMax, dflAngle, itemshareData.lpmfaParameter->vectorLpItem.at(x).flValueOffset, dflValue, stValueLine, stMinLine, stMaxLine);
						if(vectorRectFov4.at(x).stBlocks[i].right-vectorRectFov4.at(x).stBlocks[i].left > vectorRectFov4.at(x).stBlocks[i].bottom - vectorRectFov4.at(x).stBlocks[i].top)
							ROPLOW::AddDrawLP(vectorRectFov4.at(x).stBlocks[i], stValueLine, stMaxLine, stMinLine, iImgWidth, iImgHeight,itemshareData.lpmfaParameter->vectorLpItem.at(x).flSpecVec, dflValue, 1, vectorDraw, itemshareData.lpmfaParameter->stLpBasic.flGradeMultiple);
						else
							ROPLOW::AddDrawLP(vectorRectFov4.at(x).stBlocks[i], stValueLine, stMaxLine, stMinLine, iImgWidth, iImgHeight, itemshareData.lpmfaParameter->vectorLpItem.at(x).flSpecHor, dflValue, 1, vectorDraw, itemshareData.lpmfaParameter->stLpBasic.flGradeMultiple);
						ROPLOW::AFCItemDataAdd(vectorItemData, vectorRectFov4.at(x).stBlocks[i],  stValueLine, stMaxLine, stMinLine, dflValue, x, i);
					}
				}

			}
		}
#endif
		/*计算下一步调焦角度*/
#if 1
		_CODE_RJAFA_LP_ASIGNDRAW
		
		classAlgorithm.HisAFATactics_Rolongo_CaculateValue(*(itemshareData.afaBasicStacticsParameter), vectorItemData);
		dflAbsAngle		=	iteratorItemData->dflAbsAngle;
#endif
		//0-CCW 1-CW 2-retry1 3-upcheck 4-retry2 5-upcheck2 6-underspin
		/*CCW*/
#if 1
		if(uiProcess == 0)
		{
			// 			if(itemshareData.afaBasicStacticsParameter->ucDirection == 0x0){ //反旋
			if(iresult = classAlgorithm.HisAFATactics_ALL_CCW_DB_HA(*itemshareData.afaBasicStacticsParameter, vectorItemData, stAFARolongoDB, dflAbsAngle, ucType, ucDirect))
			{
				if(itemshareData.afaBasicStacticsParameter->ucLastRetryTime) {
					int iPeakIndex	=	classAlgorithm.HisAFATactics_Rolongo_GetPeakIndex(*itemshareData.afaBasicStacticsParameter, vectorItemData);
					dflRetry1AbsAngle = ROPLOW::AFAtoBestOffset(vectorItemData.at(iPeakIndex).dflAbsAngle, iteratorItemData->dflAbsAngle, itemshareData.afaBasicStacticsParameter->fltoBestAngOffset);
					// 						dflRetry1AbsAngle	=	vectorItemData.at(iPeakIndex).dflAbsAngle+itemshareData.afaBasicStacticsParameter->fltoBestAngOffset;
					uiProcess = 2;
				}
				else uiProcess = 0xFF;
			}
			else if(dflAbsAngle == _HisAlg_InvalidValueDefine_Double_999999)
			{
				dflAbsAngle = iteratorItemData->dflAbsAngle;
				if(itemshareData.afaBasicStacticsParameter->ucTactics == 0x00){ //最优调焦
					int iPeakIndex	=	classAlgorithm.HisAFATactics_Rolongo_GetPeakIndex(*itemshareData.afaBasicStacticsParameter, vectorItemData);
					if(itemshareData.afaBasicStacticsParameter->bUpCheck) {
						uiProcess = 3;
						dflUpDistance = itemshareData.afaBasicStacticsParameter->flEveryUpDis;
						dflAbsAngle = ROPLOW::AFAtoBestOffset(vectorItemData.at(iPeakIndex).dflAbsAngle, iteratorItemData->dflAbsAngle, itemshareData.afaBasicStacticsParameter->fltoBestAngOffset);
						// 							dflAbsAngle=vectorItemData.at(iPeakIndex).dflAbsAngle+itemshareData.afaBasicStacticsParameter->fltoBestAngOffset;
					}
					else if(iPeakIndex != vectorItemData.size() - 1) {
						uiProcess = 3; 
						dflAbsAngle = ROPLOW::AFAtoBestOffset(vectorItemData.at(iPeakIndex).dflAbsAngle, iteratorItemData->dflAbsAngle, itemshareData.afaBasicStacticsParameter->fltoBestAngOffset);
						// 							dflAbsAngle = vectorItemData.at(iPeakIndex).dflAbsAngle+itemshareData.afaBasicStacticsParameter->fltoBestAngOffset;
					}
					else if(itemshareData.afaBasicStacticsParameter->uiUnderSpinAngle) uiProcess = 6;
					else uiProcess = 0xFF;
				}
				else{ //PASS调焦
					if(itemshareData.afaBasicStacticsParameter->bUpCheck) {uiProcess = 3; dflUpDistance = itemshareData.afaBasicStacticsParameter->flEveryUpDis;}
					else if(itemshareData.afaBasicStacticsParameter->uiUnderSpinAngle) uiProcess = 6;
					else uiProcess = 0xFF;
				}
			}
			// 			}
		}
#endif
		/*2:retry1*/
#if 1
		if(uiProcess == 2)
		{ //retry 1
			if(iteratorItemData->ucStatus > 0x0){
				if(itemshareData.afaBasicStacticsParameter->bUpCheck) {uiProcess = 3; dflUpDistance = itemshareData.afaBasicStacticsParameter->flEveryUpDis;}
				else if(itemshareData.afaBasicStacticsParameter->uiUnderSpinAngle) uiProcess = 6;
				else uiProcess = 0xFF;
			}
			else if(ucRetry1CW < itemshareData.afaBasicStacticsParameter->ucLastRetryTime && \
				(ucRetry1CW < 2 || iteratorItemData->flWeightValue + itemshareData.afaBasicStacticsParameter->flConstPeakDefFall *1.5f > flRetry1CWWeight)){
					if(ucRetry1CW)
						dflAbsAngle	=	iteratorItemData->dflAbsAngle +itemshareData.afaBasicStacticsParameter->flLastRetryAngle *-1.0;
					else
						dflAbsAngle	=	dflRetry1AbsAngle + itemshareData.afaBasicStacticsParameter->flLastRetryAngle *-1.0;
					if(ucRetry1CW == 1) flRetry1CWWeight = iteratorItemData->flWeightValue;
					++ucRetry1CW;
			}
			else if(ucRetry1CCW < itemshareData.afaBasicStacticsParameter->ucLastRetryTime && \
				(ucRetry1CCW < 2 || iteratorItemData->flWeightValue + itemshareData.afaBasicStacticsParameter->flConstPeakDefFall *1.5f > flRetry1CCWWeight)){
					if(ucRetry1CCW)
						dflAbsAngle	=	iteratorItemData->dflAbsAngle +itemshareData.afaBasicStacticsParameter->flLastRetryAngle;
					else
						dflAbsAngle	=	dflRetry1AbsAngle + itemshareData.afaBasicStacticsParameter->flLastRetryAngle;
					if(ucRetry1CCW == 1) flRetry1CCWWeight = iteratorItemData->flWeightValue;
					++ucRetry1CCW;
			}
			else{
				uiProcess = 0xFF;
			}
		}
#endif
		/*31:up check1*/
#if 1
		if(uiProcess == 31)
		{ //up check 1
			if(iteratorItemData->ucStatus > 0x0)
			{
				if(itemshareData.afaBasicStacticsParameter->uiUnderSpinAngle) {
					if(dflUpDistance > 0.0)
					{

						RAUTOMATION::AutoFAAxisZMoveR(dflUpDistance, pclassControl);

						dflUpDistance = 0.0;
					}
					uiProcess = 6;
				}
				else uiProcess = 0xFF;
			}
			else
			{
				if(itemshareData.afaBasicStacticsParameter->ucLastRetryTime) 
				{
					if(dflUpDistance > 0.0)
					{
						RAUTOMATION::AutoFAAxisZMoveR(dflUpDistance, pclassControl);

						dflUpDistance = 0.0;
					}
					dflRetry2AbsAngle	=	iteratorItemData->dflAbsAngle;
					uiProcess = 4;
				}
				else uiProcess = 0xFF;
			}	
		}
#endif
		/*4: retry2*/ /*51:up check2*//*6:under spin*/
#if 1
		if(uiProcess == 4){ //retry 2
			if(iteratorItemData->ucStatus > 0x0){
				if(itemshareData.afaBasicStacticsParameter->bUpCheck) { uiProcess = 5; dflUpDistance = itemshareData.afaBasicStacticsParameter->flEveryUpDis;}
				else if(itemshareData.afaBasicStacticsParameter->uiUnderSpinAngle) uiProcess = 6;
				else uiProcess = 0xFF;
			}
			else if(ucRetry2CW < itemshareData.afaBasicStacticsParameter->ucLastRetryTime && \
				(ucRetry2CW < 2 || iteratorItemData->flWeightValue + itemshareData.afaBasicStacticsParameter->flConstPeakDefFall *1.5f > flRetry2CWWeight)){
					if(ucRetry2CW)
						dflAbsAngle	=	iteratorItemData->dflAbsAngle +itemshareData.afaBasicStacticsParameter->flLastRetryAngle *-1.0;
					else
						dflAbsAngle	=	dflRetry2AbsAngle+ itemshareData.afaBasicStacticsParameter->flLastRetryAngle *-1.0;
					if(ucRetry2CW == 1) flRetry2CWWeight = iteratorItemData->flWeightValue;
					++ucRetry2CW;
			}
			else if(ucRetry2CCW < itemshareData.afaBasicStacticsParameter->ucLastRetryTime && \
				(ucRetry2CCW < 2 || iteratorItemData->flWeightValue + itemshareData.afaBasicStacticsParameter->flConstPeakDefFall *1.5f > flRetry2CCWWeight)){
					if(ucRetry2CCW)
						dflAbsAngle	=	iteratorItemData->dflAbsAngle +itemshareData.afaBasicStacticsParameter->flLastRetryAngle;
					else
						dflAbsAngle	=	dflRetry2AbsAngle+itemshareData.afaBasicStacticsParameter->flLastRetryAngle;
					if(ucRetry2CCW == 1) flRetry2CCWWeight = iteratorItemData->flWeightValue;
					++ucRetry2CCW;
			}
			else{
				uiProcess = 0xFF;
			}
		}
		
		if(uiProcess == 51)
		{ //up check2
			if(iteratorItemData->ucStatus > 0x0)
			{
				if(itemshareData.afaBasicStacticsParameter->uiUnderSpinAngle) 
				{
					if(dflUpDistance > 0.0)
					{
						RAUTOMATION::AutoFAAxisZMoveR(dflUpDistance, pclassControl);
						dflUpDistance = 0.0;
					}
					uiProcess = 6;
				}
				else uiProcess = 0xFF;
			}
			else uiProcess = 0xFF;	
		}

		if(uiProcess == 6){ //under spin
			dflAbsAngle	=	iteratorItemData->dflAbsAngle - itemshareData.afaBasicStacticsParameter->uiUnderSpinAngle;
		}
#endif
/*Success*/
#if 1
		if(uiProcess == 0xFF) 
		{
			if(itemshareData.afaBasicStacticsParameter->ucChartType == _HisCCMAlg_Rolongo_Chart_MTF_A || \
				itemshareData.afaBasicStacticsParameter->ucChartType == _HisCCMAlg_Rolongo_Chart_MTF_B)
			{
				itemshareData.plotLock.lockForWrite();
				ROPLOW::fillMTFAFABarChartDrawInfo(itemshareData.vecBarChartItem, *iteratorItemData, iImgWidth, iImgHeight);
				itemshareData.dflBarChartYMin		=	0.0;
				itemshareData.dflBarChartYMax	=	1.0;
				itemshareData.plotLock.unlock();
				emit plotpainter(1);
				// 					DrawAFAMTFBarChart(*iteratorItemData);
			}				
			else if(itemshareData.afaBasicStacticsParameter->ucChartType == _HisCCMAlg_Rolongo_Chart_SFR_A){
				itemshareData.plotLock.lockForWrite();
				ROPLOW::fillSFRAFABarChartDrawInfo(itemshareData.vecBarChartItem, *iteratorItemData, &(itemshareData.sfrfacaParameter->stSFRBasic), iImgWidth, iImgHeight);
				itemshareData.dflBarChartYMin		=	0.0;
				itemshareData.dflBarChartYMax	=	0.5;
				itemshareData.plotLock.unlock();
				emit plotpainter(1);
				// 				DrawAFASFRBarChart(&itemshareData.sfrfacaParameter->stSFRBasic, *iteratorItemData);
			}
			else
			{
				itemshareData.plotLock.lockForWrite();
				ROPLOW::fillLpAFABarChartDrawInfo(itemshareData.vecBarChartItem, *iteratorItemData, iImgWidth, iImgHeight);
				itemshareData.dflBarChartYMin		=	0.0;
				itemshareData.dflBarChartYMax	=	flChartLpValueMax;
				itemshareData.plotLock.unlock();
				emit plotpainter(1);
				//				DrawAFALpBarChart(itemshareData.lpmfaParameter, *iteratorItemData);
			}
			break;
		}
#endif

		if(dflAbsAngle > 50000.0)	dflAbsAngle = iteratorItemData->dflAbsAngle;
		if(dflAbsAngle != iteratorItemData->dflAbsAngle)
		{
			if(itemshareData.afaBasicStacticsParameter->bUpCheckEveryStep)//每一步脱离Lens测试，调焦环往下
			{	

				RAUTOMATION::AutoFAAxisZMoveR(itemshareData.afaBasicStacticsParameter->flEveryUpDis, pclassControl);

			}

			RAUTOMATION::AutoFARingRotate(dflAbsAngle - iteratorItemData->dflAbsAngle, true, pclassControl);

			if(itemshareData.afaBasicStacticsParameter->bUpCheckEveryStep)//每一步脱离Lens测试，调焦环往上
			{	

				RAUTOMATION::AutoFAAxisZMoveR(itemshareData.afaBasicStacticsParameter->flEveryUpDis *-1.0, pclassControl);

			}
		}
		emit information("angle: " % QString::number(dflAbsAngle) % "\t\t" % QString::number(dflAbsAngle - iteratorItemData->dflAbsAngle) % \
			"    distance:" % QString::number(dflUpDistance));
		/*调焦环向上*/
		if(dflUpDistance != 0.0)
		{
			RAUTOMATION::AutoFAAxisZMoveR(dflUpDistance *-1.0, pclassControl);
		}

		if(itemshareData.afaBasicStacticsParameter->ucChartType == _HisCCMAlg_Rolongo_Chart_MTF_A || \
			itemshareData.afaBasicStacticsParameter->ucChartType == _HisCCMAlg_Rolongo_Chart_MTF_B){
				itemshareData.plotLock.lockForWrite();
				ROPLOW::fillMTFAFABarChartDrawInfo(itemshareData.vecBarChartItem, *iteratorItemData, iImgWidth, iImgHeight);
				itemshareData.dflBarChartYMin		=	0.0;
				itemshareData.dflBarChartYMax	=	1.0;
				itemshareData.plotLock.unlock();
				emit plotpainter(1);
				//				DrawAFAMTFBarChart(*iteratorItemData);
		}			
		else if(itemshareData.afaBasicStacticsParameter->ucChartType == _HisCCMAlg_Rolongo_Chart_SFR_A){
			itemshareData.plotLock.lockForWrite();
			ROPLOW::fillSFRAFABarChartDrawInfo(itemshareData.vecBarChartItem, *iteratorItemData, &(itemshareData.sfrfacaParameter->stSFRBasic), iImgWidth, iImgHeight);
			itemshareData.dflBarChartYMin		=	0.0;
			itemshareData.dflBarChartYMax	=	0.5;
			itemshareData.plotLock.unlock();
			emit plotpainter(1);
			// 			DrawAFASFRBarChart(&itemshareData.sfrfacaParameter->stSFRBasic, *iteratorItemData);
		}
		else{
			itemshareData.plotLock.lockForWrite();
			ROPLOW::fillLpAFABarChartDrawInfo(itemshareData.vecBarChartItem, *iteratorItemData, iImgWidth, iImgHeight);
			itemshareData.dflBarChartYMin		=	0.0;
			itemshareData.dflBarChartYMax	=	flChartLpValueMax;
			itemshareData.plotLock.unlock();
			emit plotpainter(1);
			//			DrawAFALpBarChart(itemshareData.lpmfaParameter, *iteratorItemData);
		}
		::Sleep(itemshareData.afaBasicStacticsParameter->usoperatedelay);

		if(uiProcess == 3)	
		{
			uiProcess = 31;
			emit information(QTextCodec::codecForName( "GBK")->toUnicode("调焦环脱离检测: ") % QString::number(dflUpDistance));
		}
		else if(uiProcess == 5) {
			uiProcess = 51;
			emit information(QTextCodec::codecForName( "GBK")->toUnicode("调焦环脱离检测: ") % QString::number(dflUpDistance));
		}
		else if(uiProcess == 6) {
			uiProcess = 0xFF;
			emit information(QTextCodec::codecForName( "GBK")->toUnicode("下旋"));
		}
	}

#endif
//********************  Debug Mode ***************************
	if(hisglobalparameter.bDebugMode)
	{
		QString strSerialNumber;
		classLog->getserialnumber(strSerialNumber);
		if(strSerialNumber.isEmpty()) strSerialNumber = "1";
		QDir classDir;
		QString strData=QDate::currentDate().toString("yyyyMMdd");
		classDir.mkpath(QDir::currentPath() % "/Auto FA Curve");
		QString strPath	=	QDir::currentPath() % "/Auto FA Curve/" % strData;
		if(itemshareData.afaBasicStacticsParameter->ucChartType == _HisCCMAlg_Rolongo_Chart_MTF_A || \
			itemshareData.afaBasicStacticsParameter->ucChartType == _HisCCMAlg_Rolongo_Chart_MTF_B){
				strPath = strPath % " _MTF Auto FA Curve.csv";
				ROPLOW::saveMTFHAAFACurve2File(vectorItemData, itemshareData.mtffaParameter, strPath,strSerialNumber,iImgWidth, iImgHeight);
		}
		else if(itemshareData.afaBasicStacticsParameter->ucChartType == _HisCCMAlg_Rolongo_Chart_SFR_A){
			strPath = strPath % "_SFR Auto FA Curve.csv";
			ROPLOW::saveSFRHAAFACurve2File(vectorItemData, itemshareData.sfrfacaParameter, strPath,strSerialNumber,iImgWidth, iImgHeight);
		}
		else
		{
			strPath = strPath% "_TV Line Auto FA Curve.csv";
			ROPLOW::saveLpHAAFACurve2File(vectorItemData, itemshareData.lpmfaParameter, strSerialNumber);
		}
	}

	unsigned int uiSaveIndex=0;
	if(itemshareData.afaBasicStacticsParameter->uiUnderSpinAngle)
	{
		if(vectorItemData.size() < 2) uiSaveIndex = 0;
		else if((vectorItemData.end() -2)->ucStatus > 0x0) uiSaveIndex = vectorItemData.size() -2;
		else uiSaveIndex	=	vectorItemData.size() -1;
	}
	else{
		if(vectorItemData.size() < 2) uiSaveIndex = 0;
		else uiSaveIndex	=	vectorItemData.size() -1;
	}

	if(vectorItemData.at(uiSaveIndex).ucStatus == 0x0)	iresult	=	HisCCMError_NoFocusStep;
	else if(itemshareData.afaBasicStacticsParameter->uiUnderSpinAngle)
	{
		float flUnderDev	=	vectorItemData.at(uiSaveIndex).flWeightValue - vectorItemData.at(uiSaveIndex+1).flWeightValue;
		if(flUnderDev > itemshareData.afaBasicStacticsParameter->flUnderSpinDValueMax || flUnderDev < itemshareData.afaBasicStacticsParameter->flUnderSpinDValueMin)
			iresult	=	HisCCMError_NoFocusStep;
	}

	if(itemshareData.afaBasicStacticsParameter->ucChartType == _HisCCMAlg_Rolongo_Chart_MTF_A || \
		itemshareData.afaBasicStacticsParameter->ucChartType == _HisCCMAlg_Rolongo_Chart_MTF_B)
	{
		ROPLOW::saveMTFHAAFAResult(vectorItemData.at(uiSaveIndex), !iresult, itemshareData.mtffaParameter, *classLog, iImgWidth, iImgHeight);
	}
	else if(itemshareData.afaBasicStacticsParameter->ucChartType == _HisCCMAlg_Rolongo_Chart_SFR_A)
	{
		ROPLOW::saveSHRHAAFAResult(vectorItemData.at(uiSaveIndex), !iresult, itemshareData.sfrfacaParameter, *classLog, iImgWidth, iImgHeight);
	}
	else
	{
		ROPLOW::saveLpHAAFAResult(vectorItemData.at(uiSaveIndex), !iresult, itemshareData.lpmfaParameter, *classLog, iImgWidth, iImgHeight);
	}
	if(itemshareData.afaBasicStacticsParameter->bDataBase && !iresult)
		ROPLOW::AFADataToDB(itemshareData.afaBasicStacticsParameter->bUseMark, &stAFARolongoDB, vectorItemData, uiSaveIndex);

	
	/*
	FILE *pfile;
	fopen_s(&pfile,"Sofia_FAR_MTF.csv","rb+");
	if(!pfile){
	fopen_s(&pfile,"Sofia_FAR_MTF.csv","w+");
	fprintf(pfile,"S/N,Center_H,Center_V,F0.3_LT_H,F0.3_LT_V,F0.3_RT_H,F0.3_RT_V,F0.3_RB_H,F0.3_RB_V,F0.3_LB_H,F0.3_LB_V,\
				  F0.4_R_H,F0.4_R_V,F0.4_L_H,F0.4_L_V,F0.7_LT_H,F0.7_LT_V,F0.7_RT_H,F0.7_RT_V,F0.7_RB_H,F0.7_RB_V,F0.7_LB_H,F0.7_LB_V\n");
	}else{
	fseek(pfile,0,SEEK_END);
	}

	QString strSerialNumber;
	classLog->getserialnumber(strSerialNumber);

	fprintf(pfile,"%s,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f\n",strSerialNumber.toLatin1().data(),stDataItem_EX.flMTFCenterValue_H,stDataItem_EX.flMTFCenterValue_V,\
	stDataItem_EX.vectorMTFFOV.at(0).flHValue[0],stDataItem_EX.vectorMTFFOV.at(0).flVValue[0],\
	stDataItem_EX.vectorMTFFOV.at(0).flHValue[1],stDataItem_EX.vectorMTFFOV.at(0).flVValue[1],\
	stDataItem_EX.vectorMTFFOV.at(0).flHValue[2],stDataItem_EX.vectorMTFFOV.at(0).flVValue[2],\
	stDataItem_EX.vectorMTFFOV.at(0).flHValue[3],stDataItem_EX.vectorMTFFOV.at(0).flVValue[3],\
	stDataItem_EX.vectorMTFFOV.at(1).flHValue[0],stDataItem_EX.vectorMTFFOV.at(1).flVValue[0],\
	stDataItem_EX.vectorMTFFOV.at(1).flHValue[1],stDataItem_EX.vectorMTFFOV.at(1).flVValue[1],\
	stDataItem_EX.vectorMTFFOV.at(2).flHValue[0],stDataItem_EX.vectorMTFFOV.at(2).flVValue[0],\
	stDataItem_EX.vectorMTFFOV.at(2).flHValue[1],stDataItem_EX.vectorMTFFOV.at(2).flVValue[1],\
	stDataItem_EX.vectorMTFFOV.at(2).flHValue[2],stDataItem_EX.vectorMTFFOV.at(2).flVValue[2],\
	stDataItem_EX.vectorMTFFOV.at(2).flHValue[3],stDataItem_EX.vectorMTFFOV.at(2).flVValue[3]
	);

	fclose(pfile);
	*/
	


	_CODE_AFA_ALL_EXIT1
}

#endif

#ifdef USE_EQUIPMENT_JSL_FUNCTION_V1
int itemprocess::RsCommOut(unsigned char* pucComm, unsigned int uiCount, unsigned char ucCOMIndex, bool bBack)
{
	CSerial serial;

	char strCOMIndex[10];
	sprintf(strCOMIndex, "COM%d", ucCOMIndex);
	// Attempt to open the serial port (COM1)
	LONG lLastError = serial.Open(strCOMIndex,	0,	0,	false);
	if (lLastError != ERROR_SUCCESS)
		return HisRs232Error_Open;

	// Setup the serial port (9600,8N1, which is the default setting)
	lLastError = serial.Setup(CSerial::EBaud115200,CSerial::EData8,CSerial::EParNone,CSerial::EStop1);
	if (lLastError != ERROR_SUCCESS){
		serial.Close();
		return HisRs232Error_BasicSteup;
	}

	// Setup handshaking
	lLastError = serial.SetupHandshaking(CSerial::EHandshakeOff);
	if (lLastError != ERROR_SUCCESS){
		serial.Close();
		return HisRs232Error_SetHandShake;
	}

	// Register only for the receive event
	lLastError = serial.SetMask(CSerial::EEventBreak |
		CSerial::EEventCTS   |
		CSerial::EEventDSR   |
		CSerial::EEventError |
		CSerial::EEventRing  |
		CSerial::EEventRLSD  |
		CSerial::EEventRecv);
	if (lLastError != ERROR_SUCCESS){
		serial.Close();
		return HisRs232Error_SetEvent;
	}

	// Use 'non-blocking' reads, because we don't know how many bytes
	// will be received. This is normally the most convenient mode
	// (and also the default mode for reading data).
	lLastError = serial.SetupReadTimeouts(CSerial::EReadTimeoutNonblocking);
	if (lLastError != ERROR_SUCCESS){
		serial.Close();
		return HisRs232Error_SetTimeOut;
	}

	// The serial port is now ready and we can send/receive data. If
	// the following call blocks, then the other side doesn't support
	// hardware handshaking.
	lLastError = serial.Write((const void*)(pucComm), uiCount);
	if (lLastError != ERROR_SUCCESS){
		serial.Close();
		return HisRs232Error_Write;
	}

	if(!bBack){
		serial.Close();
		return 0;
	}

	// Keep reading data, until an EOF (CTRL-Z) has been received
	bool fContinue = true;
	DWORD dwReceivebyte	=	0;
	char szBuffer[101];

	do{
		// Wait for an event
		lLastError = serial.WaitEvent();
		if (lLastError != ERROR_SUCCESS){
			serial.Close();
			return HisRs232Error_WaitEvent;
		}

		// Save event
		const CSerial::EEvent eEvent = serial.GetEventType();

		// Handle break event
		if (eEvent & CSerial::EEventBreak){
			OutputDebugStringA("### BREAK received ###");
		}

		// Handle CTS event
		if (eEvent & CSerial::EEventCTS){
			OutputDebugStringA("### Clear to send  ###");
		}

		// Handle DSR event
		if (eEvent & CSerial::EEventDSR){
			OutputDebugStringA("### Data set ready ###");
		}

		// Handle error event
		if (eEvent & CSerial::EEventError){
			OutputDebugStringA("### ERROR: ");
			switch (serial.GetError()){
			case CSerial::EErrorBreak:		
				OutputDebugStringA("Break condition");			
				break;
			case CSerial::EErrorFrame:		
				OutputDebugStringA("Framing error");			
				break;
			case CSerial::EErrorIOE:		
				OutputDebugStringA("IO device error");			
				break;
			case CSerial::EErrorMode:		
				OutputDebugStringA("Unsupported mode");			
				break;
			case CSerial::EErrorOverrun:	
				OutputDebugStringA("Buffer overrun");			
				break;
			case CSerial::EErrorRxOver:		
				OutputDebugStringA("Input buffer overflow");	
				break;
			case CSerial::EErrorParity:		
				OutputDebugStringA("Input parity error");		
				break;
			case CSerial::EErrorTxFull:		
				OutputDebugStringA("Output buffer full");		
				break;
			default:						
				OutputDebugStringA("Unknown");					
				break;
			}
		}

		// Handle ring event
		if (eEvent & CSerial::EEventRing){
			OutputDebugStringA("### RING ###");
		}

		// Handle RLSD/CD event
		if (eEvent & CSerial::EEventRLSD){
			OutputDebugStringA("### RLSD/CD ###");
		}

		// Handle data receive event
		if (eEvent & CSerial::EEventRecv){
			// Read data, until there is nothing left
			DWORD dwBytesRead = 0;
			do{
				// Read data from the COM-port
				lLastError = serial.Read(szBuffer+dwReceivebyte,99 - dwReceivebyte,&dwBytesRead);
				if (lLastError != ERROR_SUCCESS){
					serial.Close();
					return HisRs232Error_Read;
				}

				if (dwBytesRead > 0){
					dwReceivebyte	=	dwReceivebyte + dwBytesRead;
					szBuffer[dwReceivebyte]	=	'\0';

					// 					QString strText;
					// 					for(unsigned int x=0;	x<dwReceivebyte;	++x){
					// 						strText = strText % "0x" % QString::number(szBuffer[x], 16) % ",";
					// 					}
					// 					emit information("receive: " % strText);

					// Check if EOF (CTRL+'[') has been specified
					if (dwReceivebyte >= 4)
						fContinue = false;
				}
			}
			while (dwReceivebyte < 100 && fContinue);
		}
	}
	while (fContinue);

	// Close the port again
	serial.Close();

	if(dwReceivebyte != 4)	return HisRs232Error_DataMatch;
	for(unsigned int x=0;	x<4;	++x){
		if(szBuffer[x] != pucComm[x]) return HisRs232Error_DataMatch;
	}

	return 0;
}
#endif

int itemprocess::rolongodebug(unsigned int uiTestType)
{

	/*
	unsigned int uiStatus;
	int irio = classPlatform.HisFX3IO_InPortRead(uiStatus, 0xFF);
	emit information("HisFX3IO_InPortRead:" % QString::number(irio, 16));
	emit information("IO: " % QString::number(uiStatus, 16));
	return 0;*/
	//
	//海康SFR接口测试
#if 0
	//获取RGB24图像数据
	unsigned char* pucRGB241 = (unsigned char*)HisAlignedMalloc(itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight *3);
	QHisFX3MallocAlignedManage classpucRGB241(pucRGB241);
	threadshareData.GetFreshframe(pucRGB241, itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight *3, _FrameType_RGB24, true);

	//拆分Y通道的数据
	unsigned char* pucBufG	=	(unsigned char*)HisAlignedMalloc(itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight);
	QHisFX3MallocAlignedManage classpucBufG(pucBufG);
	unsigned char* pucSrc = pucRGB241+1, *pucDes = pucBufG;
	for (int x=0;	x<itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight;	++x)
	{
		*pucDes++	=	*pucSrc;
		pucSrc	+=	3;
	}

	RECT stROI;
	stROI.left		=	1853;
	stROI.top		=	1234;
	stROI.right	=	2365;
	stROI.bottom = 1726;
	// 	QString strROIText = QInputDialog::getText(0, QString("ROI"), QString("ROI Set: "), QLineEdit::Normal, QString("(left:1853)(top:1234)(right:2365)(bottom:1726)"), 0, Qt::Dialog);
	// 	emit information(strROIText);

	_HisCCMAlg_SFRBlock_ValueItem sftItem[4];
	int itrel = classAlgorithm.getSFRBlockValue(pucBufG, itemshareData.previewParameter->iWidth, itemshareData.previewParameter->iHeight, \
		stROI, 64, 128, sftItem);
	emit information("getSFRBlockValue result: 0x" % QString::number(itrel, 16));

	//绘图
	itemshareData.drawLock.lockForWrite();
	itemshareData.itemdrawList.clear();
	itemshareData.itemdrawList.resize(1);
	unsigned int dIndex = 0;
	itemshareData.itemdrawList[dIndex].stcolor = QColor::fromRgb(255, 255, 0);
	itemshareData.itemdrawList[dIndex].uctype = HisDrawType_Block;
	itemshareData.itemdrawList[dIndex].strinfo.stblock = stROI;
	itemshareData.drawLock.unlock();

	if (!itrel)
	{
		itemshareData.drawLock.lockForWrite();
		itemshareData.itemdrawList.resize(9);
		for (unsigned int x=0;	x<4;	++x)
		{
			++dIndex;
			itemshareData.itemdrawList[dIndex].stcolor = QColor::fromRgb(255, 255, 0);
			itemshareData.itemdrawList[dIndex].uctype = HisDrawType_Block;
			itemshareData.itemdrawList[dIndex].strinfo.stblock = sftItem[x].roi;

			++dIndex;
			itemshareData.itemdrawList[dIndex].uctype = HisDrawType_Text;
			itemshareData.itemdrawList[dIndex].stcolor = QColor::fromRgb(0, 255, 0);
			itemshareData.itemdrawList[dIndex].idata[0] = sftItem[x].roi.left;
			itemshareData.itemdrawList[dIndex].idata[1] = sftItem[x].roi.top;
			sprintf(itemshareData.itemdrawList[dIndex].strinfo.strtext, "%.4f", sftItem[x].mtf50);
		}
		itemshareData.drawLock.unlock();
	}

	return 0;
#endif

	// 	emit information("Error Frame Index: " % QString::number(classPlatform.getErrorFrameIndex()));
	// 	return 0;
#if 0
	unsigned char* pucRGB241 = (unsigned char*)HisAlignedMalloc(itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight *3);
	QHisFX3MallocAlignedManage classpucRGB241(pucRGB241);

	float flPt1X, flPt1Y, flPt2X, flPt2Y;
	RECT stROI1, stROI2;
	threadshareData.GetFreshframe(pucRGB241, itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight *3, _FrameType_RGB24, true);
	int irel = classRolongoTest.cvRolongoMTFChartMarkDetect(pucRGB241, itemshareData.previewParameter->iWidth, itemshareData.previewParameter->iHeight, \
		0.4f, 0.35f, 0.9f, flPt1X, flPt1Y, flPt2X, flPt2Y, stROI1, stROI2, true);
	emit information("cvRolongoMTFChartMarkDetect: " % QString::number(irel, 16));
	if(!irel)
	{
		emit information("flPt1X: " % QString::number(flPt1X, 'f', 6));
		emit information("flPt1Y: " % QString::number(flPt1Y, 'f', 6));
		emit information("flPt2X: " % QString::number(flPt2X, 'f', 6));
		emit information("flPt2Y: " % QString::number(flPt2Y, 'f', 6));
		emit information("stROI1: [" % QString::number(stROI1.left) % "," % QString::number(stROI1.top) % "][" % \
			QString::number(stROI1.right) % "," % QString::number(stROI1.bottom) % "]");
		emit information("stROI2: [" % QString::number(stROI2.left) % "," % QString::number(stROI2.top) % "][" % \
			QString::number(stROI2.right) % "," % QString::number(stROI2.bottom) % "]");
	}
#endif

#if 0
	unsigned char* pucRGB241 = (unsigned char*)HisAlignedMalloc(itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight *3);
	QHisFX3MallocAlignedManage classpucRGB241(pucRGB241);

	POINT pt[2] = {0};
	RECT stROI1;
	stROI1.left		=	1173;
	stROI1.top		=	1465;
	stROI1.right		=	2881;
	stROI1.bottom	=	2289;
	_SFRBlackItem sfrPos;
	threadshareData.GetFreshframe(pucRGB241, itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight *3, _FrameType_RGB24, true);
	unsigned char* pucBufG	=	(unsigned char*)HisAlignedMalloc(itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight);
	QHisFX3MallocAlignedManage classpucBufG(pucBufG);
	unsigned char* pucSrc = pucRGB241+1, *pucDes = pucBufG;
	for (int x=0;	x<itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight;	++x)
	{
		*pucDes++	=	*pucSrc;
		pucSrc	+=	3;
	}

	// 	int resl = classRolongoTest.DefectSFRObjectForHuaWei(pucBufG, itemshareData.previewParameter->iWidth, itemshareData.previewParameter->iHeight, \
	// 		stROI1, 40, 100, &sfrPos, pt);
	int resl = classRolongoTest.DefectSFRMacroObjectForHuaWei(pucBufG, itemshareData.previewParameter->iWidth, itemshareData.previewParameter->iHeight, \
		stROI1, 500, &sfrPos);

	emit information("DefectSFRObjectForHuaWei result: " % QString::number(resl, 16));
	emit information("pt1 [" % QString::number(pt[0].x) % ", " % QString::number(pt[0].y) % "]   [" % \
		QString::number(pt[1].x) % ", " % QString::number(pt[1].y) % "]");
	emit information("center [" % QString::number(sfrPos.stCenter.x) % "," % QString::number(sfrPos.stCenter.y) % "]");
	emit information("left [" % QString::number(sfrPos.stLeft.x) % "," % QString::number(sfrPos.stLeft.y) % "]");
	emit information("right [" % QString::number(sfrPos.stRight.x) % "," % QString::number(sfrPos.stRight.y) % "]");
	emit information("top [" % QString::number(sfrPos.stTop.x) % "," % QString::number(sfrPos.stTop.y) % "]");
	emit information("bottom [" % QString::number(sfrPos.stBottom.x) % "," % QString::number(sfrPos.stBottom.y) % "]");

	return 0;
#endif

#if 0
	unsigned char* pucRGB241 = (unsigned char*)HisAlignedMalloc(itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight *3);
	QHisFX3MallocAlignedManage classpucRGB241(pucRGB241);

	POINT pt[2] = {0};
	RECT stROI1;
	// 	stROI1.left		=	616;
	// 	stROI1.top		=	369;
	// 	stROI1.right		=	2000;
	// 	stROI1.bottom	=	1371;
	stROI1.left		=	500;
	stROI1.top		=	273;
	stROI1.right		=	1150;
	stROI1.bottom	=	913;

	_SFRBlackItem sfrPos;
	threadshareData.GetFreshframe(pucRGB241, itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight *3, _FrameType_RGB24, true);
	unsigned char* pucBufG	=	(unsigned char*)HisAlignedMalloc(itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight);
	QHisFX3MallocAlignedManage classpucBufG(pucBufG);
	unsigned char* pucSrc = pucRGB241+1, *pucDes = pucBufG;
	for (int x=0;	x<itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight;	++x)
	{
		*pucDes++	=	*pucSrc;
		pucSrc	+=	3;
	}

	int minAreaSize = 35000;
	float cx, cy, rollAngle,crossX, crossY;
	int resl = classRolongoTest.CrossCoaxialityAlgHA(pucBufG, itemshareData.previewParameter->iWidth, itemshareData.previewParameter->iHeight, \
		stROI1,minAreaSize,  cx, cy, rollAngle,crossX, crossY);
	emit information("Center: [" % QString::number(cx) % "," % QString::number(cy) % "]");
	emit information("angle: " % QString::number(rollAngle, 'f', 6));
	emit information("cross size: (" % QString::number(crossX) % "," % QString::number(crossY) % ")");

	return 0;
#endif


	//联想VR MTF demo
#if 1
	unsigned char* pucRGB241 = (unsigned char*)HisAlignedMalloc(itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight *3);
	QHisFX3MallocAlignedManage classpucRGB241(pucRGB241);
	threadshareData.GetFreshframe(pucRGB241, itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight *3, _FrameType_RGB24, true);

	QImage image1(pucRGB241, itemshareData.previewParameter->iWidth, itemshareData.previewParameter->iHeight, QImage::Format_RGB888);
	QImage image2 = image1.copy(image1.rect());
	RECT stROI[9];
	stROI[0].left = 1600; stROI[0].top = 1306; stROI[0].right = 1660; stROI[0].bottom = 1356;

	stROI[1].left = 1354; stROI[1].top = 1048; stROI[1].right = 1416; stROI[1].bottom = 1110;
	stROI[2].left = 1922; stROI[2].top = 1076; stROI[2].right = 1980; stROI[2].bottom = 1136;
	stROI[3].left = 1381; stROI[3].top = 1612; stROI[3].right = 1440; stROI[3].bottom = 1669;
	stROI[4].left = 1920; stROI[4].top = 1609; stROI[4].right = 1980; stROI[4].bottom = 1668;

	stROI[5].left = 1543; stROI[5].top = 716; stROI[5].right = 1601; stROI[5].bottom = 776;
	stROI[6].left = 1033; stROI[6].top = 1252; stROI[6].right = 1095; stROI[6].bottom = 1312;
	stROI[7].left = 1733; stROI[7].top = 1930; stROI[7].right = 1789; stROI[7].bottom = 1990;
	stROI[8].left = 2231; stROI[8].top = 1251; stROI[8].right = 2289; stROI[8].bottom = 1313;

	QPainter paiter(&image2);
	QPen pen = paiter.pen();
	pen.setColor(QColor::fromRgb(255, 0, 0));
	pen.setWidth(4);
	paiter.setPen(pen);
	QFont font = paiter.font();
	font.setBold(true);
	font.setPointSize(14);
	paiter.setFont(font);

	for (int x=0; x<9; ++x)
	{
		float mtf=0.0;
		classRolongoTest.HisCCMMTF(pucRGB241, itemshareData.previewParameter->iWidth, itemshareData.previewParameter->iHeight, \
			stROI[x], 6, mtf, true);

		paiter.drawRect(stROI[x].left, stROI[x].top, stROI[x].right-stROI[x].left, stROI[x].bottom-stROI[x].top);
		paiter.drawText(stROI[x].left, stROI[x].top, QString::number(mtf, 'f', 3));
	}

	image2.save("./mtf.png");

	return 0;
#endif

	/*
	unsigned char ucSlave[2];
	unsigned int uiReg[2];
	unsigned int uiData[2] = {0};
	unsigned short usType[2];
	for(unsigned int x=0;	x<2;	++x)
	{
	ucSlave[x] = 0x20;
	uiReg[x] = 0x0202;
	usType[x] = 0x1616;
	}
	int irel = classPlatform.HisFX3BatchReadIICNoLimit_S2(2, ucSlave, uiReg, uiData, usType, 20);
	emit information(QString::number(irel));
	emit information(QString::number(uiData[0], 16));
	emit information(QString::number(uiData[1], 16));

	return 0;
	*/

	if(uiTestType == 0)
	{
		RECT stROI;
		int iROISize = 200;
		stROI.left			=	(itemshareData.previewParameter->iWidth - iROISize) /2;
		stROI.top			=	(itemshareData.previewParameter->iHeight - iROISize) /2;
		stROI.right		=	stROI.left + iROISize;
		stROI.bottom	=	stROI.top + iROISize;
		int iresult = autoExposure(stROI, 60, 65, 800, 10, true,true,false,0.1f);
		if(iresult) 
		{
			emit information("auto exposure fail");
			return 0;
		}

		unsigned int uivalue, uimin_s, uimax_s;
		iresult = getExposureTime((itemshareData.ccmhardwareParameter->sensortype.toAscii()).data(), itemshareData.previewParameter->ucSlave, \
			uivalue, uimin_s, uimax_s, globalFunPointer.ReadHisFX3IIC, globalFunPointer.WriteHisFX3IIC, globalFunPointer.SetHisFX3IICSpeed, globalFunPointer.PullHisFX3RESET, globalFunPointer.PullHisFX3PWND, \
			globalFunPointer.PageWriteHisFX3IIC, globalFunPointer.PageReadHisFX3IIC, globalFunPointer.HisFX3PageWriteSPI, globalFunPointer.HisFX3PageReadSPI);
		if(iresult)
		{
			emit information("getExposureTime fail");
			return 0;
		}

		unsigned char* pucRawBuff = (unsigned char*)HisAlignedMalloc(itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight *2);
		QHisFX3MallocAlignedManage classpucRawBuff(pucRawBuff);

		QElapsedTimer classTime;
		unsigned __int64 ui64FrameIndexStart, ui64FrameIndexEnd;
		unsigned char* pucLine, *pucData;
		unsigned int uiSum, uiTime, uiGrabCount = 0;
		Sleep(1000);
		// 		bHaoGrab = false;
		Sleep(500);

		iresult	=	setExposureTime((itemshareData.ccmhardwareParameter->sensortype.toAscii()).data(), itemshareData.previewParameter->ucSlave, \
			uivalue *2, globalFunPointer.ReadHisFX3IIC, globalFunPointer.WriteHisFX3IIC, globalFunPointer.SetHisFX3IICSpeed, globalFunPointer.PullHisFX3RESET, globalFunPointer.PullHisFX3PWND, \
			globalFunPointer.PageWriteHisFX3IIC, globalFunPointer.PageReadHisFX3IIC, globalFunPointer.HisFX3PageWriteSPI, globalFunPointer.HisFX3PageReadSPI);
		if(iresult)
		{
			emit information("setExposureTime fail");
			return 0;
		}

		classTime.start();
		classPlatform.HisFX3GrabFrame(0, 0, ui64FrameIndexStart);

		while(1)
		{
			iresult = classPlatform.HisFX3GrabFrame(&pucRawBuff, itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight *2, ui64FrameIndexEnd);
			if(iresult)
			{
				emit information("HisFX3GrabFrame fail");
				return 0;
			}

			++uiGrabCount;
			uiTime	=	classTime.elapsed();

			switch (itemshareData.previewParameter->ucDataFormat)
			{
			case HisBaylor8_RGGB:
			case HisBaylor8_BGGR:
				{
					uiSum	=	0;
					pucLine = pucRawBuff + stROI.top *itemshareData.previewParameter->iWidth + stROI.left;
					for(int y=stROI.top; y< stROI.bottom; ++y)
					{
						pucData = pucLine;
						pucLine += itemshareData.previewParameter->iWidth;
						for(int x= stROI.left; x<stROI.right; ++x)
						{
							uiSum += *pucData++;
						}
					}
					uiSum /= ((stROI.bottom-stROI.top) * (stROI.right-stROI.left));
				}
				break;
			default:
				{
					emit information("ucDataFormat error");
					return 0;
				}
				break;
			}

			if(uiSum > 90) break;
		}

		// 		bHaoGrab = true;

		emit information("Time : " % QString::number(uiTime));
		emit information("Frame: " % QString::number(ui64FrameIndexEnd- ui64FrameIndexStart));
		emit information("Grab Count: " % QString::number(uiGrabCount));
		return 0;
	}
	else if(uiTestType == 1)
	{
		emit information("Set Packet Size: " % QString::number(hisglobalparameter.ucFX3PacketSize));
		emit information("Set USB Speed: " % QString::number(hisglobalparameter.ucFPGAUploadDelay));
		classPlatform.setBulkTransformSize(64 *1024 * hisglobalparameter.ucFX3PacketSize);
		if(classPlatform.HisFX3isopen())
		{
			classPlatform.setUSBSpeed(hisglobalparameter.ucFPGAUploadDelay);
		}
		return 0;
	}

	QElapsedTimer classTime;
	unsigned __int64 ui64Data1;
	classTime.start();
	for(unsigned int x=0;	x<400;	++x)
	{
		int irel = classPlatform.HisFX3ReadI2C(0x20, 0x0202, &ui64Data1, 0x1608);
		if(irel) emit information("fail");
	}
	emit information(QString::number(classTime.elapsed() / 400.0));
	return 0;

	int iresult = 0;
	const bool cbCurrentSort = false;
	const bool cbPageIICTest = false;
	const bool cbBatchIICTest	=	false;
	const bool cbBlemishTest = false;
	const bool cbSFROneTest = false;
	const bool cbCalibrateVolt	=	false;

	const bool cbtcpipTest	 = false;

	const bool cbMTFBMark	=	false;
	const bool cbAFAVision	=	false;

	const bool cbBarcode		=	false;
	const bool cbListGrabber = false;

	if(cbCalibrateVolt)
	{
		const int iMaxVolt = 100;
		const int iMinVolt = 13;
		float flVoltOffset[iMaxVolt];

		for(int x=iMinVolt;	x<iMaxVolt; ++x)
		{
			if(iresult = classPlatform.HisFX3SetVolt(x,x,x,x,x,x,x, _HisFX3_Platform_VlotOn_OTP)) return iresult;
			Sleep(80);
			float flReadVolt;
			if(iresult = classPlatform.HIsFX3ReadVoltageValue(0, 0, 0, 0, &flReadVolt, 0)) return iresult;

			flVoltOffset[x]	=	x*0.1 - flReadVolt;
		}

		emit information("voltage calibration success");

		QFile classFile("Volt-Hao.txt");
		classFile.open(QIODevice::WriteOnly | QIODevice::Text);
		QTextStream out(&classFile);
		for(int x=0;	x<iMinVolt;	++x)
			out << "0.0f,";

		for(int x=iMinVolt;	x<iMaxVolt; ++x)
		{
			int iTemp = flVoltOffset[x] *1000.0;
			flVoltOffset[x] = iTemp /1000.0;

			out << flVoltOffset[x] << "f,";
		}

		return 0;
	}

	if(cbListGrabber)
	{
		unsigned int uiHarwareKey[100];
		unsigned int uiHarwareKeyCount = 0;
		iresult = classPlatform.getHardwareKeyList(uiHarwareKey, uiHarwareKeyCount);
		for(unsigned int x=0;	x<uiHarwareKeyCount;	++x)
		{
			emit information("Hardware Key " % QString::number(x) % ": " % QString::number(uiHarwareKey[4*x+0]) % "." % \
				QString::number(uiHarwareKey[4*x+1]) % "." % QString::number(uiHarwareKey[4*x+2]) % "." % \
				QString::number(uiHarwareKey[4*x+3]));
		}
		return iresult;
	}

	if(cbBarcode)
	{

		int iWidth = itemshareData.previewParameter->iWidth;
		int iheight	=	itemshareData.previewParameter->iHeight;

		RECT stROI;
		// 	stROI.left	=	940;
		// 	stROI.top	=	420;
		// 	stROI.right = 1192;
		// 	stROI.bottom	=	666;
		stROI.left	=	392;
		stROI.top	=	406;
		stROI.right = 578;
		stROI.bottom	=	576;


		unsigned char* ucRGB24 = (unsigned char*)_aligned_malloc(iWidth *iheight *3, _HisCacheLine_Aligned);
		unsigned char* ucTestBuff = (unsigned char*)_aligned_malloc(iWidth *iheight *3, _HisCacheLine_Aligned);
		unsigned char* ucTestY = (unsigned char*)_aligned_malloc(iWidth *iheight, _HisCacheLine_Aligned);

		int iresult = GetFreshframe(ucRGB24, iWidth*iheight*3, _FrameType_RGB24, true);

		emit information("GetFreshframe:" % QString::number(iresult, 16));
		if(iresult)
		{
			HisReleaseMalloc(ucRGB24);
			HisReleaseMalloc(ucTestBuff);
			HisReleaseMalloc(ucTestY);
			return 0;
		}

		QImage image1(ucRGB24, iWidth, iheight, iWidth*3, QImage::Format_RGB888);
		image1.save("image1.bmp");

		unsigned char* pucLine = ucRGB24 + stROI.top *iWidth *3 + stROI.left *3;
		unsigned char* pucData, *pucDes = ucTestBuff, *pucY = ucTestY;
		for(int y=stROI.top; y<stROI.bottom; ++y)
		{
			pucData	=	pucLine;

			for(int x= stROI.left; x<stROI.right; ++x)
			{
				*pucDes++	=	*pucData++;
				*pucDes++	=	*pucY++	=	*pucData++;
				*pucDes++	=	*pucData++;
			}

			pucLine	+=	iWidth *3;
		}

		QImage image2(ucTestBuff, stROI.right-stROI.left, stROI.bottom-stROI.top, (stROI.right-stROI.left)*3, QImage::Format_RGB888);
		image2.save("image2.bmp");

		char strText[256] = "";
		CHisVision classVision2;

		strText[0] = '\0';
		iresult = classVision2.DmtxbicodeDecode(ucTestY, stROI.right - stROI.left, stROI.bottom-stROI.top, (unsigned char*)(strText), false, false);
		emit information("DmtxbicodeDecode: " % QString::number(iresult, 16));
		emit information(QString::fromAscii(strText));

		HisReleaseMalloc(ucRGB24);
		HisReleaseMalloc(ucTestBuff);
		HisReleaseMalloc(ucTestY);

		return 0;
	}


	//hardware current sort
	if(cbCurrentSort){
		iresult	=	classPlatform.HisFX3SetVolt(28, 28, 28, 28, 0, 0xFF);
		if(iresult){
			emit information(QTextCodec::codecForName( "GBK")->toUnicode("设置电压失败"));
			return iresult;
		}
		::Sleep(1000);
		float flCurrentAVDD, flCurrentDVDD, flCurrentDOVDD, flCurrentAF;
		// 		iresult	=	classPlatform.HisFX3GetStandbyCurrent(flCurrentAVDD, flCurrentDVDD, flCurrentDOVDD, flCurrentAF, 0xFF);
		if(iresult){
			emit information(QTextCodec::codecForName( "GBK")->toUnicode("静态电流测试异常："));
			return iresult;
		}

		emit information("Current AVDD: " % QString::number(flCurrentAVDD));
		emit information("Current DVDD: " % QString::number(flCurrentDVDD));
		emit information("Current DOVDD: " % QString::number(flCurrentDOVDD));
		emit information("Current AF: " % QString::number(flCurrentAF));

		if(flCurrentDOVDD > 430.0f){
			emit information(QTextCodec::codecForName( "GBK")->toUnicode("!!!!!!!!!!!!!!!!!!!!!此转板短路!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"));
			return HisCCMError_Result;
		}

		emit information(QTextCodec::codecForName( "GBK")->toUnicode("请用万用表确认各路电压是否是2.8V"));
		return 0;
	}

	//page i2c test dw9763
	if(cbPageIICTest)
	{
		unsigned char ucSlave = 0xa0;
		srand(::GetTickCount());
		bool bdw9763 = true;
		unsigned char ucWriteData[8][512], ucReadData[8][512];
		for(unsigned int y=1; y<513;	++y){
			emit information("index: " % QString::number(y));

			if(bdw9763)
			{
				if(iresult = classPlatform.HisFX3WriteIIC(ucSlave, 0x81, 0xEE, 0x0808, true)){
					if(iresult = classPlatform.HisFX3WriteIIC(ucSlave, 0x81, 0xEE, 0x0808, true)){
						emit information("erase eflash fail");
						return iresult;
					}
				}
				::Sleep(30);
				if(iresult = classPlatform.HisFX3WriteIIC(ucSlave, 0x81, 0xEE, 0x0808, true)){
					if(iresult = classPlatform.HisFX3WriteIIC(ucSlave, 0x81, 0xEE, 0x0808, true)){
						emit information("erase eflash fail");
						return iresult;
					}
				}
				::Sleep(30);
			}

			for(unsigned int x=0;	x<8;	++x){
				for(unsigned int i=0;	i<y;	++i){
					ucWriteData[x][i] =  static_cast<unsigned char>(rand() *255 / RAND_MAX);
				}

				if(iresult = classPlatform.HisFX3PageWriteIIC(ucSlave, x*1024, 2, ucWriteData[x], y)){
					if(iresult = classPlatform.HisFX3PageWriteIIC(ucSlave, x*1024, 2, ucWriteData[x], y)){
						emit information("page write ng  0x" % QString::number(iresult, 16));
						return iresult;
					}
				}
			}

			for(unsigned int x=0;	x<8;	++x){
				if(iresult = classPlatform.HisFX3PageReadIIC(ucSlave, x*1024, 2, ucReadData[x], y)){
					if(iresult = classPlatform.HisFX3PageReadIIC(ucSlave, x*1024, 2, ucReadData[x], y)){
						emit information("page read ng  0x" % QString::number(iresult, 16));
						return iresult;
					}
				}

				for(unsigned int i=0;	i<y;	++i){
					if(ucWriteData[x][i] != ucReadData[x][i]){
						emit information("write != read");
						return 3;
					}
				}
			}
		}
		emit information("test success");

		return 0;
	}

	//batch i2c test dw9763
	if(cbBatchIICTest)
	{
		DWORD dwt1 = GetTickCount();
		for(unsigned int x=0;	x<2048;	++x)
		{
			unsigned __int64 uidata = 0;
			int iresult = globalFunPointer.ReadHisFX3IIC(0xb0, x, &uidata, 0x1608);
			if(iresult) {
				emit information("read iic fail");
			}
		}

		emit information("read time:" % QString::number(GetTickCount() - dwt1));

		return 0;
	}

	//Blemish Test
	if(cbBlemishTest){
		unsigned char* pucY		=	(unsigned char*)_aligned_malloc(itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight, 64);
		unsigned char* pucR		=	(unsigned char*)_aligned_malloc(itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight, 64);
		unsigned char* pucG		=	(unsigned char*)_aligned_malloc(itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight, 64);
		unsigned char* pucB		=	(unsigned char*)_aligned_malloc(itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight, 64);
		unsigned char* pucRGB	=	(unsigned char*)_aligned_malloc(itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight *3, 64);
		GetFreshframe(pucRGB, itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight *3, \
			_FrameType_RGB24, true);
		unsigned char* pucSrc	=	pucRGB +1;
		unsigned char* pucDes	=	pucY;
		for(int y=0;	y<itemshareData.previewParameter->iHeight;	++y){
			for(int x=0; x<itemshareData.previewParameter->iWidth;	++x){
				*pucDes	= *pucSrc;
				pucSrc	+=	3;
				++pucDes;
			}
		}

		unsigned char* pucTR = pucR, *pucTG = pucG, *pucTB = pucB;
		pucSrc	=	pucRGB;
		for(int y=0;	y<itemshareData.previewParameter->iHeight;	++y){
			for(int x=0; x<itemshareData.previewParameter->iWidth;	++x){
				*pucTR	=	*pucSrc;
				++pucTR; ++pucSrc;
				*pucTG	=	*pucSrc;
				++pucTG; ++pucSrc;
				*pucTB	=	*pucSrc;
				++pucTB; ++pucSrc;
			}
		}

		RECT stROI = {0};
		_HisCCMAlg_BlemishHC_Spec stSpec[11];
		std::vector<_HisCCMAlg_BlemishHC_Blemish> vecBlemish;
		classAlgorithm.HisCCMWhitePanel_BlemishHC(pucR, pucG, pucB, itemshareData.previewParameter->iWidth, itemshareData.previewParameter->iHeight, \
			stSpec, vecBlemish);

		HisReleaseMalloc(pucRGB);
		HisReleaseMalloc(pucY);
		HisReleaseMalloc(pucR);
		HisReleaseMalloc(pucG);
		HisReleaseMalloc(pucB);
		return 0;
	}

	if(cbSFROneTest){
		unsigned char* pucRGB24	=	(unsigned char*)_aligned_malloc(itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight *3, 64);
		int iROiW= 40, iROIH = 50;
		// 	int iROiW= 80, iROIH = 130;
		unsigned char ucMinCantrast = 20;
		int isftcurvelen = iROiW + 1;
		float flmtf50;
		double* pdflsfrvalue	=	new double[isftcurvelen];
		RECT stROI[8];
		// 	stROI[0].left = 360; stROI[0].top = 460; stROI[0].right = 440; stROI[0].bottom = 590;
		stROI[0].left = 1190; stROI[0].top = 921; stROI[0].right = 1230; stROI[0].bottom = 971;
		stROI[1].left = 1260; stROI[1].top = 911; stROI[1].right = 1300; stROI[1].bottom = 961;
		stROI[2].left = 1220; stROI[2].top = 891; stROI[2].right = 1270; stROI[2].bottom = 931;
		stROI[3].left = 1220; stROI[3].top = 961; stROI[3].right = 1270; stROI[3].bottom = 1001;
		stROI[4].left = 1260; stROI[4].top = 840; stROI[4].right = 1300; stROI[4].bottom = 890;
		stROI[5].left = 1330; stROI[5].top = 840; stROI[5].right = 1370; stROI[5].bottom = 890;
		stROI[6].left = 1300; stROI[6].top = 810; stROI[6].right = 1350; stROI[6].bottom = 850;
		stROI[7].left = 1290; stROI[7].top = 890; stROI[7].right = 1340; stROI[7].bottom = 930;
		float* pflY	=	(float*)_aligned_malloc(iROiW *iROIH *sizeof(float), 64);

		GetFreshframe(pucRGB24, itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight *3, _FrameType_RGB24, true);

		for(unsigned int w=3;	w<4;	++w){
			ROPLOW::GetPartImageFromRGB24(pucRGB24, itemshareData.previewParameter->iWidth, itemshareData.previewParameter->iHeight, \
				_HisCCMAlg_ImageBuffer_Channel_Gr, stROI[w], pflY);

			classAlgorithm.HisCCMSFROne(pflY, iROiW, iROIH, ucMinCantrast, pdflsfrvalue, isftcurvelen, flmtf50);
			emit information("SFR Value: " % QString::number(flmtf50, 'f', 3));
		}

		HisReleaseMalloc(pucRGB24);
		HisReleaseMalloc(pflY);
		HisReleaseNewB(pdflsfrvalue);
		return 0;
	}


	if(cbMTFBMark){
		unsigned char* pucRGB24	=	(unsigned char*)_aligned_malloc(itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight *3, 64);
		GetFreshframe(pucRGB24, itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight *3, _FrameType_RGB24, true);
		float flPt1X, flPt1Y, flPt2X, flPt2Y;
		RECT stROI1, stROI2;
		DWORD dwstart = GetTickCount();
		classRolongoTest.cvRolongoMTFChartMarkDetect(pucRGB24,itemshareData.previewParameter->iWidth, \
			itemshareData.previewParameter->iHeight, 0.3f, 0.0f, 0.7f, flPt1X, flPt1Y, flPt2X, flPt2Y, stROI1, stROI2, true);
		emit information("time: " % QString::number(GetTickCount() - dwstart));
		HisReleaseMalloc(pucRGB24);
		return 0;
	}

	if(cbAFAVision){

		return 0;
	}


	unsigned char* pucRGB24	=	(unsigned char*)_aligned_malloc(itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight *3, 64);
	GetFreshframe(pucRGB24, itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight *3, _FrameType_RGB24, true);
	RECT stRect;
	stRect.left = 110;
	stRect.top = 110;
	stRect.right		=	itemshareData.previewParameter->iWidth-500;
	stRect.bottom = itemshareData.previewParameter->iHeight-500;
	POINT pt1,pt2;
	//cv::Mat src(itemshareData.previewParameter->iWidth, itemshareData.previewParameter->iHeight,CV_8UC3,pucRGB24);

	DWORD dwstart = GetTickCount();
	// 	classRolongoTest.cvRolongoMTFChartMarkDetect(pucRGB24,stRect, itemshareData.previewParameter->iWidth, itemshareData.previewParameter->iHeight, pt1,pt2);
	emit information("time: " % QString::number(GetTickCount() - dwstart));
	emit information("pt1: "% QString::number(pt1.x) % "," % QString::number(pt1.y));
	emit information("pt2: "% QString::number(pt2.x) % "," % QString::number(pt2.y));
	//int ivalue;
	//RECT stRect;
	//stRect.left = 0;
	//stRect.top = 0;
	//stRect.right		=	itemshareData.previewParameter->iWidth;
	//stRect.bottom = itemshareData.previewParameter->iHeight;
	//DWORD dwstart = GetTickCount();
	////emit information("original center: "% QString::number((stRect.left + stRect.right) /2) % "," % QString::number((stRect.top+stRect.bottom) /2));
	//classRolongoTest.RolongoTestenvironmentDetection(pucRGB24, itemshareData.previewParameter->iWidth, \
	//	itemshareData.previewParameter->iHeight, stRect,5, ivalue,true);
	//emit information("time: " % QString::number(GetTickCount() - dwstart));
	//emit information("result: " % QString::number(ivalue));
	//if (ivalue	==	_EnvironmentType_WhitePanel)
	//{
	//	emit information("whitepanel");
	//}
	//else if (ivalue	==	_EnvironmentType_Blackboard)
	//{
	//	emit information("blackboard");
	//}
	//else if (ivalue	==	_EnvironmentType_Error)
	//{
	//	emit information("error");
	//}
	//else
	//{
	//	emit information("AF");
	//}
	//
	//emit information("(" % QString::number(stTheRect.left) % "," % QString::number(stTheRect.top) % ")    (" % \
	//	QString::number(stTheRect.right) % "," % QString::number(stTheRect.bottom) % ")");
	HisReleaseMalloc(pucRGB24);

	return 0;

}

void itemprocess::slotItemExec(quint8 u8Channel, quint16 usItem, QString strOtherInfo, quint64 u64ID, quint8 u8LoopTime)
{
	if(bBoxChannel1 && u8Channel) return;
	else if(!bBoxChannel1 && !u8Channel) return;

	if(threadshareData.GetHisTestingflag()){
		emit information("testing");
		return;
	}

	threadshareData.SetHisTestingflag(true);
	QMutexLocker locker(&itemshareData.mutexItemExec);

	_shoutCutDetail lastitem, currentitem;
	currentitem.usItem			=	usItem;
	currentitem.ucloopTime	=	u8LoopTime;
	currentitem.strAddInfo=strOtherInfo;
	// 	globalgetShortcutAddInfoUnion(usItem, strOtherInfo, currentitem.otherInfo.ucdata);

	int iresult = operateItem(currentitem);

	emit signalwriteItemResult(u64ID, (iresult)?(_His_ItemStatus_NG):(_His_ItemStatus_PASS));

	threadshareData.SetHisTestingflag(false);
}

int itemprocess::operateItem(_shoutCutDetail& currentitem)
{
	itemshareData.shortcutKey	=	currentitem.shortcutKey;
	itemshareData.ucClickTime	=	currentitem.ucClickTime;
	itemshareData.ucItemIndex	=	currentitem.ucItemIndex;
	//itemshareData.bNG=false;

	QElapsedTimer testtimer;
	testtimer.start();

	static QElapsedTimer totalTime;

	if(hisglobalparameter.bShowItem2EndResult && currentitem.usItem != showresultitem)	emit showresult(-1);

	hisglobalparameter.flagLocker.lockForWrite();
	hisglobalparameter.stForivate.ucImageFontSize	=	hisglobalparameter.stForivate.ucImageOtherFontSize;
	hisglobalparameter.stForivate.bImageFontBold		=	hisglobalparameter.stForivate.bImageOtherFontBold;
	hisglobalparameter.flagLocker.unlock();

	int iresult = 0;
	_itemStatus itemstatus;
	itemstatus.usitem	=	currentitem.usItem;
	bool bUpdateItemStatus	=	false;
	switch (currentitem.usItem)
	{

#ifdef USE_EQUIPMENT_AFM_JSL_V2
	case showcontrolpanel:
		updateItemstatus(itemstatus);
		{
			bUpdateItemStatus	=	true;
		}
		break;
	case mtffocus:
		updateItemstatus(itemstatus);
		if(!(iresult=mtfFocus())){
			break;
		}
		bUpdateItemStatus	=	true;
		break;
#endif
	case savemtfdata:
		updateItemstatus(itemstatus);
		{
			FILE *pfile;
			fopen_s(&pfile,"Focus_MTF_Data.csv","rb+");
			if(!pfile){
				fopen_s(&pfile,"Focus_MTF_Data.csv","w+");
				fprintf(pfile,"S/N,Center,\n");
			}else{
				fseek(pfile,0,SEEK_END);
			}

			QString strSerialNumber;
			classLog->getserialnumber(strSerialNumber);
			_mtffaParameter* pstParameter	= itemshareData.mtffaParameter;

			fprintf(pfile,"%s,%.3f",strSerialNumber.toLatin1().data(),stItemData_EX.flCenterValue);

			for (int i=0;i<stItemData_EX.vectorFOV.size();i++)
			{
				for (int blks=0;blks<stItemData_EX.vectorFOV.at(i).ucBlockCount;blks++)
				{
					fprintf(pfile,",%.3f",stItemData_EX.vectorFOV.at(i).flValue[blks]);
				}
			}
			fprintf(pfile,"\n");
			fclose(pfile);
			iresult=0x00;
		}
		bUpdateItemStatus	=	true;
		break;
	case focus_messtatusupdate:
		updateItemstatus(itemstatus);
		{
			QString strSerialNumber;
			classLog->getserialnumber(strSerialNumber);
			emit sig_messtatusupdate(strSerialNumber,QString("focus"));
			while (!global_ioc_x)
			{
				Sleep(100);
			}

		}

		if(global_ioc_x>=1){
			iresult	=	0;
		}
		else if(iresult	==-1){
			emit information(QString::fromLocal8Bit("连接MES服务器失败！请重启程序再试。。。"));
			iresult=-1;
		}else{
			iresult=-1;
		}


		bUpdateItemStatus	=	true;
		global_ioc_x=0;
		break;
	case bindserialnumber:
		updateItemstatus(itemstatus);
		{
			QString strSerialNumber;
			classLog->getserialnumber(strSerialNumber);
			emit sig_serialnumberbind(strSerialNumber);
			while (!global_ioc_x)
			{
				Sleep(500);
			}
			
		}

		if(global_ioc_x>=1){
			iresult	=	0;
		}
		else if(iresult	==-1){
			emit information(QString::fromLocal8Bit("连接MES服务器失败！请重启程序再试。。。"));
			iresult=-1;
		}else{
			iresult=-1;
		}
			

		bUpdateItemStatus	=	true;
		global_ioc_x=0;
		break;
		updateItemstatus(itemstatus);
		{
			QString strSerialNumber;
			classLog->getserialnumber(strSerialNumber);
			emit sig_serialnumberbind(strSerialNumber);
			while (!global_ioc_x)
			{
				Sleep(100);
			}

		}

		if(global_ioc_x>=1){
			iresult	=	0;
		}
		else if(iresult	==-1){
			emit information(QString::fromLocal8Bit("连接MES服务器失败！请重启程序再试。。。"));
			iresult=-1;
		}else{
			iresult=-1;
		}


		bUpdateItemStatus	=	true;
		global_ioc_x=0;
		break;
	case afc_messtatusupdate:
		updateItemstatus(itemstatus);
		{
			QString strSerialNumber;
			classLog->getserialnumber(strSerialNumber);
			emit sig_messtatusupdate(strSerialNumber,QString("AFC"));
			while (!global_ioc_x)
			{
				Sleep(100);
			}

		}

		if(global_ioc_x>=1){
			iresult	=	0;
		}
		else if(iresult	==-1){
			emit information(QString::fromLocal8Bit("连接MES服务器失败！请重启程序再试。。。"));
			iresult=-1;
		}else{
			iresult=-1;
		}


		bUpdateItemStatus	=	true;
		global_ioc_x=0;
		break;
	case burn_messtatusupdate:
		updateItemstatus(itemstatus);
		{
			QString strSerialNumber;
			classLog->getserialnumber(strSerialNumber);
			emit sig_messtatusupdate(strSerialNumber,QString("Burn"));
			while (!global_ioc_x)
			{
				Sleep(100);
			}

		}

		if(global_ioc_x>=1){
			iresult	=	0;
		}
		else if(iresult	==-1){
			emit information(QString::fromLocal8Bit("连接MES服务器失败！请重启程序再试。。。"));
			iresult=-1;
		}else{
			iresult=-1;
		}


		bUpdateItemStatus	=	true;
		global_ioc_x=0;
		break;
	case burncheck_messtatusupdate:
		updateItemstatus(itemstatus);
		{
			QString strSerialNumber;
			classLog->getserialnumber(strSerialNumber);
			emit sig_messtatusupdate(strSerialNumber,QString("BurnCheck"));
			while (!global_ioc_x)
			{
				Sleep(100);
			}

		}

		if(global_ioc_x>=1){
			iresult	=	0;
		}
		else if(iresult	==-1){
			emit information(QString::fromLocal8Bit("连接MES服务器失败！请重启程序再试。。。"));
			iresult=-1;
		}else{
			iresult=-1;
		}


		bUpdateItemStatus	=	true;
		global_ioc_x=0;
		break;
	case startpreviewitem:
		updateItemstatus(itemstatus);
		
		

		for(unsigned int i=0;	i<currentitem.ucloopTime && hisglobalparameter.getrunflag();	++i){
			if(!(iresult	=	startPreview())){
				//GC5005_gcore_identify_otp();
				break;
			}
		}
		bUpdateItemStatus	=	true;
		break;
	case stoppreviewitem:
		updateItemstatus(itemstatus);
		for(unsigned char i=0;	i<currentitem.ucloopTime && hisglobalparameter.getrunflag();	++i){
			if(!(iresult	=	stopPreview()))	break;
		}
		bUpdateItemStatus	=	true;
		break;
	case manualmodebloop1:
		manualModeBLoop1();
		break;
	case mtffaitem:
		hisglobalparameter.flagLocker.lockForWrite();
		hisglobalparameter.stForivate.ucImageFontSize	=	hisglobalparameter.stForivate.ucImageMTFFontSize;
		hisglobalparameter.stForivate.bImageFontBold		=	hisglobalparameter.stForivate.bImageMTFFontBold;
		hisglobalparameter.flagLocker.unlock();
		updateItemstatus(itemstatus);
		hisglobalparameter.setfaflag(true);
		for(unsigned char i=0;	i<currentitem.ucloopTime;	++i){
			if(!(iresult	=	mtfFA()))	break;
		}
		hisglobalparameter.setfaflag(false);
		bUpdateItemStatus	=	true;
		break;
	case lpmfaitem:
		hisglobalparameter.flagLocker.lockForWrite();
		hisglobalparameter.stForivate.ucImageFontSize	=	hisglobalparameter.stForivate.ucImageTVLineFontSize;
		hisglobalparameter.stForivate.bImageFontBold		=	hisglobalparameter.stForivate.bImageTVLineFontBold;
		hisglobalparameter.flagLocker.unlock();
		updateItemstatus(itemstatus);
		hisglobalparameter.setfaflag(true);
		for(unsigned char i=0;	i<currentitem.ucloopTime;	++i){
			if(!(iresult	=	lpFA()))	break;
		}
		hisglobalparameter.setfaflag(false);
		bUpdateItemStatus	=	true;
		break;
	case sfrfacaitem:
		hisglobalparameter.flagLocker.lockForWrite();
		hisglobalparameter.stForivate.ucImageFontSize	=	hisglobalparameter.stForivate.ucImageSFRFontSize;
		hisglobalparameter.stForivate.bImageFontBold		=	hisglobalparameter.stForivate.bImageSFRFontBold;
		hisglobalparameter.flagLocker.unlock();
		updateItemstatus(itemstatus);
		hisglobalparameter.setfaflag(true);
		for(unsigned char i=0;	i<currentitem.ucloopTime;	++i){
			if(!(iresult	=	sfrFACA()))	break;
		}
		hisglobalparameter.setfaflag(false);
		bUpdateItemStatus	=	true;
		break;
	case sfrnearafcitem:
		{
			hisglobalparameter.flagLocker.lockForWrite();
			hisglobalparameter.stForivate.ucImageFontSize	=	hisglobalparameter.stForivate.ucImageSFRFontSize;
			hisglobalparameter.stForivate.bImageFontBold		=	hisglobalparameter.stForivate.bImageSFRFontBold;
			hisglobalparameter.flagLocker.unlock();
			int iOldStactics	=	255;
			updateItemstatus(itemstatus);
			_scotherInfo otherInfo;
			globalgetShortcutAddInfoUnion(currentitem.usItem, currentitem.strAddInfo, otherInfo);
			for(unsigned char i=0;	i<currentitem.ucloopTime;	++i){
				if(!(iresult	=	sfrAFCCA(0, otherInfo.idata[0], iOldStactics)))	break;
			}
			if(iOldStactics != 255 && itemshareData.sfrnearafcParameter)
				itemshareData.sfrnearafcParameter->stTacticsBasic.ucTactics = iOldStactics;
			bUpdateItemStatus	=	true;				
		}
		break;
	case sfrmiddleafcitem:
		{
			hisglobalparameter.flagLocker.lockForWrite();
			hisglobalparameter.stForivate.ucImageFontSize	=	hisglobalparameter.stForivate.ucImageSFRFontSize;
			hisglobalparameter.stForivate.bImageFontBold		=	hisglobalparameter.stForivate.bImageSFRFontBold;
			hisglobalparameter.flagLocker.unlock();
			int iOldStactics	=	255;
			updateItemstatus(itemstatus);
			_scotherInfo otherInfo;
			globalgetShortcutAddInfoUnion(currentitem.usItem, currentitem.strAddInfo, otherInfo);
			for(unsigned char i=0;	i<currentitem.ucloopTime;	++i){
				if(!(iresult	=	sfrAFCCA(1, otherInfo.idata[0], iOldStactics)))	break;
			}
			if(iOldStactics != 255 && itemshareData.sfrmiddleafcParameter)
				itemshareData.sfrmiddleafcParameter->stTacticsBasic.ucTactics = iOldStactics;
			bUpdateItemStatus	=	true;		
		}
		break;
	case sfrfarafcitem:
		{
			hisglobalparameter.flagLocker.lockForWrite();
			hisglobalparameter.stForivate.ucImageFontSize	=	hisglobalparameter.stForivate.ucImageSFRFontSize;
			hisglobalparameter.stForivate.bImageFontBold		=	hisglobalparameter.stForivate.bImageSFRFontBold;
			hisglobalparameter.flagLocker.unlock();
			int iOldStactics	=	255;
			updateItemstatus(itemstatus);
			_scotherInfo otherInfo;
			globalgetShortcutAddInfoUnion(currentitem.usItem, currentitem.strAddInfo, otherInfo);
			for(unsigned char i=0;	i<currentitem.ucloopTime;	++i){
				if(!(iresult	=	sfrAFCCA(2, otherInfo.idata[0], iOldStactics)))	break;
			}
			if(iOldStactics != 255 && itemshareData.sfrfarafcParameter)
				itemshareData.sfrfarafcParameter->stTacticsBasic.ucTactics = iOldStactics;
			bUpdateItemStatus	=	true;	
		}
		break;
	case clearresultitem:
#ifdef USE_EQUIPMENT_AFM_JSL_V1
		_His_P8102_LCD_Red(false);
		_His_P8102_LCD_Green(false);
#endif


		iMotorStartDec = iNearPeakMotorDec = iMiddlePeakMotorDec = iFarPeakMotorDec = 0x00FFFFFF;
		classLog->clear();
		totalTime.start();

		itemshareData.clearDrawList();
		itemshareData.setTotalResult(0);

		emit signaldrawframe(-10);
		emit updateresult();
		emit showresult(-1);
		break;
	case showresultitem:
		{
			int iresult=	GetTotalResult();
			if(iresult==_His_ItemStatus_PASS){
				itemshareData.totalresult=_His_ItemStatus_PASS;
			}else{
				itemshareData.totalresult=HisCCMError_Result;
			}

			_scotherInfo otherInfo;
			globalgetShortcutAddInfoUnion(currentitem.usItem, currentitem.strAddInfo, otherInfo);
			itemshareData.itemstatusLock.lockForRead();

			//***************** 2018.01.10 add*****************
			if(!otherInfo.uidata[1]){
				if(itemshareData.bOK2==true&&itemshareData.bNG!=true){
					itemshareData.bOK2=false;
					itemshareData.totalresult=0xFE;
				}else{
					itemshareData.bNG=false;
				}

				if(itemshareData.totalresult)
					
				emit showresult(itemshareData.totalresult);
				emit signaldrawframe(itemshareData.totalresult);

			}

			//***************** 2018.01.10 add*****************
			QString strSerialNumber;
			classLog->getserialnumber(strSerialNumber);

#ifdef USE_EQUIPMENT_AFM_JSL_V1
			if(bAutoFocus){
#else
			if(1){
#endif
				ROPLOW::focus2DB(strSerialNumber,iresult);
				bAutoFocus=false;
			}

			QStringList listOK,listNG;
			ROPLOW::getFocusDataFromDB(QDate::currentDate(),listOK,listNG);
			emit sigCountToPanel(listOK,listNG);
			//***********************************
#if 1 //烧录计数
		if(!iresult){
			itemshareData.itemstatusLock.lockForRead();
			bool bburn=false;
			for(QList<_itemStatus>::iterator theiterator = itemshareData.itemstatusList.begin(); theiterator != itemshareData.itemstatusList.end(); theiterator++){
				if(theiterator->usitem==otpburnitem){
					bburn=true;
					break;
				}
			}
			itemshareData.itemstatusLock.unlock();

			if(bburn){
				QSqlDatabase dbLotSN = QSqlDatabase::addDatabase("QSQLITE", "dbLotSN");
				dbLotSN.setDatabaseName("JSL_OtpCount");
				if (!dbLotSN.open()){
					itemshareData.itemparameterLock.unlock();
					return HisCCMError_Database;
				}

				QSqlQuery query(dbLotSN);
				query.prepare("select * from [CurrentBurnLotSN] where 1");
				query.exec();
				query.next();
				QString strLotSN=query.value(0).toString();

				QString str=QString("insert into [%1] values('%2','%3',%4,%5,%6,%7)").arg(strLotSN).arg(strSerialNumber).arg(strLotSN)\
					.arg(global_unit_rg).arg(global_unit_bg).arg(global_unit_g).arg(global_burn_group);
				query.prepare(str);
				if(!query.exec()){
					emit information(query.lastError().text());
					return -1;
				}

				emit sigBurnCount();
			}
		}
#endif
			//***********************************

#ifdef USE_EQUIPMENT_AFM_JSL_V1
			_His_P8102_LCD_Red(itemshareData.totalresult);
			_His_P8102_LCD_Green(!itemshareData.totalresult);
#endif


			itemshareData.itemstatusLock.unlock();

			_CODE_LOG_PUSHBACK_ALL(_HISLOG_CLASSIFY_TOTALRESULT, "total result", (itemshareData.totalresult)?("NG"):("OK"))
				getccmhardwareParameter(false); 
			if(!otherInfo.uidata[0]){
				if(iresult	=	classLog->save(itemshareData.ccmhardwareParameter->projectname, true, false)){
					emit information(QTextCodec::codecForName( "GBK")->toUnicode("保存文档错误，错误代码：0x") % QString::number(iresult, 16));
				}else{
					//************************** 2019/04/16 ************************
					QString str=QString("./savelog/%1/%2").arg(itemshareData.ccmhardwareParameter->projectname).arg(QDate::currentDate().toString("yyyy-MM-dd"));
					QFile filelog(str+".csv");
					filelog.open(QIODevice::ReadOnly);
					QByteArray buffer=filelog.readAll();
					filelog.close();

					QFileInfo fileinfo(str+".jsv");
					bool bf=fileinfo.isFile();

					QFile filelogNew(str+".jsv");
					filelogNew.open(QIODevice::Append|QIODevice::ReadWrite);

					QString strBuffer(buffer);
					QStringList list=strBuffer.split("\r\n");
					
					if(!bf){
						str=list.at(0);
						filelogNew.write((str+="\n").toLatin1());
					}else{
						filelogNew.reset();
						filelogNew.seek(filelogNew.size()-32);
					}
					
					str=list.at(list.size()-2);

					filelogNew.write((str+="\n").toLatin1());

					//*************** Calc MD5 ******************
					QCryptographicHash md(QCryptographicHash::Md5);
					filelogNew.reset();
					QByteArray array1=filelogNew.readAll();
					md.addData(array1);
					buffer=md.result();
					filelogNew.write(buffer.toHex());
					filelogNew.close();


				}
					
			}
			classLog->clear(); 
			emit signalTotalTestTime(totalTime.elapsed()); 
			emit sigBurnCount();
			emit information(tr("Total Test Time:") % QString::number(totalTime.elapsed()) % "ms");
		}
		break;
	case sleepitem:
		{
			_scotherInfo otherInfo;
			globalgetShortcutAddInfoUnion(currentitem.usItem, currentitem.strAddInfo, otherInfo);
			if(otherInfo.idata[0] > 0)	::Sleep(otherInfo.idata[0]);
		}		
		break;
	case messageboxitem:
		{
			_scotherInfo otherInfo;
			globalgetShortcutAddInfoUnion(currentitem.usItem, currentitem.strAddInfo, otherInfo);
			threadshareData.flaglock.lockForWrite();
			threadshareData.bSavingImage = true;
			threadshareData.flaglock.unlock();
			emit signalMessageBox(otherInfo.idata[0]);

			bool bLoop	=	true;
			while(bLoop){
				Sleep(10);
				threadshareData.flaglock.lockForRead();
				bLoop = threadshareData.bSavingImage;
				threadshareData.flaglock.unlock();
			}
		}		
		break;
	case brightnessitem:
		{
			_scotherInfo otherInfo;
			globalgetShortcutAddInfoUnion(currentitem.usItem, currentitem.strAddInfo, otherInfo);
			for(unsigned char i=0;	i<currentitem.ucloopTime;	++i){
				if(!(iresult	=	getBrightness(otherInfo.stRect[0], otherInfo.idata[4], otherInfo.idata[5])))	break;
			}
			bUpdateItemStatus	=	true;	
		}
		break;
	case checkcoloritem:
		{
			_scotherInfo otherInfo;
			globalgetShortcutAddInfoUnion(currentitem.usItem, currentitem.strAddInfo, otherInfo);
			for(unsigned char i=0;	i<currentitem.ucloopTime;	++i){
				if(!(iresult=getColorRatio(otherInfo.stRect[0], otherInfo.fldata[4], otherInfo.fldata[5], otherInfo.fldata[6], otherInfo.fldata[7])))	break;
			}
			bUpdateItemStatus	=	true;	
		}
		break;
	case mtffcnearitem:
		{
			hisglobalparameter.flagLocker.lockForWrite();
			hisglobalparameter.stForivate.ucImageFontSize	=	hisglobalparameter.stForivate.ucImageMTFFontSize;
			hisglobalparameter.stForivate.bImageFontBold		=	hisglobalparameter.stForivate.bImageMTFFontBold;
			hisglobalparameter.flagLocker.unlock();
			updateItemstatus(itemstatus);
			int iOldStatics = 255;
			_scotherInfo otherInfo;
			globalgetShortcutAddInfoUnion(currentitem.usItem, currentitem.strAddInfo, otherInfo);			
			for(unsigned char i=0;	i<currentitem.ucloopTime;	++i){
				if(!(iresult	=	mtfAFCCA(0, otherInfo.idata[0], iOldStatics)))	break;
			}
			if(iOldStatics != 255 && itemshareData.mtfnearafcParameter)
				itemshareData.mtfnearafcParameter->stTacticsBasic.ucTactics	=	iOldStatics;
			bUpdateItemStatus	=	true;	
		}
		break;
	case mtffcmiddleitem:
		{
			hisglobalparameter.flagLocker.lockForWrite();
			hisglobalparameter.stForivate.ucImageFontSize	=	hisglobalparameter.stForivate.ucImageMTFFontSize;
			hisglobalparameter.stForivate.bImageFontBold		=	hisglobalparameter.stForivate.bImageMTFFontBold;
			hisglobalparameter.flagLocker.unlock();
			updateItemstatus(itemstatus);
			int iOldStatics = 255;
			_scotherInfo otherInfo;
			globalgetShortcutAddInfoUnion(currentitem.usItem, currentitem.strAddInfo, otherInfo);		
			for(unsigned char i=0;	i<currentitem.ucloopTime;	++i){
				if(!(iresult	=	mtfAFCCA(1, otherInfo.idata[0], iOldStatics)))	break;
			}
			if(iOldStatics != 255 && itemshareData.mtfmiddleafcParameter)
				itemshareData.mtfmiddleafcParameter->stTacticsBasic.ucTactics	=	iOldStatics;
			bUpdateItemStatus	=	true;			
		}
		break;
	case mtffcinfiniteitem:
		{
			hisglobalparameter.flagLocker.lockForWrite();
			hisglobalparameter.stForivate.ucImageFontSize	=	hisglobalparameter.stForivate.ucImageMTFFontSize;
			hisglobalparameter.stForivate.bImageFontBold		=	hisglobalparameter.stForivate.bImageMTFFontBold;
			hisglobalparameter.flagLocker.unlock();
			updateItemstatus(itemstatus);
			int iOldStatics = 255;
			_scotherInfo otherInfo;
			globalgetShortcutAddInfoUnion(currentitem.usItem, currentitem.strAddInfo, otherInfo);		
			for(unsigned char i=0;	i<currentitem.ucloopTime;	++i){
				if(!(iresult	=	mtfAFCCA(2, otherInfo.idata[0], iOldStatics)))	break;
			}		
			if(iOldStatics != 255 && itemshareData.mtffarafcParameter)
				itemshareData.mtffarafcParameter->stTacticsBasic.ucTactics	=	iOldStatics;
			bUpdateItemStatus	=	true;	
		}
		break;
	case goldenitem:
		updateItemstatus(itemstatus);
		//执行goldenitem 程序调用
		for(unsigned char i=0;	i<currentitem.ucloopTime;	++i){
			if(!(iresult	=	ReadGolden()))		break;
		}

		bUpdateItemStatus	=	true;	
		break ;
	case autoexposureitem:
		{
			updateItemstatus(itemstatus);
			_scotherInfo otherInfo;
			globalgetShortcutAddInfoUnion(currentitem.usItem, currentitem.strAddInfo, otherInfo);		
			for(unsigned char i=0;	i<currentitem.ucloopTime;	++i){
				if(!(iresult	=	autoExposure(otherInfo.stRect[0], otherInfo.uidata[4], otherInfo.uidata[5], otherInfo.uidata[6], (otherInfo.uidata[7] & 0x00FF), \
					(otherInfo.uidata[7] & 0xFF000000), (otherInfo.uidata[7] & 0xFF0000),(otherInfo.uidata[7] & 0xFF00),otherInfo.fldata[8])))	break;
			}
			bUpdateItemStatus	=	true;	
		}
		break;
	case autofocusitem:
		{
			updateItemstatus(itemstatus);
			_scotherInfo otherInfo;
			globalgetShortcutAddInfoUnion(currentitem.usItem, currentitem.strAddInfo, otherInfo);		
			for(unsigned char i=0;	i<currentitem.ucloopTime;	++i){
				if(!(iresult	=	autoFocus(otherInfo.ucdata[0], otherInfo.ucdata[1], otherInfo.usdata[1], otherInfo.usdata[2], otherInfo.usdata[3], otherInfo.usdata[4], \
					otherInfo.usdata[5], otherInfo.usdata[6], otherInfo.usdata[7], otherInfo.usdata[8])))	break;
			}
			bUpdateItemStatus	=	true;	
		}
		break;
	case playaudioitem:
		{
			updateItemstatus(itemstatus);
			_scotherInfo otherInfo;
			globalgetShortcutAddInfoUnion(currentitem.usItem, currentitem.strAddInfo, otherInfo);		
			for(unsigned char i=0;	i<currentitem.ucloopTime;	++i){
				if(!(iresult	=	playAudio(otherInfo.uidata[0], otherInfo.uidata[1], otherInfo.fldata[2])))	break;
			}
			bUpdateItemStatus	=	true;	
		}
		break;
	case imageprocessitem:
		{
			updateItemstatus(itemstatus);
			_scotherInfo otherInfo;
			globalgetShortcutAddInfoUnion(currentitem.usItem, currentitem.strAddInfo, otherInfo);	

			if(otherInfo.ucdata[13] & 0x80) // Mirror/Flip
			{
				threadshareData.SetDSPMirrorFlip(otherInfo.ucdata[13] & 0x40, otherInfo.ucdata[13] & 0x20);
				if(otherInfo.ucdata[13] & 0x40)	emit information("Mirror:  ON");
				else emit information("Mirror:  OFF");
				if(otherInfo.ucdata[13] & 0x20)	emit information("Flip:  ON");
				else emit information("Flip:  OFF");
			}

			threadshareData.SetDSPBlackLevel(otherInfo.ucdata[12]);
			emit information("Black Level: " % QString::number(otherInfo.ucdata[12]));

			if(otherInfo.ucdata[0] & 0x80) // blemish enhance
			{
				threadshareData.SetBlemishEnhanceShowFlag(otherInfo.ucdata[0] & 0x40);
				if((otherInfo.ucdata[0] & 0x40) && threadshareData.GetHisPreviewflag())	
				{
					emit information("Blemish Enhance Show:  ON");
					/*
					unsigned char* pucShow		=	(unsigned char*)HisAlignedMalloc(itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight *3);
					QHisFX3MallocAlignedManage classpucShow(pucShow);

					int irel = globalFunPointer.GetFreshframe(pucShow, itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight *3, _FrameType_RGB24, true);
					if(!irel)
					{
					RECT stTempBlock;
					stTempBlock.left	=	stTempBlock.top	=	0;		stTempBlock.right = itemshareData.previewParameter->iWidth; stTempBlock.bottom = itemshareData.previewParameter->iHeight;
					classAlgorithm.rgb24tograybit8(pucShow, pucShow, itemshareData.previewParameter->iWidth, itemshareData.previewParameter->iHeight, stTempBlock);
					classAlgorithm.contrastenhance(pucShow, itemshareData.previewParameter->iWidth, itemshareData.previewParameter->iHeight);

					unsigned char* pucDes	=	pucShow +itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight *3 -1;
					unsigned char* pucSrc	=	pucShow + itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight -1;
					unsigned int uiPixel	=	itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight;
					for(unsigned int x=0;	x<uiPixel; ++x){
					*pucDes	=	*(pucDes-1) = *(pucDes -2) = *pucSrc;
					--pucSrc;
					pucDes	-=	3;
					}

					QImage image1(pucShow, itemshareData.previewParameter->iWidth, itemshareData.previewParameter->iHeight, itemshareData.previewParameter->iWidth*3, QImage::Format_RGB888);
					QImage image2 = image1.scaled(800, 800 *itemshareData.previewParameter->iHeight /itemshareData.previewParameter->iWidth, Qt::IgnoreAspectRatio, Qt::SmoothTransformation);
					emit signalDrawAnotherSingle(image2, 0xFFFFFFFF);
					}
					*/
				}
				else
				{
					emit information("Blemish Enhance Show:  OFF");
				}
			}

			if(otherInfo.ucdata[1] & 0x80) // lsc
			{
				threadshareData.SetDSPLSCFlag(otherInfo.ucdata[1] & 0x40);
				if(otherInfo.ucdata[1] & 0x40)	emit information("LSC:  ON");
				else emit information("LSC:  OFF");
			}

			if(otherInfo.ucdata[2] & 0x80) // awb
			{
				threadshareData.SetDSPAWBFlag(otherInfo.ucdata[2] & 0x40, otherInfo.ucdata[2] & 0x3f, otherInfo.ucdata[3]&0x80, otherInfo.ucdata[3]&0x7F, otherInfo.fldata[1], otherInfo.fldata[2]);
				if(otherInfo.ucdata[2] & 0x40)	emit information("AWB:  ON");
				else emit information("AWB:  OFF");

				if(threadshareData.ucAWB_Method == 1 && threadshareData.bUseSensorAWBGain)
				{
#if (defined _WIN64) && (defined _DEBUG)
					QString strLibPath	=	QDir::currentPath() % "/HisCCMSensor64D";
#elif (defined _WIN64) && !(defined _DEBUG)
					QString strLibPath	=	QDir::currentPath() % "/HisCCMSensor64";
#elif (defined _WIN32) && (defined _DEBUG)
					QString strLibPath	=	QDir::currentPath() % "/HisCCMSensor32D";
#else
					QString strLibPath	=	QDir::currentPath() % "/HisCCMSensor32";
#endif

					RolongosetAWBGain setAWBGain = (RolongosetAWBGain)(QLibrary::resolve(strLibPath, "setAWBGain"));
					RolongogetAWBGain getAWBGain = (RolongogetAWBGain)(QLibrary::resolve(strLibPath, "getAWBGain"));
					if(!setAWBGain || !getAWBGain)
					{
						emit information(strLibPath % " Load setAWBGain/getAWBGain Failed");
					}
					else
					{
						int errorcode = 0;
						if(errorcode = setAWBGain((itemshareData.ccmhardwareParameter->sensortype.toAscii()).data(), itemshareData.previewParameter->ucSlave, \
							threadshareData.flAWB_GainR, true, threadshareData.flAWB_GainB, true, 1.0f, true,  globalFunPointer.ReadHisFX3IIC, globalFunPointer.WriteHisFX3IIC, globalFunPointer.SetHisFX3IICSpeed, globalFunPointer.PullHisFX3RESET, globalFunPointer.PullHisFX3PWND, \
							globalFunPointer.PageWriteHisFX3IIC, globalFunPointer.PageReadHisFX3IIC, globalFunPointer.HisFX3PageWriteSPI, globalFunPointer.HisFX3PageReadSPI))
							emit information("Set " % itemshareData.ccmhardwareParameter->sensortype % " WB Gain Fail");
					}
				}
			}

			bUpdateItemStatus	=	true;	
		}
		break;
	case autorawcapture:
		{
			updateItemstatus(itemstatus);
			_scotherInfo otherInfo;
			globalgetShortcutAddInfoUnion(currentitem.usItem, currentitem.strAddInfo, otherInfo);	
			for(unsigned char i=0;	i<currentitem.ucloopTime;	++i){
				if(!(iresult	=	AutoRAWCaputre(otherInfo.strdata,0,otherInfo.uidata[2],otherInfo.uidata[0],otherInfo.uidata[1], \
					((otherInfo.uidata[3]==1)?(true):(false)))))	break;
			}
			bUpdateItemStatus	=	true;	
		}
		break;
	case awblscgoldenselection:
		{
			updateItemstatus(itemstatus);
			_scotherInfo otherInfo;
			globalgetShortcutAddInfoUnion(currentitem.usItem, currentitem.strAddInfo, otherInfo);	
			for(unsigned char i=0;	i<currentitem.ucloopTime;	++i){
				iresult	=	QualcommAWBLSCGoldenSelection(otherInfo.uidata[0],otherInfo.uidata[1],otherInfo.uidata[2],otherInfo.uidata[3],otherInfo.uidata[4]);
				if(!iresult)	break;
			}
			bUpdateItemStatus	=	true;	
		}
		break;	
	case dualcameracoaxialitytiltitem:
		{
			updateItemstatus(itemstatus);
			_scotherInfo otherInfo;
			globalgetShortcutAddInfoUnion(currentitem.usItem, currentitem.strAddInfo, otherInfo);
			hisglobalparameter.setfaflag(true);
			for(unsigned int i=0;	i<1000000000/*currentitem.ucloopTime*/ ;	++i){
				iresult	=	dualcameracoaxialitytilttest(true,true,otherInfo.dfldata[0],otherInfo.dfldata[1]);
				if(iresult == HisCoaxiality_ErrorRectNumber || iresult == HisCoaxiality_ErrorCircleNumber || iresult == HisCoaxiality_ErrorCrossNumber)
				{
					//emit information(" chart 检测失败");
					emit information(GetHisFX3ErrorInfo(iresult));
				}
				else if (iresult ==HisCoaxiality_ErrorChartExcursion)
				{
					emit information(GetHisFX3ErrorInfo(iresult));
				}
				else if (iresult ==HisCoaxiality_ErrorLuminancethreshold)
				{
					emit information(GetHisFX3ErrorInfo(iresult));
				}
				else
					break;

			}
			hisglobalparameter.setfaflag(false);
			bUpdateItemStatus	=	true;
		}
		break;
	case dualcameracoaxialityitem:
		{
			updateItemstatus(itemstatus);
			_scotherInfo otherInfo;
			globalgetShortcutAddInfoUnion(currentitem.usItem, currentitem.strAddInfo, otherInfo);
			hisglobalparameter.setfaflag(true);
			for(unsigned int i=0;	i<currentitem.ucloopTime ;	++i){
				iresult	=	dualcameracoaxialitytest(otherInfo.dfldata[0],otherInfo.dfldata[1],otherInfo.dfldata[2],otherInfo.dfldata[3],\
					((otherInfo.uidata[0]==1)?(true):(false)),((otherInfo.uidata[1]==1)?(true):(false)),otherInfo.dfldata[4],otherInfo.dfldata[5],otherInfo.dfldata[6],otherInfo.dfldata[7]);

				if(iresult == HisCoaxiality_ErrorRectNumber || iresult == HisCoaxiality_ErrorCircleNumber || iresult == HisCoaxiality_ErrorCrossNumber)
				{
					emit information(GetHisFX3ErrorInfo(iresult));
				}
				else if (iresult ==HisCoaxiality_ErrorChartExcursion)
				{
					emit information(GetHisFX3ErrorInfo(iresult));
				}
				else if (iresult ==HisCoaxiality_ErrorChartExcursion)
				{
					emit information(GetHisFX3ErrorInfo(iresult));
				}
				else if (iresult ==HisCoaxiality_ErrorLuminancethreshold)
				{
					emit information(GetHisFX3ErrorInfo(iresult));
				}
				else
					break;
			}
			hisglobalparameter.setfaflag(false);
			bUpdateItemStatus	=	true;
		}
		break;
	case FishEyejungeitem:
		{
			updateItemstatus(itemstatus);
			_scotherInfo otherInfo;
			globalgetShortcutAddInfoUnion(currentitem.usItem, currentitem.strAddInfo, otherInfo);
			hisglobalparameter.setfaflag(true);
			for(unsigned int i=0;	i<1000000000/*currentitem.ucloopTime*/ ;	++i){
				iresult	=	FishEyeForjunge(otherInfo.dfldata[0]);
				if(iresult )
				{
					//emit information(" chart 检测失败");
					emit information(GetHisFX3ErrorInfo(iresult));
					break;
				}
				else
					break;

			}
			hisglobalparameter.setfaflag(false);
			bUpdateItemStatus	=	true;
		}
		break;
	case exposureitem:
		{
			updateItemstatus(itemstatus);
			_scotherInfo otherInfo;
			globalgetShortcutAddInfoUnion(currentitem.usItem, currentitem.strAddInfo, otherInfo);	
			for(unsigned char i=0;	i<currentitem.ucloopTime && hisglobalparameter.getrunflag();	++i){
				if(!(iresult	=	setexposureTimeExe(otherInfo.uidata[0])))	break;
			}
			bUpdateItemStatus	=	true;
		}
		break;
	case setcustomiicitem:
		{
			updateItemstatus(itemstatus);
			_scotherInfo otherInfo;
			globalgetShortcutAddInfoUnion(currentitem.usItem, currentitem.strAddInfo, otherInfo);	
			for(unsigned char i=0;	i<currentitem.ucloopTime && hisglobalparameter.getrunflag();	++i){
				if(!(iresult	=	setCustomIICG(otherInfo.uidata[0])))	break;
			}
			bUpdateItemStatus	=	true;
		}
		break;
	case gainitem:
		{
			_scotherInfo otherInfo;
			globalgetShortcutAddInfoUnion(currentitem.usItem, currentitem.strAddInfo, otherInfo);	
			for(unsigned char i=0;	i<currentitem.ucloopTime && hisglobalparameter.getrunflag();	++i){
				if(!(iresult	=	setGain(otherInfo.fldata[0])))	break;
			}
			if(iresult)	bUpdateItemStatus	=	true;
		}
		break;
	case motoritem:
		{
			_scotherInfo otherInfo;
			globalgetShortcutAddInfoUnion(currentitem.usItem, currentitem.strAddInfo, otherInfo);	
			for(unsigned char i=0;	i<currentitem.ucloopTime && hisglobalparameter.getrunflag();	++i){
				if(!(iresult	=	setMotorExe(otherInfo.idata[0], otherInfo.idata[1])))	break;
			}
			bUpdateItemStatus	=	true;
		}
		break;
	case whitepanelitem_blemish:
		updateItemstatus(itemstatus);
		for(unsigned char i=0;	i<currentitem.ucloopTime;	++i){
			if(!(iresult	=	blemish()))	break;
		}
		bUpdateItemStatus	=	true;
		break;
	case whitepanelitem_blemishb:
		updateItemstatus(itemstatus);
		for(unsigned char i=0;	i<currentitem.ucloopTime;	++i){
			if(!(iresult	=	blemishb()))	break;
		}
		bUpdateItemStatus	=	true;
		break;
	case whitepanelitem_color:
		updateItemstatus(itemstatus);
		for(unsigned char i=0;	i<currentitem.ucloopTime;	++i){
			if(!(iresult	=	whitePanelColor()))	break;
		}
		bUpdateItemStatus	=	true;
		break;
	case whitepanelitem_snr:
		updateItemstatus(itemstatus);
		for(unsigned char i=0;	i<currentitem.ucloopTime;	++i){
			if(!(iresult	=	whitePanelSNR()))	break;
		}
		bUpdateItemStatus	=	true;
		break;
	case whitepanelitem_oc:
		updateItemstatus(itemstatus);
		for(unsigned char i=0;	i<currentitem.ucloopTime;	++i){
			if(!(iresult	=	whitePanelOC()))	break;
		}
		bUpdateItemStatus	=	true;
		break;
	case whitepanelitem_line:
		updateItemstatus(itemstatus);
		for(unsigned char i=0;	i<currentitem.ucloopTime;	++i){
			if(!(iresult	=	whitePanelDefectLine()))	break;
		}
		bUpdateItemStatus	=	true;
		break;
	case whitepanelitem_pixel:
		updateItemstatus(itemstatus);
		for(unsigned char i=0;	i<currentitem.ucloopTime;	++i){
			if(!(iresult	=	whitePanelDefectPixel()))	break;
		}
		bUpdateItemStatus	=	true;
		break;
	case whitepanelitem_shading:
		updateItemstatus(itemstatus);
		for(unsigned char i=0;	i<currentitem.ucloopTime;	++i){
			if(!(iresult	=	whitePanelShading()))	break;
		}
		bUpdateItemStatus	=	true;
		break;
	case whitepanelitem_vignetting:
		updateItemstatus(itemstatus);
		for(unsigned char i=0;	i<currentitem.ucloopTime;	++i){
			if(!(iresult	=	whitePanelVignetting()))	break;
		}
		bUpdateItemStatus	=	true;
		break;
	case workcurrentitem:
		updateItemstatus(itemstatus);
		for(unsigned char i=0;	i<currentitem.ucloopTime;	++i){
			if(!(iresult	=	testworkcurrent())) break;
		}
		bUpdateItemStatus	=	true;
		break;
	case standbycurrentitem:
		updateItemstatus(itemstatus);
		for(unsigned char i=0;	i<currentitem.ucloopTime;	++i){
			if(!(iresult	=	teststandbycurrent())) break;
		}
		bUpdateItemStatus	=	true;
		break;
	case openshortitem:
		updateItemstatus(itemstatus);
		for(unsigned char i=0;	i<currentitem.ucloopTime;	++i){
			if(!(iresult	=	openshortTest())) break;
		}
		Sleep(50);
		bUpdateItemStatus	=	true;		
		break;
	case otpburnitem:
		updateItemstatus(itemstatus);
		for(unsigned char i=0;	i<currentitem.ucloopTime;	++i){
			if(!(iresult	=	otpburn()))	break;
		}
		bUpdateItemStatus	=	true;
		break;
	case lightsourcecheckitem:
		updateItemstatus(itemstatus);
		for(unsigned char i=0;	i<currentitem.ucloopTime;	++i){
			if(!(iresult	=	LightSourceCheck()))	break;
		}
		bUpdateItemStatus	=	true;
		break;
	case otpcheckitem:
		updateItemstatus(itemstatus);
		for(unsigned char i=0;	i<currentitem.ucloopTime;	++i){
			if(!(iresult	=	otpcheck()))		break;
		}
		bUpdateItemStatus	=	true;
		break;
	case getserialnumberitem:
		for(unsigned char i=0;	i<currentitem.ucloopTime;	++i){
			if(!(iresult	=	getSerialNumber()))	break;
		}
		bUpdateItemStatus	=	true;
		break;
	case burnserialnumberitem:
		break;
	case afburnitem:
		updateItemstatus(itemstatus);
		for(unsigned char i=0;	i<currentitem.ucloopTime;	++i){
			if(!(iresult	=	afBurn()))	break;
		}
		bUpdateItemStatus	=	true;
		break;
	case afburncheckitem:
		updateItemstatus(itemstatus);
		for(unsigned char i=0;	i<currentitem.ucloopTime;	++i){
			if(!(iresult	=	afBurnCheck())) break;
		}
		bUpdateItemStatus	=	true;
		break;
	case lsctemplateitem:
		{
			updateItemstatus(itemstatus);
			_scotherInfo otherInfo;
			globalgetShortcutAddInfoUnion(currentitem.usItem, currentitem.strAddInfo, otherInfo);	
			for(unsigned char i=0;	i<currentitem.ucloopTime;	++i){
				if(!(iresult	=	lschatemplate(!!otherInfo.uidata[0], otherInfo.uidata[1], otherInfo.uidata[2])))	break;
			}
			bUpdateItemStatus	=	true;
		}
		break;
	case saveimageitem:
		{
			_scotherInfo otherInfo;
			globalgetShortcutAddInfoUnion(currentitem.usItem, currentitem.strAddInfo, otherInfo);	
			saveimage(otherInfo.ucdata[0], otherInfo.ucdata[1], !!otherInfo.ucdata[2],  !!otherInfo.ucdata[3], otherInfo.usdata[2]);
		}		
		break;
	case blackfielditem:
		for(unsigned char i=0;	i<currentitem.ucloopTime;	++i){
			if(!(iresult	=	blackfield()))	break;
		}
		bUpdateItemStatus	=	true;
		break;
	case lpnearafcitem:
		{
			hisglobalparameter.flagLocker.lockForWrite();
			hisglobalparameter.stForivate.ucImageFontSize	=	hisglobalparameter.stForivate.ucImageTVLineFontSize;
			hisglobalparameter.stForivate.bImageFontBold		=	hisglobalparameter.stForivate.bImageTVLineFontBold;
			hisglobalparameter.flagLocker.unlock();
			updateItemstatus(itemstatus);
			int iOldStatics = 255;
			_scotherInfo otherInfo;
			globalgetShortcutAddInfoUnion(currentitem.usItem, currentitem.strAddInfo, otherInfo);	
			for(unsigned char i=0;	i<currentitem.ucloopTime;	++i){
				if(!(iresult	=	lpAFC(0, otherInfo.idata[0], iOldStatics)))	break;
			}
			if(iOldStatics != 255 && itemshareData.lpnearafcParameter)
				itemshareData.lpnearafcParameter->stTacticsBasic.ucTactics = iOldStatics;
			bUpdateItemStatus	=	true;
		}
		break;
	case lpmiddleafcitem:
		{
			hisglobalparameter.flagLocker.lockForWrite();
			hisglobalparameter.stForivate.ucImageFontSize	=	hisglobalparameter.stForivate.ucImageTVLineFontSize;
			hisglobalparameter.stForivate.bImageFontBold		=	hisglobalparameter.stForivate.bImageTVLineFontBold;
			hisglobalparameter.flagLocker.unlock();
			updateItemstatus(itemstatus);
			int iOldStatics = 255;
			_scotherInfo otherInfo;
			globalgetShortcutAddInfoUnion(currentitem.usItem, currentitem.strAddInfo, otherInfo);	
			for(unsigned char i=0;	i<currentitem.ucloopTime;	++i){
				if(!(iresult	=	lpAFC(1, otherInfo.idata[0], iOldStatics)))	break;
			}
			if(iOldStatics != 255 && itemshareData.lpmiddleafcParameter)
				itemshareData.lpmiddleafcParameter->stTacticsBasic.ucTactics = iOldStatics;
			bUpdateItemStatus	=	true;
		}
		break;
	case lpfarafcitem:
		{
			hisglobalparameter.flagLocker.lockForWrite();
			hisglobalparameter.stForivate.ucImageFontSize	=	hisglobalparameter.stForivate.ucImageTVLineFontSize;
			hisglobalparameter.stForivate.bImageFontBold		=	hisglobalparameter.stForivate.bImageTVLineFontBold;
			hisglobalparameter.flagLocker.unlock();
			updateItemstatus(itemstatus);
			int iOldStatics = 255;
			_scotherInfo otherInfo;
			globalgetShortcutAddInfoUnion(currentitem.usItem, currentitem.strAddInfo, otherInfo);	
			for(unsigned char i=0;	i<currentitem.ucloopTime;	++i){
				if(!(iresult	=	lpAFC(2, otherInfo.idata[0], iOldStatics)))	break;
			}
			if(iOldStatics != 255 && itemshareData.lpfarafcParameter)
				itemshareData.lpfarafcParameter->stTacticsBasic.ucTactics = iOldStatics;
			bUpdateItemStatus	=	true;
		}
		break;
	case serialportitem:
		{
			_scotherInfo otherInfo;
			globalgetShortcutAddInfoUnion(currentitem.usItem, currentitem.strAddInfo, otherInfo);
			for(unsigned char i=0;	i<currentitem.ucloopTime;	++i){
				iresult	=	serialport(QString::fromAscii(otherInfo.strdata+4),otherInfo.ucdata[1],otherInfo.ucdata[2],otherInfo.ucdata[3],otherInfo.ucdata[0]);
				if(!iresult)		break;
			}
			bUpdateItemStatus	=	true;
		}
		break;
	case camdoracalibrationitem:
		{
			_scotherInfo otherInfo;
			globalgetShortcutAddInfoUnion(currentitem.usItem, currentitem.strAddInfo, otherInfo);
			for(unsigned char i=0;	i<currentitem.ucloopTime;	++i){
				iresult	=	CamdoraCaliration(otherInfo.usdata[0],otherInfo.usdata[1],otherInfo.usdata[2],otherInfo.usdata[3],otherInfo.uidata[2], \
					otherInfo.usdata[6],otherInfo.usdata[7],otherInfo.usdata[8],otherInfo.usdata[9],otherInfo.usdata[10]);
				if(!iresult)		break;
			}
			bUpdateItemStatus	=	true;
		}
		break;
	case debugitem:
		{
			_scotherInfo otherInfo;
			globalgetShortcutAddInfoUnion(currentitem.usItem, currentitem.strAddInfo, otherInfo);
			rolongodebug(otherInfo.uidata[0]);
		}	
		break;
#ifdef _HisFX3_Platform_Jigboard
	case jigchange2previewitem:
		iresult	=	Jig_Change2Preview();
		bUpdateItemStatus	=	true;
		break;
	case jigchange2captureitem:
		iresult	=	Jig_Change2Capture();
		bUpdateItemStatus	=	true;
		break;
	case jignearfocusitem:
		if(!GetHisPreviewflag())	iresult =  HisCCMError_NotPreivew;
		if(!iresult){
			if(!(iresult = jigboard_GetAFFoucsPos(iNearPeakMotorDec, 0, &classPlatform)))
				emit information(QTextCodec::codecForName( "GBK")->toUnicode("近焦PEAK马达坐标：") % QString::number(iNearPeakMotorDec));
		}
		bUpdateItemStatus	=	true;
		break;
	case jigfarfocusitem:
		if(!GetHisPreviewflag())	iresult =  HisCCMError_NotPreivew;
		if(!iresult){
			if(!(iresult = jigboard_GetAFFoucsPos(iFarPeakMotorDec, 2, &classPlatform)))
				emit information(QTextCodec::codecForName( "GBK")->toUnicode("远焦PEAK马达坐标：") % QString::number(iFarPeakMotorDec));
		}
		bUpdateItemStatus	=	true;
		break;
#endif

#ifdef USE_EQUIPMENT_GB_AFBURN
	case afbgbtoposnearitem:
		for(unsigned char i=0;	i<currentitem.ucloopTime;	++i){
			if(!(iresult	=	movetopos(2, 0, 0)))	break;
		}
		bUpdateItemStatus	=	true;
		break;
	case afbgbtoposmiddleitem:
		for(unsigned char i=0;	i<currentitem.ucloopTime;	++i){
			if(!(iresult	=	movetopos(2, 0, 0)))	break;
		}
		bUpdateItemStatus	=	true;
		break;
	case afbgbtoposinfiniteitem:
		for(unsigned char i=0;	i<currentitem.ucloopTime;	++i){
			if(!(iresult	=	movetopos(3, 0, 0)))	break;
		}
		bUpdateItemStatus	=	true;
		break;
	case afbgbtobackfieldpositem:
		for(unsigned char i=0;	i<currentitem.ucloopTime;	++i){
			if(!(iresult	=	movetopos(5, 0, 0)))	break;
		}
		bUpdateItemStatus	=	true;
		break;
	case afbgbtowhitepaneposlitem:
		for(unsigned char i=0;	i<currentitem.ucloopTime;	++i){
			if(!(iresult	=	movetopos(4, 0, 0)))	break;
		}
		bUpdateItemStatus	=	true;
		break;
#endif
#ifdef USE_EQUIPMENT_GB_PDAF
		//1: 6cm   2: 15cm   3: 50cm   5:near   6: far 7: whitefield   8:blackfield
	case pdafgbto6cmpositem:
		for(unsigned char i=0;	i<currentitem.ucloopTime;	++i){
			if(!(iresult	=	movetopos(1))) break;
		}
		bUpdateItemStatus	=	true;
		break;
	case pdafgbto15cmpositem:
		for(unsigned char i=0;	i<currentitem.ucloopTime;	++i){
			if(!(iresult	=	movetopos(2))) break;
		}
		bUpdateItemStatus	=	true;
		break;
	case pdafgbto50cmpositem:
		for(unsigned char i=0;	i<currentitem.ucloopTime;	++i){
			if(!(iresult	=	movetopos(3))) break;
		}
		bUpdateItemStatus	=	true;
		break;
	case pdafgbtonearpositem:
		for(unsigned char i=0;	i<currentitem.ucloopTime;	++i){
			if(!(iresult	=	movetopos(5))) break;
		}
		bUpdateItemStatus	=	true;
		break;
	case pdafgbtoinfinitepositem:
		for(unsigned char i=0;	i<currentitem.ucloopTime;	++i){
			if(!(iresult	=	movetopos(6)))	break;
		}
		bUpdateItemStatus	=	true;
		break;
	case pdafgbtoblackfieldpositem:
		for(unsigned char i=0;	i<currentitem.ucloopTime;	++i){
			if(!(iresult	=	movetopos(8))) break;
		}
		bUpdateItemStatus	=	true;
		break;
	case pdafgbtowhitepanelpositem:
		for(unsigned char i=0;	i<currentitem.ucloopTime;	++i){
			if(!(iresult	=	movetopos(7))) break;
		}
		bUpdateItemStatus	=	true;
		break;
#endif
	case pdafgbmtkwhitecaliitem:
		for(unsigned char i=0;	i<currentitem.ucloopTime;	++i){
			if(!(iresult	=	PDAFCalibrationWhitePanel())) break;
		}
		bUpdateItemStatus	=	true;
		break;
	case pdafgbstep2caliitem:
		for(unsigned char i=0;	i<currentitem.ucloopTime;	++i){
			if(!(iresult	=	PDAFCalibrationSTEP2())) break;
		}
		bUpdateItemStatus	=	true;
		break;
	case pdafgbmtk50cmcaliitem:
		for(unsigned char i=0;	i<currentitem.ucloopTime;	++i){
			if(!(iresult	=	PDAFCalibration50CM())) break;
		}
		bUpdateItemStatus	=	true;
		break;
	case sonypdafSPCitem:
		for(unsigned char i=0;	i<currentitem.ucloopTime;	++i){
			if(!(iresult	=SONYIMX258PDAF_SPCCal())) break;
		}
		bUpdateItemStatus	=	true;
		break;
	case pdafgbmtkcheckitem:
		for(unsigned char i=0;	i<currentitem.ucloopTime;	++i){
			if(!(iresult	=	PDAFBurnCheck()))	break;
		}
		bUpdateItemStatus	=	true;
		break;
	case tiltroationtestdataburnitem:
		for(unsigned char i=0;	i<currentitem.ucloopTime;	++i){
			if(!(iresult	=	CameraTiltRotationTestDataBurn()))	break;
		}
		bUpdateItemStatus	=	true;
		break;
	case tiltroationtestdataburncheckitem:
		for(unsigned char i=0;	i<currentitem.ucloopTime;	++i){
			if(!(iresult	=	CameraTiltRotationTestTestDataBurnCheck()))	break;
		}
		bUpdateItemStatus	=	true;
		break;
	case dualcameracoaxialitytestdataburnitem:
		for(unsigned char i=0;	i<currentitem.ucloopTime;	++i){
			if(!(iresult	=	DualCameraCoaxilityTestDataBurn()))	break;
		}
		bUpdateItemStatus	=	true;
		break;
	case dualcameracoaxialitytestdataburncheckitem:
		for(unsigned char i=0;	i<currentitem.ucloopTime;	++i){
			if(!(iresult	=	DualCameraCoaxilityTestDataBurnCheck()))	break;
		}
		bUpdateItemStatus	=	true;
		break;
	case dualcamerastereotestitem:
		for(unsigned char i=0;	i<currentitem.ucloopTime;	++i){
			//if(!(iresult	=	CameraTiltRotationTestDataBurn()))	break;
		}
		bUpdateItemStatus	=	true;
		break;
	case dualcamerastereoburncheckitem:
		for(unsigned char i=0;	i<currentitem.ucloopTime;	++i){
			//if(!(iresult	=	CameraTiltRotationTestDataBurn()))	break;
		}
		bUpdateItemStatus	=	true;
		break;
	case sensordpcfunctionitem:
		for(unsigned char i=0;	i<currentitem.ucloopTime;	++i){
			if(!(iresult	=Sensor_DPC_FunctionProcess())) break;
		}
		bUpdateItemStatus	=	true;
		break;
#ifdef USE_EQUIPMENT_AFM_JSL_V1
	case jslafctoafpositem:
		for(unsigned char i=0;	i<currentitem.ucloopTime;	++i){
			if(!(iresult	=	_His_P8102_ToAF()))	break;		
		}
		bUpdateItemStatus	=	true;
		break;
	case jslafctooriginalpositem:
		for(unsigned char i=0;	i<currentitem.ucloopTime;	++i){
			if(!(iresult	=	_His_P8102_ToOriginal()))	break;		
		}
		bUpdateItemStatus	=	true;
		break;
	case jslafctowhitepanelpositem:
		for(unsigned char i=0;	i<currentitem.ucloopTime;	++i){
			if(!(iresult	=	_His_P8102_ToWhite()))	break;
		}
		bUpdateItemStatus	=	true;
		break;
	case jslafctoblackpanelpositem:
		for(unsigned char i=0;	i<currentitem.ucloopTime;	++i){
			if(!(iresult	=	_His_P8102_ToBlack()))	break;
		}
		bUpdateItemStatus	=	true;
		break;
	case jslafchomeitem:
		for(unsigned char i=0;	i<currentitem.ucloopTime;	++i){
			if(!(iresult	=	_His_P8102_Home()))	break;
		}
		bUpdateItemStatus	=	true;
		break;
	case jslafcverticalmoveitem:
		{
			_scotherInfo otherInfo;
			globalgetShortcutAddInfoUnion(currentitem.usItem, currentitem.strAddInfo, otherInfo);
			for(unsigned char i=0;	i<currentitem.ucloopTime;	++i)
			{
				if(otherInfo.idata[0]){
					if(!(iresult	=	_His_P8102_Move_A(otherInfo.idata[1])))	break;
				}
				else{
					if(!(iresult	=	_His_P8102_Move_R(otherInfo.idata[1])))	break;
				}
			}
			bUpdateItemStatus	=	true;
		}
		break;
	case jslafcringmoveitem:
		{
			_scotherInfo otherInfo;
			globalgetShortcutAddInfoUnion(currentitem.usItem, currentitem.strAddInfo, otherInfo);
			for(unsigned char i=0;	i<currentitem.ucloopTime;	++i){
				if(!(iresult	=	_His_P8102_Rotate(otherInfo.dfldata[0])))	break;
			}
		}
		bUpdateItemStatus	=	true;
		break;
#endif


	case mictestitem:
		{
			for(unsigned char i=0;	i<currentitem.ucloopTime;	++i){
				if(!(iresult	=	testMIC()))	break;
			}
			bUpdateItemStatus	=	true;

		}
		break;

	case ledtestitem:
		{
			bUpdateItemStatus	=	true;


			for(unsigned char i=0;	i<currentitem.ucloopTime;	++i){
				if(!(iresult	=	testLED()))	break;
			}


		}
		break;

	case fwburnitem:
		{
			updateItemstatus(itemstatus);			
			for(unsigned char i=0;	i<currentitem.ucloopTime;	++i){
				if(!(iresult	=	fwBurn()))	break;
			}
			bUpdateItemStatus	=	true;
		}
		break;


#if (defined USE_EQUIPMENT_AFM_JSL_V1)
	case autofageneralitem:
		updateItemstatus(itemstatus);
		bAutoFocus=true;
		for(unsigned char i=0;	i<currentitem.ucloopTime;	++i){
			if(!(iresult	=	gereralAutoFA())) break;
		}
		bUpdateItemStatus	=	true;
		break;
#endif
#ifdef USE_EQUIPMENT_JSL_FUNCTION_V1
	case jslfuncv1tohome:
		{
			unsigned char ucWrite[6] = {0x02,0x15,0x00,0x0d,0x16,0x0a};
			iresult	=	RsCommOut(ucWrite, 6);
			bUpdateItemStatus	=	true;
		}
		break;
	case jslfuncv1negtive90item:
		{
			unsigned char ucWrite[6] = {0x02,0x11,0x00,0x0d,0x16,0x0a};
			iresult	=	RsCommOut(ucWrite, 6);
			bUpdateItemStatus	=	true;
		}
		break;
	case jslfuncv1moduletoleft:
		{
			unsigned char ucWrite[6] = {0x02,0x12,0x01,0x0d,0x16,0x0a};
			iresult	=	RsCommOut(ucWrite, 6);
			bUpdateItemStatus	=	true;
		}
		break;
	case jslfuncv1moduletoright:
		{
			unsigned char ucWrite[6] = {0x02,0x12,0x00,0x0d,0x16,0x0a};
			iresult	=	RsCommOut(ucWrite, 6);
			bUpdateItemStatus	=	true;
		}
		break;
#endif
	case iobitoutitem:
		{
			updateItemstatus(itemstatus);
			_scotherInfo otherInfo;
			globalgetShortcutAddInfoUnion(currentitem.usItem, currentitem.strAddInfo, otherInfo);
			iresult	=	IOBitOut(otherInfo.uidata[0], otherInfo.uidata[1], otherInfo.uidata[2], otherInfo.uidata[3]);
			bUpdateItemStatus	=	true;
		}
		break;
	case motormoveitem:
		{
			updateItemstatus(itemstatus);
			_scotherInfo otherInfo;
			globalgetShortcutAddInfoUnion(currentitem.usItem, currentitem.strAddInfo, otherInfo);
			iresult	=	MotorMove(otherInfo.uidata[0], otherInfo.uidata[1], otherInfo.dfldata[2], otherInfo.uidata[2]);
			bUpdateItemStatus	=	true;
		}
		break;
	case chartalignlitem:
		{
			updateItemstatus(itemstatus);
			_scotherInfo otherInfo;
			globalgetShortcutAddInfoUnion(currentitem.usItem, currentitem.strAddInfo, otherInfo);
			for(unsigned char i=0;	i<currentitem.ucloopTime;	++i){
				if(!(iresult	=	ChartAlign(otherInfo.ucdata[0], otherInfo.ucdata[1], otherInfo.ucdata[2], otherInfo.usdata[2], otherInfo.usdata[3], \
					otherInfo.usdata[4], otherInfo.usdata[5], otherInfo.fldata[3], otherInfo.fldata[4], otherInfo.fldata[5], otherInfo.usdata[12])))	break;
			}
			bUpdateItemStatus	=	true;
		}
		break;
	case toposwhitepanelitem:
		{
			iresult	=	toPosWhitePanel();
			bUpdateItemStatus	=	true;
		}
		break;
	case rrtcheckmacroitem:
		{
			updateItemstatus(itemstatus);
			for(unsigned char i=0;	i<currentitem.ucloopTime;	++i){
				if(!(iresult	=	RRTCheck(0)))	break;
			}
			bUpdateItemStatus	=	true;
		}
		break;
	case rrtcheckfaritem:
		{
			updateItemstatus(itemstatus);
			for(unsigned char i=0;	i<currentitem.ucloopTime;	++i){
				if(!(iresult	=	RRTCheck(1)))	break;
			}
			bUpdateItemStatus	=	true;
		}
		break;
	case toposblackpanelitem:
		{
			iresult	=	toPosBlackPanel();
			bUpdateItemStatus	=	true;
		}
		break;
	case toposnearfocusitem:
		{
			iresult	=	toPosNearFocus();
			bUpdateItemStatus	=	true;
		}
		break;
	case toposfarfocuslitem:
		{
			iresult	=	toPosFarFocus();
			bUpdateItemStatus	=	true;
		}
		break;

	default:
		// 		QMessageBox::warning(this, QTextCodec::codecForName( "GBK")->toUnicode("创建与HisFX3Template.s3db的连接"),"error");
		break;
	}

	itemshareData.itemstatusLock.lockForWrite();
	currentitem.status |= _shoutCutDetail_Status_Tested;
	itemshareData.itemstatusLock.unlock();

	if(bUpdateItemStatus)
	{
		itemstatus.ucstatus	=	_His_ItemStatus_PASS;
		if(iresult){
			itemshareData.setTotalResult(iresult);	
			itemstatus.ucstatus	=	_His_ItemStatus_NG;
			itemstatus.iErrorCode=iresult;
			itemshareData.bNG=true;
		}

		itemstatus.ustime	=	testtimer.elapsed();
		updateItemstatus(itemstatus);
	}

	if(iresult){

		emit information(GetHisFX3ErrorInfo(iresult));
	}	
	return iresult;
}

void itemprocess::ExecKeyshortcut(char key, unsigned char uctimer)
{
	bool bDualCamera = (classPlatform.getCameraCountSupported() == 2);
	itemshareData.shortcutInit(key, uctimer, bDualCamera);
	threadshareData.SetHisTestingflag(true);
	QMutexLocker locker(&itemshareData.mutexItemExec);

	if(!bDualCamera && !bBoxChannel1)
	{
		threadshareData.SetHisTestingflag(false);
		return;
	}

	unsigned int uiIndexAdd	=	1;
	unsigned short usItemFail;
	int iNextItemIndex,iresult;
	bool bLoop = true;
	while(bLoop)
	{
		bLoop	=	 false;
		if((iNextItemIndex = HISCCMSHORTCUT::getNextTestItem(key, uctimer, uiIndexAdd,bDualCamera, bBoxChannel1)) >= 0)
		{
			bLoop	=	true;
			if((key == '#') && itemshareData.shortcutgather.at(iNextItemIndex).bMaster)
			{
				bMasterItemExecFinish	=	false;
				emit signalwriteMasterItemExec(itemshareData.shortcutgather.at(iNextItemIndex).usItem, itemshareData.shortcutgather.at(iNextItemIndex).ucItemIndex, 0x00, bBoxChannel1);
				QElapsedTimer classTime;
				classTime.start();
				iresult = HisFX3Error_Timeout;
				while(classTime.elapsed() < hisglobalparameter.stOperatorMode.u16SlaveMasterTimeout *1000)
				{
					Sleep(20);
					threadshareData.flaglock.lockForRead();
					if(bMasterItemExecFinish) {iresult = (u8MasterItemExecStatus)?(HisCCMError_Result):(0);}
					threadshareData.flaglock.unlock();
					if(iresult != HisFX3Error_Timeout) break;
				}

				itemshareData.itemstatusLock.lockForWrite();
				itemshareData.shortcutgather[iNextItemIndex].status |= _shoutCutDetail_Status_Tested;
				itemshareData.itemstatusLock.unlock();

				_itemStatus itemstatus;
				itemstatus.usitem	=	itemshareData.shortcutgather[iNextItemIndex].usItem;
				itemstatus.ucstatus	=	_His_ItemStatus_PASS;
				if(iresult){
					itemshareData.setTotalResult(iresult);
					itemstatus.ucstatus	=	_His_ItemStatus_NG;
				}

				itemstatus.ustime	=	classTime.elapsed();
				updateItemstatus(itemstatus);

				if(iresult)	emit information(GetHisFX3ErrorInfo(iresult));
				emit signalwriteItemResult(itemshareData.shortcutgather[iNextItemIndex].usItem, !!iresult, bBoxChannel1);
			}
			else
			{
				iresult	=	operateItem(itemshareData.shortcutgather[iNextItemIndex]);
				if(hisglobalparameter.stOperatorMode.ucMode == 2)
					emit signalwriteItemResult(itemshareData.shortcutgather[iNextItemIndex].usItem, !!iresult, bBoxChannel1);
			}
		}

		if(!bLoop) break;

		usItemFail	=	0;
#ifdef USE_EQUIPMENT_AFM_JSL_V1
		if (itemshareData.shortcutgather.at(iNextItemIndex).usItem == mtffcinfiniteitem && !iresult && itemshareData.shortcutgather.at(iNextItemIndex).usItemfail){
			usItemFail	=	itemshareData.shortcutgather.at(iNextItemIndex).usItemfail;
		}
#endif
		if(!usItemFail && iresult && itemshareData.shortcutgather.at(iNextItemIndex).usItemfail) usItemFail	=	itemshareData.shortcutgather.at(iNextItemIndex).usItemfail;

		if(usItemFail)
		{
			int iFailIndex	=	HISCCMSHORTCUT::getNextTestItemFail(itemshareData.shortcutgather,  key, uctimer, uiIndexAdd, usItemFail, bDualCamera);
			if(iFailIndex < 0)
			{
				for(int x=0;	x<itemshareData.shortcutgather.size();	++x)
				{
					if(itemshareData.shortcutgather[x].shortcutKey == '#' && (itemshareData.shortcutgather[x].ucItemIndex > uiIndexAdd) && \
						itemshareData.shortcutgather[x].bMaster)
						emit signalwriteMasterItemExec(itemshareData.shortcutgather.at(x).usItem, itemshareData.shortcutgather.at(x).ucItemIndex, 0x01, bBoxChannel1);
				}
				/*
				_shoutCutDetail stItem;
				stItem.usItem	=	usItemFail;
				stItem.usItemfail	=	0;
				stItem.ucloopTime	=	1;
				stItem.shortcutKey	=	key;
				stItem.bDualCamera	=	true;
				stItem.ucClickTime		=	uctimer;
				stItem.ucItemIndex		=	0xFF;
				operateItem(stItem);
				*/
				break;
			}
			else{
				for(int x=0;	x<itemshareData.shortcutgather.size();	++x)
				{
					if((itemshareData.shortcutgather[x].shortcutKey == '#') && (itemshareData.shortcutgather[x].ucItemIndex > uiIndexAdd) && \
						(itemshareData.shortcutgather[x].ucItemIndex < iFailIndex) && itemshareData.shortcutgather[x].bMaster)
						emit signalwriteMasterItemExec(itemshareData.shortcutgather.at(x).usItem, itemshareData.shortcutgather.at(x).ucItemIndex, 0x01, bBoxChannel1);
				}
				uiIndexAdd	=	iFailIndex;
			}
		}
		else
		{
			uiIndexAdd++;
		}
	}

	threadshareData.SetHisTestingflag(false);
}

#if 0
void itemprocess::ExecKeyshortcut(char key, unsigned char uctimer)
{
	threadshareData.SetHisTestingflag(true);
	QMutexLocker locker(&itemshareData.mutexItemExec);

	int iNextItemIndexC1,iresultc1;
	unsigned int uiIndexAdd	=	1;
	unsigned short usItemFail;
	bool bC1	=	true;
	while(bC1)
	{
		bC1	=	 false;
		if((iNextItemIndexC1 = HISCCMSHORTCUT::getNextTestItemOneChannel(itemshareData.shortcutgather, key, uctimer, uiIndexAdd)) >= 0){
			bC1	=	true;
			iresultc1	=	operateItem(itemshareData.shortcutgather.at(iNextItemIndexC1));
		}

		if(!bC1) break;

		usItemFail	=	0;
		if(iresultc1 && itemshareData.shortcutgather.at(iNextItemIndexC1).usItemfail) usItemFail	=	itemshareData.shortcutgather.at(iNextItemIndexC1).usItemfail;
		if(usItemFail)
		{
			int iFailIndex	=	HISCCMSHORTCUT::getNextTestItemOneChannelFail(itemshareData.shortcutgather,  key, uctimer, uiIndexAdd, usItemFail);
			if(iFailIndex < 0)
			{
				_shoutCutDetail stItem;
				stItem.usItem	=	usItemFail;
				stItem.usItemfail	=	0;
				stItem.ucloopTime	=	1;
				stItem.shortcutKey	=	key;
				stItem.bDualCamera	=	true;
				stItem.ucClickTime		=	uctimer;
				stItem.ucItemIndex		=	0xFF;
				operateItem(stItem);
				break;
			}
			else{
				uiIndexAdd	=	iFailIndex;
			}
		}
		else
		{
			uiIndexAdd++;
		}
	}

	threadshareData.SetHisTestingflag(false);
}
#endif

void itemprocess::clearplotitem()
{
	itemshareData.plotLock.lockForWrite();
	if(itemshareData.plotimage.width() != 4 || itemshareData.plotimage.height() != 4){
		QImage tempimage(4, 4, QImage::Format_RGB888);
		tempimage.fill(QColor::fromRgb(240, 240, 240));
		itemshareData.plotimage	=	tempimage;
	}
	itemshareData.plotLock.unlock();
	emit plotpainter(0);
}
int itemprocess::FishEyeForjunge(double dspec)
{
	_CODE_CLEAR_IMAGEDRAW
		if(!(threadshareData.GetHisPreviewflag()))
			return HisFX3Error_IsNotPreview;
	int iresult = getccmhardwareParameter(false);
	if(iresult)	return iresult;
	QString strSerialNumber;
	classLog->getserialnumber(strSerialNumber);

	itemshareData.itemparameterLock.lockForRead();
	int icenterx,icentery;
	CRolongoImageTestAlg cit;
	unsigned char* CameraBufRaw = NULL;
	bool bInitFrame	=	true;
	std::vector<double> dvect;
	std::vector<_itemDraw> vectorDraw;
	vectorDraw.reserve(50);
	// 	double dmaxpercent	=0;
	// 	double dminpercent	=1;
	double dtemp	=0;
	dvect.clear();
	int iImgWidth =	itemshareData.previewParameter->iWidth, iImgHeight =	itemshareData.previewParameter->iHeight;
	unsigned int uiRawImgSize		=	iImgWidth * iImgHeight *3;
	unsigned char ucFrameType		=	_FrameType_RGB24;
	//unsigned int uiPixelSize	=	iImgWidth *iImgHeight;
	CameraBufRaw		=	(unsigned char*)_aligned_malloc(uiRawImgSize, _HisCacheLine_Aligned);
	if(!CameraBufRaw){
		HisReleaseMalloc(CameraBufRaw);
		itemshareData.itemparameterLock.unlock();
		return HisFX3Error_MallocBuffer;
	}
	while(threadshareData.GetHisPreviewflag() && hisglobalparameter.getfaflag())
	{
		if(iresult=GetFreshframe(CameraBufRaw,uiRawImgSize,ucFrameType,bInitFrame)) 
		{
			HisReleaseMalloc(CameraBufRaw);
			itemshareData.itemparameterLock.unlock();
			return iresult;
		}
		//break; 
		iresult	=	cit.cvRolongoForjungeFishEye(CameraBufRaw,iImgWidth,iImgHeight,icenterx,icentery,dvect,100);
		if (iresult)
		{
			HisReleaseMalloc(CameraBufRaw);
			itemshareData.itemparameterLock.unlock();
			return iresult;
		}
		ROPLOW::AddDrawFishEyetestitem(dvect,iImgWidth,iImgHeight,vectorDraw,dspec,icenterx,icentery);
		_CODE_RJAFA_LP_ASIGNDRAW

			for (int i=0;i< dvect.size();i++/*std::vector<double>::iterator diter = dvect.begin();diter!=dvect.end();diter++*/)
			{

				dtemp	=	dvect.at(i);

				if (dtemp > dspec)
				{
					HisReleaseMalloc(CameraBufRaw);
					itemshareData.itemparameterLock.unlock();
					return HisCoaxiality_ErrorRESULT;
				}
			}
	}

	if(!threadshareData.GetHisPreviewflag())
	{
		iresult	=	HisCCMError_NotPreivew;
		HisReleaseMalloc(CameraBufRaw);
		itemshareData.itemparameterLock.unlock();
		return iresult;
	}

	HisReleaseMalloc(CameraBufRaw);
	itemshareData.itemparameterLock.unlock();
	return 0;
}
int itemprocess::dualcameracoaxialitytest(double dDualCameraCenterdistacne, double dSquare_HorizontalDistance, double dSquare_VerticalDistance,double dTestDistance,bool bMainCameraColorSensor, bool bSubCameraColorSensor,double dSpecx,double dSpecy,int iSpecH,int iSpecV)
{

	_CODE_CLEAR_IMAGEDRAW
		if(!(threadshareDataC1.GetHisPreviewflag() && threadshareDataC2.GetHisPreviewflag())) return HisFX3Error_IsNotPreview;
	int iresult = getccmhardwareParameter(false);
	if(iresult)	return iresult;
	QString strSerialNumber;
	classLog->getserialnumber(strSerialNumber);

	itemshareData.itemparameterLock.lockForRead();

	unsigned char* pucMainCameraBufRaw = NULL;
	unsigned char*pucSubCameraBufRaw=NULL;
	int iImgWidthC1 =	itemshareDataC1.previewParameter->iWidth, iImgHeightC1 =	itemshareDataC1.previewParameter->iHeight;
	unsigned int uiRawImgSizeC1		=	iImgWidthC1 * iImgHeightC1 *3;
	unsigned char ucFrameType		=	_FrameType_RGB24;
	//unsigned int uiPixelSize	=	iImgWidth *iImgHeight;
	pucMainCameraBufRaw		=	(unsigned char*)_aligned_malloc(uiRawImgSizeC1, _HisCacheLine_Aligned);
	if(!pucMainCameraBufRaw){
		HisReleaseMalloc(pucMainCameraBufRaw);
		itemshareData.itemparameterLock.unlock();
		return HisFX3Error_MallocBuffer;
	}

	int iImgWidthC2 =	itemshareDataC2.previewParameter->iWidth, iImgHeightC2 =	itemshareDataC2.previewParameter->iHeight;
	unsigned int uiRawImgSizeC2		=	iImgWidthC2 * iImgHeightC2 *3;
	pucSubCameraBufRaw		=	(unsigned char*)_aligned_malloc(uiRawImgSizeC2, _HisCacheLine_Aligned);
	if(!pucSubCameraBufRaw){
		HisReleaseMalloc(pucMainCameraBufRaw);
		HisReleaseMalloc(pucSubCameraBufRaw);
		itemshareData.itemparameterLock.unlock();
		return HisFX3Error_MallocBuffer;
	}

	std::vector<_itemDraw> vectorDraw;
	vectorDraw.reserve(50);
	bool bInitFrame	=	true;
	double dAngleX=0.0f, dAngleY=0.0f,dAngleZ=0.0f;
	int iHorizontalShiftX=0,iVerticalShiftY=0;
	//Channel1 Main Camera    Channel2Camera Sub Camera
	while(threadshareDataC1.GetHisPreviewflag() && threadshareDataC2.GetHisPreviewflag() && hisglobalparameter.getfaflag())
	{

		if(iresult=GetFreshframeC1(pucMainCameraBufRaw,uiRawImgSizeC1,ucFrameType,bInitFrame)) break; 

		if(iresult=GetFreshframeC2(pucSubCameraBufRaw,uiRawImgSizeC2,ucFrameType,bInitFrame)) break;
		bInitFrame=false;
		vectorDraw.clear();
		iresult =	classRolongoTest.cvRolongoCoaxialityCailibrationbySquare(pucMainCameraBufRaw,true,iImgWidthC1,iImgHeightC1,pucSubCameraBufRaw,true,\
			iImgWidthC2,iImgHeightC2,dSquare_HorizontalDistance,dSquare_VerticalDistance,10,dTestDistance, \
			dAngleX,dAngleY,dAngleZ,iHorizontalShiftX,iVerticalShiftY);

		if (iresult)
		{
			HisReleaseMalloc(pucMainCameraBufRaw);
			HisReleaseMalloc(pucSubCameraBufRaw);
			itemshareData.itemparameterLock.unlock();
			//QMessageBox::warning(this, "ERROR", "error iresult");
			return iresult;
		}
		ROPLOW::AddDrawcoaxialityitem(dAngleX,dAngleY,dAngleZ,iHorizontalShiftX,iVerticalShiftY,iImgWidthC1,iImgHeightC1,vectorDraw,dSpecx,dSpecy,iSpecH,iSpecV);
		// 		emit information(QString::number(iHorizontalShiftX));
		_CODE_RJAFA_LP_ASIGNDRAW

			Sleep(200);
	}

	if(iresult)
	{
		HisReleaseMalloc(pucMainCameraBufRaw);
		HisReleaseMalloc(pucSubCameraBufRaw);
		itemshareData.itemparameterLock.unlock();
		return iresult;
	}


	if(!threadshareData.GetHisPreviewflag())
	{
		iresult	=	HisCCMError_NotPreivew;
		HisReleaseMalloc(pucMainCameraBufRaw);
		HisReleaseMalloc(pucSubCameraBufRaw);
		itemshareData.itemparameterLock.unlock();
		return iresult;
	}
	if (abs(dAngleX) > abs(dSpecx) || abs(dAngleY) > abs(dSpecy) || abs(iHorizontalShiftX) > abs(iSpecH) || abs(iVerticalShiftY) > abs(iSpecV))
	{
		HisReleaseMalloc(pucMainCameraBufRaw);
		HisReleaseMalloc(pucSubCameraBufRaw);
		itemshareData.itemparameterLock.unlock();
		return HisCoaxiality_ErrorRESULT;
	}
	HisReleaseMalloc(pucMainCameraBufRaw);
	HisReleaseMalloc(pucSubCameraBufRaw);
	itemshareData.itemparameterLock.unlock();

	return 0;

}

int itemprocess::dualcameracoaxialitytilttest(bool bMainCameraColorSensor, bool bSubCameraColorSensor,double dspecx,double dspecy)
{
	_CODE_CLEAR_IMAGEDRAW
		if(!threadshareDataC1.GetHisPreviewflag() && !threadshareDataC2.GetHisPreviewflag()) 
			return HisFX3Error_IsNotPreview;
	int iresult = getccmhardwareParameter(false);
	if(iresult)	return iresult;
	QString strSerialNumber;
	classLog->getserialnumber(strSerialNumber);

	itemshareData.itemparameterLock.lockForRead();

	unsigned char* pucMainCameraBufRaw = NULL;
	unsigned char*pucSubCameraBufRaw=NULL;
	int iImgWidthC1;
	int iImgHeightC1;
	unsigned int uiRawImgSizeC1;
	unsigned char ucFrameType		=	_FrameType_RGB24;
	int iImgWidthC2;
	int iImgHeightC2;
	unsigned int uiRawImgSizeC2;
	if(threadshareDataC1.GetHisPreviewflag())
	{

		iImgWidthC1 =	itemshareDataC1.previewParameter->iWidth;
		iImgHeightC1 =	itemshareDataC1.previewParameter->iHeight;
		uiRawImgSizeC1		=	iImgWidthC1 * iImgHeightC1 *3;
		//unsigned int uiPixelSize	=	iImgWidth *iImgHeight;
		pucMainCameraBufRaw		=	(unsigned char*)_aligned_malloc(uiRawImgSizeC1, _HisCacheLine_Aligned);
		if(!pucMainCameraBufRaw){
			HisReleaseMalloc(pucMainCameraBufRaw);
			itemshareData.itemparameterLock.unlock();
			return HisFX3Error_MallocBuffer;
		}
	}
	if(threadshareDataC2.GetHisPreviewflag() )
	{
		iImgWidthC2 =	itemshareDataC2.previewParameter->iWidth;
		iImgHeightC2 =	itemshareDataC2.previewParameter->iHeight;
		uiRawImgSizeC2		=	iImgWidthC2 * iImgHeightC2 *3;
		pucSubCameraBufRaw		=	(unsigned char*)_aligned_malloc(uiRawImgSizeC2, _HisCacheLine_Aligned);
		if(!pucSubCameraBufRaw){
			HisReleaseMalloc(pucMainCameraBufRaw);
			HisReleaseMalloc(pucSubCameraBufRaw);
			itemshareData.itemparameterLock.unlock();
			return HisFX3Error_MallocBuffer;
		}
	}

	std::vector<_itemDraw> vectorDraw;
	vectorDraw.reserve(50);
	bool bInitFrame	=	true;
	double dAngleX=0.0f, dAngleY=0.0f;
	int iHorizontalShiftX=0,iVerticalShiftY=0;
	//Channel1 Main Camera    Channel2Camera Sub Camera
	while(threadshareData.GetHisPreviewflag() && hisglobalparameter.getfaflag())
	{
		vectorDraw.clear();
		int iresult;
		if(threadshareDataC1.GetHisPreviewflag())
		{
			if(iresult=GetFreshframe(pucMainCameraBufRaw,uiRawImgSizeC1,_FrameType_RGB24,true)) break; 
			bInitFrame=false;
			iresult =	classRolongoTest.cvRolongoCoaxialityCailibrationTiltbyCircle(pucMainCameraBufRaw,true,iImgWidthC1,iImgHeightC1,dAngleX,dAngleY);
			if (iresult)
			{
				//QMessageBox::warning(this, "ERROR", "error iresult");
				HisReleaseMalloc(pucMainCameraBufRaw);
				HisReleaseMalloc(pucSubCameraBufRaw);
				itemshareData.itemparameterLock.unlock();
				return iresult;
			}
			ROPLOW::AddDrawcoaxialitytiltitem(dAngleX,dAngleY,iImgWidthC1,iImgHeightC1,vectorDraw,dspecx,dspecy);
			_CODE_RJAFA_LP_ASIGNDRAW
		}
		else if(threadshareDataC2.GetHisPreviewflag())
		{
			if(iresult=GetFreshframeC2(pucSubCameraBufRaw,uiRawImgSizeC2,ucFrameType,bInitFrame)) break; 
			bInitFrame=false;
			iresult =	classRolongoTest.cvRolongoCoaxialityCailibrationTiltbyCircle(pucSubCameraBufRaw,true,iImgWidthC2,iImgHeightC2,dAngleX,dAngleY);
			if (iresult)
			{
				//QMessageBox::warning(this, "ERROR", "error iresult");
				HisReleaseMalloc(pucMainCameraBufRaw);
				HisReleaseMalloc(pucSubCameraBufRaw);
				itemshareData.itemparameterLock.unlock();
				return iresult;
			}
			ROPLOW::AddDrawcoaxialitytiltitem(dAngleX,dAngleY,iImgWidthC2,iImgHeightC2,vectorDraw,dspecx,dspecy);
			_CODE_RJAFA_LP_ASIGNDRAW
		}

		Sleep(200);
	}

	if(!threadshareData.GetHisPreviewflag())
	{
		iresult	=	HisCCMError_NotPreivew;
		HisReleaseMalloc(pucMainCameraBufRaw);
		HisReleaseMalloc(pucSubCameraBufRaw);
		itemshareData.itemparameterLock.unlock();
		return iresult;
	}
	if (abs(dAngleX) > abs(dspecx) || abs(dAngleY) > abs(dspecy))
	{
		HisReleaseMalloc(pucMainCameraBufRaw);
		HisReleaseMalloc(pucSubCameraBufRaw);
		itemshareData.itemparameterLock.unlock();
		return HisCoaxiality_ErrorRESULT;
	}
	HisReleaseMalloc(pucMainCameraBufRaw);
	HisReleaseMalloc(pucSubCameraBufRaw);
	itemshareData.itemparameterLock.unlock();

	return 0;

}

int itemprocess::getdualcameraParameter(bool bupdate, bool bcheck)
{
	itemshareData.itemparameterLock.lockForRead();
	if(!bupdate && itemshareData.dualCameraParameter){
		itemshareData.itemparameterLock.unlock();
		return 0;
	}

	QMutexLocker locker(&hisglobalparameter.mutexDatabase);

	itemshareData.itemparameterLock.unlock();
	itemshareData.itemparameterLock.lockForWrite();
	if(!itemshareData.dualCameraParameter)
		itemshareData.dualCameraParameter		=	new _dualCameraParameter;
	if(!itemshareData.dualCameraParameter){
		itemshareData.itemparameterLock.unlock();
		return HisFX3Error_MallocBuffer;
	}

	bool bparsesuccess	=	true, bItemExist = false;

	//读取，解析config
	for(int  w=0;	w<1;	++w){ //此处是有意义的,不要删除
		QSqlDatabase customdb = QSqlDatabase::addDatabase("QSQLITE", "querycustom");
		customdb.setDatabaseName(QDir::currentPath() % "/HisFX3Custom");
		if (!customdb.open()){
			bparsesuccess	=	false;
			break;
		}

		QString strData, strdata2;
		QStringList strname, strvalue;
		QSqlQuery query(customdb);
		query.prepare("SELECT itemsuffix2,key,value,reserve FROM " % itemshareData.currentTableName % \
			" WHERE classfy='algorithm' AND item='ducalcameraburn' ORDER BY id ASC" );
		query.exec();


		while (query.next()){
			bItemExist = true;
			for(int y=0;	y<4;	++y){
				strData	=	query.value(y).toString();
				ROPLOW::patchconfigstring(strData, strname, strvalue);
				for(int x=0;	x<strname.size();	++x){
					if(strname.at(x) == "burn") itemshareData.dualCameraParameter->bburn = (strvalue.at(x) == "true");
					else if(strname.at(x)== "onlycheckdata")   itemshareData.dualCameraParameter->bOnlyCheckData =(strvalue.at(x)=="true");
					else if(strname.at(x) == "burnrule")	itemshareData.dualCameraParameter->strDualCameraBurnChoose		=	strvalue.at(x).toUpper();
					else if(strname.at(x) == "chart2lensposition")	itemshareData.dualCameraParameter->dChart2lensDistance_Rotation	=	strvalue.at(x).toDouble();
					else if(strname.at(x) == "Focuslength")	itemshareData.dualCameraParameter->dFocusLength_Rotation	=	strvalue.at(x).toDouble();
					else if(strname.at(x) == "cycledishorizontal")	itemshareData.dualCameraParameter->dCycleDistanceHorizontal_Rotation	=	strvalue.at(x).toDouble();
					else if(strname.at(x) == "cycledisvertical")	itemshareData.dualCameraParameter->dCycleDistanceVertical_Rotation	=	strvalue.at(x).toDouble();
					else if(strname.at(x) == "maxtiltXspec")	itemshareData.dualCameraParameter->dMaxTiltX	=	strvalue.at(x).toDouble();
					else if(strname.at(x) == "maxtiltYspec")	itemshareData.dualCameraParameter->dMaxTiltY	=	strvalue.at(x).toDouble();
					else if(strname.at(x) == "maxrotationspec")	itemshareData.dualCameraParameter->dMaxRotation	=	strvalue.at(x).toDouble();
					else if(strname.at(x) == "mintiltXspec")	itemshareData.dualCameraParameter->dMinTiltX	=	strvalue.at(x).toDouble();
					else if(strname.at(x) == "mintiltYspec")	itemshareData.dualCameraParameter->dMinTiltY	=	strvalue.at(x).toDouble();
					else if(strname.at(x) == "minrotationspec")	itemshareData.dualCameraParameter->dMinRotation	=	strvalue.at(x).toDouble();
					else if(strname.at(x) == "cameracenterxoffest")	itemshareData.dualCameraParameter->dCameraCenterXShift	=	strvalue.at(x).toDouble();
					else if(strname.at(x) == "cameracenteryoffest")	itemshareData.dualCameraParameter->dCameraCenterYShift	=	strvalue.at(x).toDouble();

					else if(strname.at(x) == "coaxialityburn") itemshareData.dualCameraParameter->bCoaxialityburn = (strvalue.at(x) == "true");
					else if(strname.at(x)== "coaxialityonlycheckdata")   itemshareData.dualCameraParameter->bCoaxialityOnlyCheckData =(strvalue.at(x)=="true");
					else if(strname.at(x) == "coaxialityburnrule")	itemshareData.dualCameraParameter->strDualCameraCoaxialityBurnChoose		=	strvalue.at(x).toUpper();
					else if(strname.at(x) == "dualcameracenterdistance")	itemshareData.dualCameraParameter->dDualCameraCenterDistance	=	strvalue.at(x).toDouble();
					else if(strname.at(x) == "square_horizontaldistance")	itemshareData.dualCameraParameter->dSquare_HorizontalDistance	=	strvalue.at(x).toDouble();
					else if(strname.at(x) == "square_verticaldistance")	itemshareData.dualCameraParameter->dSquare_VerticalDistance	=	strvalue.at(x).toDouble();
					else if(strname.at(x) == "coaxialitytestdistance")	itemshareData.dualCameraParameter->dCoaxialityTestDistance	=	strvalue.at(x).toDouble();
					else if(strname.at(x) == "maxspecx")	itemshareData.dualCameraParameter->dMaxAngleX	=	strvalue.at(x).toDouble();
					else if(strname.at(x) == "maxspecy")	itemshareData.dualCameraParameter->dMaxAngleY	=	strvalue.at(x).toDouble();
					else if(strname.at(x) == "maxspecz")	itemshareData.dualCameraParameter->dMaxAngleZ	=	strvalue.at(x).toDouble();
					else if(strname.at(x) == "maxshiftx")	itemshareData.dualCameraParameter->iMaxShiftX	=	strvalue.at(x).toInt();
					else if(strname.at(x) == "maxshifty")	itemshareData.dualCameraParameter->iMaxShiftY	=	strvalue.at(x).toInt();
					else if(strname.at(x) == "bmaincameracolorsensor") itemshareData.dualCameraParameter->bMainCameraColorSensor = (strvalue.at(x) == "true");
					else if(strname.at(x) == "bsubcameracolorsensor") itemshareData.dualCameraParameter->bSubCameraColorSensor = (strvalue.at(x) == "true");

				}
			}
		}

		customdb.close();
	}

	QSqlDatabase::removeDatabase("querycustom");
	if(!bparsesuccess || !bItemExist)
	{
		HisReleaseNewO(itemshareData.dualCameraParameter);
		itemshareData.itemparameterLock.unlock();
		return HisFX3Error_Parameter;
	}

	if(!bcheck) {itemshareData.itemparameterLock.unlock(); return 0; }

	if(itemshareData.dualCameraParameter->strDualCameraBurnChoose.isEmpty()){
		HisReleaseNewO(itemshareData.dualCameraParameter);
		itemshareData.itemparameterLock.unlock();
		return HisFX3Error_Parameter;
	}


	itemshareData.itemparameterLock.unlock();
	return 0;
}


int itemprocess::CameraTiltRotationTestDataBurn()
{
	//判断图像是否点亮中
	if(!threadshareData.GetHisPreviewflag())
		return HisCCMError_NotPreivew;

	//取得配置参数和规格
	int iresult	=	getdualcameraParameter(false);
	if(iresult)
		return iresult;
	iresult	=	getccmhardwareParameter(false);
	if(iresult)
		return iresult;

	itemshareData.itemparameterLock.lockForRead();

	_HisCCMDualCameraBurn_Config stParameter;
	stParameter.iheight		=	itemshareData.previewParameter->iHeight;
	stParameter.iwidth		=	itemshareData.previewParameter->iWidth;
	stParameter.uiDataFormat	=	itemshareData.previewParameter->ucDataFormat;
	stParameter.strproject	=	(itemshareData.ccmhardwareParameter->projectname.toAscii()).data();
	stParameter.strsensor	=	(itemshareData.ccmhardwareParameter->sensortype.toAscii()).data();
	stParameter.strFunctionChoose	=	(itemshareData.dualCameraParameter->strDualCameraBurnChoose.toAscii()).data();
	stParameter.ucSlave		=	itemshareData.previewParameter->ucSlave;
	stParameter.ucEESlave	=	itemshareData.ccmhardwareParameter->ucEESlave;
	stParameter.bDebug		=	hisglobalparameter.bDebugMode;

	QString strSerialNumber;
	classLog->getserialnumber(strSerialNumber);
	stParameter.strSerialNumber	=	strSerialNumber.toAscii().data();

#if (defined _WIN64) && (defined _DEBUG)
	QString strLibPath	=	QDir::currentPath() % "/HisCCMOTP64D";
#elif (defined _WIN64) && !(defined _DEBUG)
	QString strLibPath	=	QDir::currentPath() % "/HisCCMOTP64";
#elif (defined _WIN32) && (defined _DEBUG)
	QString strLibPath	=	QDir::currentPath() % "/HisCCMOTP32D";
#else
	QString strLibPath	=	QDir::currentPath() % "/HisCCMOTP32";
#endif

	RolongoOTPAPIVersion getRolongoOTPAPIVersion = (RolongoOTPAPIVersion)(QLibrary::resolve(strLibPath, "getRolongoOTPAPIVersion"));
	Rolongowritedualcameratestdata writedualcameratestdata = (Rolongowritedualcameratestdata)(QLibrary::resolve(strLibPath, "writedualcameratestdata"));

	if(!(getRolongoOTPAPIVersion && writedualcameratestdata)){
		emit information(tr("Resolve HisCCMOTP DLL Function Fail"));
		itemshareData.itemparameterLock.unlock();
		return HisCCMError_LoadDLLFuc;
	}

	unsigned char* pucRGBBuffer = NULL;
	unsigned int uiImgSize=itemshareData.previewParameter->iWidth*itemshareData.previewParameter->iHeight*3;
	unsigned char ucFrameType		=	_FrameType_RGB24;

	pucRGBBuffer		=	(unsigned char*)_aligned_malloc(uiImgSize, _HisCacheLine_Aligned);
	if(!pucRGBBuffer)
	{
		HisReleaseMalloc(pucRGBBuffer);
		itemshareData.itemparameterLock.unlock();
		return HisFX3Error_MallocBuffer;
	}

	iresult	=	GetFreshframe(pucRGBBuffer, uiImgSize, ucFrameType, true);
	if(iresult){
		HisReleaseMalloc(pucRGBBuffer);
		itemshareData.itemparameterLock.unlock();
		return iresult;
	}
	int iTiltAngleX=0,iTiltAngleY=0,iRotationAngle=0,iSiftX=0,iSiftY=0;
	iresult =	classRolongoTest.cvRolongoTiltFunction(pucRGBBuffer,itemshareData.previewParameter->iWidth,itemshareData.previewParameter->iHeight,
		itemshareData.dualCameraParameter->dChart2lensDistance_Rotation,
		itemshareData.dualCameraParameter->dFocusLength_Rotation,
		itemshareData.dualCameraParameter->dCycleDistanceHorizontal_Rotation,
		itemshareData.dualCameraParameter->dCycleDistanceVertical_Rotation,
		iTiltAngleX,iTiltAngleY,iRotationAngle,iSiftX,iSiftY,itemshareData.dualCameraParameter->dCameraCenterXShift,itemshareData.dualCameraParameter->dCameraCenterYShift);
	HisReleaseMalloc(pucRGBBuffer);
	stParameter.uiTiltX=iTiltAngleX;
	stParameter.uiTilty=iTiltAngleY;
	stParameter.uiRotation=iRotationAngle;
	double dTiltX_angle=iTiltAngleX/1000.0f;
	double dTiltY_angle=iTiltAngleY/1000.0f;
	double dRotation_angle=iRotationAngle/1000.0f;
	emit information(QTextCodec::codecForName( "GBK")->toUnicode("TiltX：") % QString::number(dTiltX_angle,'f',3));
	emit information(QTextCodec::codecForName( "GBK")->toUnicode("TiltY：") % QString::number(dTiltY_angle,'f',3));
	emit information(QTextCodec::codecForName( "GBK")->toUnicode("Rotation：") % QString::number(dRotation_angle,'f',3));

	if(dTiltX_angle<itemshareData.dualCameraParameter->dMinTiltX ||dTiltX_angle>itemshareData.dualCameraParameter->dMaxTiltX, \
		dTiltY_angle<itemshareData.dualCameraParameter->dMinTiltY ||dTiltY_angle>itemshareData.dualCameraParameter->dMaxTiltY, \
		dRotation_angle<itemshareData.dualCameraParameter->dMinRotation ||dRotation_angle>itemshareData.dualCameraParameter->dMaxRotation
		)
	{
		iresult=HisCCMError_TiltRotation;
		emit information(QTextCodec::codecForName( "GBK")->toUnicode("Tilt/Rotation测试超出规格") );
	}

	stLogItem.itemtype		=	classLog->getmaxtypeindex(_HISLOG_CLASSIFY_OTPBURN);
	stLogItem.itemkey		=	"TiltRotationTestBurn Result";
	stLogItem.itemvalue	=	(iresult)?("NG"):("OK");
	classLog->push_back(stLogItem);
	_CODE_LOG_PUSHBACK("TiltX", dTiltX_angle);
	_CODE_LOG_PUSHBACK("TiltY", dTiltY_angle);
	_CODE_LOG_PUSHBACK("Rotation", dRotation_angle);
	_CODE_LOG_PUSHBACK("ShiftX", iSiftX);
	_CODE_LOG_PUSHBACK("ShiftY",iSiftY);

	if(itemshareData.dualCameraParameter->bburn)
	{
		emit enableinfotimer(1);
		iresult	=	writedualcameratestdata(*globalFunPointer.vectorHisCCMOTPInfoW, &stParameter, globalFunPointer.ReadHisFX3IIC, globalFunPointer.WriteHisFX3IIC, globalFunPointer.SetHisFX3IICSpeed, \
			globalFunPointer.SetHisFX3Voltage, globalFunPointer.GetHisFX3Voltage, SetHisFX3VFuseVolt, GetHisFX3VFuseVolt, GetFreshframe, \
			globalFunPointer.BatchWriteHisFX3IIC, globalFunPointer.BatchReadHisFX3IIC, SetHisFX3GPIO, GetHisFX3GPIO, globalFunPointer.PullHisFX3RESET, globalFunPointer.PullHisFX3PWND, \
			globalFunPointer.BatchReadHisFX3IICNoLimit, globalFunPointer.BatchWriteHisFX3IICNoLimit, globalFunPointer.HisFX3LogPush_back, \
			globalFunPointer.PageWriteHisFX3IIC, globalFunPointer.PageReadHisFX3IIC, globalFunPointer.HisFX3PageWriteSPI, globalFunPointer.HisFX3PageReadSPI);
		emit enableinfotimer(0);
	}

	if(iresult){
		itemshareData.itemparameterLock.unlock();
		return iresult;
	}

	itemshareData.itemparameterLock.unlock();
	return 0;
}

int itemprocess::CameraTiltRotationTestTestDataBurnCheck()
{

	if(!threadshareData.GetHisPreviewflag())
		return HisCCMError_NotPreivew;

	//取得配置参数和规格
	int iresult	=	getdualcameraParameter(false);
	if(iresult)
		return iresult;
	iresult	=	getccmhardwareParameter(false);
	if(iresult)
		return iresult;

	itemshareData.itemparameterLock.lockForRead();

	_HisCCMDualCameraBurn_Config stParameter;
	stParameter.iheight		=	itemshareData.previewParameter->iHeight;
	stParameter.iwidth		=	itemshareData.previewParameter->iWidth;
	stParameter.uiDataFormat	=	itemshareData.previewParameter->ucDataFormat;
	stParameter.strproject	=	(itemshareData.ccmhardwareParameter->projectname.toAscii()).data();
	stParameter.strsensor	=	(itemshareData.ccmhardwareParameter->sensortype.toAscii()).data();
	stParameter.strFunctionChoose	=	(itemshareData.dualCameraParameter->strDualCameraBurnChoose.toAscii()).data();
	stParameter.ucSlave		=	itemshareData.previewParameter->ucSlave;
	stParameter.ucEESlave	=	itemshareData.ccmhardwareParameter->ucEESlave;
	stParameter.bDebug		=	hisglobalparameter.bDebugMode;

	QString strSerialNumber;
	classLog->getserialnumber(strSerialNumber);
	stParameter.strSerialNumber	=	strSerialNumber.toAscii().data();

#if (defined _WIN64) && (defined _DEBUG)
	QString strLibPath	=	QDir::currentPath() % "/HisCCMOTP64D";
#elif (defined _WIN64) && !(defined _DEBUG)
	QString strLibPath	=	QDir::currentPath() % "/HisCCMOTP64";
#elif (defined _WIN32) && (defined _DEBUG)
	QString strLibPath	=	QDir::currentPath() % "/HisCCMOTP32D";
#else
	QString strLibPath	=	QDir::currentPath() % "/HisCCMOTP32";
#endif

	RolongoOTPAPIVersion getRolongoOTPAPIVersion = (RolongoOTPAPIVersion)(QLibrary::resolve(strLibPath, "getRolongoOTPAPIVersion"));
	Rolongocheckdualcameratestdata cehckdualcameratestdata = (Rolongowritedualcameratestdata)(QLibrary::resolve(strLibPath, "cehckdualcameratestdata"));

	if(!(getRolongoOTPAPIVersion && cehckdualcameratestdata)){
		emit information(tr("Resolve HisCCMOTP DLL Function Fail"));
		itemshareData.itemparameterLock.unlock();
		return HisCCMError_LoadDLLFuc;
	}


	emit enableinfotimer(1);
	iresult	=	cehckdualcameratestdata(*globalFunPointer.vectorHisCCMOTPInfoW, &stParameter, globalFunPointer.ReadHisFX3IIC, globalFunPointer.WriteHisFX3IIC, globalFunPointer.SetHisFX3IICSpeed, \
		globalFunPointer.SetHisFX3Voltage, globalFunPointer.GetHisFX3Voltage, SetHisFX3VFuseVolt, GetHisFX3VFuseVolt, GetFreshframe, \
		globalFunPointer.BatchWriteHisFX3IIC, globalFunPointer.BatchReadHisFX3IIC, SetHisFX3GPIO, GetHisFX3GPIO, globalFunPointer.PullHisFX3RESET, globalFunPointer.PullHisFX3PWND, \
		globalFunPointer.BatchReadHisFX3IICNoLimit, globalFunPointer.BatchWriteHisFX3IICNoLimit, globalFunPointer.HisFX3LogPush_back, \
		globalFunPointer.PageWriteHisFX3IIC, globalFunPointer.PageReadHisFX3IIC, globalFunPointer.HisFX3PageWriteSPI, globalFunPointer.HisFX3PageReadSPI);
	emit enableinfotimer(0);


	if(iresult){
		itemshareData.itemparameterLock.unlock();
		return iresult;
	}

	itemshareData.itemparameterLock.unlock();
	return 0;
}


int itemprocess::DualCameraCoaxilityTestDataBurn()
{
	//判断图像是否点亮中
	if(!threadshareData.GetHisPreviewflag())
		return HisCCMError_NotPreivew;

	//取得配置参数和规格
	int iresult	=	getdualcameraParameter(false);
	if(iresult)
		return iresult;
	iresult	=	getccmhardwareParameter(false);
	if(iresult)
		return iresult;

	itemshareData.itemparameterLock.lockForRead();

	_HisCCMDualCameraBurn_Config stParameter;
	stParameter.iheight		=	itemshareData.previewParameter->iHeight;
	stParameter.iwidth		=	itemshareData.previewParameter->iWidth;
	stParameter.uiDataFormat	=	itemshareData.previewParameter->ucDataFormat;
	stParameter.strproject	=	(itemshareData.ccmhardwareParameter->projectname.toAscii()).data();
	stParameter.strsensor	=	(itemshareData.ccmhardwareParameter->sensortype.toAscii()).data();
	stParameter.strFunctionChoose	=	(itemshareData.dualCameraParameter->strDualCameraCoaxialityBurnChoose.toAscii()).data();
	stParameter.ucSlave		=	itemshareData.previewParameter->ucSlave;
	stParameter.ucEESlave	=	itemshareData.ccmhardwareParameter->ucEESlave;
	stParameter.bDebug		=	hisglobalparameter.bDebugMode;

	QString strSerialNumber;
	classLog->getserialnumber(strSerialNumber);
	stParameter.strSerialNumber	=	strSerialNumber.toAscii().data();

#if (defined _WIN64) && (defined _DEBUG)
	QString strLibPath	=	QDir::currentPath() % "/HisCCMOTP64D";
#elif (defined _WIN64) && !(defined _DEBUG)
	QString strLibPath	=	QDir::currentPath() % "/HisCCMOTP64";
#elif (defined _WIN32) && (defined _DEBUG)
	QString strLibPath	=	QDir::currentPath() % "/HisCCMOTP32D";
#else
	QString strLibPath	=	QDir::currentPath() % "/HisCCMOTP32";
#endif

	RolongoOTPAPIVersion getRolongoOTPAPIVersion = (RolongoOTPAPIVersion)(QLibrary::resolve(strLibPath, "getRolongoOTPAPIVersion"));
	Rolongowritedualcameratestdata writedualcameratestdata = (Rolongowritedualcameratestdata)(QLibrary::resolve(strLibPath, "writedualcameratestdata"));

	if(!(getRolongoOTPAPIVersion && writedualcameratestdata)){
		emit information(tr("Resolve HisCCMOTP DLL Function Fail"));
		itemshareData.itemparameterLock.unlock();
		return HisCCMError_LoadDLLFuc;
	}

	unsigned char* pucMainCameraBufRaw = NULL;
	unsigned char*pucSubCameraBufRaw=NULL;
	int iImgWidthC1 =	itemshareDataC1.previewParameter->iWidth, iImgHeightC1 =	itemshareDataC1.previewParameter->iHeight;
	unsigned int uiRawImgSizeC1		=	iImgWidthC1 * iImgHeightC1 *3;
	unsigned char ucFrameType		=	_FrameType_RGB24;
	//unsigned int uiPixelSize	=	iImgWidth *iImgHeight;
	pucMainCameraBufRaw		=	(unsigned char*)_aligned_malloc(uiRawImgSizeC1, _HisCacheLine_Aligned);
	if(!pucMainCameraBufRaw){
		HisReleaseMalloc(pucMainCameraBufRaw);
		itemshareData.itemparameterLock.unlock();
		return HisFX3Error_MallocBuffer;
	}

	int iImgWidthC2 =	itemshareDataC2.previewParameter->iWidth, iImgHeightC2 =	itemshareDataC2.previewParameter->iHeight;
	unsigned int uiRawImgSizeC2		=	iImgWidthC2 * iImgHeightC2 *3;
	pucSubCameraBufRaw		=	(unsigned char*)_aligned_malloc(uiRawImgSizeC2, _HisCacheLine_Aligned);
	if(!pucSubCameraBufRaw){
		HisReleaseMalloc(pucMainCameraBufRaw);
		HisReleaseMalloc(pucSubCameraBufRaw);
		itemshareData.itemparameterLock.unlock();
		return HisFX3Error_MallocBuffer;
	}

	double dAngleX=0.0f, dAngleY=0.0f,dAngleZ=0.0f;
	int iHorizontalShiftX=0,iVerticalShiftY=0;

	if(iresult=GetFreshframeC1(pucMainCameraBufRaw,uiRawImgSizeC1,ucFrameType,true)) 
	{
		HisReleaseMalloc(pucMainCameraBufRaw);
		HisReleaseMalloc(pucSubCameraBufRaw);
		itemshareData.itemparameterLock.unlock();
		return HisFX3Error_MallocBuffer;
	}

	if(iresult=GetFreshframeC2(pucSubCameraBufRaw,uiRawImgSizeC2,ucFrameType,true)) 
	{
		HisReleaseMalloc(pucMainCameraBufRaw);
		HisReleaseMalloc(pucSubCameraBufRaw);
		itemshareData.itemparameterLock.unlock();
		return HisFX3Error_MallocBuffer;
	}
	iresult =	classRolongoTest.cvRolongoCoaxialityCailibrationbySquare(pucMainCameraBufRaw,itemshareData.dualCameraParameter->bMainCameraColorSensor,iImgWidthC1,iImgHeightC1,
		pucSubCameraBufRaw,itemshareData.dualCameraParameter->bSubCameraColorSensor,iImgWidthC2,iImgHeightC2,\
		itemshareData.dualCameraParameter->dSquare_HorizontalDistance,itemshareData.dualCameraParameter->dSquare_VerticalDistance,\
		itemshareData.dualCameraParameter->dDualCameraCenterDistance,itemshareData.dualCameraParameter->dCoaxialityTestDistance, \
		dAngleX,dAngleY,dAngleZ,iHorizontalShiftX,iVerticalShiftY);

	if (iresult)
	{
		HisReleaseMalloc(pucMainCameraBufRaw);
		HisReleaseMalloc(pucSubCameraBufRaw);
		itemshareData.itemparameterLock.unlock();
		return iresult;
	}

	HisReleaseMalloc(pucMainCameraBufRaw);
	HisReleaseMalloc(pucSubCameraBufRaw);

	if (abs(dAngleX) > abs(itemshareData.dualCameraParameter->dMaxAngleX) || abs(dAngleY) > abs(itemshareData.dualCameraParameter->dMaxAngleY) || abs(iHorizontalShiftX) > abs(itemshareData.dualCameraParameter->iMaxShiftX) || abs(iVerticalShiftY) > abs(itemshareData.dualCameraParameter->iMaxShiftY))
	{
		HisReleaseMalloc(pucMainCameraBufRaw);
		HisReleaseMalloc(pucSubCameraBufRaw);
		itemshareData.itemparameterLock.unlock();
		iresult=HisCoaxiality_ErrorRESULT;
	}

	stParameter.dAlignment_X=dAngleX;
	stParameter.dAlignment_Y=dAngleY;
	stParameter.dAlignment_Z=dAngleZ;

	stLogItem.itemtype		=	classLog->getmaxtypeindex(_HISLOG_CLASSIFY_OTPBURN);
	stLogItem.itemkey		=	"CoaxilityTestBurn Result";
	stLogItem.itemvalue	=	(iresult)?("NG"):("OK");
	classLog->push_back(stLogItem);
	_CODE_LOG_PUSHBACK("Coaxility_AngleX", dAngleX);
	_CODE_LOG_PUSHBACK("Coaxility_AngleY", dAngleY);
	_CODE_LOG_PUSHBACK("Coaxility_AngleZ", dAngleZ);
	_CODE_LOG_PUSHBACK("Coaxility_ShiftX", iHorizontalShiftX);
	_CODE_LOG_PUSHBACK("Coaxility_ShiftY",iVerticalShiftY);

	if(itemshareData.dualCameraParameter->bCoaxialityburn)
	{
		emit enableinfotimer(1);
		iresult	=	writedualcameratestdata(*globalFunPointer.vectorHisCCMOTPInfoW, &stParameter, globalFunPointer.ReadHisFX3IIC, globalFunPointer.WriteHisFX3IIC, globalFunPointer.SetHisFX3IICSpeed, \
			globalFunPointer.SetHisFX3Voltage, globalFunPointer.GetHisFX3Voltage, SetHisFX3VFuseVolt, GetHisFX3VFuseVolt, GetFreshframe, \
			globalFunPointer.BatchWriteHisFX3IIC, globalFunPointer.BatchReadHisFX3IIC, SetHisFX3GPIO, GetHisFX3GPIO, globalFunPointer.PullHisFX3RESET, globalFunPointer.PullHisFX3PWND, \
			globalFunPointer.BatchReadHisFX3IICNoLimit, globalFunPointer.BatchWriteHisFX3IICNoLimit, globalFunPointer.HisFX3LogPush_back, \
			globalFunPointer.PageWriteHisFX3IIC, globalFunPointer.PageReadHisFX3IIC, globalFunPointer.HisFX3PageWriteSPI, globalFunPointer.HisFX3PageReadSPI);
		emit enableinfotimer(0);
	}

	if(iresult){
		itemshareData.itemparameterLock.unlock();
		return iresult;
	}

	itemshareData.itemparameterLock.unlock();
	return 0;
}


int itemprocess::DualCameraCoaxilityTestDataBurnCheck()
{
	if(!threadshareData.GetHisPreviewflag())
		return HisCCMError_NotPreivew;

	//取得配置参数和规格
	int iresult	=	getdualcameraParameter(false);
	if(iresult)
		return iresult;
	iresult	=	getccmhardwareParameter(false);
	if(iresult)
		return iresult;

	itemshareData.itemparameterLock.lockForRead();

	_HisCCMDualCameraBurn_Config stParameter;
	stParameter.iheight		=	itemshareData.previewParameter->iHeight;
	stParameter.iwidth		=	itemshareData.previewParameter->iWidth;
	stParameter.uiDataFormat	=	itemshareData.previewParameter->ucDataFormat;
	stParameter.strproject	=	(itemshareData.ccmhardwareParameter->projectname.toAscii()).data();
	stParameter.strsensor	=	(itemshareData.ccmhardwareParameter->sensortype.toAscii()).data();
	stParameter.strFunctionChoose	=	(itemshareData.dualCameraParameter->strDualCameraCoaxialityBurnChoose.toAscii()).data();
	stParameter.ucSlave		=	itemshareData.previewParameter->ucSlave;
	stParameter.ucEESlave	=	itemshareData.ccmhardwareParameter->ucEESlave;
	stParameter.bDebug		=	hisglobalparameter.bDebugMode;

	QString strSerialNumber;
	classLog->getserialnumber(strSerialNumber);
	stParameter.strSerialNumber	=	strSerialNumber.toAscii().data();

#if (defined _WIN64) && (defined _DEBUG)
	QString strLibPath	=	QDir::currentPath() % "/HisCCMOTP64D";
#elif (defined _WIN64) && !(defined _DEBUG)
	QString strLibPath	=	QDir::currentPath() % "/HisCCMOTP64";
#elif (defined _WIN32) && (defined _DEBUG)
	QString strLibPath	=	QDir::currentPath() % "/HisCCMOTP32D";
#else
	QString strLibPath	=	QDir::currentPath() % "/HisCCMOTP32";
#endif

	RolongoOTPAPIVersion getRolongoOTPAPIVersion = (RolongoOTPAPIVersion)(QLibrary::resolve(strLibPath, "getRolongoOTPAPIVersion"));
	Rolongocheckdualcameratestdata cehckdualcameratestdata = (Rolongowritedualcameratestdata)(QLibrary::resolve(strLibPath, "cehckdualcameratestdata"));

	if(!(getRolongoOTPAPIVersion && cehckdualcameratestdata)){
		emit information(tr("Resolve HisCCMOTP DLL Function Fail"));
		itemshareData.itemparameterLock.unlock();
		return HisCCMError_LoadDLLFuc;
	}


	emit enableinfotimer(1);
	iresult	=	cehckdualcameratestdata(*globalFunPointer.vectorHisCCMOTPInfoW, &stParameter, globalFunPointer.ReadHisFX3IIC, globalFunPointer.WriteHisFX3IIC, globalFunPointer.SetHisFX3IICSpeed, \
		globalFunPointer.SetHisFX3Voltage, globalFunPointer.GetHisFX3Voltage, SetHisFX3VFuseVolt, GetHisFX3VFuseVolt, GetFreshframe, \
		globalFunPointer.BatchWriteHisFX3IIC, globalFunPointer.BatchReadHisFX3IIC, SetHisFX3GPIO, GetHisFX3GPIO, globalFunPointer.PullHisFX3RESET, globalFunPointer.PullHisFX3PWND, \
		globalFunPointer.BatchReadHisFX3IICNoLimit, globalFunPointer.BatchWriteHisFX3IICNoLimit, globalFunPointer.HisFX3LogPush_back, \
		globalFunPointer.PageWriteHisFX3IIC, globalFunPointer.PageReadHisFX3IIC, globalFunPointer.HisFX3PageWriteSPI, globalFunPointer.HisFX3PageReadSPI);
	emit enableinfotimer(0);


	if(iresult){
		itemshareData.itemparameterLock.unlock();
		return iresult;
	}

	itemshareData.itemparameterLock.unlock();
	return 0;
}

int itemprocess::CamdoraCaliration(int left1, int top1, int right1, int bottom1, int minArea1,int left2, int top2, int right2, int bottom2, int maxYShift)
{
	if(!bBoxChannel1) return 0;

	if (!threadshareDataC1.GetHisPreviewflag()){
		emit information("Channel 1 has not previewed yet.");
		return HisCCMError_NotPreivew;
	}

	if (!threadshareDataC2.GetHisPreviewflag()){
		emit information("Channel 2 has not previewed yet.");
		return HisCCMError_NotPreivew;
	}

	stLogItem.itemtype		=	classLog->getmaxtypeindex(_HISLOG_CLASSIFY_CDRDCALIBRATION);
	stLogItem.itemkey		=	"Dual Camera Calibration";
	stLogItem.itemvalue	=	"OK";
	QHDefaultLogManage classstLogItem(classLog, &stLogItem, "NG");

	unsigned char* rgb24 = (unsigned char*)HisAlignedMalloc(itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight *3);
	if(!rgb24) return HisFX3Error_MallocBuffer;
	unsigned char* channelY = (unsigned char*)HisAlignedMalloc(itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight);
	if(!channelY) return HisFX3Error_MallocBuffer;
	int iresult = 0;
	unsigned int pixel = itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight;
	float cx1, cy1,cx2, cy2;

	//左通道
	{
		if(iresult = threadshareDataC1.GetFreshframe(rgb24, itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight *3,  _FrameType_RGB24, true)){
			HisReleaseMalloc(rgb24);
			HisReleaseMalloc(channelY);
			return iresult;
		}

		RECT stROI;
		float rollAngle,crossX, crossY;
		stROI.left	=	left1; stROI.top= top1; stROI.right = right1; stROI.bottom = bottom1;

		//画ROI
		std::vector<_itemDraw>::iterator theIterator;
		itemshareDataC1.drawLock.lockForWrite();
		itemshareDataC1.itemdrawList.resize(1);
		theIterator=itemshareDataC1.itemdrawList.begin();

		theIterator->uctype				=	HisDrawType_Block;
		theIterator->strinfo.stblock	=	stROI;
		theIterator->stcolor				=	QColor::fromRgb(255, 255, 0);
		theIterator++;

		itemshareDataC1.drawLock.unlock();

		unsigned char* psrc = rgb24+1, *pdes = channelY;
		for (unsigned int x=0;	x<pixel;	++x)
		{
			*pdes	=	*psrc;
			++pdes;	psrc +=3;
		}

		if (iresult = classRolongoTest.CrossCoaxialityAlgHA(channelY, itemshareData.previewParameter->iWidth, itemshareData.previewParameter->iHeight, \
			stROI,minArea1,  cx1, cy1, rollAngle,crossX, crossY)){
				HisReleaseMalloc(rgb24);
				HisReleaseMalloc(channelY);
				return iresult;
		}

		emit information("Left Center: (" % QString::number(cx1, 'f', 3) % "," % QString::number(cy1, 'f', 3) % ")");
		itemshareDataC1.drawLock.lockForWrite();
		itemshareDataC1.itemdrawList.resize(3);
		theIterator=itemshareDataC1.itemdrawList.begin() +1;

		theIterator->uctype				=	HisDrawType_Line;
		theIterator->strinfo.stblock.left	=	cx1 - 50;
		theIterator->strinfo.stblock.right	=	cx1 + 50;
		theIterator->strinfo.stblock.top = theIterator->strinfo.stblock.bottom	=	cy1;
		theIterator->stcolor				=	QColor::fromRgb(255, 255, 0);
		theIterator++;

		theIterator->uctype				=	HisDrawType_Line;
		theIterator->strinfo.stblock.top		=	cy1 - 50;
		theIterator->strinfo.stblock.bottom	=	cy1 + 50;
		theIterator->strinfo.stblock.left = theIterator->strinfo.stblock.right	=	cx1;
		theIterator->stcolor				=	QColor::fromRgb(255, 255, 0);
		theIterator++;
		itemshareDataC1.drawLock.unlock();
	}

	//右通道
	{
		if(iresult = threadshareDataC2.GetFreshframe(rgb24, itemshareData.previewParameter->iWidth *itemshareData.previewParameter->iHeight *3,  _FrameType_RGB24, true)){
			HisReleaseMalloc(rgb24);
			HisReleaseMalloc(channelY);
			return iresult;
		}

		RECT stROI;
		float rollAngle,crossX, crossY;
		stROI.left	=	left2; stROI.top= top2; stROI.right = right2; stROI.bottom = bottom2;

		//画ROI
		std::vector<_itemDraw>::iterator theIterator;
		itemshareDataC2.drawLock.lockForWrite();
		itemshareDataC2.itemdrawList.resize(1);
		theIterator=itemshareDataC2.itemdrawList.begin();

		theIterator->uctype				=	HisDrawType_Block;
		theIterator->strinfo.stblock	=	stROI;
		theIterator->stcolor				=	QColor::fromRgb(255, 255, 0);
		theIterator++;

		itemshareDataC2.drawLock.unlock();

		unsigned char* psrc = rgb24+1, *pdes = channelY;
		for (unsigned int x=0;	x<pixel;	++x)
		{
			*pdes	=	*psrc;
			++pdes;	psrc +=3;
		}

		if (iresult = classRolongoTest.CrossCoaxialityAlgHA(channelY, itemshareData.previewParameter->iWidth, itemshareData.previewParameter->iHeight, \
			stROI,minArea1,  cx2, cy2, rollAngle,crossX, crossY)){
				HisReleaseMalloc(rgb24);
				HisReleaseMalloc(channelY);
				return iresult;
		}

		emit information("Right Center: (" % QString::number(cx2, 'f', 3) % "," % QString::number(cy2, 'f', 3) % ")");
		itemshareDataC2.drawLock.lockForWrite();
		itemshareDataC2.itemdrawList.resize(3);
		theIterator=itemshareDataC2.itemdrawList.begin() +1;

		theIterator->uctype				=	HisDrawType_Line;
		theIterator->strinfo.stblock.left	=	cx2 - 50;
		theIterator->strinfo.stblock.right	=	cx2 + 50;
		theIterator->strinfo.stblock.top = theIterator->strinfo.stblock.bottom	=	cy2;
		theIterator->stcolor				=	QColor::fromRgb(255, 255, 0);
		theIterator++;

		theIterator->uctype				=	HisDrawType_Line;
		theIterator->strinfo.stblock.top		=	cy2 - 50;
		theIterator->strinfo.stblock.bottom	=	cy2 + 50;
		theIterator->strinfo.stblock.left = theIterator->strinfo.stblock.right	=	cx2;
		theIterator->stcolor				=	QColor::fromRgb(255, 255, 0);
		theIterator++;
		itemshareDataC2.drawLock.unlock();
	}

	HisReleaseMalloc(rgb24);
	HisReleaseMalloc(channelY);

	float shiftY = cy1-cy2;
	emit information("Y shift: " % QString::number(shiftY, 'f', 3));
	if(Http2Camdora(shiftY)) iresult = HisFX3Error_Other;

	classstLogItem.SubRef();
	if(abs(shiftY) > maxYShift) {stLogItem.itemvalue	=	"NG"; iresult = HisCCMError_Result;}
	classLog->push_back(stLogItem);
	++(stLogItem.itemtype); stLogItem.itemkey = "Y Shift"; stLogItem.itemvalue = shiftY; classLog->push_back(stLogItem);

	return iresult;
}

int itemprocess::Http2Camdora(int YShift)
{
	/*
	Json::FastWriter writer;
	Json::Value person;

	person["type"] = "stereo";
	person["x1"] = 0;
	person["x2"] = 0;
	person["y1"] = 0;
	person["y2"] = YShift;
	person["z1"] = 0;
	person["z2"] = 0;
	person["theta1"] = 0;
	person["theta2"] = 0;

	std::string json_file = writer.write(person);

	OutputDebugStringA(json_file.c_str());
	*/

	// 	ofstream ofs;
	// 	ofs.open("test1.json");
	// 	assert(ofs.is_open());
	// 	ofs<<json_file;

	/*
	QNetworkAccessManager classHttp(this);
	QNetworkRequest request(QUrl("http://10.0.0.1/camdora.cgi?service=system&calibrate=set"));
	QPair<QByteArray, QByteArray> header;
	QList<QPair<QByteArray, QByteArray>> headers;

	header.first = "Host";
	header.second = "10.0.0.1";
	headers.push_back(header);

	header.first = "User-Agent";
	header.second = "curl/7.47.0";
	headers.push_back(header);

	header.first = "Accept";
	header.second = "* / *";
	headers.push_back(header);

	header.first = "Content-type";
	header.second = "application/json";
	headers.push_back(header);

	header.first = "Content-Length";
	header.second = "106";
	headers.push_back(header);

	QByteArray data(json_file.c_str());
	QNetworkReply* pReply = classHttp.post(request, data);
	QEventLoop loop;
	connect(pReply, SIGNAL(finished()), &loop, SLOT(quit()));
	loop.exec();
	emit information("post error:" % QString::number(pReply->error()));
	*/

	//http://10.0.0.1/camdora.cgi?service=system&caliberate=set&sn=CQ75500008&type=stereo&x1=0&x2=0&y1=0&y2=0
	QString strUrl = "http://10.0.0.1/camdora.cgi?service=system&caliberate=set";
	QString serSerialNumber;
	classLog->getserialnumber(serSerialNumber);
	strUrl = strUrl % "&sn=" % serSerialNumber;
	strUrl = strUrl % "&type=stereo";
	strUrl = strUrl % "&y2=" % QString::number(YShift);

	QNetworkAccessManager classHttp(this);
	QNetworkReply * pReply = classHttp.get(QNetworkRequest(QUrl(strUrl)));
	QEventLoop loop;
	connect(pReply, SIGNAL(finished()), &loop, SLOT(quit()));
	loop.exec();
	emit information("post error:" % QString::number(pReply->error()));

	if(pReply->error()) return HisFX3Error_Other;

	QByteArray tdata = pReply->readAll();
	QString sdata(tdata);
	emit information(sdata);
	Json::Reader Reader;
	Json::Value person;
	int status=0;
	if (Reader.parse(sdata.toStdString(), person)){
		status = person["status_code"].asInt();
	}

	return (status != 200)?(HisFX3Error_Other):(0);
}




//读取GOLDEN 值
int itemprocess::ReadGolden()
{
	//判断图像是否点亮中
	if(!threadshareData.GetHisPreviewflag())	return HisCCMError_NotPreivew;

	//取得配置参数和规格
	int iresult	=	getotpburnParameter(false);
	if(iresult)
		return iresult;
	iresult	=	getccmhardwareParameter(false);
	if(iresult)
		return iresult;

	itemshareData.itemparameterLock.lockForRead();

	_HisCCMOTP_Config stParameter;
	stParameter.puiIndex	=	&(itemshareData.otpburnParameter->uiIndex);
	stParameter.iheight		=	itemshareData.previewParameter->iHeight;
	stParameter.iwidth		=	itemshareData.previewParameter->iWidth;
	stParameter.uiDataFormat	=	itemshareData.previewParameter->ucDataFormat;
	stParameter.bburn		=	itemshareData.otpburnParameter->bburn;
	stParameter.bOnlyCheckBurnData		=	itemshareData.otpburnParameter->bOnlyCheckData;
	stParameter.uiFrameSleep	=	itemshareData.otpburnParameter->uiFrameSleep;
	stParameter.uiMID	=	itemshareData.otpburnParameter->uiMID;
	stParameter.uiLENSID	=	itemshareData.otpburnParameter->uiLENSID;
	stParameter.uiVCMID	=	itemshareData.otpburnParameter->uiVCMID;
	stParameter.uiDRIVERICID	=	itemshareData.otpburnParameter->uiDRIVERICID;
	stParameter.flRangeRatio	=	itemshareData.otpburnParameter->flRangeRatio;
	stParameter.uiLuxMin	=	itemshareData.otpburnParameter->uiLuxMin;
	stParameter.uiLuxMax	=	itemshareData.otpburnParameter->uiLuxMax;
	stParameter.uiDark	=	itemshareData.otpburnParameter->uiDark;
	stParameter.flLSC_LuxShadingMin	=	itemshareData.otpburnParameter->flLSC_LuxShadingMin;
	stParameter.flLSC_LuxShadingMax	=	itemshareData.otpburnParameter->flLSC_LuxShadingMax;
	stParameter.flLSC_LuxSymmMax	=	itemshareData.otpburnParameter->flLSC_LuxSymmMax;
	stParameter.flLSC_CenterR2GrMin	=	itemshareData.otpburnParameter->flLSC_CenterR2GrMin;
	stParameter.flLSC_CenterR2GrMax	=	itemshareData.otpburnParameter->flLSC_CenterR2GrMax;
	stParameter.flLSC_CenterB2GrMin	=	itemshareData.otpburnParameter->flLSC_CenterB2GrMin;
	stParameter.flLSC_CenterB2GrMax	=	itemshareData.otpburnParameter->flLSC_CenterB2GrMax;
	stParameter.flLSC_WB2CenterMax_R2Gr	=	itemshareData.otpburnParameter->flLSC_WB2CenterMax_R2Gr;
	stParameter.flLSC_WB2CenterMax_B2Gr	=	itemshareData.otpburnParameter->flLSC_WB2CenterMax_B2Gr;
	stParameter.flLSC_LuxShadingUniform	=	itemshareData.otpburnParameter->flLSC_LuxShadingUniform;
	stParameter.uiBlockSize	=	itemshareData.otpburnParameter->uiBlockSize;
	stParameter.dflLightCoeR	=	itemshareData.otpburnParameter->dflLightCoeR;
	stParameter.dflLightCoeB	=	itemshareData.otpburnParameter->dflLightCoeB;
	stParameter.strproject	=	(itemshareData.ccmhardwareParameter->projectname.toAscii()).data();
	stParameter.strsensor	=	(itemshareData.ccmhardwareParameter->sensortype.toAscii()).data();
	stParameter.strFunctionChoose	=	(itemshareData.otpburnParameter->strFunctionChoose.toAscii()).data();
	stParameter.ucSlave		=	itemshareData.previewParameter->ucSlave;
	stParameter.ucEESlave	=	itemshareData.ccmhardwareParameter->ucEESlave;
	stParameter.bDebug		=	hisglobalparameter.bDebugMode;

	unsigned char ucBatchSlave[8192]={0};
	unsigned int uiBatchReg[8192]={0};
	unsigned short usBatchType[8192]={0};
	unsigned int uiBatchGolden[8192]={0} ;
	memset(ucBatchSlave, stParameter.ucEESlave,8192) ;
	for(unsigned int x=0;	x<8192;	++x)
		usBatchType[x]	=	0x1608;

	int uiGoldenStartAdd = 0x210 ;
	memset(uiBatchReg,0,sizeof(unsigned int) * 8192) ;
	for(unsigned int nIndex = 0 ;nIndex < 4 ;nIndex ++) 
	{
		uiBatchReg[nIndex]	=	uiGoldenStartAdd +nIndex;
	}

	if(iresult =globalFunPointer.BatchReadHisFX3IICNoLimit(4, ucBatchSlave, uiBatchReg, uiBatchGolden, usBatchType, 50)) return iresult;
	emit information("Golden_R_0x:" % QString::number(uiBatchGolden[0],16) % " Golden_G_0x:" % QString::number(uiBatchGolden[1],16) % 
		" Golden_B_0x:" % QString::number(uiBatchGolden[3],16));

	//将golden 值存入数据库

	ROPLOW::UpdateOtpBurnParameterForGolden(itemshareData.currentTableName,QString::number(uiBatchGolden[0],16),QString::number(uiBatchGolden[1],16),
		QString::number(uiBatchGolden[3],16)) ;

	itemshareData.itemparameterLock.unlock();
	return 0;

}


int itemprocess::getDPCParameter(bool bupdate, bool bcheck )
{
	itemshareData.itemparameterLock.lockForRead();
	if(!bupdate && itemshareData.dpcParameter){
		itemshareData.itemparameterLock.unlock();
		return 0;
	}

	QMutexLocker locker(&hisglobalparameter.mutexDatabase);

	itemshareData.itemparameterLock.unlock();
	itemshareData.itemparameterLock.lockForWrite();
	if(!itemshareData.dpcParameter)
		itemshareData.dpcParameter		=	new _DPCParameter;
	if(!itemshareData.dpcParameter)
	{
		itemshareData.itemparameterLock.unlock();
		return HisFX3Error_MallocBuffer;
	}

	bool bparsesuccess	=	true, bItemExist = false;

	//读取，解析config
	for(int  w=0;	w<1;	++w)
	{ //此处是有意义的,不要删除
		QSqlDatabase customdb = QSqlDatabase::addDatabase("QSQLITE", "querycustom");
		customdb.setDatabaseName(QDir::currentPath() % "/HisFX3Custom");
		if (!customdb.open())
		{
			bparsesuccess	=	false;
			break;
		}

		QString strData, strdata2;
		QStringList strname, strvalue;
		QSqlQuery query(customdb);
		query.prepare("SELECT itemsuffix2 FROM " % itemshareData.currentTableName % \
			" WHERE classfy='algorithm' AND item='dpcloadrule' ORDER BY id ASC" );
		query.exec();


		while (query.next()){
			bItemExist = true;
			for(int y=0;	y<4;	++y){
				strData	=	query.value(y).toString();
				ROPLOW::patchconfigstring(strData, strname, strvalue);
				for(int x=0;	x<strname.size();	++x)
				{
					if(strname.at(x) == "dpcrule")	itemshareData.dpcParameter->strDPCRuleChoose		=	strvalue.at(x).toUpper();
				}
			}
		}

		customdb.close();
	}

	QSqlDatabase::removeDatabase("querycustom");
	if(!bparsesuccess || !bItemExist)
	{
		emit information(tr("DPC Rule setting parameter is not configured ok "));
		HisReleaseNewO(itemshareData.dpcParameter);
		itemshareData.itemparameterLock.unlock();
		return HisFX3Error_Parameter;
	}

	if(!bcheck) {itemshareData.itemparameterLock.unlock(); return 0; }


	itemshareData.itemparameterLock.unlock();
	return 0;
}

int itemprocess::Sensor_DPC_FunctionProcess()
{
	//判断图像是否点亮中
	if(!threadshareData.GetHisPreviewflag())
		return HisCCMError_NotPreivew;

	//取得配置参数和规格
	int iresult	=	getDPCParameter(false);
	if(iresult)
		return iresult;
	iresult	=	getccmhardwareParameter(false);
	if(iresult)
		return iresult;

	itemshareData.itemparameterLock.lockForRead();

	_HisCCMOTP_Config stParameter;
	stParameter.puiIndex	=	&(itemshareData.otpburnParameter->uiIndex);
	stParameter.iheight		=	itemshareData.previewParameter->iHeight;
	stParameter.iwidth		=	itemshareData.previewParameter->iWidth;
	stParameter.uiDataFormat	=	itemshareData.previewParameter->ucDataFormat;
	stParameter.strproject	=	(itemshareData.ccmhardwareParameter->projectname.toAscii()).data();
	stParameter.strsensor	=	(itemshareData.ccmhardwareParameter->sensortype.toAscii()).data();
	stParameter.strFunctionChoose	=	(itemshareData.dpcParameter->strDPCRuleChoose.toAscii()).data();
	stParameter.ucSlave		=	itemshareData.previewParameter->ucSlave;
	stParameter.ucEESlave	=	itemshareData.ccmhardwareParameter->ucEESlave;
	stParameter.bDebug		=	hisglobalparameter.bDebugMode;

	QString strSerialNumber;
	classLog->getserialnumber(strSerialNumber);
	stParameter.strSerialNumber	=	strSerialNumber.toAscii().data();

#if (defined _WIN64) && (defined _DEBUG)
	QString strLibPath	=	QDir::currentPath() % "/HisCCMOTP64D";
#elif (defined _WIN64) && !(defined _DEBUG)
	QString strLibPath	=	QDir::currentPath() % "/HisCCMOTP64";
#elif (defined _WIN32) && (defined _DEBUG)
	QString strLibPath	=	QDir::currentPath() % "/HisCCMOTP32D";
#else
	QString strLibPath	=	QDir::currentPath() % "/HisCCMOTP32";
#endif

	RolongoOTPAPIVersion getRolongoOTPAPIVersion = (RolongoOTPAPIVersion)(QLibrary::resolve(strLibPath, "getRolongoOTPAPIVersion"));
	Rolongowriteotp writeotp = (Rolongowriteotp)(QLibrary::resolve(strLibPath, "writeotp"));

	emit information("getRolongoOTPAPIVersion: "  % QString::number((unsigned int)getRolongoOTPAPIVersion, 16));
	emit information("writeotp: "  % QString::number((unsigned int)writeotp, 16));

	if(!(getRolongoOTPAPIVersion && writeotp)){
		emit information(tr("Resolve HisCCMOTP DLL Function Fail"));
		itemshareData.itemparameterLock.unlock();
		return HisCCMError_LoadDLLFuc;
	}


	emit enableinfotimer(1);
	iresult	=	writeotp(*globalFunPointer.vectorHisCCMOTPInfoW, &stParameter, globalFunPointer.ReadHisFX3IIC, globalFunPointer.WriteHisFX3IIC, globalFunPointer.SetHisFX3IICSpeed, \
		globalFunPointer.SetHisFX3Voltage, globalFunPointer.GetHisFX3Voltage, SetHisFX3VFuseVolt, GetHisFX3VFuseVolt, GetFreshframe, \
		globalFunPointer.BatchWriteHisFX3IIC, globalFunPointer.BatchReadHisFX3IIC, SetHisFX3GPIO, GetHisFX3GPIO, globalFunPointer.PullHisFX3RESET, globalFunPointer.PullHisFX3PWND, \
		globalFunPointer.BatchReadHisFX3IICNoLimit, globalFunPointer.BatchWriteHisFX3IICNoLimit, globalFunPointer.HisFX3LogPush_back, \
		globalFunPointer.PageWriteHisFX3IIC, globalFunPointer.PageReadHisFX3IIC, globalFunPointer.HisFX3PageWriteSPI, globalFunPointer.HisFX3PageReadSPI);
	emit enableinfotimer(0);

	if(iresult){
		itemshareData.itemparameterLock.unlock();
		return iresult;
	}

	itemshareData.itemparameterLock.unlock();
	return 0;

}